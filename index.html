<!DOCTYPE html>
<html lang="ko">

<head>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ê²Œì„ì‹¤í—˜ì—°êµ¬ì†Œ ê³„ì‚°ê¸° (ì‹œì¦Œ5)</title>
  <style>
    /*ê¸°ë³¸ ë³€ìˆ˜ ìƒ‰ìƒ*/
    :root {
      --bg: #0f1115;
      --panel: #151922;
      --text: #e6e9ef;
      --muted: #9aa3b2;
      --accent: #6ea8ff;
      --ring: rgba(110, 168, 255, 0.45);
      --gold: #cfa24f;
      --gold-2: #8f6b2b;
      --card-bg: #17120f;
    }

    /*ëª¨ë“  ë°•ìŠ¤*/
    * {
      box-sizing: border-box;
    }

    /*htmlê³¼ bodyì— ëŒ€í•´ */
    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(1200px 600px at 50% -10%, #1b2130 0%, #0f1115 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial;
      overflow: auto;
    }

    .wrap {
      max-width: 1300px;
      margin: 20px auto;
      padding: 0 16px;
    }

    .top-title {
      text-align: center;
      font-weight: 800;
      font-size: clamp(20px, 2.6vw, 36px);
      margin: 6px 0 4px;
    }

    .sub-alert {
      text-align: center;
      color: #ffb3b3;
      font-size: 13px;
      margin-bottom: 10px;
    }

    .main2 {
      text-align: center;
      color: #ff0000;
      font-size: 12px;
      margin-bottom: 10px;
      font-weight: bold;
      /* ê¸€ì”¨ ë‘ê»˜ â†’ êµµê²Œ */
    }

    .grid {
      display: grid;
      grid-template-columns: 1.4fr 0.9fr;
      /* ì™¼ìª½ í° ë¹„ì£¼ì–¼ / ì˜¤ë¥¸ìª½ ê³µì§€ */
      gap: 18px;
      align-items: start;
    }

    /* ===== ì™¼ìª½: ë©”ì¸ ë¹„ì£¼ì–¼ + ë¡œê·¸ì¸ ì¹´ë“œ ===== */
    .hero {
      display: flex;
      align-items: center;
      /* ì„¸ë¡œ ê°€ìš´ë° */
      position: relative;
      background: #0b0f16;
      border: 1px solid #1f2633;
      border-radius: 14px;
      overflow: hidden;
      min-height: 460px;
    }

    .hero-img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      opacity: .92;
      filter: saturate(1.05) contrast(1.05);
    }

    /* ì˜¤ë¥¸ìª½ ì»¬ëŸ¼: ê³µì§€ + ë¡œê·¸ì¸ ì„¸ë¡œë¡œ ìŒ“ê¸° */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 16px;
      /* ë‘ ë°•ìŠ¤ ì‚¬ì´ ê°„ê²© */
    }

    /* ìŠ¤ìƒ·ì˜ ë¹¨ê°„ íƒ€ì› ìœ„ì¹˜: í•˜ë‹¨ ì¢Œì¸¡ì— ëœ¨ëŠ” ë‘¥ê·¼ ì§ì‚¬ê°í˜• */
    .login-card {
      position: static;
      /* ê³ ì • í•´ì œ */
      width: 100%;
      /* ì˜¤ë¥¸ìª½ ì¹¼ëŸ¼ ë„ˆë¹„ ê½‰ ì±„ìš°ê¸° */
      background: linear-gradient(180deg, rgba(255, 255, 255, .08), rgba(255, 255, 255, .05));
      border: 1px solid rgba(255, 255, 255, .16);
      border-radius: 16px;
      box-shadow: 0 8px 40px rgba(0, 0, 0, .45), inset 0 0 0 6px rgba(110, 168, 255, .06);
      padding: 14px 16px;
      backdrop-filter: blur(2px);
    }

    .login-title {
      font-weight: 700;
      margin: 2px 0 8px;
      font-size: 15px;
      letter-spacing: .2px;
    }

    .login-desc {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
      margin-bottom: 10px;
    }

    .login-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .login-hint {
      color: #a2ffcf;
      font-size: 12px;
    }

    /* ===== ì˜¤ë¥¸ìª½: ì—…ë°ì´íŠ¸/ê³µì§€ ===== */
    .notice {
      background: linear-gradient(180deg, rgba(255, 255, 255, .05), rgba(255, 255, 255, .03));
      border: 1px solid rgba(255, 255, 255, .12);
      border-radius: 14px;
      padding: 14px 14px 18px;
    }

    .notice h3 {
      margin: 6px 0 10px;
      font-size: 18px;
    }

    .notice .box {
      background: var(--soft);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px 12px;
      margin-bottom: 10px;
    }

    .notice ul {
      margin: 6px 0 0 18px;
      padding: 0;
      line-height: 1.5;
    }

    .badge-danger {
      color: #ff8b8b;
      font-weight: 700
    }

    .upgrade {
      margin-top: 10px;
      background: #172233;
      border: 1px solid #253148;
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 14px;
    }

    .upgrade a {
      color: #8fbaff;
      text-decoration: underline;
    }

    /* ë°˜ì‘í˜• */
    @media (max-width: 980px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .hero {
        min-height: 420px;
      }

      .login-card {
        left: 12px;
        right: 12px;
        width: auto;
      }
    }

    /*í´ë˜ìŠ¤ì„ íƒì(ìƒ‰ìƒì„¸íŠ¸)*/
    .shell {
      height: 100dvh;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    /*ë§¨ ìœ„ ì œëª©ì„*/
    /*headerëŠ” ì œëª©, headëŠ” ë©”íƒ€ì •ë³´*/
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      /*ì •ë ¬*/
      padding: 12px 18px;
      /*ì•ˆìª½ ì—¬ë°±*/
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0));
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(4px);
    }

    /*header : íƒœê·¸ì„ íƒì, title : í´ë˜ìŠ¤, h1 : íƒœê·¸ì„ íƒì, headerì•ˆ -> titleì•ˆ -> h1ë§Œ ì„ íƒ*/
    header .title h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
    }

    /*ì•ìª½ì— íƒœê·¸ì„ íƒìê°€ ì—†ìœ¼ë¯€ë¡œ, ì „ì—­ì— actions í´ë˜ìŠ¤ ì‚¬ìš©ê°€ëŠ¥*/
    .actions {
      font-size: 12px;
      color: var(--muted);
    }

    /* ë ˆì´ì•„ì›ƒ: ì˜¤ë¥¸ìª½ì— í•©ì‚° íŒ¨ë„ ì—´ ì¶”ê°€ (ê³ ì •í­) */
    .layout {
      display: grid;
      grid-template-columns:
        minmax(220px, 1fr)
        /* 1ë²ˆì§¸ ì—´ (ì™¼ìª½) */
        minmax(320px, 36vw)
        /* 2ë²ˆì§¸ ì—´ (ìºë¦­í„°) */
        minmax(220px, 1fr)
        /* 3ë²ˆì§¸ ì—´ (ì˜¤ë¥¸ìª½) */
        300px
        /* 4ë²ˆì§¸ ì—´ (ì˜µì…˜) */
        300px;
      /* 5ë²ˆì§¸ ì—´ (í•©ì‚°ìŠ¤íƒ¯) */
      grid-template-rows: auto auto;
      gap: clamp(8px, 2vw, 24px);

      grid-template-areas:
        "left char right options stats"
        "save save right options stats";
    }

    .left-col {
      grid-area: left;
    }

    .char-col {
      grid-area: char;
    }

    .right-col {
      display: flex;
      flex-direction: column;
    }

    .options-col {
      grid-area: options;
      grid-row: 1 / span 2;
    }

    .stats-col {
      grid-area: stats;
      grid-row: 1 / span 2;
    }

    .save-box {
      grid-area: save;
    }

    .save-box {
      grid-area: save;
      background: rgba(110, 168, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 18px;
      padding: 12px 16px;
      display: flex;
      justify-content: flex-start;
      /* â† ì™¼ìª½ ì •ë ¬ */
      gap: 10px;
      position: relative;
      transform: translateY(-100px);
      /* -6 ~ -20px ë“±ìœ¼ë¡œ ì¡°ì ˆ */
      z-index: 2;
      /* ê²¹ì¹  ë•Œ ìœ„ì— ë³´ì´ê²Œ */
    }

    .save-box button {
      width: 48px;
      /* ì •ì‚¬ê°í˜• */
      height: 48px;
      /* ì •ì‚¬ê°í˜• */
      border-radius: 12px;
      /* ë‘¥ê·¼ ëª¨ì„œë¦¬ */
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 24px;
      /* + ê¸°í˜¸ í¬ê²Œ */
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .save-box button:hover {
      background: rgba(255, 255, 255, 0.2);
    }


    /* justify-content ëŠ” ê°€ë¡œë°©í–¥ì •ë ¬, align-items ì€ ì„¸ë¡œë°©í–¥ì •ë ¬
 flex-startëŠ” ì•„ì´í…œë“¤ì„ ì‹œì‘ì§€ì ì— ë¶™ì—¬ì„œì •ë ¬ ê°€ë¡œë©´ ì™¼ìª½ì •ë ¬, ì„¸ë¡œë©´ ìœ„ìª½ì •ë ¬
 flex-endëŠ” ì•„ì´í…œë“¤ì„ ëì§€ì ì— ë¶™ì—¬ì„œ ì •ë ¬, ê°€ë¡œë©´ ì˜¤ë¥¸ìª½ì •ë ¬, ì„¸ë¡œë©´ ì•„ë˜ìª½ì •ë ¬*/
    .column {
      display: flex;
      flex-direction: column;
      align-self: start !important;
      /* ì„¸ë¡œì¶• ìœ„ìª½ ì •ë ¬ */
      height: max-content !important;
      /* ë‚´ìš©ë§Œí¼ë§Œ ë†’ì´ */
      gap: 12px;
      padding: 10px 6px;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .slot-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /*slot-row ì™€ left ë‘ê°€ì§€ í´ë˜ìŠ¤ ëª¨ë‘ë¥¼ ê°€ì§€ê³  ìˆëŠ”ê²ƒ, slot-rowì™€ left ì¤‘ í•˜ë‚˜ë§Œ ìˆìœ¼ë©´ ì ìš©ë˜ì§€ ì•ŠëŠ”ë‹¤)
//slot-row left ì ì´ ì•„ë‹Œ ë„ì–´ì“°ê¸°ë¥¼ í•˜ë©´, leftê°€ ì• ìš”ì†Œ ì•ˆì˜ ìš”ì†Œê°€ ë˜ëŠ”ë°, ì´ë•Œ leftëŠ” íƒœê·¸ì´ë‹¤. .leftë¡œ ì“°ê²Œë˜ë©´ í´ë˜ìŠ¤ê°€ ëœë‹¤.
//html(í´ë˜ìŠ¤)ì— ë„£ì–´ì„œ ì“¸ë•ŒëŠ” ë„ì–´ì“°ê¸°ë¡œ ì“´ë‹¤. class = "slot-row left" */
    .slot-row.left {
      justify-content: flex-end;
    }

    .slot-row.right {
      justify-content: flex-start;
    }

    .slot {
      width: clamp(64px, 10vh, 120px);
      aspect-ratio: 1/1;
      border-radius: 12px;
      background: radial-gradient(120px 120px at 40% 35%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02) 50%, rgba(255, 255, 255, 0.01) 100%);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: grid;
      place-items: center;
      position: relative;
      cursor: pointer;
      user-select: none;
      transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25) inset, 0 1px 0 rgba(255, 255, 255, 0.04);
    }

    /* :ëŠ” ì˜ì‚¬í´ë˜ìŠ¤, hoverëŠ” ë§ˆìš°ìŠ¤ë¥¼ ìœ„ì— ì˜¬ë¦° ìƒíƒœë¥¼ ëœ»í•¨. ë”°ë¼ì„œ slot í´ë˜ìŠ¤ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦¬ë©´ ì´ë¼ëŠ” ëœ»
// ê·¸ì™¸ì—ë„ active : í´ë¦­í•œ ìˆœê°„(ë§ˆìš°ìŠ¤ ë²„íŠ¼ ëˆ„ë¥´ê³  ìˆì„ë•Œ), focus : ì…ë ¥ì°½ í´ë¦­í–ˆì„ë•Œ, visited : ë°©ë¬¸í•œ ë§í¬, link : ë°©ë¬¸í•˜ì§€ ì•Šì€ ë§í¬
// first-child : ë¶€ëª¨ ì•ˆì—ì„œ ì²«ë²ˆì§¸ ìì‹, last-child : ë¶€ëª¨ ì•ˆì—ì„œ ë§ˆì§€ë§‰ ìì‹, ntn-child(n) : ë¶€ëª¨ ì•ˆì—ì„œ në²ˆì§¸ ìì‹
//checked : ì²´í¬ë°•ìŠ¤ë‚˜ ë¼ë””ì˜¤ë²„íŠ¼ì— ì²´í¬ëœìƒíƒœ, valid, invalid : ì…ë ¥ê°’ì´ ìœ íš¨ì„± ê²€ì‚¬ì— ë§ê±°ë‚˜ ì•„ë‹ë•Œ
//root : ë¬¸ì„œ ìµœìƒìœ„ ìš”ì†Œ */
    .slot:hover {
      transform: translateY(-2px);
      border-color: rgba(110, 168, 255, 0.5);
      box-shadow: 0 0 0 4px var(--ring), 0 10px 24px rgba(0, 0, 0, 0.35) inset;
    }

    /* slot-label í´ë˜ìŠ¤ëŠ” slotì˜ ìì†ì„ íƒìì´ë‹¤. ë”°ë¼ì„œ slot í´ë˜ìŠ¤ë¥¼ ì„ ì–¸í•˜ê³  ê·¸ ì•ˆì— ë˜ slot-label í´ë˜ìŠ¤ë¥¼ ì„ ì–¸í•´ì•¼í•œë‹¤. */
    .slot .slot-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      color: var(--muted);
      background: rgba(0, 0, 0, 0.35);
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      white-space: nowrap;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .outer-rects {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .rect {
      width: clamp(52px, 8vh, 96px);
      height: clamp(18px, 3vh, 28px);
      border-radius: 10px;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.06) inset, 0 6px 16px rgba(0, 0, 0, 0.25) inset;
      color: var(--text);
      font-size: 10px;
    }

    .rect:hover {
      border-color: rgba(110, 168, 255, 0.55);
      box-shadow: 0 0 0 3px var(--ring), 0 8px 18px rgba(0, 0, 0, 0.35) inset;
    }

    .rect.disabled {
      opacity: .45;
      pointer-events: none;
    }

    .center {
      display: grid;
      place-items: center;
      min-width: min(34vw, 460px);
      height: 100%;
    }

    .character-card {
      /*ë©”ì¸ ìºë¦­í„° ë°•ìŠ¤*/
      /*margin-top: 0px;  /* ì›í•˜ëŠ” ê°’(px, %, rem ë“±) */
      align-self: start;
      /* â† ì„¸ë¡œì¶• ìœ„ìª½ì— ë¶™ìŒ */
      width: clamp(20px, 25vw, 520px);
      aspect-ratio: 3/4;
      border-radius: 22px;
      background: radial-gradient(60% 40% at 50% 10%, rgba(110, 168, 255, 0.08), transparent 60%),
        linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: grid;
      place-items: center;
      position: relative;
      overflow: hidden;
      cursor: pointer;
      box-shadow: 0 0 0 6px rgba(110, 168, 255, 0.08) inset, 0 20px 50px rgba(0, 0, 0, 0.45);
    }

    .character-ghost {
      width: 80%;
      height: 80%;
      border-radius: 24px;
      border: 2px dashed rgba(255, 255, 255, 0.18);
      display: grid;
      place-items: center;
      color: var(--muted);
      text-align: center;
    }

    .character-img {
      position: absolute;
      inset: 12px;
      width: calc(100% - 24px);
      height: calc(100% - 24px);
      object-fit: contain;
      filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.45));
      display: none;
    }

    /* â–¼ í•˜ë‹¨ 4ê°œ ìŠ¬ë¡¯ */
    .mini-bar {
      align-self: start;
      /* ê·¸ë¦¬ë“œ ì¹¸ì—ì„œ ìœ„ìª½ì— ë¶™ì„ */
      /*margin-top: 10px;*/
      margin-bottom: 70px;
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    .mini-cell {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .slot.mini {
      width: clamp(64px, 10vh, 120px);
      aspect-ratio: 1 / 1;
      border-radius: 12px;
      flex: 0 0 auto;
    }

    /*slotí´ë˜ìŠ¤ì™€ minií´ë˜ìŠ¤ ë™ì‹œì— ì ìš©í•˜ë©° ê·¸ ë‘ í´ë˜ìŠ¤ì˜ ìì†í´ë˜ìŠ¤ê°€ slot-labelì´ ëœë‹¤.*/
    .slot.mini .slot-label {
      position: absolute;
      top: 50%;
      left: 50%;
      bottom: auto;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      z-index: 50;
    }

    .modal.show {
      display: grid;
    }

    .backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(2px);
    }

    .dialog {
      position: relative;
      width: min(1100px, 95vw);
      height: min(720px, 92vh);
      background: #0e0b09;
      border: 1px solid #2a211a;
      border-radius: 18px;
      padding: 12px 14px;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
    }

    /*headerì™€ h2ëŠ” dialogì˜ ìì†íƒœê·¸ë“¤ì´ë‹¤. íƒœê·¸ëŠ” ì“°ë ¤ë©´ <header> </header>ì„ ì¨ì•¼í•œë‹¤.
//ì´ ì½”ë“œë§Œ ë³´ê³ ëŠ” ì¢…ì†ê´€ê³„ë¥¼ ì•Œìˆ˜ëŠ” ì—†ë‹¤. headerê°€ ë” ë†’ì€ì§€, h2ê°€ ë†’ì€ì§€ ì•Œìˆ˜ì—†ë‹¤. */
    .dialog header {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 10px;
      padding: 6px 4px 8px;
      border-bottom: 1px solid #2a211a;
    }

    .dialog h2 {
      margin: 0;
      font-size: 15px;
      font-weight: 700;
      color: #f0e6d2;
    }

    .input {
      height: 34px;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      padding: 0 10px;
      background: #1a130f;
      color: #f0e6d2;
    }

    /* ìºë¦­í„° ì¹´íƒˆë¡œê·¸ */
    .catalog {
      overflow: auto;
      padding: 10px 6px 14px;
    }

    .row {
      display: grid;
      grid-template-columns: 56px 1fr 56px;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    .badge-img {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      object-fit: cover;
      background: #20170f;
      border: 2px solid #6e5124;
    }

    .cards {
      /* ì¹´ë“œì˜ ìŠ¤íƒ€ì¼ */
      display: grid;
      /* ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ ë°°ì¹˜*/
      grid-template-columns: repeat(5, minmax(160px, 1fr));
      /* ê°€ë¡œì¹¸(columns) 4ê°œ, ê°ì¹¸ì€ ìµœì†Œ 160px, ìµœëŒ€ 1fr(=ë‚¨ëŠ” ê³µê°„ ê· ë“± ë¶„ë°°) í¬ê¸° */
      gap: 12px;
      /*ì¹´ë“œë“¤ ì‚¬ì´ ê°€ë¡œ/ì„¸ë¡œ ê°„ê²© */
    }

    .char-card {
      position: relative;
      display: grid;
      grid-template-rows: auto auto;
      /*ì„¸ë¡œë¡œ 2ì¤„ ê·¸ë¦¬ë“œ (ì²«ì¤„ ì´ë¯¸ì§€, ë‘ë²ˆì§¸ì¤„ ì´ë¦„*/
      gap: 6px;
      /* ì¤„ ì‚¬ì´ 6px ê°„ê²© */
      padding: 8px;
      /* ì•ˆìª½ ì—¬ë°± */
      border-radius: 12px;
      background: var(--card-bg);
      cursor: pointer;
      /*ë§ˆìš°ìŠ¤ ì˜¬ë¦¬ë©´ ì†ê°€ë½ ëª¨ì–‘*/
      border: 1px solid var(--gold-2);
      /* ì¹´ë“œ í…Œë‘ë¦¬ (ê¸ˆìƒ‰ ê³„ì—´ ë³€ìˆ˜) */
    }

    .char-card:hover {
      /*ë§ˆìš°ìŠ¤ ì˜¬ë ¸ì„ë•Œ íš¨ê³¼ */
      box-shadow: inset 0 0 0 2px rgba(207, 162, 79, 0.22), 0 8px 22px rgba(0, 0, 0, 0.55);
    }

    .char-img {
      width: 100%;
      /* ë¶€ëª¨ ì¹´ë“œì˜ ê°€ë¡œí­ì„ ì „ë¶€ ì°¨ì§€ */
      aspect-ratio: 16/7;
      /* ê°€ë¡œ:ì„¸ë¡œ ë¹„ìœ¨ 16:7 ìœ ì§€ */
      object-fit: cover;
      /* ì´ë¯¸ì§€ ì˜ë¦¬ë”ë¼ë„ ì˜ì—­ ê½‰ ì±„ì›€ */
      border-radius: 8px;
      border: 1px solid rgba(207, 162, 79, 0.35);
      background: #0c0a08;
    }

    .char-name {
      font-size: 14px;
      color: #f0e6d2;
      font-weight: 700;
    }

    /* ë¬´ê¸° íƒ­ */
    .weapon-tabs {
      display: flex;
      gap: 8px;
      margin: 0 10px;
      flex-wrap: wrap
    }

    .weapon-tabs .tab-btn {
      height: 30px;
      padding: 0 12px;
      border-radius: 999px;
      cursor: pointer;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #c7b589
    }

    .weapon-tabs .tab-btn.active {
      background: #2a211a;
      border-color: #cfa24f;
      color: #f0e6d2;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset
    }

    /*overflowëŠ” ìš”ì†Œí¬ê¸°ë³´ë‹¤ ë‚´ìš©ì´ ë„˜ì¹˜ë©´ ì–´ë–»ê²Œ ì²˜ë¦¬í• ì§€ë¥¼ ë‚˜íƒ€ëƒ„
//autoëŠ” ìë™ ìŠ¤í¬ë¡¤ë°” ìƒê¹€, visibleì€ ê·¸ëƒ¥ ë°–ìœ¼ë¡œ ì‚ì ¸ë‚˜ì˜´, hiddenì€ ë„˜ì¹˜ëŠ” ë¶€ë¶„ ì˜ë¼ëƒ„, scrollì€ í•­ìƒ ìŠ¤í¬ë¡¤ë°” í‘œì‹œ */
    /* ë¦¬ìŠ¤íŠ¸í˜• ì¹´ë“œ */
    .items {
      overflow: auto;
      padding: 12px 8px 16px;
      display: grid;
      gap: 14px;
    }

    .item-list {
      display: grid;
      grid-template-columns: repeat(2, minmax(280px, 1fr));
      gap: 12px
    }

    .item-row {
      display: grid;
      grid-template-columns: 72px 1fr 64px;
      align-items: center;
      gap: 12px;
      background: #15100c;
      border: 1px solid #3a2c21;
      border-radius: 12px;
      padding: 10px;
      cursor: pointer
    }

    .item-row:hover {
      border-color: #7c5b37;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset
    }

    .iconbox {
      position: relative;
      width: 64px;
      height: 64px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(207, 162, 79, .35);
      background: #0c0a08
    }

    .iconbox .icon {
      width: 100%;
      height: 100%;
      object-fit: cover
    }

    .badge-lv {
      position: absolute;
      left: 4px;
      top: 4px;
      font-size: 11px;
      padding: 2px 5px;
      border-radius: 6px;
      background: #1e2b1e;
      color: #9fe19f;
      border: 1px solid #254c25
    }

    .meta .meta-top {
      display: flex;
      align-items: baseline;
      gap: 8px
    }

    .meta .lvl {
      color: #9fe19f;
      font-weight: 700;
      font-size: 13px
    }

    .meta .name {
      color: #f0e6d2;
      font-weight: 800;
      font-size: 15px
    }

    .meta-sub {
      color: #c7b589;
      font-size: 12px;
      margin-top: 4px
    }

    .rarity-chip {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid #7c5b37;
      background: #2a211a;
      color: #e7c27a;
      font-weight: 700;
      font-size: 12px;
      text-align: center
    }

    /* === Options panel (ìš°ì¸¡ ì˜µì…˜ ì—´) === */
    .column.options {
      align-items: stretch;
      /* ë„ˆë¹„ ê½‰ ì°¨ê²Œ */
      gap: 12px;
    }

    .opt-box {
      width: 100%;
      border-radius: 14px;
      padding: 12px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: grid;
      gap: 10px;
    }

    .opt-title {
      margin: 0 0 2px;
      font-size: 13px;
      font-weight: 800;
      color: #f0e6d2;
      letter-spacing: .2px;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field .label {
      font-size: 11px;
      color: var(--muted);
    }

    .select {
      height: 34px;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      padding: 0 10px;
      background: #1a130f;
      color: #f0e6d2;
      outline: none;
    }

    .select:focus {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    /*@ëŠ” ëª¨ë°”ì¼ ì „í™˜ì‹œ ì‚¬ìš©í•˜ëŠ” ë¶€í˜¸. ì •í™•íˆëŠ” í­ì´ ì¢ì•„ì§€ë©´.
    /* ëª¨ë°”ì¼ 1ì—´ ì „í™˜ ì‹œ ìì—°ìŠ¤ëŸ½ê²Œ íë¥´ë„ë¡(ê¸°ì¡´ ê·œì¹™ ìœ ì§€) */
    @media (max-width: 900px) {
      .column.options {
        order: 3;
      }

      /* ì¤‘ì•™/ì˜¤ë¥¸ìª½ ë‹¤ìŒì— ìœ„ì¹˜ */
    }

    /* â–¶ í•©ì‚° íŒ¨ë„ (ìš°ì¸¡ ê³ ì • + ìµœì¢…ë°ë¯¸ì§€) */
    aside.stats {
      align-self: start;
      /* ê·¸ë¦¬ë“œ ì•ˆì—ì„œ ìœ„ìª½ ì •ë ¬ */
      width: 100%;
      position: static;
      /* ê¸°ë³¸ íë¦„ìœ¼ë¡œ */
      top: auto;
      /* sticky ê¸°ì¤€ ì œê±° */
      height: 100%;
      /* ë¶ˆí•„ìš”í•œ 100% ë†’ì´ ì œê±° */
    }

    .stats-panel {
      width: 100%;
      height: 100%;
      border-radius: 18px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
    }

    .stats-panel h3 {
      margin: 4px 0 0;
      font-size: 14px;
      color: #f0e6d2;
    }

    .stat-list {
      overflow: auto;
      padding-right: 6px;
      display: grid;
      gap: 8px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 8px 10px;
    }

    .stat-label {
      color: var(--muted);
      font-size: 12px;
    }

    .stat-value {
      color: #e8edd6;
      font-weight: 800;
      font-size: 14px;
      text-align: right;
    }

    .final-damage {
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      padding-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 6px;
    }

    .final-damage .label {
      color: #f0e6d2;
      font-size: 13px;
      line-height: 1;
      text-align: left;
    }

    .final-damage .value {
      color: #ff5a6a;
      font-weight: 900;
      font-size: 25px;
      letter-spacing: .3px;
      line-height: 1.15;
      align-self: flex-end;
      text-align: right;
    }

    /* #ì€ ê³ ìœ  idë¥¼ ëœ»í•œë‹¤. í´ë˜ìŠ¤ì™€ ë‹¤ë¥¸ì ì€ ê³ ìœ í•˜ê¸°ë•Œë¬¸ì— ë‹¨í•œë²ˆë§Œ ì‚¬ìš©í•œë‹¤ëŠ” ì°¨ì´ê°€ ìˆìŒ */
    /* ê°•í™” ì„ íƒ ëª¨ë‹¬(í…ìŠ¤íŠ¸ ë¦¬ìŠ¤íŠ¸) */
    #enhanceModal .dialog {
      width: min(520px, 95vw);
      height: min(520px, 85vh);
    }

    .enh-list {
      overflow: auto;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .enh-option {
      height: 36px;
      padding: 0 12px;
      text-align: left;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #f0e6d2;
      cursor: pointer;
    }

    .enh-option:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
        grid-auto-rows: max-content;
        gap: 18px;
        height: auto;
        overflow: auto;
      }

      .center {
        min-width: 0;
      }

      .cards,
      .item-list {
        grid-template-columns: repeat(2, 1fr);
      }

      .row {
        grid-template-columns: 40px 1fr 40px;
      }

      .badge-img {
        width: 40px;
        height: 40px;
      }

      aside.stats {
        position: static;
      }
    }

    /* autoEnchantModal ì „ìš© 2-ì»¬ëŸ¼ ë ˆì´ì•„ì›ƒ */
    #autoEnchantModal .dialog {
      /* ê°•í™”ì„¤ì • ëª¨ë‹¬ê³¼ ê°™ì€ í­/íŒ¨ë”©ì„ ê³µìœ í•œë‹¤ë©´ ìƒëµ ê°€ëŠ¥ */
      max-width: 700px;
      /*ëª¨ë‹¬ë„ˆë¹„*/
    }

    #autoEnchantModal .body.two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    /* ê° ì»¬ëŸ¼ ë‚´ë¶€ ë²„íŠ¼ ë¦¬ìŠ¤íŠ¸ ë ˆì´ì•„ì›ƒ */
    #autoEnchantModal .col .list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    /* íƒ€ì´í‹€ ì—¬ë°±/ìŠ¤íƒ€ì¼ë„ ê°•í™”ì„¤ì • ëª¨ë‹¬ê³¼ í†¤ì„ ë§ì¶¤ */
    #autoEnchantModal .col .title {
      font-weight: 600;
      margin-bottom: 8px;
    }

    /* ì¶”ì²œ ë§ˆë²•ë¶€ì—¬ ëª¨ë‹¬: ì„ íƒ ê°•ì¡° */
    #autoEnchantModal .opt-btn.active {
      border-color: var(--brand, #2563eb);
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.25);
      /* í•„ìš”ì‹œ ë°°ê²½ë„ ì‚´ì§ */
      background: rgba(37, 99, 235, 0.06);
    }

    /* í‚¤ë³´ë“œ í¬ì»¤ìŠ¤ ì ‘ê·¼ì„±ë„ ë³´ì •(ì„ íƒê³¼ êµ¬ë¶„ë˜ê²Œ) */
    #autoEnchantModal .opt-btn:focus-visible {
      outline: 2px solid var(--brand, #2563eb);
      outline-offset: 2px;
    }

    /* ëª¨ë°”ì¼ ì¢ì€ í™”ë©´ì—ì„  1ì—´ë¡œ ë–¨ì–´ì§€ë„ë¡ */
    @media (max-width: 520px) {
      #autoEnchantModal .body.two-col {
        grid-template-columns: 1fr;
      }
    }

    /* ê³ ì • ë†’ì´ ì•„ì´í…œ ëª¨ë‹¬ */
    #itemModal .dialog {
      grid-template-rows: auto auto;
    }

    #itemModal .items {
      height: clamp(420px, 60vh, 560px);
      max-height: clamp(420px, 60vh, 560px);
      overflow: auto;
    }

    /* === Emblem sockets & modal â€” FINAL MERGED === */

    /* Stack of 2 sockets (vertical) */
    .emblem-stack {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    /* Socket dot (small circular button) */
    .emblem-dot {
      width: 28px;
      height: 28px;
      position: relative;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, .25);
      background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35) inset, 0 0 0 3px rgba(110, 168, 255, 0);
      display: grid;
      place-items: center;
      /* Hard guarantee: perfect circle in every browser */
      border-radius: 999px !important;
      overflow: hidden !important;
      clip-path: circle(50% at 50% 50%) !important;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
      background-clip: padding-box;
    }

    .emblem-dot:hover {
      box-shadow: 0 0 0 3px var(--ring);
    }

    /* When an emblem image is applied from JS as CSS var */
    .emblem-dot.has-img {
      background:
        var(--emblem) center/cover no-repeat,
        linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02)) !important;
    }

    .emblem-dot.has-img::after {
      display: none !important;
    }

    /* hide dashed guide when filled */

    /* Empty socket guide */
    .emblem-dot.empty {
      opacity: .45;
    }

    .emblem-dot.empty::after {
      content: "";
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px dashed rgba(255, 255, 255, .3);
    }

    /* Images inside sockets always clipped to circle */
    .emblem-dot img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      border-radius: 999px !important;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
    }

    /* Center number (socket & picker) â€” bright & legible */
    .emblem-dot .num,
    .em-thumb .num {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      color: #fff;
      font-weight: 900;
      letter-spacing: .2px;
      -webkit-text-stroke: 1px rgba(0, 0, 0, .35);
      text-shadow:
        0 1px 1px rgba(0, 0, 0, .55),
        0 0 4px rgba(255, 255, 255, .65),
        0 0 10px rgba(255, 255, 255, .45);
    }

    .emblem-dot .num {
      font-size: 16px;
    }

    /* 28px socket */
    .em-thumb .num {
      font-size: 22px;
    }

    /* 56px picker */

    /* Subtle center darkening behind number (not too strong) */
    .emblem-dot .num::before,
    .em-thumb .num::before {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 80%;
      border-radius: 999px;
      pointer-events: none;
      background: radial-gradient(circle,
          rgba(0, 0, 0, .18) 0%,
          rgba(0, 0, 0, .10) 45%,
          rgba(0, 0, 0, 0) 70%);
    }

    /* Hover: enhance number legibility */
    .emblem-dot:hover .num,
    .em-thumb:hover .num {
      -webkit-text-stroke: 1px rgba(0, 0, 0, .45);
      text-shadow:
        0 1px 2px rgba(0, 0, 0, .75),
        0 0 6px rgba(255, 255, 255, .60),
        0 0 14px rgba(255, 255, 255, .50);
    }

    /* === Emblem picker rows (horizontal scrollers) === */
    .em-rows {
      display: grid;
      gap: 12px;
      padding: 12px;
    }

    .em-row {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 6px;
    }

    /* Picker thumbnail (badge-like) */
    .em-thumb {
      width: 56px;
      height: 56px;
      position: relative;
      cursor: pointer;
      border-radius: 999px;
      padding: 0;
      border: 1px solid #3a2c21;
      background: #1a130f;
      display: grid;
      place-items: center;
      overflow: hidden;
    }

    .em-thumb:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    /* Always circular images */
    .em-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      border-radius: 999px !important;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
    }

    /* 'None' option as a circular crossed badge */
    .em-thumb.none {
      background: linear-gradient(135deg, #1a130f 0%, #0c0a08 100%);
      border-radius: 999px;
    }

    .em-thumb.none::before,
    .em-thumb.none::after {
      content: "";
      position: absolute;
      left: 10px;
      right: 10px;
      top: 50%;
      height: 2px;
      background: rgba(255, 255, 255, .35);
    }

    .em-thumb.none::after {
      transform: rotate(90deg);
    }

    /* Caption (for accessary/title slots) */
    .emblem-caption {
      margin-top: 4px;
      font-size: 11px;
      line-height: 1.1;
      color: #e7c27a;
      text-align: center;
      max-width: 84px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
    }

    /* === Seal text captions inside slots === */
    .seal-captions {
      position: absolute;
      left: 6px;
      bottom: 6px;
      display: flex;
      flex-direction: column;
      gap: 2px;
      /* í–‰ ê°„ê²© 2px */
      pointer-events: none;
      /* ë¹„í´ë¦­ */
    }

    .seal-captions .seal-row {
      display: flex;
      gap: 2px;
      justify-content: flex-start;
    }

    /* ì¢Œì¸¡ì •ë ¬ */
    .seal-captions .seal-chip {
      max-width: calc(100% - 12px);
      font-size: 9px;
      line-height: 1.2;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(207, 162, 79, 0.35);
      /* ê¸°ì¡´ ê³¨ë“œ í†¤ê³¼ ì–´ìš¸ë¦¬ê²Œ */
      color: inherit;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }



    /* === Skill Rune === */
    .rune-head {
      display: flex;
      gap: 8px;
      align-items: center;
      white-space: nowrap;
      /* âœ… ì¤„ë°”ê¿ˆ ë°©ì§€ */
    }

    .rune-head div {
      font-size: 12px;
      color: var(--muted, #6b7280);
      white-space: nowrap;
      /* âœ… ì¹´ìš´í„°ë„ ì¤„ë°”ê¿ˆ ì—†ìŒ */
    }

    .rune-head b {
      color: #e7c27a;
    }

    .rune-grid {
      --col-w: minmax(64px, 1fr);
      display: grid;
      grid-auto-rows: 40px;
      gap: 8px;
      overflow: auto;
    }

    .rune-grid .row {
      display: grid;
      grid-template-columns: 120px repeat(8, var(--col-w));
      align-items: center;
      gap: 8px;
    }

    .rune-grid .head {
      position: sticky;
      left: 0;
      z-index: 1;
      padding: 0 10px;
      border: 1px solid #3a2c21;
      border-radius: 10px;
      background: #1a130f;
      color: #f0e6d2;
      font-weight: 800;
      font-size: 13px;
      white-space: nowrap;
    }

    .rune-grid .cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .rune-select {
      width: 100%;
      height: 30px;
      border-radius: 8px;
      border: 1px solid #3a2c21;
      background: #15100c;
      color: #f0e6d2;
      padding: 0 8px;
    }

    .rune-select:focus {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    /* ë£¬ ê°ì¸ UI */
    .rune-engrave-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .field.compact {
      flex: 1 1 220px;
    }

    /* === Skill Tree UI â€” FINAL MERGED === */

    /* Header row */
    .skilltree-head {
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      gap: 15px;
      white-space: nowrap;
      /* âœ… ì¤„ë°”ê¿ˆ ê¸ˆì§€ */
    }

    .st-counters {
      display: flex;
      flex-direction: column;
      /* âœ… ì„¸ë¡œ ë°©í–¥ìœ¼ë¡œ */
      align-items: flex-start;
      gap: 6px;
      /* ìœ„ì•„ë˜ ê°„ê²© */
      white-space: nowrap;
    }

    .skilltree-head .st-counters span {
      display: inline-flex;
      align-items: center;
      font-size: 14px;
      color: var(--muted, #6b7280);
    }

    .skilltree-head .st-counters b {
      margin-left: 4px;
      color: var(--text, #1f2937);
    }

    /* ê³µí†µ ë²„íŠ¼(ì–‡ì€ ë¼ìš´ë“œ, ëŒ€ë¹„ í™•ë³´) */
    .ui-btn {
      --ui-bg: #fff;
      --ui-fg: #1f2937;
      --ui-bd: #e5e7eb;
      --ui-ring: rgba(37, 99, 235, .15);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 32px;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid var(--ui-bd);
      background: var(--ui-bg);
      color: var(--ui-fg);
      font-size: 13px;
      font-weight: 600;
      letter-spacing: .1px;
      white-space: nowrap;
      /* âœ… ë²„íŠ¼ ìì²´ë„ ì¤„ë°”ê¿ˆ ê¸ˆì§€ */
      user-select: none;
      cursor: pointer;
      transition: transform .06s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease;
      box-shadow: 0 1px 2px rgba(0, 0, 0, .04);
    }

    .ui-btn:hover {
      box-shadow: 0 4px 14px rgba(31, 41, 55, .08);
    }

    .ui-btn:active {
      transform: translateY(1px);
    }

    .ui-btn:focus-visible {
      outline: 0;
      box-shadow: 0 0 0 3px var(--ui-ring);
    }

    /* ë‹´ë°±í•œ ë³€í˜• */
    .ui-btn.ghost {
      background: #f8fafc;
    }

    /* ë‹¤í¬ í…Œë§ˆ ëŒ€ë¹„(ìˆìœ¼ë©´ ì ìš©) */
    @media (prefers-color-scheme: dark) {
      .ui-btn {
        --ui-bg: #0f1115;
        --ui-fg: #e6e9ef;
        --ui-bd: #273041;
      }

      .ui-btn.ghost {
        background: #151922;
      }
    }

    .ui-btn.primary {
      --ui-bg: #2563eb;
      /* íŒŒë€ ë°°ê²½ */
      --ui-fg: #fff;
      /* í° ê¸€ì”¨ */
      --ui-bd: #2563eb;
      background: var(--ui-bg);
      color: var(--ui-fg);
      border: 1px solid var(--ui-bd);
    }

    /* Top utility bar */
    .st-topbar {
      display: flex;
      gap: 14px;
      align-items: center;
      font-size: 12px;
      color: #c7b589;
    }

    /* ===== Universal counter styles (base) ===== */
    .st-counter {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, .25);
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 10px;
      font-size: 13px;
      /* base size; overridden in modal scope */
    }

    .st-counter .label {
      font-weight: 800;
      letter-spacing: .3px;
      font-size: 13px;
    }

    .st-counter .label.sp {
      color: #6ec6ff;
    }

    /* cyan-like */
    .st-counter .label.tp {
      color: #ff4444;
    }

    /* red */
    .st-counter .val {
      min-width: 18px;
      text-align: right;
      color: #e6e9ef;
      font-variant-numeric: tabular-nums;
      font-size: 13px;
    }

    /* Keep modal header balanced */
    .modal .dialog header {
      justify-content: space-between;
    }

    /* ===== Optional large pills elsewhere (kept for compatibility) ===== */
    :root {
      --sp-blue: #2BCCED;
      --tp-red: #F03231;
    }

    .actions .sp-tp {
      display: none;
      gap: 18px;
      align-items: center;
      font-size: 20pt;
    }

    .counter-pill {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-weight: 800;
      letter-spacing: .1px;
      color: var(--text);
      text-shadow: 0 1px 2px rgba(0, 0, 0, .55);
    }

    .counter-pill .lab {
      font-size: 1em;
      font-style: italic;
      font-weight: 900;
    }

    .counter-pill.sp .lab {
      color: var(--sp-blue);
    }

    .counter-pill.tp .lab {
      color: var(--tp-red);
    }

    /* ===== Modal-only: big counters aligned to the right ===== */
    #skillTreeModal .st-counters {
      margin-left: auto;
      font-size: 20pt;
    }

    #skillTreeModal .st-counter,
    #skillTreeModal .st-counter .label,
    #skillTreeModal .st-counter .val {
      font-size: 20pt;
    }

    /* Modal size */
    #skillTreeModal .dialog {
      width: min(1600px, 98vw) !important;
      height: min(920px, 95vh) !important;
    }

    /* ===== SkillTree v1 (legacy banded columns) ===== */
    .st-grid {
      grid-auto-flow: column;
      grid-auto-columns: 320px;
      /* generous column width */
      gap: 12px;
      padding: 12px;
    }

    .st-col {
      gap: 8px;
      align-content: start;
    }

    .st-band {
      position: sticky;
      top: 0;
      z-index: 2;
      padding: 6px 10px;
      border: 1px solid #3a2c21;
      border-radius: 10px;
      background: #1a130f;
      color: #e7c27a;
      font-weight: 800;
      font-size: 13px;
      text-align: center;
    }

    /* ===== SkillTree v2 (bands / coordinate grid) ===== */

    /* Wrapper for bands */
    .st2-wrap {
      display: grid;
      gap: 14px;
    }

    /* Each band's grid sits a bit below its dashed label line */
    .st2-band>.st2-grid {
      margin-top: 3px;
    }

    /* Band container: prevent clipping; add room above/below */
    .st2-band {
      position: relative;
      margin: 1px 0;
      padding-top: 10px;
      /* room for label/dashed line */
      padding-bottom: 1px;
      /* room for controls */
      overflow: visible;
    }

    /* Band dashed line */
    .st2-band::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      border-top: 1px dashed rgba(207, 162, 79, .55);
    }

    /* Band label sitting over dashed line */
    .st2-band-label {
      position: absolute;
      left: 0;
      top: 0;
      transform: translateY(-50%);
      padding: 0 6px;
      border-radius: 8px;
      background: #0e0b09;
      color: #e7c27a;
      font-weight: 800;
      font-size: 12px;
      line-height: 1.4;
      z-index: 1;
    }

    /* 6-column responsive grid; variable row height */
    .st2-grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(100px, 1fr));
      grid-auto-rows: minmax(164px, max-content);
      gap: 10px;
    }

    /* ===== Skill tiles ===== */

    /* Tile: icon (top) / name (middle) / controls (bottom) */
    .st2-tile {
      display: grid;
      grid-template-rows: auto auto auto;
      align-items: center;
      justify-items: center;
      gap: 6px;
      max-width: 100%;
      overflow: hidden;
    }

    /* Skill name */
    .st2-name {
      width: 100%;
      max-width: 340px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 17px;
      font-weight: 800;
      line-height: 1.1;
      color: #e7c27a;
    }

    /* Circular icon */
    .st2-skill {
      width: clamp(68px, 7.6vw, 92px);
      height: clamp(68px, 7.6vw, 92px);
      border-radius: 999px;
      border: 1px solid #3a2c21;
      background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35) inset;
      display: grid;
      place-items: center;
      overflow: hidden;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%);
      mask-image: radial-gradient(circle, #000 99%, transparent 100%);
    }

    .st2-skill img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 999px;
    }

    /* Controls: left stack / center level box / right stack */
    .st2-ctrl2 {
      display: grid;
      grid-template-columns: max-content auto max-content;
      grid-template-rows: auto auto;
      align-items: center;
      justify-items: center;
      column-gap: 8px;
      row-gap: 2px;
    }

    /* Left/Right button stacks */
    .st2-side-left,
    .st2-side-right {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    /* Central level box */
    .st2-lv {
      grid-column: 2;
      grid-row: 1 / span 2;
      min-width: 110px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #f0e6d2;
      text-align: center;
      font-weight: 800;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .st2-lvnums {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .st2-lv .cur,
    .st2-lv .tp {
      font-size: 16px;
      line-height: 1;
    }

    .st2-lv .sep {
      opacity: .6;
      margin: 0;
    }

    /* Buttons */
    .st2-btn {
      height: 24px;
      padding: 0 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #c7b589;
      cursor: pointer;
      white-space: nowrap;
    }

    .st2-btn:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .18) inset;
    }

    .st2-btn:disabled {
      opacity: .5;
      cursor: default;
      border-color: #2a211a;
      box-shadow: none;
    }

    /* ===== Auto Input Panels ===== */
    .auto-box {
      width: 100%;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
      margin-bottom: 10px;
    }

    .auto-box h4 {
      margin: 0 0 8px;
      font-size: 14px;
      color: #e7c27a;
    }

    .auto-box .btn {
      width: 100%;
      height: 34px;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #f0e6d2;
      cursor: pointer;
    }

    .auto-box .btn:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    .auto-box .btn[disabled] {
      opacity: .5;
      cursor: not-allowed;
    }

    /* Simple list modal */
    .simple-modal .dialog {
      width: min(420px, 92vw);
    }

    .simple-modal .list {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      padding: 10px;
    }

    .simple-modal .list .opt-btn {
      height: 38px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: #1a1b27;
      color: #e6e9ef;
      cursor: pointer;
    }

    .simple-modal .list .opt-btn:hover {
      border-color: #6ea8ff;
      box-shadow: 0 0 0 2px rgba(110, 168, 255, .25) inset;
    }

    /* ========== ë¡œê·¸ì¸ ì´í›„ ë ˆì´ì•„ì›ƒ ì •ë¦¬(PC/Mobile ê³µí†µ) ========== */

    /* ê³µí†µ: hiddenì€ ì™„ì „ ì œê±° */
    [hidden] {
      display: none !important;
    }

    /* 1) ë¡œê·¸ì¸ ë·° ê³„ì—´ í†µì§¸ë¡œ ì ‘ê¸° (.login-wrap, #main-view, .hero) */
    body:is(.pc, .mobile) :is(.login-wrap, #main-view, section.hero) {
      display: none !important;
      height: 0 !important;
      min-height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    /* 2) .shellì€ ì»¨í…Œì´ë„ˆ ë°•ìŠ¤ ì œê±°(ìì‹ë§Œ íë¥´ê²Œ) */
    body:is(.pc, .mobile) .shell {
      display: contents !important;
      height: auto !important;
      min-height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      gap: 0 !important;
      grid-template-rows: none !important;
      grid-auto-rows: auto !important;
    }

    /* 3) ë³¸ë¬¸ ì‹œì‘ ê°„ê²©(í•„ìš” ì‹œ ìˆ«ìë§Œ ì¡°ì ˆ) */
    body:is(.pc, .mobile) #calc-view {
      margin-top: 12px !important;
    }

    /* 4) ì•ˆì „í•€: calc-viewëŠ” ìœ„ë¡œ ë”± ë¶™ê²Œ(ìƒë‹¨ ë§ˆì§„ ì´ˆê¸°í™”) */
    #calc-view {
      margin-top: 0 !important;
    }

    /* ===== Header ê´‘ê³ (ì˜¤ë¥¸ìª½ í…ìŠ¤íŠ¸) ===== */
    .header-ads {
      margin-left: auto;
      /* ìš°ì¸¡ ì •ë ¬ */
      margin-right: 40px;
      /* â† ìš°ì¸¡ ì—¬ë°± (ì›í•˜ë©´ 12~24px ì¡°ì ˆ) */
      display: flex;
      align-items: center;
      max-width: 40vw;
    }

    .header-ads .ad-text {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 32vw;
      transition: opacity .25s ease;
      opacity: 1;
    }

    .header-ads .fade-out {
      opacity: 0;
    }

    /* í•œë§ˆë”” ê³µí†µ */
    .header-ads .line .hdrmsg {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .header-ads .line .hdrmsg .msg-bullet {
      opacity: 0.6;
    }

    .header-ads .line .hdrmsg .msg-text {
      opacity: 0.95;
    }

    /* ë°°ì§€ ê¸°ë³¸ */
    .header-ads .line .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
    }

    /* ì±…ì„ = ì°¨ë¶„í•œ ì¤‘ë¦½í†¤ */
    .header-ads .line .tag-lead {
      background: rgba(120, 120, 120, 0.12);
      color: rgba(120, 120, 120, 1);
      border: 1px solid rgba(120, 120, 120, 0.25);
    }

    /* ìˆ˜ì„ = ê³¨ë“œ ê·¸ë¼ë°ì´ì…˜ + ì€ì€í•œ ê´‘íƒ */
    /* ê³µí†µ ë ˆì´ì•„ì›ƒ */
    .hdrmsg {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .hdrmsg .msg-bullet {
      opacity: 0.6;
    }

    .hdrmsg .msg-text {
      opacity: 0.95;
    }

    /* ìˆ˜ì„ ë°°ì§€(ğŸ‘‘ë§Œ ë“¤ì–´ê°€ë„ ì˜ˆì˜ê²Œ ë³´ì´ê²Œ) */
    .tag-senior {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 10px;
      /* pill ëª¨ì–‘ì´ ë³´ì´ë„ë¡ íŒ¨ë”© */
      min-width: 32px;
      /* ë„ˆë¬´ ì‘ê²Œ ë¶™ì§€ ì•Šê²Œ ìµœì†Œ í­ */
      height: 20px;
      border-radius: 999px;
      font-size: 13px;
      /* ğŸ‘‘ í¬ê¸° */
      line-height: 1;
      background: linear-gradient(135deg, #ffe08a 0%, #ffd257 45%, #ffc63a 100%);
      border: 1px solid rgba(172, 124, 22, 0.55);
      color: #2a1b00;
      /* ì´ëª¨ì§€ ì™¸ ê¸€ììƒ‰(í˜¹ì‹œ í…ìŠ¤íŠ¸ê°€ ì¶”ê°€ë˜ì–´ë„) */
      position: relative;
      overflow: hidden;
    }

    /* ì€ì€í•œ ë°˜ì§ì„ */
    .tag-senior::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, .45) 35%, transparent 70%);
      transform: translateX(-120%);
      animation: shimmer 2.4s linear infinite;
      pointer-events: none;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-120%);
      }

      100% {
        transform: translateX(120%);
      }
    }

    /* ì±…ì„ ë°°ì§€: ì•„ì£¼ ì‘ì€ íšŒìƒ‰ ì  */
    .tag-lead {
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(120, 120, 120, .7);
      box-shadow: 0 0 0 1px rgba(120, 120, 120, .25);
      margin-right: 2px;
      /* ë‹‰ë„¤ì„ê³¼ ì‚´ì§ ê°„ê²© */
      vertical-align: middle;
    }

    /* ìˆ˜ì„ ë‹‰ë„¤ì„ ì‚´ì§ ê°•ì¡° (ì˜µì…˜) */
    .hdrmsg.senior .msg-nick {
      font-weight: 600;
      text-decoration: underline;
      text-decoration-color: rgba(255, 198, 58, .7);
      text-underline-offset: 2px;
    }

    /* ì±…ì„ì€ ë°°ì§€ ì—†ìœ¼ë‹ˆ ë³„ë„ ìŠ¤íƒ€ì¼ ë¶ˆí•„ìš” (ì›í•˜ë©´ ì•„ì£¼ ì˜…ì€ ì  ë°°ì§€ ì¶”ê°€ ê°€ëŠ¥) */

    .loading-overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      background: rgba(0, 0, 0, .55);
      display: grid;
      place-items: center;
    }

    .loading-box {
      width: min(480px, 90vw);
      background: #0f1115;
      color: #e6e9ef;
      border: 1px solid rgba(255, 255, 255, .2);
      border-radius: 14px;
      padding: 20px 24px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .45);
    }

    .loading-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .loading-bar {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .12);
      overflow: hidden;
    }

    .loading-bar__fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #6ea8ff, #8fe3ff);
      transition: width .2s ease;
    }

    .loading-info {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      opacity: .9;
    }

    /* ì„±ì•ˆì˜ ë´‰ì¸ ëª¨ë‹¬ ë ˆì´ì•„ì›ƒ */
    #castleSealModal .dialog.seal {
      width: min(920px, 95vw);
    }

    #castleSealModal .two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    #castleSealModal .list {
      max-height: 60vh;
      overflow: auto;
    }

    #castleSealModal .opt-row {
      display: block;
      width: 100%;
      text-align: left;
      border: 1px solid rgba(255, 255, 255, .15);
      background: #0f1115;
      border-radius: 8px;
      padding: 12px 14px;
      margin: 8px 0;
    }

    #castleSealModal .opt-row .name {
      font-weight: 600;
      margin-bottom: 4px;
    }

    #castleSealModal .opt-row .desc {
      opacity: .9;
      font-size: 12px;
      line-height: 1.3;
    }

    #castleSealModal .opt-row.active {
      outline: 2px solid #8fe3ff;
      background: #121521;
    }

    .seal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      /* ì œëª© ì™¼ìª½, ë²„íŠ¼ ì˜¤ë¥¸ìª½ */
      gap: 8px;
    }

    #optSeal .opt-title {
      margin: 0;
      font-size: 14px;
    }
  </style>

<body>
  <!-- ë¡œë”© ì˜¤ë²„ë ˆì´ (ê¸°ë³¸ hidden) -->
  <div id="loadingOverlay" class="loading-overlay" hidden>
    <div class="loading-box">
      <div class="loading-title">ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</div>
      <div class="loading-bar">
        <div class="loading-bar__fill" style="width:0%"></div>
      </div>
      <div class="loading-info">
        <span id="loadingLabel">ì´ˆê¸°í™”â€¦</span>
        <span id="loadingPct">0%</span>
      </div>
    </div>
  </div>
  <div class="shell">
    <header>
      <div class="title">
        <div class="dot" aria-hidden="true"></div>
        <h1>ê²Œì„ì‹¤í—˜ì—°êµ¬ì†Œ ê³„ì‚°ê¸° (ì‹œì¦Œ5)</h1>
      </div>
      <!--span ì€ í•œì¤„ì—ì„œ íŠ¹ë³„íˆ ê°•ì¡° í• ë•Œ ì“´ë‹¤. divëŠ” í•œì¤„ì´ ê°•ì œë¡œ ë‚˜ë‰˜ê¸°ë•Œë¬¸ì— ì“´ë‹¤.-->
      <div class="actions">
        <div class="sp-tp" id="spTpTop">
          <span class="counter-pill sp"><span class="lab">SP</span><span id="spLeftTop"
              style="min-width:24px;display:inline-block;text-align:right;">â€”</span></span>
          <span class="counter-pill tp"><span class="lab">TP</span><span id="tpLeftTop"
              style="min-width:24px;display:inline-block;text-align:right;">â€”</span></span>

        </div>
      </div>
    </header>
    <section id="main-view">
      <!-- ì—¬ê¸°ì— ë„¤ê°€ ë§Œë“  ë©”ì¸(ë°°ê²½/ìš°ì¸¡ ê³µì§€/ë¹¨ê°„ íƒ€ì› ìœ„ì¹˜ ë¡œê·¸ì¸ ì¹´ë“œ) ë§ˆí¬ì—… -->
      <!-- PC / ëª¨ë°”ì¼ ë²„íŠ¼ë„ ì—¬ê¸° -->
      <div class="wrap">
        <h1 class="top-title">ë˜ì „ì•¤íŒŒì´í„° ëª¨ë°”ì¼ <span style="color:#ffdf6b">ì‹œì¦Œ 5</span> ë°ë¯¸ì§€ ê³„ì‚°ê¸°</h1>
        <div class="main2">â€» ë³¸ ê³„ì‚°ê¸°ëŠ” ê²Œì„í”Œë ˆì´ì— ë„ì›€ì´ ë˜ê³ ì ë§Œë“  ê²ƒì…ë‹ˆë‹¤. ìˆœìˆ˜í•œ ì •ë³´ê³µìœ ê°€ ì•„ë‹Œ, ìƒì—…ì  ëª©ì ìœ¼ë¡œì˜ ë¸”ë¡œê·¸ ê²Œì¬, ê°œì¸ë°©ì†¡, ìœ íŠœë¸Œ ì˜ìƒì œì‘ ë“±ì˜ ì œì‘ì ë™ì˜ì—†ëŠ”
          ì´ìš©ì„ ê¸ˆí•˜ë©°, ë¬´ë‹¨ìˆ˜ì • ë° ë„ìš©ë„ ì—„ê²©íˆ ê¸ˆì§€í•©ë‹ˆë‹¤.</div>

        <div class="grid">
          <!-- ì™¼ìª½: ë©”ì¸ ë¹„ì£¼ì–¼ -->
          <section class="hero">
            <!-- ë„¤ê°€ ì“°ë ¤ëŠ” ë©”ì¸ ì´ë¯¸ì§€ë¥¼ ë„£ì–´ì¤˜ -->
            <img class="hero-img" src="img/main/main.png" alt="ë©”ì¸ ë¹„ì£¼ì–¼" />
          </section>
          <!-- ì˜¤ë¥¸ìª½: ê³µì§€/ì—…ë°ì´íŠ¸ -->
          <div class="sidebar">
            <aside class="notice">
              <h3>* ê³„ì‚°ê¸°ëŠ” ê³„ì†í•´ì„œ ì—…ë°ì´íŠ¸ë  ì˜ˆì •ì…ë‹ˆë‹¤!</h3>
              <div class="box">
                <div class="badge-danger">25.10.27 ì‹ ê·œ ê³„ì‚°ê¸° ë¸”ë ˆì´ë“œ ë²„ì „ ë°°í¬</div>
                <ul>
                  <li>ê²Œì„ì‹¤í—˜ì—°êµ¬ì†Œ ì‹ ê·œ ê³„ì‚°ê¸° ì˜¤í”ˆ!</li>
                  <li>"ë¸”ë ˆì´ë“œ" ìºë¦­ ìŠ¤í‚¬íŠ¸ë¦¬ ì—°ë™ ë° ìµœì¢… ê³„ì‚° ë°˜ì˜</li>
                  <li>íƒ€ìºë¦­ ì¶”í›„ êµ¬í˜„ ì˜ˆì •</li>
                  <li>ìŠ¤í™ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ê¸°ëŠ¥ ì¶”í›„ êµ¬í˜„ ì˜ˆì • </li>
                </ul>
              </div>
              <div class="upgrade">
                ë©¤ë²„ì‹­ ì—…ê·¸ë ˆì´ë“œ ì‹œ <span class="main2" style="font-size:16px;">í¸ì˜ ê¸°ëŠ¥</span> ì´ìš©ê°€ëŠ¥ <br> â†’
                <!--ë©¤ë²„ì‹­ ì—…ê·¸ë ˆì´ë“œ ì‹œ <span class="main2" style="font-size:16px;">ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°</span> ë“± í¸ì˜ ê¸°ëŠ¥ ì´ìš© ê°€ëŠ¥ <br> â†’-->
                <a href="https://www.youtube.com/channel/UCijUV3SuVe_qErzBpdOmKIA/join" target="_blank"
                  rel="noopener">ì§€ê¸ˆ ë©¤ë²„ì‹­ ì—…ê·¸ë ˆì´ë“œ!!!</a>
              </div>
            </aside>
            <div class="login-card">
              <div class="login-title">ê³„ì‚°ê¸° ì ‘ê·¼ì„ ìœ„í•´ êµ¬ê¸€ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸</div>
              <div class="login-desc">
                í—ˆìš©ëœ ê³„ì •ë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤. ë¡œê·¸ì¸ í›„ ìë™ìœ¼ë¡œ ê¶Œí•œì„ í™•ì¸í•©ë‹ˆë‹¤.
              </div>

              <div class="login-row">
                <!-- Google Sign-In ë²„íŠ¼ -->
                <!-- 1) onload ì„¸íŒ…: client_id êµì²´ í•„ìˆ˜ -->
                <div id="g_id_onload"
                  data-client_id="110486887643-3c136grpud2llf2b31d24fqr40s1p44g.apps.googleusercontent.com"
                  data-callback="onGoogleCredential" data-auto_prompt="false" data-itp_support="true">
                </div>
                <!-- 2) ë²„íŠ¼ ë Œë” -->
                <div class="g_id_signin" data-type="standard" data-size="large" data-shape="pill" data-theme="outline"
                  data-text="signin_with" data-logo_alignment="left">
                </div>

                <div class="login-hint">â€» ë²„íŠ¼ì´ ë³´ì´ì§€ ì•Šìœ¼ë©´ íŒì—…/ì¶”ì ì°¨ë‹¨ì„ í™•ì¸í•´ ì£¼ì„¸ìš”.</div>
              </div>
            </div>
          </div>
        </div>
      </div>
  </div>
  </section>
  <section id="calc-view" hidden>
    <section class="layout">
      <div class="column left">
        <div class="auto-box">
          <h4>ìë™ ì…ë ¥</h4>
          <button id="btnAutoEnh" class="btn">ê°•í™” ìë™ ì…ë ¥</button>
          <div style="height:8px;"></div>
          <button id="btnAutoSeal" class="btn">ì¶”ì²œ ë§ˆë²•ë´‰ì¸ ìë™ ì…ë ¥</button>
        </div>

        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button></div>
          <div class="slot" data-slot="L1"><span class="slot-label">ë¨¸ë¦¬ì–´ê¹¨</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button></div>
          <div class="slot" data-slot="L2"><span class="slot-label">ìƒì˜</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button></div>
          <div class="slot" data-slot="L3"><span class="slot-label">í•˜ì˜</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button></div>
          <div class="slot" data-slot="L4"><span class="slot-label">í—ˆë¦¬</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button></div>
          <div class="slot" data-slot="L5"><span class="slot-label">ì‹ ë°œ</span></div>
        </div>
      </div>

      <div class="center">
        <div id="characterCard" class="character-card">
          <img id="characterImg" class="character-img" alt="ìºë¦­í„°" />
          <div id="characterGhost" class="character-ghost">í´ë¦­í•˜ì—¬ ìºë¦­í„° ì„ íƒ</div>
        </div>
        <div class="mini-bar">
          <div class="mini-cell">
            <div class="outer-rects">
              <button class="rect" data-unused="true">ì„ íƒ</button>
              <button class="rect" data-unused="true">ì„ íƒ</button>
            </div>
            <div class="slot mini" data-slot="C2"><span class="slot-label">ì¹­í˜¸</span></div>
          </div>
          <div class="slot mini" data-slot="C1"><span class="slot-label">ì˜¤ë¼</span></div>
          <div class="slot mini" data-slot="C3"><span class="slot-label">í¬ë¦¬ì³</span></div>
          <div class="slot mini" data-slot="C4"><span class="slot-label">ì•„í‹°íŒ©íŠ¸</span></div>
        </div>
      </div>

      <div class="column right">
        <div class="auto-box">
          <h4>ìë™ ì…ë ¥</h4>
          <button id="btnAutoEnchant" class="btn">ì¶”ì²œ ë§ˆë²•ë¶€ì—¬ ìë™ ì…ë ¥</button>
          <div style="height:8px;"></div>
          <button id="btnAutoEmblem" class="btn">ì— ë¸”ë ˜ ìë™ ì…ë ¥</button>
        </div>

        <div class="slot-row right">
          <div class="slot" data-slot="R1"><span class="slot-label">ë¬´ê¸°</span></div>
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R2"><span class="slot-label">íŒ”ì°Œ</span></div>
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R3"><span class="slot-label">ëª©ê±¸ì´</span></div>
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R4"><span class="slot-label">ë°˜ì§€</span></div>
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R5"><span class="slot-label">ë³´ì¡°ì¥ë¹„</span></div>
          <div class="outer-rects"><button class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button><button
              class="rect">ì„ íƒ</button><button class="rect">ì„ íƒ</button></div>
        </div>
      </div>
      <div class="save-box">
        <button>+</button>
        <button>+</button>
        <button>+</button>
        <button>+</button>
        <button>+</button>
      </div>

      <div class="column options">
        <div class="opt-box">
          <h4 class="opt-title">ì•„ë°”íƒ€ ì„¸ë¶€ ì„ íƒ</h4>
          <label class="field">
            <span class="label">ì•„ë°”íƒ€</span>
            <select id="selAvatar" class="select" aria-label="ì•„ë°”íƒ€ ì„ íƒ">
              <option value="" disabled>ì•„ë°”íƒ€ ì„ íƒ</option>
              <option value="rare" selected>ë ˆì–´ ì•„ë°”íƒ€</option>
              <option value="advanced">ìƒê¸‰ ì•„ë°”íƒ€</option>
              <option value="empty">ì—†ìŒ</option>
            </select>
          </label>
          <label class="field">
            <span class="label">ë¬´ê¸°ì••</span>
            <select id="selImprint" class="select" aria-label="ë¬´ê¸°ì•• ì„ íƒ">
              <option value="" disabled>ë¬´ê¸°ì•• ì„ íƒ</option>
              <option value="add5">ì¶”ë€ 5% ë¬´ê¸°ì••</option>
              <option value="patkmatk5" selected>ë¬¼/ë§ˆê³µ 5% ë¬´ê¸°ì••</option>
              <option value="patkmatk3">ë¬¼/ë§ˆê³µ 3% ë¬´ê¸°ì••</option>
              <option value="monster">ëª¬ìŠ¤í„° ë¬´ê¸°ì••</option>
              <option value="quest">í€˜ìŠ¤íŠ¸ ë¬´ê¸°ì••</option>
              <option value="empty">ì—†ìŒ</option>
            </select>
          </label>
        </div>

        <div class="opt-box">
          <h4 class="opt-title">ê³„ì‚° ì„¸ë¶€ ì˜µì…˜ ì¡°ì ˆ</h4>
          <label class="field">
            <span class="label">ì‹œê°„ ê¸°ì¤€</span>
            <select id="selTime" class="select" aria-label="ì‹œê°„ ê¸°ì¤€">
              <option value="" disabled>ì‹œê°„ ê¸°ì¤€</option>
              <option value="30s">30ì´ˆë”œ</option>
              <option value="1m" selected>1ë¶„ë”œ</option>
              <option value="3m">3ë¶„ë”œ</option>
              <option value="5m">5ë¶„ë”œ</option>
              <option value="10m">10ë¶„ë”œ</option>
            </select>
          </label>
          <!--document.getElementById("selMonster").value ë¼ê³  ì“°ë©´ ì„¤ì •ëœ ëª¬ìŠ¤í„°ê°’ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆìŒ-->
          <label class="field">
            <span class="label">ëª¬ìŠ¤í„° ì„¤ì •</span>
            <select id="selMonster" class="select" aria-label="ëª¬ìŠ¤í„° ì„¤ì •">
              <option value="" disabled>ëª¬ìŠ¤í„° ì„¤ì •</option>
              <option value="nugol" selected>ê±°ëŒ€ëˆ„ê³¨</option>
              <option value="blackdragon">í‘ë£¡</option>
              <option value="anton">ì•ˆí†¤</option>
              <option value="asmar_calix">ì•„ìŠ¤ë§ˆë¥´/ì¹¼ë¦­ìŠ¤</option>
            </select>
          </label>

          <label class="field">
            <span class="label">ë˜ì „ ë‚œì´ë„</span>
            <select id="selDifficulty" class="select" aria-label="ë˜ì „ ë‚œì´ë„ ì„¤ì •">
              <option value="" disabled>ë˜ì „ ë‚œì´ë„ ì„¤ì •</option>
              <option value="hard">ì–´ë ¤ì›€</option>
              <option value="normal">ë³´í†µ</option>
              <option value="easy">ì‰¬ì›€</option>
              <option value="nugol_room" selected>ëˆ„ê³¨ë°©</option>
            </select>
          </label>
        </div>
        <div class="opt-box">
          <h4 class="opt-title">ìŠ¤í‚¬ë£¬</h4>
          <div class="rune-head">
            <button id="btnRune" class="ui-btn ghost" type="button" aria-label="ìŠ¤í‚¬ë£¬ ì„¤ì •">
              ìŠ¤í‚¬ë£¬ ì„¤ì •
            </button>
            <div style="font-size:12px;color:var(--muted);">
              ì„ íƒí•œ ìŠ¤í‚¬ë£¬ ê°œìˆ˜: <b id="runeCount" style="color:#e7c27a;">0</b>
            </div>
          </div>
          <div class="rune-engrave-row">
            <label class="field compact">
              <span class="label">ë£¬ ê°ì¸ ì„¤ì •</span>
              <select id="selRuneEngrave" class="select" aria-label="ë£¬ ê°ì¸ ì„¤ì •">
                <option value="" selected disabled>ë£¬ ê°ì¸ ì„¤ì •</option>
              </select>
            </label>

            <label class="field compact">
              <span class="label">ì„¸ë¶€ ì„¤ì •</span>
              <select id="selRuneDetail" class="select" aria-label="ì„¸ë¶€ ì„¤ì •" disabled>
                <option value="" selected disabled>ì„¸ë¶€ ì„¤ì •</option>
              </select>
            </label>
          </div>


        </div>

        <div class="opt-box">
          <h4 class="opt-title">ìŠ¤í‚¬íŠ¸ë¦¬</h4>
          <div class="skilltree-head">
            <button id="btnSkillTree" class="ui-btn primary" type="button" aria-label="ìŠ¤í‚¬íŠ¸ë¦¬ ì„¤ì •"
              style="margin-top:2px;">ìŠ¤í‚¬íŠ¸ë¦¬ ì„¤ì •</button>
            <div class="st-counters">
              <span>ë‚¨ì€ SP: <b id="stSpLeft">â€”</b></span>
              <span>ë‚¨ì€ TP: <b id="stTpLeft">â€”</b></span>
            </div>
          </div>
        </div>
        <div class="final-damage">
          <span class="label">ìµœì¢…ë°ë¯¸ì§€</span>
          <strong class="value" id="finalDamageValue2">&nbsp;</strong>
          <button id="btn-sum-all-final2" type="button">ê³„ì‚°í•˜ê¸°</button>
        </div>
      </div>

      <aside class="stats">
        <div class="stats-panel">
          <!-- â–¼ ì„±ì•ˆì˜ ë´‰ì¸ -->
          <div class="opt-box" id="optSeal">
            <div class="seal-head">
              <h4 class="opt-title">ì„±ì•ˆì˜ ë´‰ì¸</h4>
              <button id="btnCastleSeal" class="ui-btn primary" type="button" aria-label="ì˜µì…˜ ì„ íƒ">
                ì˜µì…˜ ì„ íƒ
              </button>
            </div>
          </div>
          <h3>í•©ì‚° ìŠ¤íƒ¯</h3>
          <div id="statList" class="stat-list"></div>
          <div class="final-damage">
            <span class="label">ìµœì¢…ë°ë¯¸ì§€</span>
            <strong class="value" id="finalDamageValue">&nbsp;</strong>
            <button id="btn-sum-all-final" type="button">ê³„ì‚°í•˜ê¸°</button>
          </div>
        </div>
      </aside>
    </section>
  </section>
  </div>
  <!--ã…‡-->
  <div id="charModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div><!--ëª¨ë‹¬ ë’¤ ë°°ê²½ ê²€ì •, data-close ì†ì„± ë¶™ì€ ìš”ì†Œ í´ë¦­í•˜ë©´ ëª¨ë‹¬ ë‹«í˜-->
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="dlgTitle">
      <header>
        <h2 id="dlgTitle">ìºë¦­í„° ì„ íƒ</h2>
        <div></div>
      </header>
      <div id="catalog" class="catalog"></div>
    </div>
  </div>

  <div id="itemModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="itemDlgTitle">
      <header>
        <h2 id="itemDlgTitle">ì•„ì´í…œ ì„ íƒ</h2>
        <nav id="weaponTabs" class="weapon-tabs" style="display:none"></nav>
        <input id="itemSearch" class="input" type="text" placeholder="ì•„ì´í…œ ê²€ìƒ‰ (ì´ë¦„ / ì¢…ë¥˜)" />
      </header>
      <div class="items">
        <div id="itemList" class="item-list"></div>
      </div>
    </div>
  </div>

  <div id="enhanceModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="enhDlgTitle">
      <header>
        <h2 id="enhDlgTitle">ê°•í™” ì„ íƒ</h2>
      </header>
      <div class="items">
        <div id="enhanceList" class="enh-list"></div>
      </div>
    </div>
  </div>

  <div id="enchantModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="enchantDlgTitle">
      <header>
        <h2 id="enchantDlgTitle">ë§ˆë²•ë¶€ì—¬ ì„ íƒ</h2>
      </header>
      <div class="items">
        <div id="enchantList" class="enh-list"></div>
      </div>
    </div>
  </div>

  <div id="refineModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog sm">
      <div class="dialog-head">
        <h3>ì—°ë§ˆ ì„ íƒ</h3>
        <button class="icon-btn" data-close aria-label="ë‹«ê¸°">âœ•</button>
      </div>
      <div class="dialog-body">
        <div id="refineList" class="v-list"></div>
      </div>
    </div>
  </div>


  <div id="emblemModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="emblemDlgTitle"
      style="width:min(920px,95vw);height:min(620px,88vh);">
      <header>
        <h2 id="emblemDlgTitle">ì— ë¸”ë ˜ ì„ íƒ</h2>
      </header>
      <div id="emblemRows" class="em-rows"></div>
    </div>
  </div>

  <div id="runeModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="runeDlgTitle"
      style="width:min(980px,95vw);height:min(620px,88vh);">
      <header>
        <h2 id="runeDlgTitle">ìŠ¤í‚¬ë£¬ ì„¤ì •</h2>
        <div style="justify-self:end;font-size:12px;color:#c7b589;">
          ì„ íƒí•œ ìŠ¤í‚¬ë£¬ ê°œìˆ˜: <b id="runeCountLabel" style="color:#ff6b6b;">0</b> / 20
        </div>
      </header>
      <div class="items" style="padding:10px;">
        <div id="runeGrid" class="rune-grid"></div>
      </div>
    </div>
  </div>

  <div id="skillTreeModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="stDlgTitle"
      style="width:min(1100px,96vw);height:min(720px,92vh);">
      <header>
        <h2 id="stDlgTitle">ìŠ¤í‚¬íŠ¸ë¦¬</h2>
        <div class="st-counters">
          <div class="st-counter"><span class="label sp">SP</span><span class="val" id="stSpLeftMini">0</span></div>
          <div class="st-counter"><span class="label tp">TP</span><span class="val" id="stTpLeftMini">0</span></div>
        </div>
      </header>
      <div class="items" style="padding:10px;">
        <div id="stGrid"></div>
      </div>
    </div>
  </div>

  <!-- â–¼ ì„±ì•ˆì˜ ë´‰ì¸ ëª¨ë‹¬ -->
  <div id="castleSealModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog seal">
      <div class="modal-head">
        <div class="title">ì˜µì…˜ ì„ íƒ</div>
        <button class="close" data-close aria-label="ë‹«ê¸°">Ã—</button>
      </div>

      <div class="modal-body two-col">
        <section class="col">
          <h5>ì£¼ìš” ì˜µì…˜</h5>
          <div id="sealMainList" class="list"></div>
        </section>
        <section class="col">
          <h5>ì¶”ê°€ ì˜µì…˜</h5>
          <div id="sealSubList" class="list"></div>
        </section>
      </div>

      <div class="modal-foot">
        <button id="sealCommit" class="ui-btn gold block">ì„ íƒ í•˜ê¸°</button>
      </div>
    </div>
  </div>


  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>

    // ì „ì—­ í”Œë˜ê·¸
    let __calcInited = false;

    async function initCalculatorOnce() {
      if (__calcInited) return;
      __calcInited = true;

      // 1) ë£¬ ê°ì¸ ì´ë¦„ ëª©ë¡ êµ¬ì„±
      buildRuneEngraveNameOptions();

      // 2) ì˜µì…˜ ë“œë¡­ë‹¤ìš´ ë°”ì¸ë”©
      const $ = (id) => document.getElementById(id);
      const bind = (id, key) => {
        const el = $(id);
        if (!el) return;
        el.addEventListener('change', () => {
          state.options[key] = el.value || null;
          if (key === 'avatar') {
            applyAvatarEnhFromState();
          } else if (key === 'weaponImprint') {
            applyImprintEnhFromState();
          } else if (key === 'monster') {
            const txt = el.options[el.selectedIndex]?.textContent ?? el.value;
            onMonsterChange(txt);
          }
        });
      };

      bind('selAvatar', 'avatar');
      bind('selImprint', 'weaponImprint');
      bind('selTime', 'timeWindow');
      bind('selMonster', 'monster');
      bind('selDifficulty', 'difficulty');

      // 3) ê¸°ë³¸ê°’ì„ ì‹¤ì œ ë¡œì§ì— ë°˜ì˜ (ì—¬ê¸°ê°€ ìë™ ë¡œë”©ì˜ ì£¼ë²”ì´ì—ˆìŒ â†’ ì§€ê¸ˆë¶€í„°ëŠ” ë²„íŠ¼ í´ë¦­ ì´í›„ì—ë§Œ í˜¸ì¶œ)
      document.getElementById('selAvatar')?.dispatchEvent(new Event('change'));
      document.getElementById('selImprint')?.dispatchEvent(new Event('change'));
      onMonsterChange(); // ê¸°ë³¸ ëª¬ìŠ¤í„° ë°˜ì˜

      // === ì„±ì•ˆì˜ ë´‰ì¸ ê¸°ë³¸ê°’ ì ìš© (ì •ê·œí™” stats ì‚¬ìš©) ===
      try {
        // 1) ê°•í™”Â·ë§ˆë´‰Â·ë§ˆë¶€ ë°ì´í„° ë¡œë“œ ë³´ì¥
        if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

        const enh = window.DBEnh || {};

        // 2) byType ì—†ìœ¼ë©´ listì—ì„œ ì¦‰ì„ ê·¸ë£¹í•‘ (êµ¬ë²„ì „ í˜¸í™˜)
        let byType = enh.byType;
        if (!byType) {
          const list = Array.isArray(enh.list)
            ? enh.list
            : Array.isArray(enh.rows)
              ? enh.rows.map(r => ({ type: String(r['ì¢…ë¥˜'] || '').trim(), name: String(r['ì´ë¦„'] || '').trim(), stats: r.stats || null, raw: r }))
              : [];
          byType = list.reduce((acc, it) => {
            const t = String(it.type || '').trim();
            (acc[t] ||= []).push(it);
            return acc;
          }, {});
        }

        // 3) í›„ë³´ ëª©ë¡ ì–»ê¸°
        const mainList = Array.isArray(byType['ì£¼ìš” ì˜µì…˜']) ? byType['ì£¼ìš” ì˜µì…˜'] : [];
        const subList = Array.isArray(byType['ì¶”ê°€ ì˜µì…˜']) ? byType['ì¶”ê°€ ì˜µì…˜'] : [];

        // ë°ì´í„° ì—†ìœ¼ë©´ ì¡°ìš©íˆ í†µê³¼ (ê³„ì‚°ê¸° ì—´ê¸°ë§Œ ì§„í–‰)
        if (!mainList.length || !subList.length) {
          console.info('[SEAL:init] ëª©ë¡ ë¹„ì–´ ìˆìŒ â†’ ê¸°ë³¸ê°’ ì£¼ì… ìƒëµ', { mainLen: mainList.length, subLen: subList.length });
        } else {
          // 4) state ì¤€ë¹„
          if (!state.castleSeal) state.castleSeal = { main: null, sub: null };

          // 5) ì´ë¯¸ ì„ íƒë¼ ìˆì§€ ì•Šì„ ë•Œë§Œ ê¸°ë³¸ê°’ ì£¼ì…
          //    (íŠ¹ì • ì´ë¦„ì„ ì›í•˜ë©´ .find(x => x.name === 'í˜,ì§€ëŠ¥ +170') í˜•íƒœë¡œ)
          const mainPick = state.castleSeal.main
            || mainList.find(x => x.name === 'í˜,ì§€ëŠ¥ +170')
            || mainList[0];
          const subPick = state.castleSeal.sub
            || subList.find(x => x.name === 'í˜,ì§€ëŠ¥ +224')
            || subList[0];

          // 6) ì •ê·œí™”ëœ í˜•íƒœë¡œ ì €ì¥ (í•©ì‚° í•¨ìˆ˜ê°€ ë°”ë¡œ ë¨¹ê²Œ)
          state.castleSeal.main = mainPick ? { name: mainPick.name, stats: mainPick.stats || null, raw: mainPick.raw || mainPick } : null;
          state.castleSeal.sub = subPick ? { name: subPick.name, stats: subPick.stats || null, raw: subPick.raw || subPick } : null;

          console.info('[SEAL:init] ê¸°ë³¸ê°’ ì ìš©:', {
            main: state.castleSeal.main?.name || null,
            sub: state.castleSeal.sub?.name || null
          });
        }
      } catch (e) {
        console.warn('[SEAL:init] ê¸°ë³¸ê°’ ì ìš© ì¤‘ ì˜¤ë¥˜(ë¬´ì‹œ):', e);
      }

      // í•„ìš” ì‹œ ì²« ë Œë”
      recalcAndRenderPanel();
    }


    /* ===== ìƒíƒœ/ìƒìˆ˜ ===== */
    const state = {
      currentCharacter: { jobGroup: null, jobGroupLabel: null, name: null, imgSrc: null, power: null },
      selections: {}, // ì¥ë¹„
      upgrades: {},   // ìŠ¬ë¡¯ë³„ ê°•í™” ì„ íƒ
      enchants: {},   // ìŠ¬ë¡¯ë³„ ë§ˆë²•ë¶€ì—¬ ì„ íƒ
      ui: { weaponTypeTab: null, enhTargetSlot: null, enhTargetBtn: null },
      currentSlotKey: null
    };
    state.skillLv = state.skillLv || {}; // {skillId: í˜„ì¬ë ˆë²¨}
    state.stUsedSP = state.stUsedSP || 0;
    state.stUsedTP = state.stUsedTP || 0;
    // ===== SP/TP ìƒíƒœ ë° ë Œë” =====
    state.sp = state.sp || { total: 0, left: 0 };
    state.tp = state.tp || { total: 0, left: 0 };
    state.skillTpLv = state.skillTpLv || {};   // TP ë ˆë²¨ ì €ì¥(ì‚¬ìš© ì¤‘ì´ ì•„ë‹ˆì–´ë„ ë¬´í•´)
    // ===== ë ˆë²¨ë§(ì¥ë¹„/ìŠ¤íƒ¯ í•©ì‚°) =====
    state.leveling = state.leveling || {}; // { 15: n, 20: n, 25: n, ... }
    state.skillDmg = state.skillDmg || {};   // â˜… ìŠ¤í‚¬ í˜„ì¬ ë°ë¯¸ì§€ ìºì‹œ {id: { per, flat, lv }}


    let __progressPct = 0;

    function setProgressExactMonotonic(nextPct, label) {
      const p = Math.max(__progressPct, Math.min(100, Math.round(nextPct)));
      __progressPct = p;
      const bar = document.querySelector('.loading-bar__fill');
      const txt = document.getElementById('loadingPct');
      const lbl = document.getElementById('loadingLabel');
      if (bar) bar.style.width = p + '%';
      if (txt) txt.textContent = p + '%';
      if (lbl && label) lbl.textContent = String(label);
    }
    function resetProgress(label) {
      __progressPct = 0;
      setProgressExactMonotonic(0, label ?? 'ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦');
    }

    function incProgress(dx, label) {
      const next = Math.min(100, Math.max(0, Math.round(__progressPct + dx)));
      setProgressExactMonotonic(next, label);
    }
    function showOverlay(label) {
      __progressPct = 0;
      setProgressExactMonotonic(0, label || 'ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦');
      document.getElementById('loadingOverlay')?.removeAttribute('hidden');
    }
    function hideOverlay() {
      document.getElementById('loadingOverlay')?.setAttribute('hidden', '');
    }
    function hideOverlay() {
      const ov = document.getElementById('loadingOverlay');
      if (ov) ov.setAttribute('hidden', '');
    }
    function setProgress(pct, label) {
      const bar = document.querySelector('.loading-bar__fill');
      const l = document.getElementById('loadingLabel');
      const t = document.getElementById('loadingPct');
      const p = Math.max(0, Math.min(100, Math.round(pct)));
      if (bar) bar.style.width = p + '%';
      if (t) t.textContent = p + '%';
      if (l && label) l.textContent = label;
    }

    // ëª¨ë“  ì‹œíŠ¸ í•œ ë²ˆì— í”„ë¦¬ë¡œë“œ (ë¡œê·¸ì¸ í›„ì—ë§Œ í˜¸ì¶œ)
    // ëª¨ë“  ì‹œíŠ¸ í•œ ë²ˆì— í”„ë¦¬ë¡œë“œ (ë¡œê·¸ì¸ í›„ì—ë§Œ í˜¸ì¶œ)
    async function preloadAllSheets({ weightCore = 30, weightSlots = 70 } = {}) {
      await waitForIdToken();

      const slots = [
        'weapon', 'headshoulder', 'top', 'bottom', 'belt', 'shoes',
        'bracelet', 'necklace', 'ring', 'support', 'aura', 'title',
        'creature', 'artifact'
      ];
      const totalSlots = slots.length;

      const coreW = Math.max(0, Math.min(100, weightCore | 0));
      const slotsW = Math.max(0, Math.min(100 - coreW, weightSlots | 0));
      // â”€â”€ ë™ì  ì½”ì–´ ë‹¨ê³„ êµ¬ì„± â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const steps = [];
      if (typeof loadCharacterSheet === 'function') steps.push(['ìºë¦­í„°', () => loadCharacterSheet()]);
      if (typeof ensureSkillLoaded2 === 'function') steps.push(['ìŠ¤í‚¬', () => ensureSkillLoaded2()]);
      else if (typeof loadSkillSheet === 'function') steps.push(['ìŠ¤í‚¬', () => loadSkillSheet()]);
      if (typeof BuffLeveling?.preload === 'function') steps.push(['ë²„í”„', () => BuffLeveling.preload()]);
      if (typeof ensureEnhLoaded === 'function') steps.push(['ê°•í™”/ì— ë¸”ë ˜', () => ensureEnhLoaded()]);
      if (typeof ensureSetLoaded === 'function') steps.push(['ì„¸íŠ¸', () => ensureSetLoaded()]);
      if (typeof ensureExceptionLoaded === 'function') steps.push(['ì˜ˆì™¸ê·œì¹™', () => ensureExceptionLoaded()]);
      const perCore = steps.length ? (coreW / steps.length) : coreW;
      // ìŠ¬ë¡¯ì€ **done/total ê¸°ë°˜ìœ¼ë¡œ í¼ì„¼íŠ¸ ë°˜ì˜**
      let slotProgress = 0;

      // â”€â”€ 1. ì½”ì–´ ë‹¨ê³„(ë™ì ) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const runStep = async (label, fn) => {
        setProgressExactMonotonic(__progressPct, `${label} ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦`);
        await fn();
        __progressPct += perCore;
        setProgressExactMonotonic(__progressPct, `${label} ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦`);
      };
      for (const [label, fn] of steps) {
        await runStep(label, fn);
      }


      // â”€â”€ 2. ìŠ¬ë¡¯ë“¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const loadSlot = (s) => ensureLoaded(s);

      let done = 0;
      const promises = slots.map(s =>
        Promise.resolve()
          .then(() => {
            const label = labelForSlot(s);
            setProgressExactMonotonic(__progressPct, `${label} ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦`);
          })
          .then(() => loadSlot(s))
          .then(() => {
            done += 1;
            // âœ… ë¹„ìœ¨ ê¸°ë°˜ ì§„í–‰ë„
            slotProgress = (done / totalSlots) * slotsW;
            setProgressExactMonotonic(coreW + slotProgress, `ì•„ì´í…œ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦ (${done}/${totalSlots})`);
          })
      );

      await Promise.all(promises);

      // â”€â”€ 3. ë”± ë§ì¶°ì„œ 100% â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      __progressPct = 100;
      setProgressExactMonotonic(100, 'ëª¨ë“  ë°ì´í„° ë¡œë”© ì™„ë£Œ');
    }






    // === [ENCHANT] ì „ì—­ ìºì‹œ & í”„ë¦¬ë¡œë“œ ===
    const ENCHANT_CACHE = {
      ready: false,            // í”„ë¦¬ë¡œë“œ ì™„ë£Œ ì—¬ë¶€
      byType: new Map(),       // 'ë¬´ê¸°ë§ˆë¶€' -> [{name, typeKey}, ...]
      version: 'v1',           // ìºì‹œ ë²„ì „(ì‹œíŠ¸ê°€ ë°”ë€Œë©´ ì—¬ê¸° ë¬¸ìì—´ë§Œ ë°”ê¿” ìƒˆë¡œ ë°›ë„ë¡)
    };

    const DBSkill = { loaded: false, headers: [], rows: [] };

    // ê°•í™”/ë§ˆë´‰/ë§ˆë¶€(ENHANCE_SHEET) ì‚¬ì „ ë¡œë“œ: ë°±ì—”ë“œ(JSON) ë²„ì „
    async function preloadEnchantSheet() {
      if (ENCHANT_CACHE.ready) return;

      // 1) ë¡œê·¸ì¸ í† í°
      const token = await waitForIdToken();

      // 2) í”„ë¡ì‹œ â†’ GAS: ?type=enhance
      const r = await fetch(window.WEBAPP_URL + '?type=enhance', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',                  // ìºì‹œ ì‚¬ìš© ì•ˆ í•¨(ë²„ì „ ê´€ë¦¬ ì›í•˜ë©´ ì¿¼ë¦¬ë¡œ)
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('enhance_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_enhance_payload');

      const rows = data.rows || [];
      const byType = new Map();

      // 3) í–‰ ê°€ê³µ: ê¸°ì¡´ mapRowToEnhanceë¥¼ ìµœìš°ì„  ì‚¬ìš© (ìˆìœ¼ë©´)
      for (const raw of rows) {
        const obj = (typeof mapRowToEnhance === 'function') ? mapRowToEnhance(raw) : null;

        const typeKey = String(obj?.type ?? raw['ì¢…ë¥˜'] ?? '').trim();
        if (!typeKey) continue;

        const name = String(obj?.name ?? raw['ì´ë¦„'] ?? raw['name'] ?? '').trim();
        if (!name) continue;

        const stats = obj?.stats ?? null;                     // ì•ˆì „
        const jobGroup = String(obj?.jobGroup ?? raw['ì§ì—…êµ°'] ?? '').trim();

        if (!byType.has(typeKey)) byType.set(typeKey, []);
        byType.get(typeKey).push({
          name,
          typeKey,
          stats,
          jobGroup,
          raw: raw                                         // ì›ë³¸ë„ ë³´ì¡´
        });
      }

      ENCHANT_CACHE.byType = byType;
      ENCHANT_CACHE.ready = true;
    }


    async function ensureEnchantCache() {
      if (!ENCHANT_CACHE.ready) {
        try { await preloadEnchantSheet(); }
        catch (e) { console.warn('[ENCHANT] preload failed:', e); ENCHANT_CACHE.ready = true; }
      }
    }



    // === [ENCHANT] 0) ì„¸ë¶€ìƒì(3ë²ˆì§¸) ê¸°ë³¸ ë¼ë²¨ "ë§ˆë²• ë¶€ì—¬"ë¡œ ì„¸íŒ… ===
    // === [ENCHANT] 0) ì„¸ë¶€ìƒì ê¸°ë³¸ ë¼ë²¨/ì—­í•  ì„¸íŒ… ===
    function setDefaultEnchantLabels() {
      // â‘  ì¥ë¹„ ìŠ¬ë¡¯ í–‰: ì„¸ ë²ˆì§¸ ì„¸ë¶€ìƒì â†’ "ë§ˆë²• ë¶€ì—¬"
      document.querySelectorAll('.slot-row').forEach(row => {
        const third = row.querySelector('.outer-rects .rect:nth-child(3)');
        if (third) {
          third.textContent = 'ë§ˆë²• ë¶€ì—¬';
          third.dataset.role = 'enchant';
          third.removeAttribute('data-unused');
          third.removeAttribute('aria-disabled');
          third.disabled = false;
          third.classList.remove('disabled', 'is-disabled');
          third.style.pointerEvents = ''; // í˜¹ì‹œ ë§‰í˜€ ìˆìœ¼ë©´ í•´ì œ
        }
      });

      // â‘¡ C2(ì¹­í˜¸) mini-cell: ì²« ë²ˆì§¸ ì„¸ë¶€ë²„íŠ¼ í™œì„±í™” â†’ "ë§ˆë²• ë¶€ì—¬"
      const c2cell = document.querySelector('.slot.mini[data-slot="C2"]')?.closest('.mini-cell');
      if (c2cell) {
        const firstBtn = c2cell.querySelector('.outer-rects .rect:nth-child(1)');
        if (firstBtn) {
          firstBtn.textContent = 'ë§ˆë²• ë¶€ì—¬';
          firstBtn.dataset.role = 'enchant';
          firstBtn.removeAttribute('data-unused');
          firstBtn.removeAttribute('aria-disabled');
          firstBtn.disabled = false;
          firstBtn.classList.remove('disabled', 'is-disabled');
          firstBtn.style.pointerEvents = '';
        }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      setDefaultEnchantLabels();
      ensureEnchantCache();
    });

    // === [ENCHANT] 1) ìŠ¬ë¡¯í‚¤ â†’ ë§ˆë²•ë¶€ì—¬ ì¢…ë¥˜í‚¤ ë§¤í•‘ ===
    // L1 ë¨¸ë¦¬ì–´ê¹¨, L2 ìƒì˜, L3 í•˜ì˜, L4 í—ˆë¦¬, L5 ì‹ ë°œ
    // R1 ë¬´ê¸°, R2 íŒ”ì°Œ, R3 ëª©ê±¸ì´, R4 ë°˜ì§€, R5 ë³´ì¡°ì¥ë¹„
    function enchantTypeForSlot(slotKey) {
      const map = {
        'R1': 'ë¬´ê¸°ë§ˆë¶€',
        'L2': 'ìƒì˜ë§ˆë¶€',
        'L3': 'í•˜ì˜ë§ˆë¶€',
        'L1': 'ë¨¸ë¦¬ì–´ê¹¨ë§ˆë¶€',
        'L4': 'í—ˆë¦¬ë§ˆë¶€',
        'L5': 'ì‹ ë°œë§ˆë¶€',
        'R2': 'íŒ”ì°Œë§ˆë¶€',
        'R3': 'ëª©ê±¸ì´ë§ˆë¶€',
        'R4': 'ë°˜ì§€ë§ˆë¶€',
        'R5': 'ë³´ì¥ë§ˆë¶€',
        'C2': 'ì¹­í˜¸ë§ˆë¶€',
      };
      return map[String(slotKey).toUpperCase()] || null;
    }

    // === [ENCHANT] 2) ENHANCE_SHEET ë¡œë”© & ì˜µì…˜ ì¶”ì¶œ ===
    // === [ENCHANT] ìºì‹œ ìš°ì„  ì˜µì…˜ ë¡œë” ===
    async function loadEnchantOptions(typeKey) {
      await ensureEnchantCache();
      const list = ENCHANT_CACHE.byType.get(String(typeKey).trim());
      return Array.isArray(list) ? list : [];
    }



    // === [ENCHANT] 3) ëª¨ë‹¬ í•¸ë“¤ëŸ¬ ===
    const $enchantModal = document.getElementById('enchantModal');
    const $enchantList = document.getElementById('enchantList');

    function openEnchantModalFor(slotKey) {
      state.currentSlotKey = slotKey;
      const typeKey = enchantTypeForSlot(slotKey);
      if (!typeKey) { alert('í•´ë‹¹ ìŠ¬ë¡¯ì˜ ë§ˆë²•ë¶€ì—¬ ì¢…ë¥˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
      renderEnchantList(typeKey);
      showModal($enchantModal, true);
    }

    async function renderEnchantList(typeKey) {
      const list = await loadEnchantOptions(typeKey);
      if (!list.length) {
        $enchantList.innerHTML = '<div style="color:#c7b589;">í•´ë‹¹ ë¶€ìœ„ì˜ ë§ˆë²•ë¶€ì—¬ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
        return;
      }
      // ìº¡ì…˜ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ(ìš”êµ¬ 5). ì´ë¦„ë§Œ ë²„íŠ¼ìœ¼ë¡œ.
      $enchantList.innerHTML = '';
      list.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = 'enh-option';
        btn.type = 'button';
        btn.textContent = opt.name;
        btn.addEventListener('click', () => applyEnchantSelection(opt));
        $enchantList.appendChild(btn);
      });
    }
    // === [ENCHANT][AUTO] ì†ì„±+í‹°ì–´/í‹°ì–´ë§Œ ê·œì¹™ëŒ€ë¡œ ì „ì²´ ìë™ ì ìš©
    async function applyAutoEnchant(attr, tier) {
      await ensureEnchantCache(); // ìºì‹œ ë³´ì¥

      const combo = `${attr}${tier}`;

      // ê·œì¹™: ë¬´ê¸°/íŒ”/ëª©/ë°˜ì§€ëŠ” "ì†ì„±+í‹°ì–´"ë¡œ ì°¾ëŠ”ë‹¤
      const USE_COMBO = new Set(['ë¬´ê¸°ë§ˆë¶€', 'íŒ”ì°Œë§ˆë¶€', 'ëª©ê±¸ì´ë§ˆë¶€', 'ë°˜ì§€ë§ˆë¶€']);
      // ê·œì¹™: ë¨¸ì–´/ìƒì˜/í•˜ì˜/í—ˆë¦¬/ì‹ ë°œ/ë³´ì¥/ì¹­í˜¸ëŠ” "í‹°ì–´"ë§Œìœ¼ë¡œ ì°¾ëŠ”ë‹¤
      const USE_TIER = new Set(['ë¨¸ë¦¬ì–´ê¹¨ë§ˆë¶€', 'ìƒì˜ë§ˆë¶€', 'í•˜ì˜ë§ˆë¶€', 'í—ˆë¦¬ë§ˆë¶€', 'ì‹ ë°œë§ˆë¶€', 'ë³´ì¥ë§ˆë¶€', 'ì¹­í˜¸ë§ˆë¶€']);

      // ì ìš© ëŒ€ìƒ ìŠ¬ë¡¯ ì½”ë“œ(ì¢Œ/ìš°/ë³´ì¡°/ì¹­í˜¸ í¬í•¨)
      const targetSlots = ['R1', 'R2', 'R3', 'R4', 'R5', 'L1', 'L2', 'L3', 'L4', 'L5', 'C2'];

      const applied = [];
      // í•œ ìŠ¬ë¡¯ì”© ì°¾ì•„ì„œ state.enchantsì— ë„£ê³  ë²„íŠ¼ ë¼ë²¨ë„ ê°±ì‹ 
      for (const slotCode of targetSlots) {
        const typeKey = enchantTypeForSlot(slotCode); // ì˜ˆ: R1 -> 'ë¬´ê¸°ë§ˆë¶€' :contentReference[oaicite:2]{index=2}
        if (!typeKey) continue;

        const keyToUse = USE_COMBO.has(typeKey) ? combo
          : USE_TIER.has(typeKey) ? tier
            : null;
        if (!keyToUse) continue;

        const opt = findEnchantByJobGroup(typeKey, keyToUse);
        if (!opt) continue;

        // ê¸°ì¡´ ë‹¨ì¼ ì ìš© ë¡œì§ì„ ì¬ì‚¬ìš©í•´ì„œ ë¼ë²¨/í•©ì‚°ê¹Œì§€ ë™ì¼ ë™ì‘
        const prev = state.currentSlotKey;
        state.currentSlotKey = slotCode;
        applyEnchantSelection(opt); // ì´ í•¨ìˆ˜ ì•ˆì—ì„œ ë²„íŠ¼ëª… ê°±ì‹  + ì¬ê³„ì‚° + ëª¨ë‹¬ë‹«ê¸°ê¹Œì§€ ì²˜ë¦¬ë¨ :contentReference[oaicite:3]{index=3}
        state.currentSlotKey = prev;

        applied.push({ slot: slotCode, name: opt.name });
      }

      if (!applied.length) {
        // ì°¾ì„ ìˆ˜ ì—†ëŠ” ì¼€ì´ìŠ¤ë¥¼ ì•ˆë‚´(ì„ íƒí•œ ì¡°í•©ì´ ì‹œíŠ¸ì— ì—†ëŠ” ê²½ìš°)
        if (typeof toast === 'function') toast('ì¡°ê±´ì— ë§ëŠ” ì¶”ì²œ ë§ˆë²•ë¶€ì—¬ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
        else alert('ì¡°ê±´ì— ë§ëŠ” ì¶”ì²œ ë§ˆë²•ë¶€ì—¬ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
      }
    }

    function applyEnchantSelection(opt) {
      const slotKey = state.currentSlotKey;
      if (!slotKey) return;
      state.enchants[slotKey] = {
        name: opt.name,
        typeKey: opt.typeKey,
        stats: opt.stats || null,
        raw: opt.raw || null
      };

      // 1) ì¥ë¹„ ìŠ¬ë¡¯ í–‰(.slot-row)ì— ìˆìœ¼ë©´: ë§ˆë²•ë¶€ì—¬ ë²„íŠ¼(data-role) ë˜ëŠ” 3ë²ˆì§¸ ë²„íŠ¼ ê°±ì‹ 
      const row = document.querySelector(`.slot-row .slot[data-slot="${slotKey}"]`)?.closest('.slot-row');
      if (row) {
        const target = row.querySelector('.outer-rects .rect[data-role="enchant"]')
          || row.querySelector('.outer-rects .rect:nth-child(3)');
        if (target) target.textContent = opt.name;
      } else {
        // 2) ë¯¸ë‹ˆ ì…€(C1~C4)ì— ìˆìœ¼ë©´: ë§ˆë²•ë¶€ì—¬ ë²„íŠ¼(data-role) ë˜ëŠ” 1ë²ˆì§¸ ë²„íŠ¼ ê°±ì‹ 
        const cell = document.querySelector(`.mini-cell .slot.mini[data-slot="${slotKey}"]`)?.closest('.mini-cell');
        if (cell) {
          const target = cell.querySelector('.outer-rects .rect[data-role="enchant"]')
            || cell.querySelector('.outer-rects .rect:nth-child(1)');
          if (target) target.textContent = opt.name;
        }
      }

      showModal($enchantModal, false);
      recalcAndRenderPanel();
    }

    // ê³µìš© ëª¨ë‹¬ show/hide ìœ í‹¸(íŒŒì¼ ë‚´ ë‹¤ë¥¸ ëª¨ë‹¬ê³¼ ë™ì¼ ë°©ì‹ ì‚¬ìš©)
    function showModal(modal, on) {
      if (!modal) return;
      if (on) { modal.classList.add('show'); modal.setAttribute('aria-hidden', 'false'); }
      else { modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true'); }
    }
    $enchantModal?.querySelector('.backdrop[data-close]')?.addEventListener('click', () => showModal($enchantModal, false));

    // === [ENCHANT] 4) ì„¸ ë²ˆì§¸ ì„¸ë¶€ìƒì í´ë¦­ ì‹œ ëª¨ë‹¬ ===
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('.rect');
      if (!btn) return;

      // 3ë²ˆì§¸ ë²„íŠ¼ë§Œ ì²˜ë¦¬ (dataset.role='enchant'ëŠ” Aë‹¨ê³„ì—ì„œ ë¶€ì—¬)
      if (btn.dataset.role === 'enchant') {
        // â˜… slot-row ë˜ëŠ” mini-cell(í•˜ë‹¨ C1~C4 ì˜ì—­) ëª¨ë‘ ì§€ì›
        const container = btn.closest('.slot-row, .mini-cell, .mini-bar');
        const slotKey = container?.querySelector('.slot')?.getAttribute('data-slot');
        if (!slotKey) return;
        openEnchantModalFor(slotKey);
      }
    });

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('.rect');
      if (!btn) return;

      // [REFINE] 4ë²ˆì§¸ ë²„íŠ¼
      if (btn.dataset.role === 'refine') {
        const container = btn.closest('.slot-row, .mini-cell');
        const slotCode = container?.querySelector('.slot')?.getAttribute('data-slot'); // R1/R5
        if (!slotCode) return;

        // 1ë‹¨ê³„: ë¬´ê¸°(R1)ë§Œ ë¨¼ì € ë™ì‘. R5ëŠ” ì¶”í›„ ì ìš©.
        if (slotCode === 'R1') {
          openRefineModalForWeapon(btn);
        } else if (slotCode === 'R5') {
          openRefineModalForSub(btn);   // â˜… ìƒˆë¡œìš´ í•¨ìˆ˜ë¡œ ì—°ê²°
        }
      }
    });


    const $refineModal = document.getElementById('refineModal');
    const $refineList = document.getElementById('refineList');

    function showRefineModal(on) {
      if (!$refineModal) return;
      if (on) { $refineModal.classList.add('show'); $refineModal.setAttribute('aria-hidden', 'false'); }
      else { $refineModal.classList.remove('show'); $refineModal.setAttribute('aria-hidden', 'true'); }
    }
    $refineModal?.addEventListener('click', (e) => {
      if (e.target.dataset.close != null || e.target.classList.contains('backdrop')) {
        showRefineModal(false);
      }
    });

    async function openRefineModalForWeapon(btnEl) {    //ë¬´ê¸°ì—°ë§ˆ
      if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

      // ë²„íŠ¼ ëª©ë¡ ë§Œë“¤ê¸°
      const labels = ['ì—°ë§ˆì—†ìŒ', '1ì—°ë§ˆ', '2ì—°ë§ˆ', '3ì—°ë§ˆ', '4ì—°ë§ˆ', '5ì—°ë§ˆ', '6ì—°ë§ˆ', '7ì—°ë§ˆ', '8ì—°ë§ˆ', '9ì—°ë§ˆ'];
      $refineList.innerHTML = '';
      labels.forEach(name => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'btn block';    // ë„¤ ë²„íŠ¼ ê·œì¹™ì— ë§ì¶° block í‘œì‹œ
        b.textContent = name;
        b.addEventListener('click', () => applyWeaponRefine(name, btnEl));
        $refineList.appendChild(b);
      });

      showRefineModal(true);
    }

    async function openRefineModalForSub(btnEl) {     //ë³´ì¥ì—°ë§ˆ
      if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

      const labels = ['ì—°ë§ˆì—†ìŒ', '1ì—°ë§ˆ', '2ì—°ë§ˆ', '3ì—°ë§ˆ', '4ì—°ë§ˆ', '5ì—°ë§ˆ', '6ì—°ë§ˆ', '7ì—°ë§ˆ', '8ì—°ë§ˆ', '9ì—°ë§ˆ'];
      $refineList.innerHTML = '';
      labels.forEach(name => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'btn block';
        b.textContent = name;
        b.addEventListener('click', () => applySubRefine(name, btnEl));
        $refineList.appendChild(b);
      });

      showRefineModal(true);
    }


    function applyWeaponRefine(name, btnEl) {   //ë¬´ê¸°ì—°ë§ˆ ì ìš©
      state.refines = state.refines || {};
      // â€˜ì—°ë§ˆì—†ìŒâ€™ ì´ë©´ í•´ì œ
      if (name === 'ì—°ë§ˆì—†ìŒ') {
        state.refines.weapon = null;
        if (btnEl) btnEl.textContent = 'ì—°ë§ˆ ì„¤ì •';
        showRefineModal(false);
        recalcAndRenderPanel();
        return;
      }

      // ê°•í™”/ë§ˆë´‰/ë§ˆë¶€ ì‹œíŠ¸ì— ì´ë¯¸ ë¡œë“œí•´ë‘” DBEnhì—ì„œ ì¢…ë¥˜=ë¬´ê¸°ì—°ë§ˆ & ì´ë¦„=name í–‰ì„ ì°¾ìŒ
      const list = (DBEnh?.byType?.['ë¬´ê¸°ì—°ë§ˆ'] || (DBEnh?.list || []).filter(o => (o?.type || '') === 'ë¬´ê¸°ì—°ë§ˆ'));
      const found = Array.isArray(list) ? list.find(o => String(o.name).trim() === name) : null;

      if (!found) {
        if (typeof toast === 'function') toast(`ë¬´ê¸°ì—°ë§ˆì—ì„œ '${name}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        else alert(`ë¬´ê¸°ì—°ë§ˆì—ì„œ '${name}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return;
      }

      // ìƒíƒœ ì €ì¥(í•©ì‚° ì‹œ ê³±ì—°ì‚° ê³„ì—´ì€ addStatsì—ì„œ ìë™ ì²˜ë¦¬)
      state.refines.weapon = { name: found.name, stats: found.stats || null, raw: found.raw || null };

      // ë²„íŠ¼ ë¼ë²¨ ê°±ì‹ 
      if (btnEl) btnEl.textContent = name;

      showRefineModal(false);
      recalcAndRenderPanel();
    }

    function applySubRefine(name, btnEl) {    //ë³´ì¥ì—°ë§ˆì ìš©
      state.refines = state.refines || {};

      if (name === 'ì—°ë§ˆì—†ìŒ') {
        state.refines.sub = null;
        if (btnEl) btnEl.textContent = 'ì—°ë§ˆ ì„¤ì •';
        showRefineModal(false);
        recalcAndRenderPanel();
        return;
      }

      const list = (DBEnh?.byType?.['ë³´ì¥ì—°ë§ˆ'] || (DBEnh?.list || []).filter(o => (o?.type || '') === 'ë³´ì¥ì—°ë§ˆ'));
      const found = Array.isArray(list) ? list.find(o => String(o.name).trim() === name) : null;

      if (!found) {
        if (typeof toast === 'function') toast(`ë³´ì¥ì—°ë§ˆì—ì„œ '${name}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        else alert(`ë³´ì¥ì—°ë§ˆì—ì„œ '${name}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return;
      }

      state.refines.sub = { name: found.name, stats: found.stats || null, raw: found.raw || null };

      if (btnEl) btnEl.textContent = name;

      showRefineModal(false);
      recalcAndRenderPanel();
    }





    function _setText(id, v) { const el = document.getElementById(id); if (el) el.textContent = String(v); }

    function renderSpTp() {
      const sp = state.sp || {};
      const tp = state.tp || {};
      const set = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = String(v); };
      // Top header (if visible)
      set('spLeftTop', sp.left ?? 0);
      set('tpLeftTop', tp.left ?? 0);
      // Modal right-top mini counters
      set('stSpLeftMini', sp.left ?? 0);
      set('stTpLeftMini', tp.left ?? 0);
      // Any small counters near the button (outside modal)
      set('stSpLeft', sp.left ?? 0);
      set('stTpLeft', tp.left ?? 0);
      // Used/Total for detailed displays
      set('stSpUsed', (sp.total ?? 0) - (sp.left ?? 0));
      set('stSpTotal', sp.total ?? 0);
      set('stTpUsed', (tp.total ?? 0) - (tp.left ?? 0));
      set('stTpTotal', tp.total ?? 0);
    }

    function setTotals(spTotal, tpTotal) {
      const spt = Number(spTotal || 0), tpt = Number(tpTotal || 0);
      state.sp.total = spt;
      state.sp.left = spt;
      state.tp.total = tpt; state.tp.left = tpt;
      renderSpTp();
    }

    function canSpendSp(cost) { return (state.sp.left ?? 0) >= (Number(cost) || 0); }
    function spendSp(cost) { state.sp.left = Math.max(0, (state.sp.left ?? 0) - (Number(cost) || 0)); renderSpTp(); }
    function refundSp(cost) { state.sp.left = Math.min((state.sp.total ?? 0), (state.sp.left ?? 0) + (Number(cost) || 0)); renderSpTp(); }
    function canSpendTp(cost) { return (state.tp.left ?? 0) >= (Number(cost) || 0); }
    function spendTp(cost) { state.tp.left = Math.max(0, (state.tp.left ?? 0) - (Number(cost) || 0)); renderSpTp(); }
    function refundTp(cost) { state.tp.left = Math.min((state.tp.total ?? 0), (state.tp.left ?? 0) + (Number(cost) || 0)); renderSpTp(); }
    function noSpFeedback() { alert('SPê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.'); }
    function noTpFeedback() { alert('TPê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.'); }
    // â¬‡ ê¸°ì¡´ loadCharTotalsAndApply ì „ì²´ë¥¼ ì´ê±¸ë¡œ êµì²´
    async function loadCharTotalsAndApply(charName) {
      try {
        // ë¡œê·¸ì¸ í† í° í•„ìš”
        if (!idToken) { setTotals(0, 35); return; }

        // í”„ë¡ì‹œ â†’ GAS: ìºë¦­í„°ì‹œíŠ¸(JSON)
        const r = await fetch(window.WEBAPP_URL + '?type=char', {
          method: 'POST',
          mode: 'cors',
          cache: 'no-store',
          headers: { 'Content-Type': 'text/plain' },
          body: idToken
        });
        if (!r.ok) throw new Error('char_fetch_fail');
        const data = await r.json();
        const rows = Array.isArray(data?.rows) ? data.rows : [];

        // ì´ë¦„ ì •ê·œí™”í•´ì„œ 1í–‰ ì°¾ê¸°
        const key = String(charName || '').replace(/\s+/g, '');
        const row = rows.find(x => String(x?.name || '').replace(/\s+/g, '') === key);

        // ë°±ì—”ë“œì—ì„œ ë‚´ë ¤ì£¼ëŠ” í‘œì¤€ í‚¤(spTotal, tpTotal)ë¥¼ ìµœìš°ì„  ì‚¬ìš©
        const spTotal = Number(row?.spTotal ?? row?.['ì´SP'] ?? row?.['ì´ìŠ¤í¬'] ?? 0) || 0;
        const tpTotal = Number(row?.tpTotal ?? row?.['ì´TP'] ?? row?.['ì´í‹°í”¼'] ?? 35) || 35;

        setTotals(spTotal, tpTotal);
      } catch (e) {
        console.warn('[SP/TP] load totals failed', e);
        setTotals(0, 35);
      }
    }



    /* ===== ìŠ¤í‚¬ ì‹œíŠ¸ ë¡œë” & ê²Œì„í˜•(ê°€ë¡œ ì¹¼ëŸ¼) ë Œë”ëŸ¬ ===== */
    // CSV -> JSON ì „í™˜: ST2.rows ë¥¼ JSON ì‘ë‹µìœ¼ë¡œ ì±„ì›€
    async function loadSkillSheet() {
      if (DBSkill.loaded) return;

      const token = await waitForIdToken();

      const r = await fetch(window.WEBAPP_URL + '?type=skill', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('skill_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_skill_payload');

      // ê·¸ëŒ€ë¡œ ë³´ê´€ (CSV header:true ê²°ê³¼ì™€ ë™ì¼í•œ êµ¬ì¡°)
      DBSkill.headers = Array.isArray(data.headers) ? data.headers : [];
      DBSkill.rows = data.rows;

      // ë„¤ê°€ ê¸°ì¡´ì— ì“°ë˜ ì „ì—­ í•¸ë“¤(ST2)ì„ ìœ ì§€í•˜ê³  ì‹¶ë‹¤ë©´:
      window.ST2 = { rows: DBSkill.rows, headers: DBSkill.headers };

      DBSkill.loaded = true;
    }


    // (ìŠ¤í‚¬íŠ¸ë¦¬ ë Œë”ëŸ¬ ìƒë‹¨ ì–´ë”˜ê°€, ì¤‘ë³µ ì •ì˜ ì—†ì´ 1íšŒ ì„ ì–¸)
    const onSkillTreeChanged = (() => {
      let t = null;
      return () => {
        clearTimeout(t);
        t = setTimeout(() => {
          if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
        }, 60); // ë„ˆë¬´ ìì£¼ ëŒì§€ ì•Šê²Œ ì‚´ì§ ë””ë°”ìš´ìŠ¤
      };
    })();
    const ST_BANDS = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 65, 70, 75, 80];
    const DBSkills = { loaded: false, rows: [] };

    function parseNumber(v) {
      if (v == null) return 0;
      const m = String(v).match(/-?\d+(\.\d+)?/);
      return m ? Number(m[0]) : 0;
    }
    function bandOf(v) {
      const n = parseNumber(v);
      if (!n) return 'ê¸°ë³¸';
      let best = ST_BANDS[0], dmin = 1e9;
      for (const b of ST_BANDS) { const d = Math.abs(n - b); if (d < dmin) { dmin = d; best = b; } }
      return best;
    }

    function skillsForCurrentChar(rows) {
      const key = (state.currentCharacter?.jobGroupLabel || '') + (state.currentCharacter?.name || '');
      const want = key.replace(/\s+/g, '');
      if (!want) return rows;
      const fil = rows.filter(s => !s.ownerKey || s.ownerKey === want);
      return fil.length ? fil : rows;
    }

    /* 25.09.20 ìŠ¤í‚¬íŠ¸ë¦¬ ì¶”ê°€S */
    /* ===== SkillTree v2: ë¡œë”/í•„í„°/ë Œë” ===== */
    /** ìºì‹œ */
    const ST2 = { loaded: false, rows: [] };
    /** ìœ í‹¸: ì•ˆì „ ìˆ«ì */
    const toInt = (v, def = 0) => {
      const n = Number(String(v || '').trim()); return Number.isFinite(n) ? n : def;
    };
    /** ì‹œíŠ¸ â†’ í‘œì¤€ ìŠ¤í‚¬ ê°ì²´ ë§¤í•‘ */
    // êµì²´í•  í•¨ìˆ˜
    function mapRowToSkill2(r) {        // ì‹œíŠ¸ ì»¬ëŸ¼ë“¤ì„ ì½ìŠµë‹ˆë‹¤. who = ìºë¦­í„°ëª…, show = ë…¸ì¶œì—¬ë¶€, ...
      // 1) ìºë¦­í„° í‚¤(ì‹œíŠ¸ 'ìºë¦­í„°ëª…'ê³¼ ì •í™•íˆ ì¼ì¹˜, ê³µë°± ì œê±°)
      const who = String(r['ìºë¦­í„°ëª…'] || '').replace(/\s+/g, '');
      // 2) ë…¸ì¶œ/ì •ë ¬/ì¢Œí‘œ
      const show = Number(String(r['ë…¸ì¶œì—¬ë¶€'] || '').trim()) === 1;
      const level = Number(String(r['ìŠ¤í‚¬ë ™ì œ'] || '').trim()) || 0;
      const x = Math.min(6, Math.max(1, Number(String(r['ê°€ë¡œìœ„ì¹˜'] || '').trim()) || 1));
      const y = Math.max(1, Number(String(r['ì„¸ë¡œìœ„ì¹˜'] || '').trim()) || 1);
      const cd = toNum(r['ì¿¨íƒ€ì„']);
      const castFrames = toNum(r['ì‹œì „í”„ë ˆì„']);
      // â˜… ì¶”ê°€: êµ¬ë¶„(í‰íƒ€/ì—°ê²°í‰íƒ€/ìŠ¤í‚¬/ê°ì„±ê¸°)
      const rawKind = String(r['êµ¬ë¶„'] || '').trim();
      // ê¸°ë³¸ê°’ì€ 'ìŠ¤í‚¬' (ì‹œíŠ¸ì—ì„œ ë¹„ì›Œë‘ë©´ ìŠ¤í‚¬ë¡œ ì·¨ê¸‰)
      const kind = rawKind || 'ìŠ¤í‚¬';
      // 3) í•µì‹¬ í•„ë“œ(ìŠ¤í™: ìŠ¤í‚¬ëª…/ì´ë¯¸ì§€ ì‚¬ìš©)
      const name = String(r['ìŠ¤í‚¬ëª…'] || '').trim();
      const img = cleanUrl(r['ì´ë¯¸ì§€'] || '') || PLACEHOLDER_IMG;
      // 4) ìµœì†Œ/ìµœëŒ€ ìŠ¤í‚¬ ë ˆë²¨
      const minLv = Math.max(0, Number(String(r['ìµœì†ŒìŠ¤í‚¬ë ˆë²¨'] || '').trim()) || 0);
      const maxLv = Math.max(minLv, Number(String(r['ìµœëŒ€ìŠ¤í‚¬ë ˆë²¨'] || '').trim()) || minLv); // ìµœì†Œë³´ë‹¤ ì‘ì§€ ì•Šê²Œ

      // 5) ID(ì—†ìœ¼ë©´ ìŠ¤í‚¬ëª… ê¸°ë°˜ ëŒ€ì²´)
      const idSrc = String(r['ID'] ?? r['id'] ?? name).trim();
      const id = idSrc || ('SK_' + Math.random().toString(36).slice(2));

      // 6) SP/TP ì½”ìŠ¤íŠ¸
      const sp = toInt(r['ì†Œëª¨ SP'] ?? r['ì†Œëª¨SP'] ?? r['SP'] ?? r['sp'] ?? 0, 0);
      const tpCost = toInt(r['tpì„¤ì •'] ?? r['TPì„¤ì •'] ?? r['tp ì„¤ì •'] ?? r['TP ì„¤ì •'] ?? r['tp'] ?? r['TP'] ?? 0, 0);

      // 7) â˜… í¼ë€/ê³ ë€ ì„ í˜• ëª¨ë¸(ì‹œíŠ¸ ì»¬ëŸ¼ ê·¸ëŒ€ë¡œ)
      //    - '1ë ™ë°ë¯¸ì§€'   : minLv ê¸°ì¤€ í¼ë€
      //    - '1ë ™ê³ ì •ë€'   : minLv ê¸°ì¤€ ê³ ë€
      //    - '1ë ™ë‹¹ ë°ë¯¸ì§€': ë ˆë²¨ +1ë‹¹ í¼ë€ ì¦ê°€ì¹˜
      //    - '1ë ™ë‹¹ ê³ ì •ë€': ë ˆë²¨ +1ë‹¹ ê³ ë€ ì¦ê°€ì¹˜
      const dmg1Base = toNum(r['1ë ™ë°ë¯¸ì§€'], NaN);
      const fix1Base = toNum(r['1ë ™ê³ ì •ë€'], NaN);
      const dmg1PerLv = toNum(r['1ë ™ë‹¹ ë°ë¯¸ì§€'], NaN);
      const fix1PerLv = toNum(r['1ë ™ë‹¹ ê³ ì •ë€'], NaN);

      return {
        id, name, img, who, show, level, x, y, minLv, maxLv, sp, tpCost,
        // â˜… ì¶”ê°€ëœ 4ê°œ í•„ë“œ
        dmg1Base, fix1Base, dmg1PerLv, fix1PerLv, band: level, levelGate: level, cd,             // â˜… ì¶”ê°€: ê³„ì‚°ì—ì„œ ë°”ë¡œ ì“°ë„ë¡
        cooldown: cd,
        castFrames,    // â˜… í˜¸í™˜ìš© í‚¤
        kind
      };
    }



    /** ì‹œíŠ¸ ë¡œë“œ(1íšŒ) â€” ë°±ì—”ë“œ(JSON) ë²„ì „ */
    async function ensureSkillLoaded2() {     // ST2 í‘œì¤€ ìŠ¤í‚¬ ê°ì²´ë¥¼ ST2.rowsì— ìºì‹œ
      if (ST2.loaded) return;

      // ë¡œê·¸ì¸ í† í° í™•ë³´ (ì´ë¯¸ ê°€ì§„ waitForIdToken ì¬ì‚¬ìš©)
      const token = await waitForIdToken();

      // í”„ë¡ì‹œ â†’ Apps Script: ?type=skill
      const r = await fetch(window.WEBAPP_URL + '?type=skill', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('skill_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_skill_payload');

      // CSV ë•Œì™€ ë™ì¼: ì‹œíŠ¸ í—¤ë”ëª… í‚¤ë¥¼ ê°€ì§„ ê° í–‰ì„ ST2 í‘œì¤€ ìŠ¤í‚¬ë¡œ ë§¤í•‘
      const rows = data.rows.map(mapRowToSkill2).filter(s => s.id && s.name && s.who);

      ST2.rows = rows;
      ST2.loaded = true;
    }


    /** í˜„ì¬ ìºë¦­í„° í‚¤ ì–»ê¸° (ë‚¨ê·€ê²€ì‚¬+ì´ë¦„) */
    function currentCharKey() {
      const k = currentSkillOwnerKey?.() || '';      // ì´ë¯¸ ì½”ë“œì— ìˆëŠ” í•¨ìˆ˜ ì¬í™œìš©
      return String(k).replace(/\s+/g, '') || null;
    }

    /* ===== TP ë²”ìœ„ & ìƒíƒœ ===== */
    const TP_MIN = 0, TP_MAX = 5;
    state.skillTpLv = state.skillTpLv || {}; // { skillId: tpLevel }

    /* ===== ìŠ¤í‚¬ ë°ë¯¸ì§€ ìœ í‹¸(ì„ í˜• + TP ë°°ìœ¨) ===== */
    // 0) (ì—†ìœ¼ë©´ ì¶”ê°€) í˜„ì¬ ë°ë¯¸ì§€ ìºì‹œ
    state.skillDmg = state.skillDmg || {};   // { skillId: {per, flat, lv, tpLv, tpIncPercent} }

    // 1) (ì—†ìœ¼ë©´ ì¶”ê°€) ì„ í˜• í¼ë€/ê³ ë€ ê³„ì‚°
    function calcSkillDamageLinear(skill, lv) {
      // 0ê³¼ null/undefined ë¥¼ êµ¬ë¶„: 0ì€ ìœ íš¨ ë ˆë²¨
      const maxLv = Number(skill.maxLv ?? 0);
      const rawLv = Number(lv ?? 0);

      // 1) ë ˆë²¨ í•˜í•œì€ 0ìœ¼ë¡œ í´ë¨í”„ (0ë ˆë²¨ í—ˆìš©)
      // âœ… ê³„ì‚°ìƒ ìƒí•œ ì œê±°
      const curLv = Math.max(0, rawLv);

      // 2) 0ë ˆë²¨ì´ë©´ ë°ë¯¸ì§€ 0 í™•ì •
      if (curLv === 0) return { per: 0, flat: 0, lv: 0 };

      // 3) '1ë ™ë°ë¯¸ì§€'ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì„ í˜• ì¦ê°€
      //    stepì€ í•­ìƒ (í˜„ì¬ë ˆë²¨ - 1)
      const dmg1Base = Number.isFinite(skill.dmg1Base) ? skill.dmg1Base : 0;
      const fix1Base = Number.isFinite(skill.fix1Base) ? skill.fix1Base : 0;
      const dmg1PerLv = Number.isFinite(skill.dmg1PerLv) ? skill.dmg1PerLv : 0;
      const fix1PerLv = Number.isFinite(skill.fix1PerLv) ? skill.fix1PerLv : 0;

      const step = curLv - 1; // â˜… 1ë ™ ê¸°ì¤€
      const per = dmg1Base + dmg1PerLv * step;  // í¼ë€
      const flat = fix1Base + fix1PerLv * step;  // ê³ ë€

      return { per, flat, lv: curLv };
    }

    // 2) ì™¸ë¶€(ì•„ì´í…œ/ë£¬ ë“±) TP ë³´ë„ˆìŠ¤ í•©ì‚° â€“ ì´ˆê¸°ëŠ” 0ìœ¼ë¡œ ë‘ê³  ë‚˜ì¤‘ì— êµ¬í˜„
    // TP ì¶”ê°€ ë³´ì •ì¹˜(ê¸°êµë£¬ ë“±)
    function getTpBonusFromSources(skillId) {
      // â‘  ì‚¬ìš©ìê°€ ì°ì€ 'ê¸°ë³¸ TP'ê°€ 0ì´ë©´ â†’ ê¸°êµë£¬ ë³´ë„ˆìŠ¤ ì°¨ë‹¨
      const baseUiTp = Number(state.skillTpLv?.[skillId] ?? 0);
      if (!(baseUiTp > 0)) return 0;

      // â‘¡ ê¸°êµë£¬(+TP) í•©ì‚°
      const s = (ST2?.rows || []).find(r => r.id === skillId);
      if (!s) return 0;
      const { enhLvAdd } = runeLevelAdds(s); // ê¸°êµë£¬ ìˆ˜ëŸ‰
      return Number(enhLvAdd || 0);
    }

    // 3) tpì„¤ì •(1/2)ì— ë”°ë¥¸ TP ì¦ê°€ìœ¨(%) ê³„ì‚° (ìµœëŒ€ 7ë ˆë²¨)
    function tpIncreasePercent(tpSetting, tpLevel) {
      const lv = Math.max(0, Math.min(7, Number(tpLevel) || 0));
      if (lv === 0 || !Number.isFinite(tpSetting) || tpSetting <= 0) return 0;

      if (tpSetting === 1) return 5 + (lv - 1) * 2; // 1ë ˆë²¨ 5%, ì´í›„ +2%
      if (tpSetting === 2) return 8 + (lv - 1) * 3; // 1ë ˆë²¨ 8%, ì´í›„ +3%
      return 0;
    }

    // 4) ì„ í˜• ë°ë¯¸ì§€ì— TP ë¹„ìœ¨ì„ ê³±í•´ ìµœì¢…ì¹˜ ì‚°ì¶œ

    /* ===== ê¸¸ê²Œëˆ„ë¥´ê¸°(ë¯¼ê° ì™„í™”): pointer ì´ë²¤íŠ¸ ê¸°ë°˜ ===== */
    function attachPressRepeat(btn, stepFn) {
      let timer = null, active = false, interval = 180;
      const start = (e) => {
        e.preventDefault();
        if (btn.disabled) return;
        active = true;
        stepFn(); // ì²« ëˆŒë¦¼ ì¦‰ì‹œ 1íšŒ
        let firstDelay = 500; // ì´ˆê¸° ì§€ì—°
        timer = setTimeout(function kick() {
          if (!active) return;
          stepFn();
          interval = Math.max(120, interval);     // ìµœì†Œ 120ms
          timer = setTimeout(kick, interval);
        }, firstDelay);
      };
      const stop = () => {
        active = false;
        if (timer) { clearTimeout(timer); timer = null; interval = 180; }
      };

      // pointer ê³„ì—´ë§Œ ì‚¬ìš©í•´ ì¤‘ë³µ ì´ë²¤íŠ¸ ë°©ì§€
      btn.addEventListener('pointerdown', start);
      ['pointerup', 'pointerleave', 'pointercancel', 'blur'].forEach(ev => btn.addEventListener(ev, stop));
      window.addEventListener('pointerup', stop);
    }

    /* ===== ë Œë”ëŸ¬ êµì²´ ===== */
    async function renderSkillTreeBands() {   //ìŠ¤í‚¬ì„ ë°´ë“œí˜•ìœ¼ë¡œ ë°°ì¹˜
      await waitForIdToken();
      await ensureSkillLoaded2();

      // í˜„ì¬ ìºë¦­í„° í‚¤
      const key = currentCharKey?.();
      const wrap = document.getElementById('stGrid');
      wrap.className = 'st2-wrap';
      wrap.innerHTML = '';

      {
        const nmEl = document.getElementById('stCharName');
        if (nmEl) nmEl.textContent = (state.currentCharacter && state.currentCharacter.name) ? state.currentCharacter.name : 'â€”';
      }
      if (!key) {
        wrap.innerHTML = `<div style="color:#c7b589; padding:8px;">ìºë¦­í„°ë¥¼ ë¨¼ì € ì„ íƒí•´ ì£¼ì„¸ìš”.</div>`;
        return;
      }

      // 1) ìºë¦­í„° ì¼ì¹˜ + ë…¸ì¶œ=1
      let list = ST2.rows.filter(s => s.who === String(key).replace(/\s+/g, '') && s.show);
      // 2) ì •ë ¬: ìŠ¤í‚¬ë ™ì œ â†’ ì„¸ë¡œ â†’ ê°€ë¡œ â†’ ì´ë¦„
      list.sort((a, b) => a.level - b.level || a.y - b.y || a.x - b.x || a.name.localeCompare(b.name));
      const levels = [...new Set(list.map(s => s.level))];
      if (levels.length === 0) {
        wrap.innerHTML = `<div style="color:#c7b589; padding:8px;">í‘œì‹œí•  ìŠ¤í‚¬ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
        return;
      }

      // ìœ í‹¸: ê²½ê³„ ë³´ì •
      const clampSkill = (s, v) => Math.max(s.minLv ?? 0, Math.min(s.maxLv ?? 0, Number(v) || 0));
      const clampTp = (v) => Math.max(TP_MIN, Math.min(TP_MAX, Number(v) || 0));
      const getSkill = (s) => {
        if (state.skillLv[s.id] === undefined) state.skillLv[s.id] = clampSkill(s, s.minLv ?? 0);
        return clampSkill(s, state.skillLv[s.id]);
      };
      const setSkill = (s, v) => {
        const target = clampSkill(s, v);
        const cur = getSkill(s);
        const delta = target - cur;
        const per = Number(s.sp || 0);

        if (delta > 0) {
          const cost = per * delta;
          if (!canSpendSp(cost)) { noSpFeedback(); return; }
          state.skillLv[s.id] = target;
          spendSp(cost);
        } else if (delta < 0) {
          state.skillLv[s.id] = target;
          refundSp(per * (-delta));
        } else {
          state.skillLv[s.id] = target;
        }

        // â˜… ì—¬ê¸°ë¶€í„° êµì²´: í™•ì • ë ˆë²¨(target)ê³¼ TP(ì—†ìœ¼ë©´ 0)ë¥¼ ì‚¬ìš©, ??ë¡œ ì•ˆì „ ì²˜ë¦¬
        const curTpLv = state.skillTpLv?.[s.id] ?? 0;              // â† 0 ê·¸ëŒ€ë¡œ ì¸ì •
        state.skillDmg[s.id] = calcSkillDamageWithTp(s, curTpLv);
        onSkillTreeChanged();
      };
      const getTp = (s) => {
        if (state.skillTpLv[s.id] === undefined) state.skillTpLv[s.id] = TP_MIN;
        return clampTp(state.skillTpLv[s.id]);
      };
      const setTp = (s, v) => {
        const unit = Number(s.tpCost || 0);
        if (!Number.isFinite(unit) || unit <= 0) return; // TP ê°•í™” ë¯¸ì§€ì›

        const target = clampTp(v);
        const cur = getTp(s);

        if (target > cur) {
          const need = (target - cur) * unit;
          if (!canSpendTp(need)) { noTpFeedback(); return; }
          spendTp(need);
        } else if (target < cur) {
          const back = (cur - target) * unit;
          refundTp(back);
        }
        state.skillTpLv[s.id] = target;

        // â˜… ì—¬ê¸°! TP í™•ì • í›„ ì¬ê³„ì‚°. minLv=0ì„ ê¹¨ì§€ ì•Šë„ë¡ ?? ì‚¬ìš©
        const curLv = state.skillLv?.[s.id] ?? (s.minLv ?? 1);     // â† 0 ê·¸ëŒ€ë¡œ ì¸ì •
        state.skillDmg[s.id] = calcSkillDamageWithTp(s, target);
        onSkillTreeChanged();
      };

      // ë ˆë²¨ ë°´ë“œ ë‹¨ìœ„ë¡œ DOM ìƒì„±
      levels.forEach(lvl => {
        const group = list.filter(s => s.level === lvl);

        // âœ… ë°´ë“œ ì»¨í…Œì´ë„ˆ(ì ì„ +ë¼ë²¨+ê·¸ë¦¬ë“œ í¬í•¨)
        const band = document.createElement('div');
        band.className = 'st2-band';

        const label = document.createElement('div');
        label.className = 'st2-band-label';
        label.textContent = String(lvl);
        band.appendChild(label);

        // ì´ ë°´ë“œ ì•ˆì˜ 6ì—´ ê·¸ë¦¬ë“œ
        const grid = document.createElement('div');
        grid.className = 'st2-grid';

        group.forEach(s => {
          const tile = document.createElement('div');
          tile.className = 'st2-tile';
          tile.style.gridColumn = String(s.x);
          tile.style.gridRow = String(s.y || 1);

          // ì•„ì´ì½˜(ì›í˜•)
          const icon = document.createElement('div');
          icon.className = 'st2-skill';
          const img = document.createElement('img');
          img.alt = s.name; img.src = s.img || PLACEHOLDER_IMG;
          img.onerror = () => {
            icon.classList.add('st2-empty');
            img.remove();
            const ini = document.createElement('div');
            ini.className = 'st2-initial';
            ini.textContent = (s.name || '?').slice(0, 1);
            icon.appendChild(ini);
          };
          icon.appendChild(img);

          // â˜… ìŠ¤í‚¬ëª… (ì•„ì´ì½˜ê³¼ ë ˆë²¨ë°•ìŠ¤ ì‚¬ì´ì˜ 'ë…ë¦½' ì¤„)
          const nameEl = document.createElement('div');
          nameEl.className = 'st2-name';
          nameEl.textContent = s.name;
          nameEl.title = s.name; // ë§ì¤„ì„ ë³´ì™„ìš© íˆ´íŒ

          // ì»¨íŠ¸ë¡¤(2í–‰ Ã— 3ì—´)
          const ctrl = document.createElement('div');
          ctrl.className = 'st2-ctrl2';

          // ì¢Œì¸¡-ìƒë‹¨(ìŠ¤í‚¬: Max ìœ„, + ì•„ë˜) â€” ê°€ìš´ë° ì •ë ¬
          const LTop = document.createElement('div');
          LTop.className = 'st2-side-left';
          const btnSkillMax = document.createElement('button'); btnSkillMax.className = 'st2-btn'; btnSkillMax.textContent = 'Max';
          const btnSkillPlus = document.createElement('button'); btnSkillPlus.className = 'st2-btn'; btnSkillPlus.textContent = '+';
          LTop.appendChild(btnSkillMax);
          LTop.appendChild(btnSkillPlus);

          // ì¢Œì¸¡-í•˜ë‹¨(ìŠ¤í‚¬: âˆ’ ìœ„, Min ì•„ë˜)
          const LBot = document.createElement('div');
          LBot.className = 'st2-side-left';
          const btnSkillMinus = document.createElement('button'); btnSkillMinus.className = 'st2-btn'; btnSkillMinus.textContent = 'âˆ’';
          const btnSkillMin = document.createElement('button'); btnSkillMin.className = 'st2-btn'; btnSkillMin.textContent = 'Min';
          LBot.appendChild(btnSkillMinus);
          LBot.appendChild(btnSkillMin);

          // ì¤‘ì•™ ë ˆë²¨ í‘œì‹œ(â€œìŠ¤í‚¬ â”‚ TPâ€)
          // ì¤‘ì•™ ë ˆë²¨ í‘œì‹œ(ì„¸ë¡œ ì¤‘ì•™ ê³ ì •, â€œìŠ¤í‚¬ëª…â€ + â€œìŠ¤í‚¬ â”‚ TPâ€)
          const lvBox = document.createElement('div');
          lvBox.className = 'st2-lv';



          // ìˆ«ì ë¼ì¸(ì•„ë«ì¤„): â€œìŠ¤í‚¬ â”‚ TPâ€
          const nums = document.createElement('div');
          nums.className = 'st2-lvnums';

          const spanCur = document.createElement('span');
          spanCur.className = 'cur';
          const spanSep = document.createElement('span'); spanSep.className = 'sep'; spanSep.textContent = 'â”‚';
          const spanTp = document.createElement('span');
          spanTp.className = 'tp';

          nums.appendChild(spanCur);
          nums.appendChild(spanSep);
          nums.appendChild(spanTp);


          lvBox.appendChild(nums);


          // ìš°ì¸¡-ìƒë‹¨(TP: Max ìœ„, + ì•„ë˜)
          const RTop = document.createElement('div');
          RTop.className = 'st2-side-right';
          const btnTpMax = document.createElement('button'); btnTpMax.className = 'st2-btn'; btnTpMax.textContent = 'Max';
          const btnTpPlus = document.createElement('button'); btnTpPlus.className = 'st2-btn'; btnTpPlus.textContent = '+';
          RTop.appendChild(btnTpMax);
          RTop.appendChild(btnTpPlus);

          // ìš°ì¸¡-í•˜ë‹¨(TP: âˆ’ ìœ„, Min ì•„ë˜)
          const RBot = document.createElement('div');
          RBot.className = 'st2-side-right';
          const btnTpMinus = document.createElement('button'); btnTpMinus.className = 'st2-btn'; btnTpMinus.textContent = 'âˆ’';
          const btnTpMin = document.createElement('button'); btnTpMin.className = 'st2-btn'; btnTpMin.textContent = 'Min';
          RBot.appendChild(btnTpMinus);
          RBot.appendChild(btnTpMin);

          // ì»¨íŠ¸ë¡¤ ê·¸ë¦¬ë“œ ë°°ì¹˜
          LTop.style.gridColumn = '1'; LTop.style.gridRow = '1';
          LBot.style.gridColumn = '1'; LBot.style.gridRow = '2';
          lvBox.style.gridColumn = '2'; lvBox.style.gridRow = '1 / span 2';
          RTop.style.gridColumn = '3'; RTop.style.gridRow = '1';
          RBot.style.gridColumn = '3'; RBot.style.gridRow = '2';

          ctrl.appendChild(LTop); ctrl.appendChild(LBot);
          ctrl.appendChild(lvBox);
          ctrl.appendChild(RTop); ctrl.appendChild(RBot);

          tile.appendChild(icon);
          tile.appendChild(nameEl);
          tile.appendChild(ctrl);
          grid.appendChild(tile);

          // ìƒíƒœ â†’ UI ë°˜ì˜
          const refresh = () => {
            const cur = getSkill(s);
            const tp = getTp(s);
            spanCur.textContent = String(cur);
            spanTp.textContent = String(tp);
            // ìŠ¤í‚¬ ê²½ê³„
            btnSkillPlus.disabled = (cur >= s.maxLv);
            btnSkillMax.disabled = (cur >= s.maxLv);
            btnSkillMinus.disabled = (cur <= s.minLv);
            btnSkillMin.disabled = (cur <= s.minLv);
            // TP ê²½ê³„ (ìŠ¤í‚¬ë³„ tpCost ì ìš©)
            const unit = Number(s.tpCost || 0);
            if (!Number.isFinite(unit) || unit <= 0) {
              btnTpPlus.disabled = true;
              btnTpMax.disabled = true;
              btnTpMinus.disabled = true;
              btnTpMin.disabled = true;
            } else {
              btnTpPlus.disabled = (tp >= TP_MAX) || !canSpendTp(unit);
              btnTpMax.disabled = (tp >= TP_MAX) || !canSpendTp((TP_MAX - tp) * unit);
              btnTpMinus.disabled = (tp <= TP_MIN);
              btnTpMin.disabled = (tp <= TP_MIN);
            }
          };
          refresh();
          // ì¡°ì‘ í•¨ìˆ˜
          const stepSkillUp = () => { setSkill(s, getSkill(s) + 1); refresh(); };
          const stepSkillDn = () => { setSkill(s, getSkill(s) - 1); refresh(); };
          const toSkillMax = () => { setSkill(s, s.maxLv); refresh(); };
          const toSkillMin = () => { setSkill(s, s.minLv); refresh(); };

          const stepTpUp = () => { setTp(s, getTp(s) + 1); refresh(); };
          const stepTpDn = () => { setTp(s, getTp(s) - 1); refresh(); };
          const toTpMax = () => { setTp(s, TP_MAX); refresh(); };
          const toTpMin = () => { setTp(s, TP_MIN); refresh(); };

          // ê¸¸ê²Œëˆ„ë¥´ê¸°(ë¯¼ê°ë„ ì™„í™”)
          attachPressRepeat(btnSkillPlus, stepSkillUp);
          attachPressRepeat(btnSkillMinus, stepSkillDn);
          attachPressRepeat(btnSkillMax, toSkillMax);
          attachPressRepeat(btnSkillMin, toSkillMin);

          attachPressRepeat(btnTpPlus, stepTpUp);
          attachPressRepeat(btnTpMinus, stepTpDn);
          attachPressRepeat(btnTpMax, toTpMax);
          attachPressRepeat(btnTpMin, toTpMin);
        });

        band.appendChild(grid);
        wrap.appendChild(band);
      });
    }




    /** ë²„íŠ¼ ì—°ê²° (ê¸°ì¡´ old ë Œë”ëŸ¬ ë°”ì¸ë”©ì´ ìˆë‹¤ë©´ êµì²´) */
    const stModal = document.getElementById('skillTreeModal');

    /* ESCë¡œ ë‹«ê¸°(ì„ íƒ ì‚¬í•­) */
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.querySelectorAll('.modal.show').forEach(m => {
          m.classList.remove('show'); m.setAttribute('aria-hidden', 'true');
        });
      }
    });
    /* 25.09.20 ìŠ¤í‚¬íŠ¸ë¦¬ ì¶”ê°€ F*/

    /* ë²„íŠ¼ìœ¼ë¡œ ì—´ê¸° */
    document.getElementById('btnSkillTree')?.addEventListener('click', async () => {
      await renderSkillTreeBands(); /*25.09.20ë³€ê²½*/
      stModal?.classList.add('show');
      stModal?.setAttribute('aria-hidden', 'false');
    });
    stModal?.addEventListener('click', (e) => {
      if (e.target.classList?.contains('backdrop') || e.target.hasAttribute?.('data-close')) {
        stModal.classList.remove('show');
        stModal.setAttribute('aria-hidden', 'true');
      }
    });
    // ë£¬ ê°ì¸ ì„ íƒ ê²°ê³¼(í•œ ê°œë§Œ ìœ ì§€)
    state.runeEngrave = state.runeEngrave || null; // {name, tag, stats, ...}
    //ì¼ë°˜ìŠ¤í‚¬ë£¬
    const RUNE_LEVELS = [15, 20, 25, 30, 35, 40, 45, 65];
    const RUNE_CATS = [
      { key: 'awakening', label: 'ê°ì„±' },
      { key: 'magic', label: 'ë§ˆë ¥' },
      { key: 'illusion', label: 'í—ˆìƒ' },
      { key: 'training', label: 'ìˆ™ë ¨' },
      { key: 'technique', label: 'ê¸°êµ' }
    ];
    state.runes = state.runes || {}; // {catKey: {level: count}}
    function ensureRunesInitialized() {
      RUNE_CATS.forEach(c => {
        state.runes[c.key] ||= {};
        RUNE_LEVELS.forEach(lvl => {
          if (typeof state.runes[c.key][lvl] !== 'number') state.runes[c.key][lvl] = 0;
        });
      });
    }
    /* ===== ìŠ¤í‚¬ë£¬ ì½”ì–´ ===== */
    // ì¹´í…Œê³ ë¦¬ í‚¤: RUNE_CATSì—ì„œ ì“°ëŠ” í‚¤ ê·¸ëŒ€ë¡œ ì‚¬ìš©(ê°ì„±/ë§ˆë ¥/í—ˆìƒ/ìˆ™ë ¨/ê¸°êµ)
    const RUNE_KEYS = {
      awakening: 'ê°ì„±ë£¬',   // ë°ë¯¸ì§€ Ã—1.04^n
      magic: 'ë§ˆë ¥ë£¬',   // ë°ë¯¸ì§€ Ã—1.03^n
      illusion: 'í—ˆìƒë£¬',   // ì¿¨íƒ€ì„ Ã—0.96^n
      training: 'ìˆ™ë ¨ë£¬',   // ìŠ¤í‚¬ë ˆë²¨ +n
      technique: 'ê¸°êµë£¬',   // ìŠ¤í‚¬ê°•í™”ë ˆë²¨ +n
    };

    // ì„ íƒ ê°œìˆ˜ ê°€ì ¸ì˜¤ê¸°: state.runes[catKey][tier] (ì—†ìœ¼ë©´ 0)
    function getRuneCountByKey(catKey, tier) {
      const row = (state.runes?.[catKey]) || {};
      return Number(row[tier] || 0);
    }

    // ìŠ¤í‚¬ì˜ ë ™ì œ(ë°´ë“œ) ì•Œì•„ë‚´ê¸°: mapRowToSkillì—ì„œ band í•„ë“œë¥¼ ì±„ì›€
    // (ìŠ¤í‚¬ ê°ì²´ì— bandê°€ ì—†ìœ¼ë©´ 0/ê¸°ë³¸ ì·¨ê¸‰)
    function skillTierOf(skill) {
      const b = Number(skill?.band || 0);
      return b > 0 ? b : null;
    }

    // (skillTierOf ë°”ë¡œ ì•„ë˜ì—)
    function getLevelingCountByTier(tier) {
      return Number(state.leveling?.[tier] || 0);
    }

    // cd ê°’ì„ 'ì´ˆ' ìˆ«ìë¡œë§Œ ì–»ê¸° (ë¬¸ì ì„ì—¬ ìˆì–´ë„ ìˆ«ìë§Œ ì¶”ì¶œ)
    function toSec(v) {
      const n = Number(String(v ?? '').replace(/[^\d.]/g, ''));
      return Number.isFinite(n) ? n : 0;
    }

    // 1) ìµœì¢… ê³µê²©ë ¥ ë°°ìˆ˜: ê°ì„±(1.04^n) Ã— ë§ˆë ¥(1.03^n)
    function runeDamageMultiplier(skill) {
      const tier = skillTierOf(skill);
      if (!tier) return 1;
      const nA = getRuneCountByKey('awakening', tier);
      const nM = getRuneCountByKey('magic', tier);
      return Math.pow(1.04, nA) * Math.pow(1.03, nM);
    }

    // 2) ì¿¨íƒ€ì„ ë³´ì •: í—ˆìƒë£¬ â†’ baseCd Ã— (0.96^n)
    function runeCooldown(skill, baseCd) {
      const tier = skillTierOf(skill);
      if (!tier) return baseCd;
      const nH = getRuneCountByKey('illusion', tier);
      return baseCd * Math.pow(0.96, nH);
    }

    // 3) ë ˆë²¨ ë³´ì •: ìˆ™ë ¨(+n), ê¸°êµ(+n)
    function runeLevelAdds(skill) {
      const tier = skillTierOf(skill);
      if (!tier) return { skillLvAdd: 0, enhLvAdd: 0 };
      const nS = getRuneCountByKey('training', tier);
      const nT = getRuneCountByKey('technique', tier);
      return { skillLvAdd: nS, enhLvAdd: nT };
    }

    function countSelectedRunes() {
      let sum = 0;
      Object.values(state.runes).forEach(row => {
        Object.values(row).forEach(v => sum += (Number(v) || 0));
      });
      return sum;
    }
    function updateRuneCountSummary() {
      const n = countSelectedRunes();
      const a = document.getElementById('runeCount'); if (a) a.textContent = n;
      const b = document.getElementById('runeCountLabel'); if (b) b.textContent = n;
    }
    // ë£¬ ë³€ê²½ ì‹œ ì‚´ì§ ë””ë°”ìš´ìŠ¤í•´ì„œ ì „ì²´ ì¬ê³„ì‚°
    const onRunesChanged = (() => {
      let t = null;
      return () => {
        clearTimeout(t);
        t = setTimeout(() => {
          // ì „ì²´ í•©ì‚°/ìŠ¤í‚¬ ìºì‹œ/í‘œì‹œê¹Œì§€ í•œ ë²ˆì— ì²˜ë¦¬
          if (typeof recalcAndRenderPanel === 'function') {
            recalcAndRenderPanel();
          }
        }, 60);
      };
    })();

    state.options = state.options || {
      avatar: null,        // 'rare' | 'advanced'
      weaponImprint: null, // 'add5' | 'patkmatk5' | 'patkmatk3' | 'monster' | 'quest'
      timeWindow: null,    // '30s' | '1m' | '3m' | '5m' | '10m'
      monster: null,       // 'nugol' | 'blackdragon' | 'asmar_calix'
      difficulty: null     // 'hard' | 'normal' | 'easy' | 'nugol_room'
    };
    /* â–¼ ë“œë¡­ë‹¤ìš´ value â†’ ì‹œíŠ¸ 'ì´ë¦„' ë§¤í•‘ */
    const AVATAR_NAME = {
      rare: 'ë ˆì–´ ì•„ë°”íƒ€',
      advanced: 'ìƒê¸‰ ì•„ë°”íƒ€',
      empty: 'ì—†ìŒ'
    };
    const IMPRINT_NAME = {
      add5: 'ì¶”ë€ 5% ë¬´ê¸°ì••',
      patkmatk5: 'ë¬¼/ë§ˆê³µ 5% ë¬´ê¸°ì••',
      patkmatk3: 'ë¬¼/ë§ˆê³µ 3% ë¬´ê¸°ì••',
      monster: 'ëª¬ìŠ¤í„° ë¬´ê¸°ì••',
      quest: 'í€˜ìŠ¤íŠ¸ ë¬´ê¸°ì••',
      empty: 'ì—†ìŒ'
    };
    /* â–¼ ë“œë¡­ë‹¤ìš´ value â†’ ì‹œíŠ¸ 'ëª¬ìŠ¤í„°ëª…' ë§¤í•‘ */
    const MONSTER_NAME = {
      nugol: 'ê±°ëŒ€ëˆ„ê³¨',
      blackdragon: 'í‘ë£¡',
      anton: 'ì•ˆí†¤',
      asmar_calix: 'ì•„ìŠ¤ë§ˆë¥´/ì¹¼ë¦­ìŠ¤'
    };

    // â˜… C) íš¨ê³¼ì  ìŠ¤í‚¬ ë ˆë²¨(ë ˆë²¨ë§ + ìˆ™ë ¨ë£¬ ì ìš©, 0ë ˆë²¨ì€ í™œì„±í™” ì•ˆ í•¨)
    function effectiveSkillLevelForDamage(skill) {
      // 1) ê¸°ë³¸ ìŠ¤í‚¬ ë ˆë²¨
      let baseLv = Number(state.skillLv?.[skill.id] ?? 0);
      const kind = String(skill?.kind || '').trim();

      // í‰íƒ€/ì—°ê²°í‰íƒ€ëŠ” ê¸°ë³¸ ë ˆë²¨ì´ ì—†ìœ¼ë©´ 1ë¡œ ë³´ì •
      const isNormal = (kind === 'í‰íƒ€' || kind === 'ì—°ê²°í‰íƒ€' || kind.startsWith('í‰íƒ€'));
      if ((!Number.isFinite(baseLv) || baseLv <= 0) && isNormal) {
        baseLv = 1;
      }
      // í‰íƒ€ê°€ ì•„ë‹ˆê³ , ìœ íš¨ ë² ì´ìŠ¤ë ˆë²¨ì´ ì—†ìœ¼ë©´ 0 (ê¸°ì¡´ ê·œì¹™ ìœ ì§€)
      if (!Number.isFinite(baseLv) || baseLv <= 0) {
        return 0;
      }

      // 2) ìŠ¤í‚¬ë ™ì œ(ë ˆë²¨ë§ ê²Œì´íŠ¸) ê²°ì •: levelGate â†’ band â†’ ê¸°ì¡´ helper ìˆœ
      const gate =
        Number(skill?.levelGate ?? 0) ||
        Number(skill?.band ?? 0) ||
        (skillTierOf ? (Number(skillTierOf(skill)) || 0) : 0);

      const lvlAddByLeveling = gate ? getLevelingCountByTier(gate) : 0;

      // 3) ìˆ™ë ¨ë£¬(+n)
      const { skillLvAdd } = runeLevelAdds ? runeLevelAdds(skill) : { skillLvAdd: 0 };

      // â˜… ì˜ˆì™¸ê·œì¹™: ìŠ¤í‚¬ë ˆë²¨ ê°€ì‚°
      const excAdd = Number(__EXC?.addLv?.[skill.id] || 0);
      if (excAdd) baseLv = Math.max(0, baseLv + excAdd);

      // 4) ìµœì¢… ìœ íš¨ ë ˆë²¨(ìƒí•œ ì—†ìŒ, 1 ì´ìƒìœ¼ë¡œ ë³´ì •)
      const eff = baseLv + (lvlAddByLeveling || 0) + (skillLvAdd || 0);
      return Math.max(1, eff);
    }


    // â˜… D) ìµœì¢… ë°ë¯¸ì§€: (ì„ í˜• ë°ë¯¸ì§€ at íš¨ê³¼ì  ë ˆë²¨) Ã— (TP ë°°ìœ¨) Ã— (ë£¬ ë°°ìœ¨)
    function calcSkillDamageWithTp(skill, baseTpLv) {
      // 1) ì´ˆ ë‹¨ìœ„ ì¿¨ ê³„ì‚° (â˜… ìˆœì„œ ì¤‘ìš”)
      const cdBase = (typeof toSec === 'function') ? toSec(skill.cd) : Number(skill.cd || 0);

      // â˜… (A) 'ì¿¨íƒ€ì„ê³ ì •ê°ì†Œ'(ì´ˆ) â€” ê°€ì¥ ë¨¼ì € ì ìš©
      const excCdFlat = Number(__EXC?.addCdFlat?.[skill.id] || 0);
      const cdAfterFlat = (cdBase > 0) ? Math.max(0, cdBase - excCdFlat) : 0;

      // â˜… (B) í—ˆìƒë£¬/ë£¬ ë³´ì • â€” ê³ ì •ê°ì†Œ ì ìš©ëœ ê°’ì— ëŒ€í•´ ìˆ˜í–‰
      let cdFinal = (cdAfterFlat > 0) ? runeCooldown(skill, cdAfterFlat) : 0;

      // â˜… (C) 'ì¿¨íƒ€ì„ê°ì†Œ'(%) â€” ê·¸ ë‹¤ìŒ ê³±
      const excCdPct = Number(__EXC?.addCdPct?.[skill.id] || 0);
      if (cdFinal > 0 && excCdPct) {
        cdFinal *= Math.max(0, 1 - excCdPct / 100);
      }

      // â˜… (D) 'ì¿¨ì´ˆí™•ë¥ '(%) â€” ê¸°ëŒ€ê°’ ê·¼ì‚¬
      const resetPct = Math.max(0, Math.min(100, Number(__EXC?.resetPct?.[skill.id] || 0)));
      if (cdFinal > 0 && resetPct) {
        cdFinal *= (1 - resetPct / 100);
      }

      // ìµœì¢… ë°°ìˆ˜(ì›ë˜ ê¸°ë³¸ ì¿¨ ëŒ€ë¹„)
      const cdMul = (cdBase > 0) ? (cdFinal / cdBase) : 1;

      // 2) ì‹œì „ í”„ë ˆì„
      const castFrames = Number(skill.castFrames || 0);

      // 3) ìœ íš¨ ìŠ¤í‚¬ ë ˆë²¨
      let effLv = effectiveSkillLevelForDamage(skill);     // â† (A) let ìœ¼ë¡œ ë³€ê²½ (ë³´ì • ìœ„í•´)
      const kindNorm = String(skill?.kind || 'ìŠ¤í‚¬').trim();

      // â˜… ì˜µì…˜ B: í‰íƒ€(ë˜ëŠ” ì—°ê²°í‰íƒ€)ëŠ” ë ˆë²¨ ë¯¸ì§€ì •ì´ì–´ë„ 1ë ˆë²¨ë¡œ ë³´ì •
      if (effLv === 0 && (kindNorm === 'í‰íƒ€' || kindNorm === 'ì—°ê²°í‰íƒ€' || kindNorm.startsWith('í‰íƒ€'))) {
        effLv = 1;
      }
      if (effLv === 0) {
        return {
          per: 0,
          flat: 0,
          lv: 0,
          tpLv: 0,
          tpIncPercent: 0,
          runeMul: 1,
          cdBase,
          cdFinal,
          cdMul,
          castFrames,
          dps: 0,            // â˜… ì¡°ê¸° ë¦¬í„´ì—ë„ dps ëª…ì‹œ
          uses: 0,           // â˜… ì‹œë®¬ í›„ ë®ì–´ì”€
          kind: kindNorm,
        };
      }

      // 4) ì„ í˜• ë°ë¯¸ì§€ ê¸°ë°˜
      const base = calcSkillDamageLinear(skill, effLv); // {per, flat, lv}

      // 5) TP (TP 0ì´ë©´ ê¸°êµë£¬ ë¬´íš¨ ê·œì¹™ ìœ ì§€)

      // ê¸°ì¡´ íŒ¨í„´ ìœ ì§€: ìˆ˜ë™ TPëŠ” 0~5
      const tpBase = Math.max(0, Math.min(5, Number(state.skillTpLv?.[skill.id] ?? 0)));

      // ì˜ˆì™¸ ê·œì¹™ì—ì„œ ì˜¨ tpë ˆë²¨ ë³´ë„ˆìŠ¤
      const tpExc = Number(__EXC?.addTp?.[skill.id] || 0);

      // â˜… ë³´ë„ˆìŠ¤ì— ì–¹ì–´ì£¼ê¸° (ìˆ˜ë™ TP>0ì¼ ë•Œë§Œ ë£¬/ë³´ë„ˆìŠ¤ ì ìš© ê·œì¹™ ìœ ì§€)
      const tpBonus = (tpBase > 0) ? (getTpBonusFromSources(skill.id) + tpExc) : 0;

      // ìµœì¢… TP 0~7
      const tpLv = Math.max(0, Math.min(7, tpBase + tpBonus));

      const tpPct = tpIncreasePercent(Number(skill.tpCost || 0), tpLv);
      const tpMul = 1 + (tpPct / 100);

      // 6) ë£¬ ë°°ìˆ˜
      const rMul = runeDamageMultiplier(skill);

      // 7) ìµœì¢… per/flat ë¨¼ì € ì‚°ì¶œ
      let per = (base.per || 0) * tpMul * rMul;
      let flat = (base.flat || 0) * tpMul * rMul;

      // â˜… ì˜ˆì™¸: ë°ë¯¸ì§€ì¦ê°€(%) ì ìš© (ì—¬ëŸ¬ ì¤„ í•©ì‚° â†’ 1 + í•©ê³„/100)
      const excDmgPct = Number(__EXC?.addDmgPct?.[skill.id] || 0);
      if (excDmgPct) {
        const m = 1 + excDmgPct / 100;
        per *= m;
        flat *= m;
      }

      // 8) ì´ì œ dps ê³„ì‚° (ê³ ë€ ì œì™¸, perë§Œ)
      const dps = cdFinal > 0 ? (per / cdFinal) : 0;

      // 9) ë°˜í™˜
      return {
        per,
        flat,
        lv: base.lv,
        tpLv,
        tpIncPercent: tpPct,
        runeMul: rMul,
        cdBase,
        cdFinal,
        cdMul,
        castFrames,
        dps,            // â˜… ì—¬ê¸°ì„œ ì •ì˜ëœ dps ì‚¬ìš©
        uses: 0,        // â˜… ì‹œë®¬ í›„ ë®ì–´ì”€
        kind: kindNorm,
      };
    }


    /* ===== Uses ì‹œë®¬ë ˆì´í„°(í”„ë ˆì„ ë‹¨ìœ„) ===== */
    (function () {
      const FPS = 60;

      function currentCharKey() {
        const k =
          (typeof currentSkillOwnerKey === 'function' ? currentSkillOwnerKey() : null) ??
          [state.currentCharacter?.jobGroupLabel, state.currentCharacter?.name].filter(Boolean).join('');
        return String(k || '').replace(/\s+/g, '');
      }

      // ë‚´ë¶€: ëŒ€ìƒ ìŠ¤í‚¬ ëª©ë¡ êµ¬ì„±(ìš”êµ¬ì‚¬í•­ 8 ë°˜ì˜)
      function collectSimCandidates() {
        const key = currentCharKey();
        if (!key || !(ST2?.rows?.length)) return { skills: [], awks: [], normals: [], link: null };

        const rowsAll = ST2.rows.filter(s => s.who === key);

        // í˜„ì¬ ì‚¬ìš© ë ˆë²¨(>=1)ì¸ ìŠ¤í‚¬/ê°ì„±ê¸°
        const isOn = (id) => Number(state.skillLv?.[id] ?? 0) >= 1;

        const skills = rowsAll.filter(s => (s.kind === 'ìŠ¤í‚¬') && isOn(s.id));
        const awks = rowsAll.filter(s => (s.kind === 'ê°ì„±ê¸°') && isOn(s.id));

        // í‰íƒ€/ì—°ê²°í‰íƒ€(showì™€ ë¬´ê´€)
        const normals = rowsAll.filter(s => s.kind === 'í‰íƒ€');
        const link = rowsAll.find(s => s.kind === 'ì—°ê²°í‰íƒ€') || null;

        return { skills, awks, normals, link };
      }

      // ë‚´ë¶€: ìŠ¤í‚¬ ì—”íŠ¸ë¦¬ë¡œ ë³€í™˜(ë°ë¯¸ì§€ ìºì‹œ ë³´ê°• + cd/ìºìŠ¤íŠ¸ í”„ë ˆì„ ì‚°ì¶œ)
      function toEntry(skill) {
        const tp = Math.max(0, Math.min(5, Number(state.skillTpLv?.[skill.id] ?? 0)));
        const d = calcSkillDamageWithTp(skill, tp); // per, flat, cdFinal(ì´ˆ), castFrames ë“±
        // state.skillDmgì— ë³‘í•©(uses ì´ˆê¸°í™”/ìœ ì§€)
        const prev = state.skillDmg?.[skill.id] || {};
        state.skillDmg[skill.id] = { ...prev, ...d, uses: Number(prev.uses || 0) };

        const cdF = Math.max(0, Math.round(Number(d.cdFinal || 0) * FPS)); // ì¿¨(í”„ë ˆì„)
        const castF = Math.max(0, Math.round(Number(skill.castFrames || 0))); // ì‹œì „(í”„ë ˆì„)

        return {
          id: skill.id,
          name: skill.name,
          kind: skill.kind || 'ìŠ¤í‚¬',
          per: Number(d.per || 0),
          cdF,
          castF,
          nextReady: 0
        };
      }

      // ë‚´ë¶€: DPS ê³„ì‚°(per / cd[ì´ˆ]) â€” í‰íƒ€/ì—°ê²°í‰íƒ€ì—ëŠ” ì‚¬ìš© ì•ˆí•¨
      const dps = (e) => {
        const cdSec = e.cdF / FPS;
        return (cdSec > 0) ? (e.per / cdSec) : 0;
      };

      function getTimeWindowSec() {
        const el = document.getElementById('selTime');
        const v = el?.value || '';
        switch (v) {
          case '30s': return 30;
          case '1m': return 60;
          case '3m': return 180;
          case '5m': return 300;
          case '10m': return 600;
          default: return 60; // ì„ íƒ ì „/ì´ìƒê°’ â†’ 60ì´ˆ
        }
      }

      document.getElementById('selTime')?.addEventListener('change', () => {
        queueMicrotask(() => window.simulateSkillUsage?.(getTimeWindowSec()));
      });

      // ë©”ì¸: 60ì´ˆ(=3600í”„ë ˆì„) ì‹œë®¬
      function simulateSkillUsage(totalSec = 60) {
        const totalF = Math.max(1, Math.floor(totalSec * FPS));

        const { skills, awks, normals, link } = collectSimCandidates();
        let S = skills.map(toEntry);
        let A = awks.map(toEntry);
        let N = normals.map(toEntry);
        let L = link ? toEntry(link) : null;

        // uses ì´ˆê¸°í™”
        for (const e of [...S, ...A, ...N, ...(L ? [L] : [])]) {
          state.skillDmg[e.id].uses = 0;
        }

        const log = [];
        let now = 0;              // í˜„ì¬ í”„ë ˆì„
        let lastKind = null;      // ì§ì „ ì•¡ì…˜ kind (í‰íƒ€ ì—°ì† ê¸ˆì§€ ì²´í¬ìš©)

        // nextReadyë¥¼ tStart + cdF ë¡œ ì„¤ì •í•˜ê¸° ìœ„í•´ start í”„ë ˆì„ ë³„ë„ ë³€ìˆ˜ ì‚¬ìš©
        const use = (entry) => {
          const t0 = now; // ì‹œì‘ í”„ë ˆì„
          const t1 = t0 + entry.castF;
          if (t1 > totalF) return false; // ë‚¨ì€ ì‹œê°„ ë¶€ì¡± â†’ ì‹œì „ ë¶ˆê°€

          // ë¡œê·¸ ì¶•ì (ìë™ì¶œë ¥ ê¸ˆì§€ â€” ë°°ì—´ì—ë§Œ ì €ì¥)
          log.push({
            fStart: t0, fEnd: t1, kind: entry.kind, id: entry.id, name: entry.name
          });

          // uses ì¦ê°€
          state.skillDmg[entry.id].uses = (state.skillDmg[entry.id].uses || 0) + 1;

          // ì¿¨ë‹¤ìš´: â€œì‚¬ìš© ì¦‰ì‹œ ì‹œì‘, ìºìŠ¤íŒ… ì¤‘ì—ë„ íë¦„â€ â†’ nextReady = t0 + cdF
          entry.nextReady = Math.max(entry.nextReady, t0 + entry.cdF);

          // ì‹œê°„ ì§„í–‰
          now = t1;
          lastKind = entry.kind;
          return true;
        };

        // ë‹¤ìŒ â€˜ë¹„-í‰íƒ€(ìŠ¤í‚¬/ê°ì„±ê¸°)â€™ ì¤€ë¹„ê¹Œì§€ ë‚¨ì€ í”„ë ˆì„ R
        const nextReadyNonNormals = () => {
          const arr = [...S, ...A].map(e => e.nextReady).filter(v => Number.isFinite(v));
          if (!arr.length) return Number.POSITIVE_INFINITY;
          return Math.max(0, Math.min(...arr) - now);
        };

        while (now < totalF) {
          // 1) ìŠ¤í‚¬(ì¤€ë¹„ë¨) ì¤‘ DPS ìµœê³ 
          const readyS = S.filter(e => now >= e.nextReady);
          if (readyS.length) {
            // DPS ìµœëŒ€ ì„ íƒ
            let pick = readyS.reduce((a, b) => (dps(a) >= dps(b) ? a : b));
            if (!use(pick)) break;
            continue;
          }

          // 2) ê°ì„±ê¸°(ì¤€ë¹„ë¨) ì¤‘ DPS ìµœê³ 
          const readyA = A.filter(e => now >= e.nextReady);
          if (readyA.length) {
            let pick = readyA.reduce((a, b) => (dps(a) >= dps(b) ? a : b));
            if (!use(pick)) break;
            continue;
          }

          // 3) ë‘˜ ë‹¤ ì¿¨ì´ë©´ í‰íƒ€/ì—°ê²°í‰íƒ€
          let R = nextReadyNonNormals(); // ë‹¤ìŒ ë¹„-í‰íƒ€ê¹Œì§€ ë‚¨ì€ í”„ë ˆì„
          if (R <= 0) {
            // ì´ë¡ ìƒ 0ì´í•˜ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆìœ¼ë‹ˆ í•œ í”„ë ˆì„ ì§„í–‰(í˜¹ì€ ì¤€ë¹„ ì¬í‰ê°€)
            now += 1;
            continue;
          }

          // í‰íƒ€ ì—°ì† ê¸ˆì§€
          // 3) ë‘˜ ë‹¤ ì¿¨ì´ë©´ í‰íƒ€/ì—°ê²°í‰íƒ€


          // â›” ê·œì¹™ ë³´ê°•: ì§ì „ì´ 'í‰íƒ€'ì˜€ë‹¤ë©´, í‰íƒ€/ì—°ê²°í‰íƒ€ëŠ” ì „ë¶€ ê¸ˆì§€.
          //    ì˜¤ë¡œì§€ ìŠ¤í‚¬/ê°ì„±ê¸°ê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ 'ëŒ€ê¸°(í”„ë ˆì„ ì í”„)'ë§Œ í—ˆìš©.
          const canUseAnyNormal = (lastKind !== 'í‰íƒ€');
          if (!canUseAnyNormal) {
            if (Number.isFinite(R) && R > 0) {
              now = Math.min(totalF, now + R);
            } else {
              now = Math.min(totalF, now + 1);
            }
            continue;
          }

          // (ì—¬ê¸°ë¶€í„°ëŠ” ì§ì „ì´ í‰íƒ€ê°€ ì•„ë‹ ë•Œë§Œ ì‹¤í–‰ë¨)
          // í‰íƒ€ í›„ë³´: castF â‰¤ R, Rì— ë” ê·¼ì ‘(|R - castF| ìµœì†Œ), ë™ë¥ ì´ë©´ per í° ê²ƒ
          let pickN = null;
          if (N.length) {
            const candidates = N
              .filter(e => e.castF > 0 && e.castF <= R)
              .sort((a, b) => {
                const da = Math.abs(R - a.castF);
                const db = Math.abs(R - b.castF);
                if (da !== db) return da - db;           // R ê·¼ì ‘ ìš°ì„ 
                if (a.per !== b.per) return b.per - a.per; // ë™ë¥ ì´ë©´ per í° ê²ƒ
                return 0;
              });
            pickN = candidates[0] || null;
          }

          if (pickN) {                 // í‰íƒ€ 1íšŒë§Œ í—ˆìš© (uses ì¦ê°€ ë° lastKind='í‰íƒ€'ë¡œ ì„¤ì •ë¨)
            if (!use(pickN)) break;
            continue;
          }

          // í‰íƒ€ê°€ ì•ˆ ë§ìœ¼ë©´ 'ì—°ê²°í‰íƒ€' ê³ ë ¤ (ì—°ì† í—ˆìš©)
          //  âš ï¸ ì£¼ì˜: ìœ„ì—ì„œ canUseAnyNormal=false(=ì§ì „ í‰íƒ€)ì˜€ìœ¼ë©´ ì´ ë¸”ë¡ê¹Œì§€ ì˜¤ì§€ ì•ŠìŒ
          if (L && L.castF > 0) {
            if (!use(L)) break;
            continue;
          }

          // í‰íƒ€/ì—°ê²°í‰íƒ€ ë‘˜ ë‹¤ ëª» ì“°ë©´, ë‹¤ìŒ ìŠ¤í‚¬/ê°ì„±ê¸° ì¤€ë¹„ ì‹œì ê¹Œì§€ ì í”„
          if (Number.isFinite(R) && R > 0) {
            now = Math.min(totalF, now + R);
          } else {
            now = Math.min(totalF, now + 1);
          }

        }

        // ë¡œê·¸ ì €ì¥(ìë™ ì¶œë ¥ X)
        state.skillSimLog = log;
        return log;
      }

      // ì™¸ë¶€ ë…¸ì¶œ: ìˆ˜ë™ ì¶œë ¥ìš©
      window.printSkillSimLog = function () {
        const L = state?.skillSimLog || [];
        if (!L.length) { console.log('[SIM] ë¡œê·¸ ì—†ìŒ'); return; }
        for (const row of L) {
          console.log(`[f=${row.fStart}~${row.fEnd}] ì‚¬ìš©: [${row.kind}] ${row.name} (${row.id})`);
        }
        // ë§ˆì§€ë§‰ì— uses ìš”ì•½
        const summary = {};
        for (const [id, v] of Object.entries(state.skillDmg || {})) {
          if (v?.uses) summary[id] = v.uses;
        }
        console.log('[SIM] uses:', summary);
      };

      // ì™¸ë¶€ ë…¸ì¶œ: ì‹¤í–‰ í•¨ìˆ˜
      window.simulateSkillUsage = simulateSkillUsage;
      (() => {
        const el = document.getElementById('selTime');
        if (el && !el.value) el.value = '1m';  // í˜¹ì‹œ ê³µë°±ì´ë©´ 1ë¶„ìœ¼ë¡œ ë³´ì •
        window.simulateSkillUsage?.(getTimeWindowSec());
      })();
    })();


    let __monsterApplyingDefault = false;
    // ë“œë¡­ë‹¤ìš´ ë³€ê²½ ì‹œ í˜¸ì¶œ
    async function onMonsterChange(selectedName) {
      await ensureMonsterLoaded();

      // 1) ì„ íƒê°’ì´ ë¹„ì—ˆìœ¼ë©´ (ì´ˆê¸° ìƒíƒœ ë“±) ê¸°ë³¸ê°’ìœ¼ë¡œ ë³´ì •
      let name = selectedName || state?.options?.monster || 'ê±°ëŒ€ëˆ„ê³¨';

      // 2) ë“œë¡­ë‹¤ìš´(UI)ê³¼ ê°’ ë™ê¸°í™” (ì˜µì…˜ ëª©ë¡ì´ ì´ë¯¸ ì±„ì›Œì¡Œë‹¤ê³  ê°€ì •)
      if (!selectedName && !__monsterApplyingDefault) {
        __monsterApplyingDefault = true;
        const sel = document.getElementById('selMonster');
        if (sel) {
          // value ë§¤ì¹­ â†’ ì‹¤íŒ¨ ì‹œ í…ìŠ¤íŠ¸ë¡œ ë§¤ì¹­
          let v = name;
          const byText = [...sel.options].find(o => o.textContent.trim() === name);
          if (byText) v = byText.value;

          // ê°’ë§Œ ì„¸íŒ… (ì—¬ê¸°ì„œ changeë¥¼ ë‹¤ì‹œ ì˜ë©´ ì¬ê·€ë˜ë¯€ë¡œ 'í˜¸ì¶œ ì—†ì´' ë™ê¸°í™”)
          if (sel.value !== v) sel.value = v;
        }
        __monsterApplyingDefault = false;
      }

      // 3) ìƒíƒœ ë°˜ì˜
      state.options = state.options || {};
      state.options.monster = name;

      // 4) DBì—ì„œ í–‰ ì°¾ê¸°
      const row = DBMonster.rows.find(r => String(r['ëª¬ìŠ¤í„°ëª…']).trim() === name);

      if (row) {
        state.monster = {
          level: Number(row['ëª¬ìŠ¤í„°ë ˆë²¨']) || 0,
          defRate: Number(row['ë°©ì–´ìœ¨']) || 0,
          fire: Number(row['í™”ì†ì„±ì €í•­']) || 0,
          water: Number(row['ìˆ˜ì†ì„±ì €í•­']) || 0,
          light: Number(row['ëª…ì†ì„±ì €í•­']) || 0,
          dark: Number(row['ì•”ì†ì„±ì €í•­']) || 0,
        };
      } else {
        state.monster = { level: 0, defRate: 0, fire: 0, water: 0, light: 0, dark: 0 };
      }
    }

    document.getElementById('selMonster').value

    /* ì„ íƒëœ ì‹œíŠ¸ ì•„ì´í…œ(ìŠ¤íƒ¯ ë¬¶ìŒ) ë³´ê´€ ìŠ¬ë¡¯ */
    state.options.avatarEnh = state.options.avatarEnh || null; // {name,type,img,stats...}
    state.options.imprintEnh = state.options.imprintEnh || null;
    /* ëª¬ìŠ¤í„° ì„ íƒ ê²°ê³¼ ì €ì¥ ìŠ¬ë¡¯(ì •ë³´/ì €í•­ ë“±) */
    state.monster = state.monster || null; // { name, info, stats, raw }
    // ìŠ¬ë¡¯ í‚¤ ë§¤í•‘
    const SLOT_MAP = {    //ìŠ¬ë¡¯ ì•½ì–´, ì‚¬ìš©í• ë• SLOT_MAP["L1"]; ì²˜ëŸ¼ ì”€
      L1: 'headshoulder', L2: 'top', L3: 'bottom', L4: 'belt', L5: 'shoes',
      R1: 'weapon', R2: 'bracelet', R3: 'necklace', R4: 'ring', R5: 'support',
      C1: 'aura', C2: 'title', C3: 'creature', C4: 'artifact'
    };
    window.SLOT_MAP = SLOT_MAP;   // ë¸Œë¼ìš°ì € ì „ì—­ ê°ì²´, SLOT_MAPì„ ì „ì—­ ë³€ìˆ˜ë¡œ ë“±ë¡ = ë‹¤ë¥¸ ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì´ë‚˜ ë¸Œë¼ìš°ì € ì½˜ì†”ì—ì„œë„ ì ‘ê·¼ ê°€ëŠ¥

    const ALLOWED_WEAPON_TYPES = {
      slayer: ['ì†Œê²€', 'ë„', 'ë‘”ê¸°', 'ëŒ€ê²€', 'ê´‘ê²€'],
      gunner: ['ë¦¬ë³¼ë²„', 'ìë™ê¶Œì´', 'ë¨¸ìŠ¤ì¼“', 'í•¸ë“œìºë„Œ', 'ë³´ìš°ê±´'],
      fighter: ['ë„ˆí´', 'ê±´í‹€ë¦¿', 'í´ë¡œ', 'ê¶Œíˆ¬ê¸€ëŸ¬ë¸Œ', 'í†µíŒŒ'],
      priest: ['ì‹­ìê°€', 'ì—¼ì£¼', 'í† í…œ', 'ë‚«', 'ë°°í‹€ì•¡ìŠ¤'],
      warrior: ['ë½ì†Œë“œ', 'ìœ™ë¸”ë ˆì´ë“œ'],
      mage: ['ìŠ¤íƒœí”„', 'ë¡œë“œ', 'ë´‰', 'ì°½', 'ë¹—ìë£¨'],
      spear: ['ë¯¸ëŠ˜ì°½', 'íˆ¬ì°½'],
      thief: ['ë‹¨ê²€', 'ìŒê²€', 'ì°¨í¬ë¼ì›¨í€']
    };
    // DB
    const DB = { itemsBySlot: {}, loaded: {}, chars: { loaded: false, groups: [] } };
    const DBEnh = { loaded: false, list: [], byType: {} };
    /* ===== ìœ í‹¸ ===== */
    const num = v => (v === '' || v == null ? 0 : Number(v));
    const pct = v => { if (v === '' || v == null) return 0; const s = String(v).trim().replace('%', ''); const n = Number(s); return isNaN(n) ? 0 : n / 100; };
    const list = v => (v ? String(v).replaceAll(';', ',').split(',').map(s => s.trim()).filter(Boolean) : []);
    const normalizeJobGroup = (s) => {
      s = (s || '').toLowerCase();
      if (['ë‚¨ê·€ê²€ì‚¬', 'ì—¬ê·€ê²€ì‚¬', 'ê·€ê²€ì‚¬', 'slayer'].some(k => s.includes(k))) return 'slayer';
      if (['ë§ˆë²•ì‚¬', 'ì—¬ë§ˆë²•ì‚¬', 'ë‚¨ë§ˆë²•ì‚¬', 'mage'].some(k => s.includes(k))) return 'mage';
      if (['ë‚¨ê±°ë„ˆ', 'ì—¬ê±°ë„ˆ'].some(k => s.includes(k))) return 'gunner';
      if (['ê²©íˆ¬ê°€', 'ë‚¨ê²©íˆ¬ê°€', 'ì—¬ê²©íˆ¬ê°€'].some(k => s.includes(k))) return 'fighter';
      if (['í”„ë¦¬ìŠ¤íŠ¸', 'ì—¬í”„ë¦¬ìŠ¤íŠ¸', 'ë‚¨í”„ë¦¬ìŠ¤íŠ¸'].some(k => s.includes(k))) return 'priest';
      if (['ì›Œë¦¬ì–´'].some(k => s.includes(k))) return 'warrior';
      if (['ë§ˆì°½ì‚¬'].some(k => s.includes(k))) return 'spear';
      if (['ë„ì '].some(k => s.includes(k))) return 'thief';
      return s || 'slayer';
    };
    const normalizePower = (s) => {     //ë¬¼ ì„ phys ë¡œ ë³€ê²½, ë§ˆ ë¥¼ mag ë¡œ ë³€ê²½
      s = (s || '').toLowerCase();
      if (['ë¬¼', 'phys', 'str', 'physical'].some(k => s.includes(k))) return 'phys';
      if (['ë§ˆ', 'mag', 'int', 'magic', 'ë§ˆë²•'].some(k => s.includes(k))) return 'mag';
      return null;
    };
    const powerLabel = (p) => p === 'phys' ? 'ë¬¼ë¦¬' : p === 'mag' ? 'ë§ˆë²•' : 'ë¬¼ë¦¬/ë§ˆë²•';   // phys ë¥¼ ë¬¼ë¦¬ ë¡œ ë³€ê²½, magë¥¼ ë§ˆë²•, ?(ì´ë©´), :(ì•„ë‹ˆë©´) ë”°ë¼ì„œ pê°€ phys ì´ë©´ ë¬¼ë¦¬, ì•„ë‹ˆë©´ pê°€ mag ì´ë©´ ë§ˆë²• ì•„ë‹ˆë©´ ë¬¼ë¦¬/ë§ˆë²•

    const PLACEHOLDER_IMG = 'data:image/svg+xml;utf8,' + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='10' fill='#0c0a08'/><path d='M10 48L26 30l10 12 8-8 10 14' stroke='#9cc7ff' stroke-width='4' fill='none'/></svg>");
    function cleanUrl(u) { if (!u) return ''; return String(u).replace(/^\s+|\s+$/g, '').replace(/^["']|["']$/g, '').replace(/\\/g, '/'); }

    /* ===== í–‰ â†’ ì•„ì´í…œ ë§¤í•‘ ===== */
    function mapRowToItem(r) {
      const pick = (...ks) => { for (const k of ks) { if (r[k] != null && String(r[k]).trim() !== '') return r[k]; } return ''; };  // ì´ê±´ ê·¸ëƒ¥ í—¬í¼ : ì²˜ìŒìœ¼ë¡œ ê°’ì´ ì œëŒ€ë¡œ ìˆëŠ” ì»¬ëŸ¼ ë°˜í™˜
      const skill_levels = [];    //ë ˆë²¨ë§(10), ë ˆë²¨ë (15) ê°™ì€ ì»¬ëŸ¼ ìˆìœ¼ë©´ ìˆ«ìë¡œ ë³€í™˜í•˜ì—¬ ëˆ„ì 
      [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 65, 70, 75, 80].forEach(lv => {
        const v = Number(pick(`ë ˆë²¨ë§(${lv})`));
        if (!isNaN(v) && v !== 0) skill_levels.push({ skill_id: `LV${lv}`, delta: v });
      });
      const jgs = list(pick('ì§ì—…êµ°', 'job_groups')).map(normalizeJobGroup);    // ì§ì—…êµ° í…ìŠ¤íŠ¸ë¥¼ ë°°ì—´í™” í•˜ê³  í‘œì¤€ì½”ë“œë¡œ í†µì¼ (ê·€ê²€ì‚¬, ë‚¨ê±°ë„ˆ ë“±)
      return {        // ìµœì¢… ì•„ì´í…œ ê°ì²´ ë°˜í™˜
        id: String(r.id || r.ID || Date.now().toString(36) + Math.random().toString(36).slice(2)),
        slot: 'unknown',
        name: String(pick('ì´ë¦„', 'name')),
        img: cleanUrl(pick('ì´ë¯¸ì§€', 'img')) || PLACEHOLDER_IMG,
        job_groups: jgs,
        type: String(pick('ì¢…ë¥˜', 'type')),
        rarity: r.rarity || r.ë“±ê¸‰ || 'epic',
        rarity_kr: pick('ë“±ê¸‰') || undefined,
        level: num(pick('ë ™ì œ', 'ë ˆë²¨', 'level')) || 65,
        level_text: (() => { const v = pick('ë ™ì œ', 'ë ˆë²¨', 'level'); return (v === undefined || v === null || String(v).trim() === '') ? '' : String(v).trim(); })(),
        stats: {
          phys_atk: num(pick('ë¬¼ë¦¬ ë°ë¯¸ì§€', 'ë¬¼ë¦¬ë°ë¯¸ì§€', 'phys_atk')),
          mag_atk: num(pick('ë§ˆë²• ë°ë¯¸ì§€', 'ë§ˆë²•ë°ë¯¸ì§€', 'mag_atk')),
          str: num(pick('í˜', 'str')),
          int: num(pick('ì§€ëŠ¥', 'int')),
          acc: num(pick('ì ì¤‘', 'acc')),
          phys_crit: num(pick('ë¬¼ë¦¬ í¬ë¦¬í‹°ì»¬', 'ë¬¼ë¦¬í¬ë¦¬í‹°ì»¬', 'phys_crit')),
          mag_crit: num(pick('ë§ˆë²• í¬ë¦¬í‹°ì»¬', 'ë§ˆë²•í¬ë¦¬í‹°ì»¬', 'mag_crit')),
          phys_crit_rate: pct(pick('ë¬¼ë¦¬ í¬ë¦¬í‹°ì»¬(%)', 'phys_crit_rate%')),
          mag_crit_rate: pct(pick('ë§ˆë²• í¬ë¦¬í‹°ì»¬(%)', 'mag_crit_rate%')),
          add_damage: pct(pick('ì¶”ê°€ë°ë¯¸ì§€(%)', 'add_damage%')),
          counter_add_damage: pct(pick('ì¹´ìš´í„°ë€ì¦(%)', 'counter_add_damage%')) || pct(pick('ì¹´ìš´í„°ì¶”ë€(%)')),
          str_pct: pct(pick('í˜(%)', 'str_pct%')),
          int_pct: pct(pick('ì§€ëŠ¥(%)', 'int_pct%')),
          damage_inc: pct(pick('ë€ì¦(%)', 'damage_inc%')),
          counter_damage_inc: pct(pick('ì¹´ìš´í„°ë€ì¦(%)', 'counter_damage_inc%')),
          crit_damage_inc: pct(pick('í¬ì¦ë€(%)', 'crit_damage_inc%')),
          phys_atk_pct: pct(pick('ë¬¼ë¦¬ ê³µê²©ë ¥(%)', 'ë¬¼ë¦¬ê³µê²©ë ¥(%)', 'phys_atk_pct%')),
          mag_atk_pct: pct(pick('ë§ˆë²• ê³µê²©ë ¥(%)', 'ë§ˆë²•ê³µê²©ë ¥(%)', 'mag_atk_pct%')),
          skill_atk_inc: pct(pick('ìŠ¤ì¦(%)', 'skill_atk_inc%')),
          elem: { fire: num(pick('í™”', 'elem_fire')), water: num(pick('ìˆ˜', 'elem_water')), light: num(pick('ëª…', 'elem_light')), dark: num(pick('ì•”', 'elem_dark')), all: 0 },
          elem_add_damage: {
            fire: pct(pick('í™”ì†ì¶”', 'elem_add_fire%')),
            water: pct(pick('ìˆ˜ì†ì¶”', 'elem_add_water%')),
            light: pct(pick('ëª…ì†ì¶”', 'elem_add_light%')),
            dark: pct(pick('ì•”ì†ì¶”', 'elem_add_dark%'))
          },
          speed: { attack: pct(pick('ê³µì†', 'speed_attack%')), move: pct(pick('ì´ì†', 'speed_move%')), cast: pct(pick('ìºì†', 'speed_cast%')) },
          cdr: pct(pick('ì¿¨ê°')),
          dot_add: { poison: pct(pick('ì¤‘ë…ì¶”ë€')), bleed: pct(pick('ì¶œí˜ˆì¶”ë€')), burn: pct(pick('í™”ìƒì¶”ë€')), shock: pct(pick('ê°ì „ì¶”ë€')) },
          dot_inc: { poison: pct(pick('ì¤‘ë…ë€ì¦')), bleed: pct(pick('ì¶œí˜ˆë€ì¦')), burn: pct(pick('í™”ìƒë€ì¦')), shock: pct(pick('ê°ì „ë€ì¦')) },
          other: { def_break_inc: pct(pick('ë°©ê¹ë€ì¦')), enchant_bleed: num(pick('ì¸ì±ˆì¶œí˜ˆ')) }
        },
        effects: [],
        notes: [pick('ì„¤ëª…', 'notes1'), pick('ì„¤ëª…2', 'notes2'), pick('ì„¤ëª…3', 'notes3')].filter(Boolean),
        skill_levels,
        raw: r
      };
    }

    /* ===== ê°•í™” í–‰ ë§¤í•‘ (ì´ë¯¸ì§€/íƒœê·¸/ë‹¨ê³„ ì§€ì›) ===== */
    function mapRowToEnhance(r) {
      const get = (k) => r[k] ?? r[k?.toLowerCase()] ?? '';
      const num = (v) => (v === '' || v == null ? 0 : Number(v));
      const pct = (v) => { if (v === '' || v == null) return 0; const s = String(v).trim().replace('%', ''); const n = Number(s); return isNaN(n) ? 0 : n / 100; };
      const name = String(get('ì´ë¦„') || get('ê°•í™”ëª…') || get('í‘œì‹œëª…') || '').trim();
      const type = String(get('ì¢…ë¥˜') || '').trim(); // ex) ë¶‰ì€ë¹›ì— ë¸”ë ˜ / í”Œë˜í‹°ë„˜ì— ë¸”ë ˜ / ë¬´ê¸°ê°•í™” ...
      const img = cleanUrl(get('ì´ë¯¸ì§€')) || PLACEHOLDER_IMG;
      const tag = String(get('ë ™ì œ') || '').trim();        // í”Œë˜í‹°ë„˜ ë¶„ë¥˜ìš©(í™”ì†ì„±/ìˆ˜ì†ì„±/..)
      const lvlMatch = name.match(/(\d+)\s*ë‹¨ê³„/);
      const level_num = lvlMatch ? parseInt(lvlMatch[1], 10) : null;

      const stats = {
        phys_atk: num(get('ë¬¼ë¦¬ ë°ë¯¸ì§€')) || num(get('ë¬¼ë¦¬ë°ë¯¸ì§€')),
        mag_atk: num(get('ë§ˆë²• ë°ë¯¸ì§€')) || num(get('ë§ˆë²•ë°ë¯¸ì§€')),
        str: num(get('í˜')), int: num(get('ì§€ëŠ¥')),
        phys_crit: num(get('ë¬¼ë¦¬ í¬ë¦¬í‹°ì»¬')) || num(get('ë¬¼ë¦¬í¬ë¦¬í‹°ì»¬')),
        mag_crit: num(get('ë§ˆë²• í¬ë¦¬í‹°ì»¬')) || num(get('ë§ˆë²•í¬ë¦¬í‹°ì»¬')),
        phys_crit_rate: pct(get('ë¬¼ë¦¬ í¬ë¦¬í‹°ì»¬(%)')),
        mag_crit_rate: pct(get('ë§ˆë²• í¬ë¦¬í‹°ì»¬(%)')),
        add_damage: pct(get('ì¶”ê°€ë°ë¯¸ì§€(%)')),
        str_pct: pct(get('í˜(%)')), int_pct: pct(get('ì§€ëŠ¥(%)')),
        damage_inc: pct(get('ë€ì¦(%)')),
        crit_damage_inc: pct(get('í¬ì¦ë€(%)')),
        phys_atk_pct: pct(get('ë¬¼ë¦¬ ê³µê²©ë ¥(%)')) || pct(get('ë¬¼ë¦¬ê³µê²©ë ¥(%)')),
        mag_atk_pct: pct(get('ë§ˆë²• ê³µê²©ë ¥(%)')) || pct(get('ë§ˆë²•ê³µê²©ë ¥(%)')),
        skill_atk_inc: pct(get('ìŠ¤ì¦(%)')),
        elem: { fire: num(get('í™”')), water: num(get('ìˆ˜')), light: num(get('ëª…')), dark: num(get('ì•”')), all: 0 },
        cdr: pct(get('ì¿¨ê°')),
        speed: { attack: pct(get('ê³µì†')), move: pct(get('ì´ì†')), cast: pct(get('ìºì†')) },
        other: { def_break_inc: pct(get('ë°©ê¹ë€ì¦')) }
      };
      return { name, type, img, tag, level_num, stats };
    }

    (function () {
      function _getTimeWindowSec() {
        // ë“œë¡­ë‹¤ìš´(#selTime)ì˜ ê°’: "30s" | "1m" | "3m" | "5m" | "10m"
        const el = document.getElementById('selTime');
        const v = (el && el.value) ? el.value : '1m'; // ê¸°ë³¸ 1ë¶„
        const n = Number(v.slice(0, -1));             // ì•ì˜ ìˆ«ì
        return v.endsWith('s') ? n : n * 60;           // sâ†’ì´ˆ, mâ†’ë¶„*60
      }

      // â˜… ì „ì—­ì— ë³´ì¦ (module ìŠ¤ì½”í”„/ì¤‘ë³µ ë¡œë“œ ëŒ€ë¹„)
      if (!window.getTimeWindowSec) window.getTimeWindowSec = _getTimeWindowSec;
    })();

    /* ===== ì‹œíŠ¸ ë¡œë” ===== */
    async function loadSheet(slotKey) {
      if (DB.loaded[slotKey]) return;

      const token = await waitForIdToken();
      const r = await fetch(window.WEBAPP_URL + '?type=' + slotKey, {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error(`${slotKey}_fetch_failed`);
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error(`bad_${slotKey}_payload`);

      // rows(ì‹œíŠ¸ ì›ë¬¸ í–‰ ê°ì²´) â†’ í”„ë¡ íŠ¸ ë‚´ë¶€ ì•„ì´í…œ êµ¬ì¡°ë¡œ ë§¤í•‘
      const items = data.rows.map(mapRowToItem).map(it => ({ ...it, slot: slotKey }));
      DB.itemsBySlot[slotKey] = items;
      DB.loaded[slotKey] = true;
      console.log(`[Sheets->API] ${slotKey} loaded:`, items.length);
    }
    const __slotState = {};  // ì „ì—­ì— ì„ ì–¸

    async function ensureLoaded(slotKey) {
      const st = (__slotState[slotKey] ||= { loaded: false, inflight: null });

      if (st.loaded) return;             // ì´ë¯¸ ëë‚¬ìœ¼ë©´ ë°”ë¡œ ë¦¬í„´
      if (st.inflight) return st.inflight; // ì§„í–‰ ì¤‘ì´ë©´ ê°™ì€ Promise ë°˜í™˜

      st.inflight = (async () => {
        await loadSheet(slotKey);
        st.loaded = true;
        st.inflight = null;
      })();

      return st.inflight;
    }


    /* ê°•í™”/ì— ë¸”ë ˜ ì‹œíŠ¸ ë¡œë” */
    // ê°•í™”/ì— ë¸”ë ˜ ì‹œíŠ¸ ë¡œë” (ë°±ì—”ë“œ JSON ë²„ì „)
    async function ensureEnhLoaded() {
      if (DBEnh.loaded) return;

      const token = await waitForIdToken();
      const r = await fetch(window.WEBAPP_URL + '?type=enhance', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('enhance_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_enhance_payload');

      const rows = data.rows.map(mapRowToEnhance).filter(x => (x.name && x.type));
      DBEnh.list = rows;
      DBEnh.byType = rows.reduce((acc, x) => { (acc[x.type] ||= []).push(x); return acc; }, {});
      DBEnh.loaded = true;
      console.log('[Enhance->API] loaded:', rows.length);

      // â–¼ ì„±ì•ˆì˜ ë´‰ì¸: ê¸°ë³¸ê°’ ì£¼ì… (ì´ë¯¸ ì„ íƒë¼ ìˆìœ¼ë©´ ê±´ë„ˆëœ€)
      try {
        const mainList = DBEnh.byType?.['ì£¼ìš” ì˜µì…˜'] || [];
        const subList = DBEnh.byType?.['ì¶”ê°€ ì˜µì…˜'] || [];
        if (!state.castleSeal) state.castleSeal = { main: null, sub: null };
        if (!state.castleSeal.main && mainList.length) {
          const m = mainList.find(x => x.name === 'í˜,ì§€ëŠ¥ +170') || mainList[0];
          state.castleSeal.main = { name: m.name, stats: m.stats, raw: m.raw || m };
        }
        if (!state.castleSeal.sub && subList.length) {
          const s = subList.find(x => x.name === 'í˜,ì§€ëŠ¥ +224') || subList[0];
          state.castleSeal.sub = { name: s.name, stats: s.stats, raw: s.raw || s };
        }
      } catch (e) { console.warn('[SEAL:init@ensureEnhLoaded] skip:', e); }
    }



    //ëª¬ìŠ¤í„° ì‹œíŠ¸ ë¡œë”
    let DBMonster = { loaded: false, rows: [] };
    async function ensureMonsterLoaded() {
      if (DBMonster.loaded) return;
      const token = await waitForIdToken(); // ì´ë¯¸ ë„¤ ì½”ë“œì— ìˆìŒ (ë‹¤ë¥¸ ì‹œíŠ¸ ë¡œë”ì—ì„œ ì‚¬ìš©)
      const r = await fetch(window.WEBAPP_URL + '?type=monster', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('monster_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_monster_payload');
      // ë°±ì—”ë“œê°€ "í—¤ë”ëª…ì„ í‚¤ë¡œ í•œ ê°ì²´"ë¥¼ ê·¸ëŒ€ë¡œ ë‚´ë ¤ì£¼ë¯€ë¡œ ì¶”ê°€ ë§¤í•‘ ë¶ˆí•„ìš”
      DBMonster.rows = data.rows;
      DBMonster.loaded = true;
      console.log('[Monster->API] loaded:', DBMonster.rows.length);
    }

    // ===== ì„¸íŠ¸ ì‹œíŠ¸ ë¡œë”/ìºì‹œ =====
    const DBSet = { loaded: false, list: [], byType: {} };

    // ì„¸íŠ¸ ì‹œíŠ¸ëŠ” 'ê°•í™”' ë§¤í•‘ê³¼ ì»¬ëŸ¼ êµ¬ì„±ì´ ë™ì¼í•˜ë‹¤ê³  ê°€ì •:
    // => íŒŒì‹± ë¡œì§ì„ ì¬ì‚¬ìš©í•©ë‹ˆë‹¤.
    function mapRowToSet(r) {
      // ê¸°ë³¸ íŒŒì‹±
      const base = mapRowToEnhance(r);

      // â–¶ ì„¸íŠ¸ ì „ìš©: type ê°•ì œ ë³´ì • (ì¢…ë¥˜ê°€ ë¹„ì–´ ìˆê±°ë‚˜ í—¤ë”ëª…ì´ ë‹¤ë¥¼ ë•Œ ëŒ€ë¹„)
      const get = (k) => r[k] ?? r[k?.toLowerCase()] ?? '';
      const rawType =
        (get('ì¢…ë¥˜') || get('ì„¸íŠ¸') || get('ë¶„ë¥˜') || get('íƒ€ì…') || get('ìœ í˜•') ||
          get('type') || get('Type') || get('ì´ë¦„') || '').toString().trim();

      // ì´ë¦„ë§Œ ìˆê³  ì¢…ë¥˜ê°€ ë¹„ì—ˆì„ ê°€ëŠ¥ì„±ê¹Œì§€ ì»¤ë²„
      base.type = rawType;

      return base;
    }

    async function ensureSetLoaded() {
      if (DBSet.loaded) return;
      const token = await waitForIdToken();
      const r = await fetch(window.WEBAPP_URL + '?type=set', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('set_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_set_payload');

      const rows = data.rows.map(mapRowToSet).filter(x => (x?.name && x?.type));
      DBSet.list = rows;
      DBSet.byType = rows.reduce((acc, x) => {
        const k = String(x.type || '').trim();
        (acc[k] ||= []).push(x);
        return acc;
      }, {});
      DBSet.loaded = true;
      console.log('[Set->API] loaded:', rows.length);
    }

    // ===== ì˜ˆì™¸ê·œì¹™ ë¡œë”/ìºì‹œ =====
    const DBException = { loaded: false, rows: [], byItem: {}, skillIdByName: {} };

    function normalizeType(s) {
      const t = String(s || '').trim().toLowerCase();
      // í‘œì˜ 'ìœ í˜•' ê°’ ì •ê·œí™”: ìŠ¤í‚¬ë ˆë²¨ / tpë ˆë²¨ / ë°ë¯¸ì§€ì¦ê°€ / ì¿¨íƒ€ì„ê°ì†Œ
      if (t.includes('tp')) return 'tpë ˆë²¨';
      // â˜… ë¨¼ì € ê³ ì •ê°ì†Œë¶€í„° ìºì¹˜ (ì¿¨/ê³ ì •/ê°ì†Œ í‚¤ì›Œë“œ)
      if ((t.includes('ì¿¨') || t.includes('cool')) && t.includes('ê³ ì •') && (t.includes('ê°ì†Œ') || t.includes('down')))
        return 'ì¿¨íƒ€ì„ê³ ì •ê°ì†Œ';
      if (t.includes('ë²„í”„') && t.includes('ë ˆë²¨')) return 'ë²„í”„ë ˆë²¨';
      if (t.includes('cool') || t.includes('ì¿¨')) return 'ì¿¨íƒ€ì„ê°ì†Œ';
      if (t.includes('ë°ë¯¸') || t === 'dmg' || t === 'damage') return 'ë°ë¯¸ì§€ì¦ê°€';
      if (t.includes('ë ˆë²¨')) return 'ìŠ¤í‚¬ë ˆë²¨';
      // â˜… ì¶”ê°€: ì¿¨ì´ˆí™•ë¥ 
      if (t.includes('ë¦¬ì…‹') || t.includes('ì´ˆê¸°í™”') || t.includes('ì¿¨ì´ˆ')) return 'ì¿¨ì´ˆí™•ë¥ ';
      return t;
    }
    function mapRowToException(r) {
      return {
        type: normalizeType(r['ìœ í˜•']),
        item: String(r['ì•„ì´í…œëª…'] || '').trim(),
        skillName: String(r['ì ìš©ìŠ¤í‚¬ëª…'] || '').trim(),
        value: toNum(r['ì˜µì…˜ìˆ˜ì¹˜'])
      };
    }

    async function ensureExceptionLoaded() {
      if (DBException.loaded) return;
      const token = await waitForIdToken();
      if (!token) { console.warn('[EXC] skip: no idToken yet'); return; }

      const r = await fetch(WEBAPP_URL + '?type=exception', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      const js = await r.json();
      if (!js?.ok) { console.warn('[EXC] load failed:', js); DBException.loaded = true; return; }

      DBException.rows = (js.rows || []).map(mapRowToException);
      DBException.byItem = {};
      DBException.rows.forEach(row => {
        const key = row.item; if (!key) return;
        (DBException.byItem[key] ||= []).push(row);
      });
      DBException.skillIdByName = {};
      DBException.loaded = true;
      console.log('[EXC] rows loaded =', DBException.rows.length);
      console.log('[EXC] sample rows =',
        DBException.rows.slice(0, 10).map(r => `${r.item} | ${r.type} | ${r.skillName} : ${r.value}`));
    }

    // ìŠ¤í‚¬ ì‹œíŠ¸(ST2.rows)ê°€ ì¤€ë¹„ëœ ë’¤, ìŠ¤í‚¬ëª… â†’ id ë§¤í•‘ êµ¬ì„±
    function refreshExceptionSkillIdMap() {
      if (!ST2?.loaded || !(ST2.rows?.length)) return;
      DBException.skillIdByName = {};
      ST2.rows.forEach(s => {
        const name = String(s?.name || '').trim();
        if (!name) return;
        DBException.skillIdByName[name] = s.id;  // ì´ë¦„ì´ ìœ ì¼í•˜ë‹¤ëŠ” ê°€ì • (ë™ëª…ì´ì¸ ì¡´ì¬ì‹œ ìš°ì„  ì¼ì¹˜ ì²« í•­ëª©)
      });
    }

    // í˜„ì¬ ì°©ìš© ì•„ì´í…œëª… ë°°ì—´
    function equippedItemNames() {
      return Object.values(state.selections || {}).map(it => String(it?.name || '').trim()).filter(Boolean);
    }

    // í™œì„± ì˜ˆì™¸íš¨ê³¼ ì§‘ê³„(ìŠ¤í‚¬ID í‚¤ ê¸°ì¤€)
    function collectActiveExceptionMaps() {
      const items = equippedItemNames();  // ì°©ìš© ì¤‘ ì•„ì´í…œ ì´ë¦„ ë°°ì—´
      const addLv = {};       // {skillId: +ë ˆë²¨}
      const addTp = {};       // {skillId: +tpë ˆë²¨}
      const addDmgPct = {};   // {skillId: +ë°ë¯¸ì§€ì¦ê°€%}
      const addCdPct = {};    // {skillId: +ì¿¨ê°%}  // ê°ì†Œìœ¨(%) ê·¸ëŒ€ë¡œ ì €ì¥
      const resetPct = {};    // ì¿¨ì´ˆ
      // â˜… ì¶”ê°€: ë²„í”„ë ˆë²¨ (ë²„í”„ "ì´ë¦„" ê¸°ì¤€)
      const buffLvByName = {};  // {'ë²„í”„ëª…': +ë ˆë²¨}
      // â˜… ì¶”ê°€: ê³ ì • ì¿¨ê°(ì´ˆ)
      const addCdFlat = {};   // { skillId: secondsToReduce }

      // ì´ë¦„ ì •ê·œí™”(ê³µë°±/ì œë¡œí­ ì œê±° ì •ë„ë§Œ)
      const normName = s => String(s ?? '')
        .normalize('NFC')
        .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
        .replace(/\s+/g, '');

      for (const nm of items) {
        const list = DBException.byItem[nm] || [];
        for (const r of list) {
          // 1) 'ë²„í”„ë ˆë²¨'ì€ ìŠ¤í‚¬ID ì—†ì´ "ë²„í”„ ì´ë¦„"ìœ¼ë¡œ í•©ì‚°
          if (r.type === 'ë²„í”„ë ˆë²¨') {
            const key = normName(r.skillName);
            if (key) buffLvByName[key] = (buffLvByName[key] || 0) + Number(r.value || 0);
            continue; // â˜… ì´ë¯¸ ì²˜ë¦¬í–ˆìœ¼ë‹ˆ ë‹¤ìŒ ê·œì¹™ìœ¼ë¡œ
          }
          const id = DBException.skillIdByName[r.skillName];
          if (!id) continue;
          switch (r.type) {
            case 'ìŠ¤í‚¬ë ˆë²¨':
              addLv[id] = (addLv[id] || 0) + r.value;
              break;
            case 'tpë ˆë²¨':
              addTp[id] = (addTp[id] || 0) + r.value;
              break;
            case 'ë°ë¯¸ì§€ì¦ê°€':
              addDmgPct[id] = (addDmgPct[id] || 0) + r.value;
              break;
            case 'ì¿¨íƒ€ì„ê°ì†Œ':
              addCdPct[id] = (addCdPct[id] || 0) + r.value;
              break;
            // â˜… ì¶”ê°€: ì¿¨ì´ˆí™•ë¥ (%) í•©ì‚°
            case 'ì¿¨ì´ˆí™•ë¥ ': resetPct[id] = (resetPct[id] || 0) + r.value; break;
            // â˜… ì‹ ê·œ: ì¿¨íƒ€ì„ê³ ì •ê°ì†Œ(ì´ˆ)
            case 'ì¿¨íƒ€ì„ê³ ì •ê°ì†Œ': addCdFlat[id] = (addCdFlat[id] || 0) + Number(r.value || 0); break;
          }
        }
      }
      console.log('[EXC] equipped items =', equippedItemNames());
      console.log('[EXC] addLv:', addLv, 'addTp:', addTp, 'addDmgPct:', addDmgPct, 'addCdPct:', addCdPct);
      console.log('[EXC] buffLvByName:', buffLvByName);   // â˜… ë²„í”„ë ˆë²¨ í•µì‹¬
      return { addLv, addTp, addDmgPct, addCdPct, resetPct, buffLvByName, addCdFlat };
    }

    // ì „ì—­ ë³´ê´€(í”„ë ˆì„ ê³„ì‚°/ë°ë¯¸ì§€ ìºì‹œì— í™œìš©)
    let __EXC = { addLv: {}, addTp: {}, addDmgPct: {}, addCdPct: {}, resetPct: {}, buffLvByName: {}, addCdFlat: {} };
    function refreshActiveExceptions() {
      __EXC = collectActiveExceptionMaps();
    }

    /* ===== ì„±ì•ˆì˜ ë´‰ì¸ ===== */
    const $sealModal = document.getElementById('castleSealModal');
    const $sealMainList = document.getElementById('sealMainList');
    const $sealSubList = document.getElementById('sealSubList');
    let __sealPick = { main: null, sub: null };

    function showSealModal(on) {
      if (!$sealModal) return;
      if (on) { $sealModal.classList.add('show'); $sealModal.setAttribute('aria-hidden', 'false'); }
      else { $sealModal.classList.remove('show'); $sealModal.setAttribute('aria-hidden', 'true'); }
    }
    $sealModal?.addEventListener('click', (e) => {
      if (e.target.dataset.close != null || e.target.classList.contains('backdrop')) showSealModal(false);
    });

    document.getElementById('btnCastleSeal')?.addEventListener('click', openCastleSealModal);
    document.getElementById('sealCommit')?.addEventListener('click', commitCastleSealSelection);

    async function openCastleSealModal() {
      // ê°•í™”/ë§ˆë´‰/ë§ˆë¶€ ì‹œíŠ¸ ë¡œë“œ(ì—°ë§ˆì—ì„œ ì“°ë˜ ìºì‹œ ì¬ì‚¬ìš©)
      if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

      // ì‹œíŠ¸ì—ì„œ ì¢…ë¥˜ë³„ë¡œ ë¶„ë¦¬
      const mainList = (DBEnh?.byType?.['ì£¼ìš” ì˜µì…˜'] || (DBEnh?.list || []).filter(o => (o?.type || '') === 'ì£¼ìš” ì˜µì…˜'));
      const subList = (DBEnh?.byType?.['ì¶”ê°€ ì˜µì…˜'] || (DBEnh?.list || []).filter(o => (o?.type || '') === 'ì¶”ê°€ ì˜µì…˜'));

      // í˜„ì¬ ì„ íƒ ë³µêµ¬
      __sealPick = {
        main: state.castleSeal?.main || null,
        sub: state.castleSeal?.sub || null
      };

      fillSealList($sealMainList, mainList, 'main');
      fillSealList($sealSubList, subList, 'sub');

      showSealModal(true);
    }

    function fillSealList(host, list, which) {
      host.innerHTML = '';
      list.forEach(row => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'opt-row';
        b.innerHTML = `
      <div class="name">${row.name || '(ì´ë¦„ì—†ìŒ)'}</div>
      ${row.uiText ? `<div class="desc">${row.uiText}</div>` : ''}`;
        if (__sealPick[which]?.name === row.name) b.classList.add('active');
        b.addEventListener('click', () => {
          __sealPick[which] = row;
          host.querySelectorAll('.opt-row').forEach(x => x.classList.remove('active'));
          b.classList.add('active');
        });
        host.appendChild(b);
      });
    }

    function commitCastleSealSelection() {
      // stateì— ì €ì¥(í•©ì‚°ì€ sumSelectionsì—ì„œ addStats ê·œì¹™ìœ¼ë¡œ ë”í•¨)
      state.castleSeal = {
        main: __sealPick.main ? { name: __sealPick.main.name, stats: __sealPick.main.stats, raw: __sealPick.main.raw } : null,
        sub: __sealPick.sub ? { name: __sealPick.sub.name, stats: __sealPick.sub.stats, raw: __sealPick.sub.raw } : null
      };
      showSealModal(false);
      if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
    }


    /* ===== ë£¬ ê°ì¸ ë“œë¡­ë‹¤ìš´(ì‹œíŠ¸ ì—°ë™) ===== */

    // ì‹œíŠ¸ì—ì„œ 'ë£¬ê°ì¸'ë§Œ ì¶”ë¦¬ê¸° (byType ìš°ì„ , ì—†ìœ¼ë©´ filter)
    function getRuneEngraveRows() {
      const base = (DBEnh?.byType?.['ë£¬ê°ì¸']) || (DBEnh?.list || []).filter(x => x.type === 'ë£¬ê°ì¸');
      return base || [];
    }

    // ì´ë¦„ ëª©ë¡(ì¤‘ë³µ ì œê±°, â€œì‹œíŠ¸ ìˆœì„œ ìœ ì§€â€)
    async function buildRuneEngraveNameOptions() {
      await ensureEnhLoaded();
      const rows = getRuneEngraveRows();
      const seen = new Set(); const names = [];
      rows.forEach(r => { const k = (r.name || '').trim(); if (k && !seen.has(k)) { seen.add(k); names.push(k); } });
      const sel1 = document.getElementById('selRuneEngrave');
      if (!sel1) return;
      sel1.innerHTML = `<option value="" selected disabled>ë£¬ ê°ì¸ ì„¤ì •</option>`;
      names.forEach(n => {
        const op = document.createElement('option'); op.value = n; op.textContent = n; sel1.appendChild(op);
      });
      // ì´ì „ ì„ íƒ ë³µêµ¬ê°€ í•„ìš”í•˜ë©´ ì—¬ê¸°ì„œ sel1.value = ... í›„ detail ì±„ìš°ê¸°
    }

    // ì„¸ë¶€ ì„¤ì •(ë ™ì œ) ì˜µì…˜ ì±„ìš°ê¸° â€” ì´ë¦„ê³¼ ì¢…ë¥˜=ë£¬ê°ì¸ ì¼ì¹˜ í–‰ë“¤ì˜ tag(ë ™ì œ)ë§Œ
    async function populateRuneDetailOptions(name) {
      await ensureEnhLoaded();
      const sel2 = document.getElementById('selRuneDetail');
      if (!sel2) return;

      sel2.disabled = true;
      sel2.innerHTML = `<option value="" selected disabled>ì„¸ë¶€ ì„¤ì •</option>`;

      if (!name) return;
      const rows = getRuneEngraveRows().filter(r => (r.name || '').trim() === String(name).trim());
      // ì¤‘ë³µ ì œê±°(ì‹œíŠ¸ ìˆœì„œ ìœ ì§€)
      const seenTag = new Set();
      rows.forEach(r => {
        const t = (r.tag || '').trim(); if (!t) return;
        if (!seenTag.has(t)) { seenTag.add(t); const op = document.createElement('option'); op.value = t; op.textContent = t; sel2.appendChild(op); }
      });
      sel2.disabled = false;
    }

    // (ì´ë¦„, tag)ë¡œ ì •í™•íˆ 1í–‰ ë§¤ì¹­í•˜ì—¬ í•©ì‚°ì— ë°˜ì˜
    function applyRuneEngraveByNameTag(name, tag) {
      const rows = getRuneEngraveRows();
      const row = rows.find(r => (r.name || '').trim() === String(name).trim() && (r.tag || '').trim() === String(tag).trim()) || null;
      state.runeEngrave = row ? { name: row.name, tag: row.tag, stats: row.stats } : null;
      recalcAndRenderPanel();
    }
    /* ENHANCE_SHEETì—ì„œ 'ì´ë¦„' ì •í™• ì¼ì¹˜ë¡œ 1ê°œ ì°¾ê¸° */
    function findEnhByExactName(name) {
      if (!name) return null;
      const list = DBEnh?.list || [];
      const key = String(name).trim();
      return list.find(x => (x?.name || '').trim() === key) || null;
    }

    /* ì•„ë°”íƒ€/ë¬´ê¸°ì•• ì„ íƒ â†’ ì‹œíŠ¸ì—ì„œ ì°¾ì•„ ìƒíƒœì— ë³´ê´€ â†’ í•©ì‚° ê°±ì‹  */
    async function applyAvatarEnhFromState() {
      await ensureEnhLoaded();
      const name = AVATAR_NAME[state.options.avatar] || null;
      state.options.avatarEnh = name ? findEnhByExactName(name) : null;
      recalcAndRenderPanel();
    }
    async function applyImprintEnhFromState() {
      await ensureEnhLoaded();
      const name = IMPRINT_NAME[state.options.weaponImprint] || null;
      state.options.imprintEnh = name ? findEnhByExactName(name) : null;
      recalcAndRenderPanel();
    }
    /* ===== ìºë¦­í„° ì‹œíŠ¸ ë¡œë” ===== */
    const characterCard = document.getElementById('characterCard');
    const characterImg = document.getElementById('characterImg');
    const characterGhost = document.getElementById('characterGhost');
    const charModal = document.getElementById('charModal');
    const catalogEl = document.getElementById('catalog'); /*<div id="catalog" class="catalog"></div> ë¥¼ JSë³€ìˆ˜ catalogElë¡œ ì°¸ì¡°*/
    const DBChars = { loaded: false, groups: [] }; //ì „ì—­ ìºì‹œ ê°ì²´, í•œë²ˆ ë¡œë“œë˜ë©´ ë‹¤ì‹œ ì•ˆë¶ˆëŸ¬ì˜¤ê²Œí•¨, loaded : ì‹œíŠ¸ê°€ ì´ë¯¸ ë¡œë“œëëŠ”ì§€, groups : í™”ë©´ì— ë¿Œë¦´ ìµœì¢… ë°ì´í„°(ê·¸ë£¹ë°°ì—´)

    // ë¡œê·¸ì¸ í† í°ì´ ì¤€ë¹„ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ìœ í‹¸ (ìµœëŒ€ 15ì´ˆ)
    async function waitForIdToken(timeout = 15000) {
      if (window.idToken) return window.idToken;
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          document.removeEventListener('gsi:issued', onReady);
          reject(new Error('login_timeout'));
        }, timeout);
        function onReady() {
          if (window.idToken) {
            clearTimeout(timer);
            document.removeEventListener('gsi:issued', onReady);
            resolve(window.idToken);
          }
        }
        document.addEventListener('gsi:issued', onReady);
      });
    }


    // ===== ìºë¦­í„° ì‹œíŠ¸ ë¡œë” (ë°±ì—”ë“œ JSON ë²„ì „) =====
    async function loadCharacterSheet() {
      if (DBChars.loaded) return;

      // â¬‡ ì¶”ê°€: ë¡œê·¸ì¸ ì™„ë£Œê¹Œì§€ ëŒ€ê¸°í•˜ê³  í† í° í™•ë³´
      const token = await waitForIdToken();

      try {
        // í”„ë¡ì‹œ â†’ ë°±ì—”ë“œ í˜¸ì¶œ: ?type=char
        const r = await fetch(window.WEBAPP_URL + '?type=char', {
          method: 'POST',
          mode: 'cors',
          cache: 'no-store',
          headers: { 'Content-Type': 'text/plain' },
          body: token                    // â¬… ì „ì—­ idToken ëŒ€ì‹  ì§€ì—­ token ì‚¬ìš©
        });
        if (!r.ok) throw new Error("char_load_failed");
        const data = await r.json();
        if (!data.ok || !Array.isArray(data.rows)) throw new Error("bad_char_payload");

        // rows: [{jobGroup, name, thumb, full, spTotal?, tpTotal?}]
        const groupsMap = new Map();

        data.rows.forEach(row => {
          const groupTitle = (row.jobGroup || '').trim();
          const name = (row.name || '').trim();
          if (!groupTitle || !name) return;

          const badge = cleanUrl(row.badge || '');  // â¬… ì¢…ë¥˜ ì»¬ëŸ¼(ë±ƒì§€)
          const thumb = cleanUrl(row.thumb || '');  // â¬… ë ™ì œ ì»¬ëŸ¼(ì¹´ë“œ)
          const full = cleanUrl(row.full || '');  // â¬… ì´ë¯¸ì§€(ì„ íƒ í›„)

          if (!groupsMap.has(groupTitle)) {
            groupsMap.set(groupTitle, { badgeSrc: badge, items: [] });
          }
          const g = groupsMap.get(groupTitle);
          if (!g.badgeSrc && badge) g.badgeSrc = badge; // ì²« ìœ íš¨ê°’ ê³ ì •(í˜¹ì‹œ í–‰ë§ˆë‹¤ ë‹¬ë¼ë„ ì²«ê°’ ì‚¬ìš©)

          g.items.push({
            name,
            thumbSrc: thumb,
            fullSrc: full,
            power: row.power || 'phys',
            spTotal: Number(row.spTotal ?? 0) || 0,  // ğŸ‘ˆ ì¶”ê°€
            tpTotal: Number(row.tpTotal ?? 35) || 35 // ğŸ‘ˆ ì¶”ê°€
          });
        });

        // Map â†’ ë°°ì—´ (ë±ƒì§€ í¬í•¨)
        DBChars.groups = Array.from(groupsMap.entries()).map(([title, g]) => ({
          title,
          badgeSrc: g.badgeSrc,   // â¬… í”„ë¡ íŠ¸ ë Œë”ì—ì„œ group.badgeSrc ì‚¬ìš©
          items: g.items
        }));
        DBChars.loaded = true;
      } catch (e) {
        console.error("[CHAR] ë¡œë“œ ì‹¤íŒ¨:", e);
        throw e;
      }
    }


    async function ensureCharactersLoaded() {   //í•„ìš” í• ë•Œë§Œ loadCharactersheet() í˜¸ì¶œ
      await waitForIdToken();
      if (!DBChars.loaded) await loadCharacterSheet();
    }

    /*ì‹¤ì œ ìºë¦­í„° ì„ íƒì°½ ë‚´ìš©ì„ ì±„ìš°ëŠ” ë¡œì§*/
    function renderCatalog() {
      catalogEl.innerHTML = '';   /*catalog ì˜ì—­ ì•ˆì— ìˆëŠ” HTML ëª¨ë‘ ì§€ì›€ = ìƒˆë¡œìš´ ëª©ë¡ ê·¸ë¦¬ê¸° ì „ì— í•­ìƒ ê¸°ì¡´ ë‚´ìš© ì´ˆê¸°í™”*/
      const groups = DBChars.groups || [];    /*DBChars.groups ë¼ëŠ” ë°°ì—´ ê°€ì ¸ì˜´, ì—†ìœ¼ë©´ [](ë¹ˆë°°ì—´) ì‚¬ìš©*/
      if (!groups.length) {   /*ìœ„ groupsì˜ ë°°ì—´ ê¸¸ì´ê°€ 0ì´ë©´ = ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì•„ë˜ì½”ë“œ ì‹¤í–‰*/
        const msg = document.createElement('div');    /* ìƒˆë¡œìš´ <div> ìš”ì†Œ ë§Œë“¬*/
        msg.style.color = '#c7b589';    /*ê¸€ììƒ‰ ë² ì´ì§€ìƒ‰*/
        msg.textContent = 'ì‹œíŠ¸ì—ì„œ ìºë¦­í„° ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';   /*í…ìŠ¤íŠ¸ ì¶œë ¥*/
        catalogEl.appendChild(msg); /*ë§Œë“  ë©”ì‹œì§€ë¥¼ catalog ì˜ì—­ì— ì¶”ê°€, appendChildëŠ” ìì‹ ìš”ì†Œë¡œ ë§¨ ë’¤ì— ë¶™ì¸ë‹¤ ëŠ” ë©”ì„œë“œ, ì¦‰, catalogEl(ë¶€ëª¨)ì— msg(ìì‹)ì„ ë„£ëŠ”ê²ƒ*/
        return;
      }
      groups.forEach(group => {   /*groups ë°°ì—´ì„ ëŒë©´ì„œ ê° ê·¸ë£¹(ë‚¨ê·€ê²€ì‚¬, ì—¬ë§ˆë²•ì‚¬ ë“±)ì— ëŒ€í•´ <div clas="row" í•˜ë‚˜ ë§Œë“ ë‹¤*/
        const row = document.createElement('div'); row.className = 'row';
        const left = document.createElement('img'); left.className = 'badge-img'; left.src = group.badgeSrc || PLACEHOLDER_IMG; left.alt = 'ë°°ì§€';    /*row ì™¼ìª½ì—” ë°°ì§€ ì´ë¯¸ì§€ ë„£ëŠ”ë‹¤*/
        left.onerror = () => { left.src = PLACEHOLDER_IMG; };
        const cards = document.createElement('div'); cards.className = 'cards';  /*ìºë¦­í„° ì¹´ë“œë“¤ì„ ë‹´ëŠ” <div clas="cards">*/
        group.items.forEach(item => {   /*group.items ë°°ì—´ ì•ˆì˜ ìºë¦­í„°ë¥¼ ëŒë©´ì„œ ìºë¦­í„° ì¹´ë“œ ë²„íŠ¼ì„ ë§Œë“¦*/
          const card = document.createElement('button'); card.className = 'char-card';
          const img = document.createElement('img'); img.className = 'char-img'; img.alt = item.name; img.src = item.thumbSrc || PLACEHOLDER_IMG;
          img.onerror = () => { img.src = PLACEHOLDER_IMG; };
          const name = document.createElement('div'); name.className = 'char-name'; name.textContent = item.name;
          card.appendChild(img); card.appendChild(name);
          card.addEventListener('click', () => {    /*ì´ ì¹´ë“œ ë²„íŠ¼ í´ë¦­í•˜ë©´ applyCharacter() í•¨ìˆ˜ ì‹¤í–‰ë˜ì–´ ìºë¦­í„° ì •ë³´ ë„˜ê¹€*/
            applyCharacter({
              src: item.fullSrc || PLACEHOLDER_IMG,
              jobGroup: normalizeJobGroup(group.title),
              jobGroupLabel: group.title,
              name: item.name,
              power: item.power,
              spTotal: item.spTotal,   // ğŸ‘ˆ ì¶”ê°€
              tpTotal: item.tpTotal    // ğŸ‘ˆ ì¶”ê°€
            });
            closeCharacterPicker(); /*ëª¨ë‹¬ ë‹«ê¸°*/
          });
          cards.appendChild(card);    //ë§Œë“  ìºë¦­í„° ì¹´ë“œë“¤ì„ cards ì»¨í…Œì´ë„ˆì— ì¶”ê°€
        });
        const right = document.createElement('div'); right.textContent = 'âœ¶'; right.style.opacity = '.3'; right.style.textAlign = 'center';
        right.style.color = '#d8c088';    // row ì˜¤ë¥¸ìª½ì— ì¥ì‹ìš© ë³„í‘œ í•˜ë‚˜ë¥¼ ë°°ì¹˜
        row.appendChild(left); row.appendChild(cards); //row.appendChild(right);
        catalogEl.appendChild(row);   //ìµœì¢…ì ìœ¼ë¡œ í•œì¤„(row) ì•ˆì—, ì™¼ìª½(left) ë°°ì§€ ì´ë¯¸ì§€, ê°€ìš´ë°(cards) ìºë¦­í„° ì¹´ë“œ ëª©ë¡, ì˜¤ë¥¸ìª½(right) ë³„í‘œ ë¥¼ ë„£ê³  ì™„ì„±ëœ rowë¥¼ catalogì— ì¶”ê°€.
      });
    }
    async function openCharacterPicker() {    // ëª¨ë‹¬ ì—´ë•Œ ì”€
      await ensureCharactersLoaded();    // ì‹œíŠ¸ ë°ì´í„°ë¥¼ ì•„ì§ ì•ˆë°›ì•˜ë‹¤ë©´ ë°›ì•„ì˜¬ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
      renderCatalog();   // ë¡œë“œëœ ë°ì´í„°ë¡œ ì¹´íƒˆë¡œê·¸ ê·¸ë¦¬ê¸°
      charModal.classList.add('show');   //ëª¨ë‹¬ì— show í´ë˜ìŠ¤ ì¶”ê°€ - í™”ë©´ì— ë³´ì´ê²Œ, ë³´í†µ .modal.show {display:block;} ê°™ì´ ì œì–´
      charModal.setAttribute('aria-hidden', 'false');    // ìŠ¤í¬ë¦°ë¦¬ë”ì— 'ë³´ì´ëŠ” ìƒíƒœ' ì•Œë¦¼, ëª¨ë‹¬ì—´ë¦´ë•Œ false, ëª¨ë‹¬ ë‹«íë•Œ true.
    }
    function closeCharacterPicker() {   // ëª¨ë‹¬ ë‹«ì„ ë•Œ ì”€
      charModal.classList.remove('show');   // show ì œê±° - ìˆ¨ê¹€
      charModal.setAttribute('aria-hidden', 'true');    // ì ‘ê·¼ì„± : ìˆ¨ê¹€ ìƒíƒœ ì•Œë¦¼
    }
    async function applyCharacter({ src, jobGroup, jobGroupLabel, name, power, spTotal, tpTotal }) {
      //ì¹´ë“œ í´ë¦­ ì‹œ ì´ í•¨ìˆ˜ê°€ í˜¸ì¶œë¨, ui ì´ë¯¸ì§€ êµì²´ - ìƒíƒœ ì—…ë°ì´íŠ¸ - íŒŒìƒ uiì—…ë°ì´íŠ¸ê¹Œì§€ í•œë²ˆì— ì²˜ë¦¬
      characterImg.src = src;   // ë©”ì¸ ìºë¦­í„° ì´ë¯¸ì§€ êµì²´
      characterImg.style.display = 'block';   // ì‹¤ì œ ì´ë¯¸ì§€ ë³´ì´ê¸°
      characterGhost.style.display = 'none';    // í”Œë ˆì´ìŠ¤í™€ë”(ìœ ë ¹ ì´ë¯¸ì§€) ìˆ¨ê¹€
      state.currentCharacter = {    // ì „ì—­/ìƒíƒœì— í˜„ì¬ ì„ íƒ ê¸°ë¡
        jobGroup,
        jobGroupLabel: jobGroupLabel || null,  // â† í•œê¸€ ì§ì—…êµ° ë¼ë²¨(ì˜ˆ: ë‚¨ê·€ê²€ì‚¬)
        name,
        imgSrc: src,
        power: power || null
      };
      state.skillLv = {}; state.skillTpLv = {}; // í˜„ì¬ ì‚¬ìš©í•œ SP/TP ì´ˆê¸°í™”
      state.skillDmg = {};
      state.stUsedSP = 0; state.stUsedTP = 0;
      if (Number.isFinite(spTotal) && Number.isFinite(tpTotal)) {
        setTotals(spTotal, tpTotal);        // ğŸ‘ˆ ì¦‰ì‹œ ë°˜ì˜ (ë¬´ë„¤íŠ¸ì›Œí¬)
      } else {
        await loadCharTotalsAndApply(name); // ğŸ‘ˆ ì˜ˆì™¸ì ìœ¼ë¡œ ê°’ì´ ì—†ì„ ë•Œë§Œ ë°±ì—… ê²½ë¡œ
      }
      recalcAndRenderPanel();
    }

    characterCard.addEventListener('click', openCharacterPicker);
    charModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeCharacterPicker(); });
    /* ìŠ¤í‚¬ì‹œíŠ¸ ë§¤ì¹­ìš© í‚¤: ì§ì—…êµ°(ë¼ë²¨)+ì´ë¦„ â†’ ê³µë°± ì œê±° */
    function currentSkillOwnerKey() {
      const ch = state.currentCharacter || {};
      const key = String((ch.jobGroupLabel || '') + (ch.name || '')).replace(/\s+/g, '');
      return key || null; // ì˜ˆ: 'ë‚¨ê·€ê²€ì‚¬ì†Œìš¸ë¸Œë§ì–´'
    }

    /* ===== ì•„ì´í…œ í”¼ì»¤ (ê³µìš©) ===== */
    const itemModal = document.getElementById('itemModal');
    const itemList = document.getElementById('itemList');
    const itemSearch = document.getElementById('itemSearch');
    const weaponTabs = document.getElementById('weaponTabs');
    const itemDlgTitle = document.getElementById('itemDlgTitle');
    function getItemsForSlot(slotKey) { return (DB.itemsBySlot[slotKey] || []).slice(); }
    function getWeaponsFilteredByJob(jobGroup) {
      const allowed = new Set(ALLOWED_WEAPON_TYPES[jobGroup] || []);
      return getItemsForSlot('weapon').filter(it => allowed.has(it.type));
    }
    function renderWeaponTabs(jobGroup) {
      const types = ALLOWED_WEAPON_TYPES[jobGroup] || [];
      weaponTabs.innerHTML = '';
      if (!types.length) { weaponTabs.style.display = 'none'; return; }
      if (!state.ui.weaponTypeTab || !types.includes(state.ui.weaponTypeTab)) state.ui.weaponTypeTab = types[0];
      types.forEach(t => {
        const b = document.createElement('button');
        b.className = 'tab-btn' + (t === state.ui.weaponTypeTab ? ' active' : '');
        b.textContent = t;
        b.onclick = () => { state.ui.weaponTypeTab = t; renderItems('weapon', itemSearch.value); updateActive(); };
        weaponTabs.appendChild(b);
      });
      function updateActive() { [...weaponTabs.children].forEach(ch => ch.classList.toggle('active', ch.textContent === state.ui.weaponTypeTab)); }
      weaponTabs.style.display = 'flex';
    }

    function renderItems(slotKey, query = '') {
      itemList.innerHTML = '';
      const q = (query || '').trim().toLowerCase();
      let items = slotKey === 'weapon' && state.currentCharacter.jobGroup ? getWeaponsFilteredByJob(state.currentCharacter.jobGroup) : getItemsForSlot(slotKey);
      if (slotKey === 'weapon' && state.ui.weaponTypeTab) items = items.filter(it => it.type === state.ui.weaponTypeTab);
      if (q) items = items.filter(it => (it.name || '').toLowerCase().includes(q) || (it.type || '').toLowerCase().includes(q));
      if (!items.length) {
        const msg = document.createElement('div'); msg.style.color = '#c7b589';
        msg.textContent = 'ì¡°ê±´ê³¼ ì¼ì¹˜í•˜ëŠ” ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.'; itemList.appendChild(msg); return;
      }
      items.forEach(it => {
        const row = document.createElement('button');
        row.className = 'item-row';
        const isBottom = (slotKey === 'aura' || slotKey === 'title' || slotKey === 'creature' || slotKey === 'artifact');
        const badge = isBottom ? (it.level_text && String(it.level_text).trim()) : `Lv.${it.level ?? 65}`;
        const lvlLabel = isBottom ? (it.level_text && String(it.level_text).trim()) : `${it.level ?? 65}ë ˆë²¨`;
        row.innerHTML = `
          <div class="iconbox">
            <img class="icon" src="${it.img || PLACEHOLDER_IMG}" alt="${it.name}">
            ${badge ? `<span class="badge-lv">${badge}</span>` : ``}
          </div>
          <div class="meta">
            <div class="meta-top">${lvlLabel ? `<span class="lvl">${lvlLabel}</span>` : ``}<span class="name">${it.name}</span></div>
            <div class="meta-sub">${it.type || ''}</div>
          </div>
          <div class="right"><span class="rarity-chip">${it.rarity_kr || (it.rarity === 'epic' ? 'ì—í”½' : (it.rarity || ''))}</span></div>`;
        row.onclick = () => { applyItemToSlot(slotKey, it); closeItemPicker(); };
        const icon = row.querySelector('.icon');
        icon.onerror = () => { icon.src = PLACEHOLDER_IMG; };
        itemList.appendChild(row);
      });
    }

    async function openItemPicker(slotKey) {
      state.currentSlotKey = slotKey;
      await ensureLoaded(slotKey);
      if (slotKey === 'weapon') {
        itemDlgTitle.textContent = 'ë¬´ê¸° ì„ íƒ';
        if (!state.currentCharacter.jobGroup) { openCharacterPicker(); return; }
        renderWeaponTabs(state.currentCharacter.jobGroup);
      } else {
        itemDlgTitle.textContent = labelForSlot(slotKey) + ' ì„ íƒ';
        weaponTabs.style.display = 'none';
      }
      renderItems(slotKey);
      itemModal.classList.add('show'); itemModal.setAttribute('aria-hidden', 'false');
      itemSearch.value = ''; itemSearch.oninput = () => renderItems(slotKey, itemSearch.value);
    }
    function closeItemPicker() { itemModal.classList.remove('show'); itemModal.setAttribute('aria-hidden', 'true'); }
    itemModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeItemPicker(); });
    function applyItemToSlot(slotKey, item) {
      if (!item.raw && item._raw) item.raw = item._raw;
      state.selections[slotKey] = item;
      const tile = tileElForSlot(slotKey); if (!tile) return;
      tile.innerHTML = `<img class="item-img" alt="${item.name}" src="${item.img || PLACEHOLDER_IMG}" style="width:70%;height:70%;border-radius:8px;">`;
      const img = tile.querySelector('img');
      if (img) img.onerror = () => { img.src = PLACEHOLDER_IMG; };
      recalcAndRenderPanel();
      refreshSealCaptionsForSlot(slotKey);
      refreshSealLabelsFromState();
    }
    function tileElForSlot(slotKey) { const domKey = Object.keys(SLOT_MAP).find(k => SLOT_MAP[k] === slotKey); return document.querySelector(`.slot[data-slot="${domKey}"]`); }
    function labelForSlot(slotKey) {
      return ({
        weapon: 'ë¬´ê¸°', headshoulder: 'ë¨¸ë¦¬ì–´ê¹¨', top: 'ìƒì˜', bottom: 'í•˜ì˜', belt: 'í—ˆë¦¬', shoes: 'ì‹ ë°œ',
        bracelet: 'íŒ”ì°Œ', necklace: 'ëª©ê±¸ì´', ring: 'ë°˜ì§€', support: 'ë³´ì¡°ì¥ë¹„',
        aura: 'ì˜¤ë¼', title: 'ì¹­í˜¸', creature: 'í¬ë¦¬ì³', artifact: 'ì•„í‹°íŒ©íŠ¸'
      })[slotKey] || 'ì•„ì´í…œ';
    }

    /* ===== ê°•í™” ì„ íƒ ===== */
    const enhanceModal = document.getElementById('enhanceModal');
    const enhanceListEl = document.getElementById('enhanceList');

    function enhTypeForSlot(slotKey) {
      if (slotKey === 'weapon') return 'ë¬´ê¸°ê°•í™”';
      if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slotKey)) return 'ë°©ì–´êµ¬ê°•í™”';
      if (['bracelet', 'necklace', 'ring'].includes(slotKey)) return 'ì•…ì„¸ê°•í™”';
      if (slotKey === 'support') return 'ë³´ì¥ê°•í™”';
      return null;
    }
    async function openEnhPicker(slotKey, btnEl) {
      const type = enhTypeForSlot(slotKey);
      if (!type) return;
      await ensureEnhLoaded();
      const list = (DBEnh.byType[type] || []).slice();
      enhanceListEl.innerHTML = '';
      list.forEach(opt => {
        const b = document.createElement('button'); b.className = 'enh-option'; b.textContent = opt.name || '(ì´ë¦„ì—†ìŒ)';
        b.onclick = () => { state.upgrades[slotKey] = opt; if (btnEl) btnEl.textContent = opt.name; closeEnhPicker(); recalcAndRenderPanel(); };
        enhanceListEl.appendChild(b);
      });
      state.ui.enhTargetSlot = slotKey; state.ui.enhTargetBtn = btnEl || null;
      enhanceModal.classList.add('show'); enhanceModal.setAttribute('aria-hidden', 'false');
    }
    function closeEnhPicker() { enhanceModal.classList.remove('show'); enhanceModal.setAttribute('aria-hidden', 'true'); }
    enhanceModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeEnhPicker(); });

    /* ===== í•©ì‚° íŒ¨ë„ ===== */
    const statListEl = document.getElementById('statList');
    function sumSelections() {
      const S = {     //ëª¨ë“  í•­ëª© 0ìœ¼ë¡œ ì‹œì‘
        phys_atk: 0, mag_atk: 0, str: 0, int: 0, phys_crit: 0, mag_crit: 0, phys_crit_rate: 0, mag_crit_rate: 0, add_damage: 0, counter_damage_inc: 0, elem_add_sum: 0,
        str_pct: 0, int_pct: 0, damage_inc: 0, crit_damage_inc: 0, phys_atk_pct: 0, mag_atk_pct: 0, skill_atk_inc: 0,
        elem: { fire: 0, water: 0, light: 0, dark: 0 }, cdr: 0, speed: { attack: 0, move: 0, cast: 0 }, def_break_inc: 0,
        counter_add_damage: 0,                        // ì¹´ìš´í„°ì¶”ë€(%)
        elem_add: { fire: 0, water: 0, light: 0, dark: 0 },     // ì†ì„±ë³„ â€˜ê¸°ë³¸â€™ ì†ì¶”(%) í•©
        elem_add_eff_sum: 0,           // ì‹ ì ìš© í›„ ìœ íš¨ ì†ì¶”(%) í•©
        fin_add_damage: 0,    //ìµœì¢…ì¶”ë€(%)
        final_phys_crit_pct: 0,   // ìµœì¢… ë¬¼ë¦¬í¬ë¦¬ìœ¨(0~1)
        final_mag_crit_pct: 0,    // ìµœì¢… ë§ˆë²•í¬ë¦¬ìœ¨(0~1)
        factor_phys: 1,           // ë¬¼ê³µ ê¸°ì¤€ í™•ë¥ ê³„ìˆ˜
        factor_mag: 1,             // ë§ˆê³µ ê¸°ì¤€ í™•ë¥ ê³„ìˆ˜
      };
      // â˜… ìŠ¤ì¦ ì „ìš© ì„ì‹œ ëˆ„ì ê¸°(ë² ì´ìŠ¤ë¶€í„° ëˆ„ì  ì‹œì‘)
      S.__skillMul = 1;        // ê³±ì—°ì‚° ëŒ€ìƒ(ì•„ì´í…œ/ê°•í™”/ì— ë¸”ë ˜/ì˜µì…˜/ë£¬/ë§ˆë´‰/ë§ˆë¶€ ë“±)
      S.__skillAddBuff = 0;    // í•©ì—°ì‚° ëŒ€ìƒ(ë²„í”„ ì‹œíŠ¸ì—ì„œ ì˜¨ ìŠ¤ì¦)
      const addStats = (s) => {   // ì•„ì´í…œ í•˜ë‚˜ì˜ statsë¥¼ ë°›ì•„ Sì— ëˆ„ì 
        if (!s) return;
        S.phys_atk += s.phys_atk || 0; S.mag_atk += s.mag_atk || 0;
        S.str += s.str || 0; S.int += s.int || 0;
        S.phys_crit += s.phys_crit || 0; S.mag_crit += s.mag_crit || 0;
        S.phys_crit_rate += s.phys_crit_rate || 0; S.mag_crit_rate += s.mag_crit_rate || 0;
        S.add_damage += s.add_damage || 0;
        S.counter_add_damage += s.counter_add_damage || 0;
        S.counter_damage_inc += s.counter_damage_inc || 0;

        if (s.elem_add_damage) {
          S.elem_add.fire += s.elem_add_damage.fire || 0;
          S.elem_add.water += s.elem_add_damage.water || 0;
          S.elem_add.light += s.elem_add_damage.light || 0;
          S.elem_add.dark += s.elem_add_damage.dark || 0;
        }

        S.str_pct += s.str_pct || 0; S.int_pct += s.int_pct || 0;
        S.damage_inc += s.damage_inc || 0; S.crit_damage_inc += s.crit_damage_inc || 0;
        S.phys_atk_pct += s.phys_atk_pct || 0; S.mag_atk_pct += s.mag_atk_pct || 0;

        // â˜… ìŠ¤ì¦ì€ ë”í•˜ì§€ ë§ê³  ê³± ëˆ„ì (ë²„í”„ëŠ” ì•„ì§ ì•ˆ ë“¤ì–´ì˜´)
        if (s.skill_atk_inc) {
          S.__skillMul *= (1 + (s.skill_atk_inc || 0));
        }

        if (s.elem) { S.elem.fire += s.elem.fire || 0; S.elem.water += s.elem.water || 0; S.elem.light += s.elem.light || 0; S.elem.dark += s.elem.dark || 0; }
        S.cdr += s.cdr || 0;
        if (s.speed) { S.speed.attack += s.speed.attack || 0; S.speed.move += s.speed.move || 0; S.speed.cast += s.speed.cast || 0; }
        if (s.other) { S.def_break_inc += s.other.def_break_inc || 0; }
      };
      Object.values(state.selections).forEach(it => addStats(it?.stats));   //ì„ íƒ ì¥ë¹„ë“¤ ëª¨ë‘ ëˆ„ì í•´ì„œ ìµœì¢… së°˜í™˜
      // ì¥ë¹„ í•©
      Object.values(state.upgrades).forEach(up => addStats(up?.stats));   // ì„ íƒ ê°•í™”ë“¤ ëª¨ë‘ ëˆ„ì í•´ì„œ ìµœì¢… së°˜í™˜
      // [REFINE] ë¬´ê¸°ì—°ë§ˆ (ê³±ì—°ì‚° ê³„ì—´ì€ addStats ë‚´ë¶€ì—ì„œ ìë™ ê³±)
      if (state.refines?.weapon?.stats) addStats(state.refines.weapon.stats);
      // [REFINE] ë³´ì¡°ì—°ë§ˆ (ë§ì—°ì‚°)
      if (state.refines?.sub?.stats) addStats(state.refines.sub.stats);
      // â–¼â–¼â–¼ ì—¬ê¸° ì¶”ê°€: ì„±ì•ˆì˜ ë´‰ì¸(ë§ì—°ì‚°) â–¼â–¼â–¼
      if (state.castleSeal?.main?.stats) addStats(state.castleSeal.main.stats);
      if (state.castleSeal?.sub?.stats) addStats(state.castleSeal.sub.stats);
      // ê°•í™” í•©(ìš”ì²­: í•©ì—°ì‚°)
      //Object.values(state.enchants || {}).forEach(en => addStats(en?.stats));
      // ë§ˆë²•ë¶€ì—¬ í•©ì‚°
      // ê¸°ë³¸(ì›ì‹œ) ì´í•©ë„ ìœ ì§€
      // â–¼â–¼â–¼ ì„¸íŠ¸ ì˜µì…˜ ê³„ì‚°/ì ìš© (ì¥ë¹„ ì„ íƒ ì´í›„) â–¼â–¼â–¼
      try {
        // ì„¸íŠ¸ ë°ì´í„°ê°€ ì•„ì§ì´ë©´ ë¹„ë™ê¸° ë¡œë”© ì‹œë„(ëŒ€ê¸°í•˜ì§€ ì•ŠìŒ)
        if (!DBSet.loaded) { ensureSetLoaded().catch(() => { }); }

        // ì„¸íŠ¸ ì¹´ìš´íŠ¸ ëŒ€ìƒ ìŠ¬ë¡¯(ë°©ì–´êµ¬ 5ë¶€ìœ„ + ì•…ì„¸ 3ë¶€ìœ„)
        // ë™ì¼ ê¸°ì¤€ì€ ì— ë¸”ë ˜ ìë™ ì ìš© ì½”ë“œì—ì„œë„ ì‚¬ìš© ì¤‘. :contentReference[oaicite:7]{index=7}
        const SET_SLOTS = ['headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring'];

        // 1) ë‚´ê°€ ì°©ìš©í•œ ì•„ì´í…œë“¤ì˜ "ì¢…ë¥˜" ì¹´ìš´íŠ¸
        const counts = Object.create(null);
        for (const sk of SET_SLOTS) {
          const it = state?.selections?.[sk];
          const k = String(it?.type || '').trim();      // ê° ì•„ì´í…œ ì‹œíŠ¸ì˜ 'ì¢…ë¥˜' ì»¬ëŸ¼ ë§¤í•‘ ê°’
          if (!k) continue;
          counts[k] = (counts[k] || 0) + 1;
        }

        // 2) ì˜ˆì™¸ í”Œë˜ê·¸(ì°¨ë‹¨ ê·œì¹™)
        const blockBaseSets = (counts['ì—˜ë¦¬íŠ¸ìƒì˜'] || 0) >= 1; // ë§¹ê³µ/ê·œìœ¨/ìŒìœ¨ ë¯¸ì ìš©
        const blockKH = (counts['ì—˜ë¦¬íŠ¸íŒ”ì°Œ'] || 0) >= 1; // ì¹¼ë‚ /í•¨ì„± ë¯¸ì ìš©

        // 3) ì ìš©í•  ì„¸íŠ¸ íƒ€ì… ê²°ì •
        const want = [];

        if (!blockBaseSets) {
          if ((counts['ë§¹ê³µ'] || 0) >= 3) want.push('ë§¹ê³µ');
          if ((counts['ê·œìœ¨'] || 0) >= 3) want.push('ê·œìœ¨');
          if ((counts['ìŒìœ¨'] || 0) >= 3) want.push('ìŒìœ¨');
        }
        if (!blockKH) {
          const k = counts['ì¹¼ë‚ '] || 0;
          if (k >= 3) {                 // 3ê°œ ì´ìƒì´ë©´ 2ì…‹+3ì…‹ ëª¨ë‘
            want.push('ì¹¼ë‚ 2ì…‹', 'ì¹¼ë‚ 3ì…‹');
          } else if (k >= 2) {
            want.push('ì¹¼ë‚ 2ì…‹');
          }

          const h = counts['í•¨ì„±'] || 0;
          if (h >= 3) {                 // 3ê°œ ì´ìƒì´ë©´ 2ì…‹+3ì…‹ ëª¨ë‘
            want.push('í•¨ì„±2ì…‹', 'í•¨ì„±3ì…‹');
          } else if (h >= 2) {
            want.push('í•¨ì„±2ì…‹');
          }
        }

        // 4) ì„¸íŠ¸ ìŠ¤íƒ¯ ì ìš© (ì—¬ëŸ¬ í–‰ì´ë©´ ì „ë¶€ ë”í•¨)
        if (Array.isArray(DBSet.list) && want.length) {
          for (const t of want) {
            const tt = String(t).trim();
            const list = (DBSet.byType?.[tt] || DBSet.list.filter(o => String(o.type || '').trim() === tt));
            for (const o of list) addStats(o.stats);
          }
        }

        // (ë””ë²„ê·¸/í‘œì‹œìš©) ì´ë²ˆ í•©ì‚°ì— ì ìš©ëœ ì„¸íŠ¸ ëª©ë¡ ì €ì¥
        state.appliedSets = want.slice();
      } catch (e) {
        console.warn('Set bonus apply failed:', e);
      }
      // â–²â–²â–² ì„¸íŠ¸ ì˜µì…˜ ê³„ì‚°/ì ìš© ë â–²â–²â–²
      S.skill_atk_inc = (S.__skillMul - 1) + S.__skillAddBuff;
      return S;
    }

    const fmtInt = (v) => (v == null ? 'â€”' : Math.round(v).toString());   // ì •ìˆ˜,í¼ì„¼íŠ¸ë¥¼ ui í‘œì‹œìš© ë¬¸ìì—´ë¡œ ë°”ê¿ˆ(ì—†ìœ¼ë©´ -)
    const fmtPct = (v) => (v == null ? 'â€”' : (Math.round((v || 0) * 1000) / 10).toFixed(1) + '%');
    const show = (label, value) => {    // í•˜ë‚˜ì˜ í†µê³„ í–‰ DOM ì„ ë§Œë“¤ì–´ì£¼ëŠ” íŒ©í† ë¦¬
      const row = document.createElement('div'); row.className = 'stat-row';
      const L = document.createElement('div'); L.className = 'stat-label'; L.textContent = label;
      const R = document.createElement('div'); R.className = 'stat-value'; R.textContent = value;
      row.appendChild(L); row.appendChild(R); return row;
    };

    function renderStats(S) {     //ë¬¼ê³µìº ë§ˆê³µìºì— ë”°ë¼ ë¼ë²¨ê³¼ ê°’ ì„ íƒì„ ë°”ê¿”ì¤Œ
      statListEl.innerHTML = '';
      const HIDE_MOVE_CAST = true; // â† UI ë¹„í‘œì‹œ í”Œë˜ê·¸
      const p = state.currentCharacter.power; // 'phys' | 'mag' | null
      const atkLabel = (p ? powerLabel(p) : 'ë¬¼ë¦¬/ë§ˆë²•') + ' ê³µê²©ë ¥';
      const mainStatLabel = (p === 'phys' ? 'í˜' : p === 'mag' ? 'ì§€ëŠ¥' : 'í˜/ì§€ëŠ¥');
      const critLabel = (p ? powerLabel(p) : 'ë¬¼ë¦¬/ë§ˆë²•') + ' í¬ë¦¬í‹°ì»¬';
      const mainPctLabel = (p === 'phys' ? 'í˜(%)' : p === 'mag' ? 'ì§€ëŠ¥(%)' : 'í˜/ì§€ëŠ¥(%)');
      const atkPctLabel = (p ? powerLabel(p) : 'ë¬¼ë¦¬/ë§ˆë²•') + ' ê³µê²©ë ¥(%)';
      const atkVal = p === 'phys' ? S.phys_atk : p === 'mag' ? S.mag_atk : null;
      const mainStatVal = p === 'phys' ? S.str : p === 'mag' ? S.int : null;
      const critVal = p === 'phys' ? S.phys_crit : p === 'mag' ? S.mag_crit : null;
      const critRateVal = p === 'phys' ? S.phys_crit_rate : p === 'mag' ? S.mag_crit_rate : null;
      const finalCritPct =
        p === 'phys' ? (S.final_phys_crit_pct ?? 0)
          : p === 'mag' ? (S.final_mag_crit_pct ?? 0)
            : Math.max(S.final_phys_crit_pct ?? 0, S.final_mag_crit_pct ?? 0); // ë¯¸ì •ì´ë©´ í° ìª½
      const mainPctVal = p === 'phys' ? S.str_pct : p === 'mag' ? S.int_pct : null;
      const atkPctVal = p === 'phys' ? S.phys_atk_pct : p === 'mag' ? S.mag_atk_pct : null;
      const elems = S.elem; const maxVal = Math.max(elems.fire, elems.water, elems.light, elems.dark);
      const winners = []; const tag = (k) => ({ fire: 'í™”', water: 'ìˆ˜', light: 'ëª…', dark: 'ì•”' }[k]);
      for (const k of ['fire', 'water', 'light', 'dark']) if (elems[k] === maxVal && maxVal > 0) winners.push(tag(k));
      const elemText = winners.length ? (winners.join('/') + ' ' + Math.round(maxVal)) : 'â€”';

      statListEl.appendChild(show(atkLabel, fmtInt(atkVal)));   // ì‹¤ì œ í™”ë©´ UIì— í–‰ì¶”ê°€
      statListEl.appendChild(show(mainStatLabel, fmtInt(mainStatVal)));
      statListEl.appendChild(show(critLabel, fmtInt(critVal)));
      statListEl.appendChild(show('ìµœì¢… í¬ë¦¬í‹°ì»¬(%)', (finalCritPct * 100).toFixed(1) + '%'));
      statListEl.appendChild(show('ìµœì¢… ì¶”ê°€ë°ë¯¸ì§€(%)', fmtPct(S.fin_add_damage)));
      statListEl.appendChild(show(mainPctLabel, fmtPct(mainPctVal)));
      statListEl.appendChild(show('ë°ë¯¸ì§€ì¦ê°€(%)', fmtPct(S.damage_inc)));
      statListEl.appendChild(show('í¬ë¦¬í‹°ì»¬ë°ë¯¸ì§€ì¦ê°€(%)', fmtPct(S.crit_damage_inc)));
      statListEl.appendChild(show(atkPctLabel, fmtPct(atkPctVal)));
      statListEl.appendChild(show('ìŠ¤í‚¬ê³µê²©ë ¥ì¦ê°€(%)', fmtPct(S.skill_atk_inc)));
      statListEl.appendChild(show('ì†ì„±ê°•í™”', elemText));
      statListEl.appendChild(show('ë°©ì–´ë ¥ê°ì†Œ(%)', fmtPct(S.def_break_inc)));
      statListEl.appendChild(show('ì „ì²´ ì¿¨íƒ€ì„ ê°ì†Œ(%)', fmtPct(S.cdr)));
      statListEl.appendChild(show('ê³µê²©ì†ë„(%)', fmtPct(S.speed.attack)));
      statListEl.appendChild(show('ìºìŠ¤íŒ…ì†ë„', fmtPct(S.speed.cast)));
      if (!HIDE_MOVE_CAST) {
        statListEl.appendChild(show('ì´ë™ì†ë„', fmtPct(S.speed.move)));
      }

      const row = document.createElement('div');  // ë„¤ UI êµ¬ì¡°ì— ë§ê²Œ li/tr ë“±ìœ¼ë¡œ ë°”ê¿”ë„ ë¨

    }

    async function recalcAndRenderPanel() {
      // 1) ë²„í”„ ë¨¼ì € ê³„ì‚°
      await waitForIdToken();
      await BuffLeveling.preload();
      state.__buffStats = await BuffLeveling.computeBuffStats();
      console.log("[BUFF-DEBUG] state.__buffStats ì €ì¥ë¨:", state.__buffStats); //ë¡œê·¸ê°’

      // 2) í•©ì‚°
      const S = sumSelections();
      console.log("[BUFF-DEBUG] sumSelections ìµœì¢… í•©ì‚°:", S);  //ë¡œê·¸ê°’
      console.log("[SET] applied:", state.appliedSets);

      // â˜… ì•„ì´í…œ ë³€ê²½ìœ¼ë¡œ state.levelingì´ ê°±ì‹ ë˜ì—ˆì„ ìˆ˜ ìˆìœ¼ë‹ˆ, ëª¨ë“  ìŠ¤í‚¬ ìºì‹œ ì¬ê³„ì‚°
      // â˜… ì•„ì´í…œ ë³€ê²½ìœ¼ë¡œ state.levelingì´ ë°”ë€Œì—ˆì„ ìˆ˜ ìˆìœ¼ë‹ˆ,
      //    í˜„ì¬ ìºë¦­í„°ì˜ ìŠ¤í‚¬ë§Œ ë°ë¯¸ì§€ ìºì‹œ ì¬ê³„ì‚°
      // â˜… í˜„ì¬ ìºë¦­í„° ìŠ¤í‚¬ë§Œ ë°ë¯¸ì§€ ìºì‹œ ì¬ê³„ì‚° (ì•ˆì „ í‚¤ ìƒì„±)
      try {
        // ìŠ¤í‚¬ ì‹œíŠ¸ ì¤€ë¹„
        if (typeof ensureSkillLoaded2 === 'function') {
          await waitForIdToken();
          await ensureSkillLoaded2();
          // â˜… ìŠ¤í‚¬ì‹œíŠ¸ ë¡œë”© ì§í›„: ì˜ˆì™¸ê·œì¹™ ë§¤í•‘/í™œì„±í™”
          await ensureExceptionLoaded();
          refreshExceptionSkillIdMap();
          refreshActiveExceptions();
        }

        // ì•ˆì „ ë¬¸ìì—´ ë³€í™˜ê¸°
        const toStr = (v) => (v == null ? '' : String(v));

        // í˜„ì¬ ìºë¦­í„° í‚¤(ê³µë°± ì œê±°) â€” ì–´ë–¤ í•¨ìˆ˜/í•„ë“œê°€ ë¹„ì–´ë„ ì•ˆì „
        const rawKey =
          (typeof currentCharKey === 'function' ? currentCharKey() : null)
          ?? (typeof currentSkillOwnerKey === 'function' ? currentSkillOwnerKey() : null)
          ?? [state.currentCharacter?.jobGroupLabel, state.currentCharacter?.name].filter(Boolean).join('');

        const key = toStr(rawKey).replace(/\s+/g, '');

        // ìºë¦­í„° í‚¤ê°€ ì—†ìœ¼ë©´ ì¬ê³„ì‚° ìŠ¤í‚µ
        if (!key) {
          console.warn('[LEVELING] ìºë¦­í„° í‚¤ ì—†ìŒ: ì¬ê³„ì‚° ìŠ¤í‚µ');
        } else if (ST2?.rows?.length) {
          // í˜„ì¬ ìºë¦­í„° + í‘œì‹œ ìŠ¤í‚¬ë§Œ
          const rows = ST2.rows.filter(s => s.who === key && s.show);

          // ë‹¤ë¥¸ ìºë¦­í„° ìºì‹œ ì •ë¦¬(ì„ íƒ)
          for (const id of Object.keys(state.skillDmg || {})) {
            if (!rows.some(s => s.id === id)) delete state.skillDmg[id];
          }

          // TP 0~5(ë˜ëŠ” ë„¤ ìƒìˆ˜)ì— ë§ì¶° í´ë¨í”„
          for (const s of rows) {
            const tp = Math.max(0, Math.min(5, Number(state.skillTpLv?.[s.id] ?? 0)));
            state.skillDmg[s.id] = calcSkillDamageWithTp(s, tp);
          }
          // â˜…â˜…â˜… ìŠ¤í‚¬ ì‚¬ìš©íšŸìˆ˜ ì‹œë®¬ë ˆì´ì…˜(60ì´ˆ = 3600í”„ë ˆì„) â€” ìë™ ì¶œë ¥ ì—†ìŒ
          queueMicrotask(() => window.simulateSkillUsage?.(getTimeWindowSec()));

        }
      } catch (e) {
        console.warn('[LEVELING] ìŠ¤í‚¬ ì¼ê´„ ì¬ê³„ì‚° ì‹¤íŒ¨:', e);
      }


      // 3) ë Œë”ë§ (ë„¤ ê¸°ì¡´ í•¨ìˆ˜ë“¤ ê·¸ëŒ€ë¡œ)
      renderStats(S);
      // ì´ˆê¸°ì—” ê°’ ë¹„ì›Œë‘ (â€”). ë²„íŠ¼ ëˆ„ë¥´ë©´ ê°±ì‹ .
      //updateFinalDamageField('â€”');

    }

    /* ===== ì— ë¸”ë ˜ ì‹œìŠ¤í…œ ===== */

    /** ìŠ¬ë¡¯ë³„ í—ˆìš© ì— ë¸”ë ˜ íƒ€ì… */
    const SOCKET_RULES = {
      headshoulder: ['ë…¸ë€ë¹›ì— ë¸”ë ˜'],
      belt: ['ë…¸ë€ë¹›ì— ë¸”ë ˜'],
      top: ['ë¶‰ì€ë¹›ì— ë¸”ë ˜'],
      bottom: ['ë¶‰ì€ë¹›ì— ë¸”ë ˜'],
      shoes: ['í‘¸ë¥¸ë¹›ì— ë¸”ë ˜'],
      bracelet: ['í‘¸ë¥¸ë¹›ì— ë¸”ë ˜'],
      necklace: ['ë…¹ìƒ‰ë¹›ì— ë¸”ë ˜'],
      ring: ['ë…¹ìƒ‰ë¹›ì— ë¸”ë ˜'],
      weapon: ['ë¶‰ì€ë¹›ì— ë¸”ë ˜', 'ë…¸ë€ë¹›ì— ë¸”ë ˜', 'ë…¹ìƒ‰ë¹›ì— ë¸”ë ˜', 'í‘¸ë¥¸ë¹›ì— ë¸”ë ˜'],
      support: ['í”Œë˜í‹°ë„˜ì— ë¸”ë ˜'],
      title: ['í”Œë˜í‹°ë„˜ì— ë¸”ë ˜']  // ì¹­í˜¸ ì¢Œì¸¡ ì› 1ê°œ
    };
    const SOCKET_COUNT = (slotKey) => (slotKey === 'support' || slotKey === 'title') ? 1 : 2;

    const emblemModal = document.getElementById('emblemModal');
    const emblemRows = document.getElementById('emblemRows');

    state.emblems = state.emblems || {};  // { slotKey: [null, null] }
    state.ui.emblemTarget = { slotKey: null, sockIndex: 0 };
    function ensureEmblemArray(slotKey) {
      if (!state.emblems[slotKey]) state.emblems[slotKey] = new Array(SOCKET_COUNT(slotKey)).fill(null);
    }

    /** ì‘ì€ ì› UI ì—…ë°ì´íŠ¸ */
    function paintEmblemDot(slotKey, sockIndex) {
      const dot = document.querySelector(`.emblem-dot[data-slot="${slotKey}"][data-sock="${sockIndex}"]`);
      if (!dot) return;
      const picked = (state.emblems[slotKey] || [])[sockIndex] || null;
      // ì´ˆê¸°í™”
      dot.innerHTML = '';
      dot.classList.toggle('empty', !picked);
      if (picked) {
        // ë°°ê²½ ì´ë¯¸ì§€ë¡œ ì£¼ì… (ì›í˜• í´ë¦¬í•‘ 100% ë³´ì¥)
        const src = (picked.img || PLACEHOLDER_IMG).replace(/"/g, '\\"');
        dot.style.setProperty('--emblem', `url("${src}")`);
        dot.classList.add('has-img');

        // ì¤‘ì•™ ìˆ«ì
        const n = document.createElement('span');
        n.className = 'num';
        n.textContent = picked.level_num ?? '';
        dot.appendChild(n);
      } else {
        // ë¹„ì›Œì§ ìƒíƒœ
        dot.classList.remove('has-img');
        dot.style.removeProperty('--emblem');
      }
      /* â–¼ ë³´ì¡°ì¥ë¹„/ì¹­í˜¸(í”Œë˜í‹°ë„˜)ì¼ ë•Œ ìº¡ì…˜ í‘œì‹œ */
      const isPlatSocket = (slotKey === 'support' || slotKey === 'title');
      if (isPlatSocket) {
        // dot ë°”ë¡œ ì•„ë˜ì— .emblem-captionì„ ë§Œë“¤ê±°ë‚˜ ì°¾ì•„ì„œ ê°±ì‹ 
        let cap = dot.nextElementSibling;
        if (!cap || !cap.classList.contains('emblem-caption')) {
          cap = document.createElement('div');
          cap.className = 'emblem-caption';
          dot.parentNode.insertBefore(cap, dot.nextSibling);
        }
        // ì„ íƒ ì‹œì—” 'ë ™ì œ' í…ìŠ¤íŠ¸(item.tag), ë¯¸ì„ íƒì´ë©´ ìˆ¨ê¹€
        if (picked && picked.tag) {
          cap.textContent = picked.tag;
          cap.style.display = 'block';
        } else {
          cap.textContent = '';
          cap.style.display = 'none';
        }
      }

    }

    /** ëª¨ë“  ì  ìƒˆë¡œê³ ì¹¨ */
    function refreshAllDots() { Object.keys(state.emblems).forEach(slotKey => { (state.emblems[slotKey] || []).forEach((_, i) => paintEmblemDot(slotKey, i)); }); }

    /** ì—†ìŒ ì¸ë„¤ì¼ */
    function makeNoneThumb(onPick) {
      const b = document.createElement('button');
      b.type = 'button'; b.className = 'em-thumb none'; b.title = 'ì—†ìŒ'; b.onclick = onPick; return b;
    }
    /** ì¼ë°˜ ì¸ë„¤ì¼(ì´ë¯¸ì§€ ì¤‘ì•™ ìˆ«ì) */
    function makeEmblemThumb(item, onPick) {
      const b = document.createElement('button');
      b.type = 'button'; b.className = 'em-thumb';
      const img = document.createElement('img'); img.src = item.img || PLACEHOLDER_IMG;
      img.onerror = () => { img.src = PLACEHOLDER_IMG; };
      const num = document.createElement('span'); num.className = 'num'; num.textContent = item.level_num ?? '';
      b.appendChild(img); b.appendChild(num); b.onclick = onPick; return b;
    }

    /** í”Œë˜í‹°ë„˜ 7ì¤„ ë¶„ë¥˜ í‚¤ì›Œë“œ */
    const PLAT_LINES = [
      { label: 'í™”', key: 'í™”' },
      { label: 'ìˆ˜', key: 'ìˆ˜' },
      { label: 'ëª…', key: 'ëª…' },
      { label: 'ì•”', key: 'ì•”' },
      { label: 'ëª¨ì†', key: 'ëª¨ì†' },
      { label: 'í˜', key: 'í˜' },
      { label: 'ì§€ëŠ¥', key: 'ì§€ëŠ¥' },
    ];

    /** ì— ë¸”ë ˜ ëª¨ë‹¬ ì—´ê¸° */
    async function openEmblemPicker(slotKey, sockIndex) {
      await ensureEnhLoaded();
      ensureEmblemArray(slotKey);

      state.ui.emblemTarget = { slotKey, sockIndex };
      emblemRows.innerHTML = '';

      const allow = SOCKET_RULES[slotKey] || [];
      const isPlatinumOnly = allow.length === 1 && allow[0] === 'í”Œë˜í‹°ë„˜ì— ë¸”ë ˜';
      if (isPlatinumOnly) {
        const base = DBEnh.byType['í”Œë˜í‹°ë„˜ì— ë¸”ë ˜'] || [];
        PLAT_LINES.forEach(line => {
          const row = document.createElement('div'); row.className = 'em-row';
          row.appendChild(makeNoneThumb(() => pickEmblem(null)));
          base.filter(x => (x.tag || '').includes(line.key)).forEach(item => {
            row.appendChild(makeEmblemThumb(item, () => pickEmblem(item)));
          });
          emblemRows.appendChild(row);
        });
      } else {
        // ì¼ë°˜ ìƒ‰ ì— ë¸”ë ˜: ìŠ¬ë¡¯ ê·œì¹™ëŒ€ë¡œ í•œ ì¤„ì”© ê°€ë¡œ ë¦¬ìŠ¤íŠ¸
        const orderMap = { 'ë¶‰ì€ë¹›ì— ë¸”ë ˜': 0, 'ë…¸ë€ë¹›ì— ë¸”ë ˜': 1, 'ë…¹ìƒ‰ë¹›ì— ë¸”ë ˜': 2, 'í‘¸ë¥¸ë¹›ì— ë¸”ë ˜': 3 };
        allow.slice().sort((a, b) => (orderMap[a] ?? 9) - (orderMap[b] ?? 9)).forEach(type => {
          const row = document.createElement('div'); row.className = 'em-row';
          row.appendChild(makeNoneThumb(() => pickEmblem(null)));
          (DBEnh.byType[type] || []).forEach(item => {
            row.appendChild(makeEmblemThumb(item, () => pickEmblem(item)));
          });
          emblemRows.appendChild(row);
        });
      }

      document.getElementById('emblemDlgTitle').textContent = `ì— ë¸”ë ˜ ì„ íƒ - ${labelForSlot(slotKey)} (ì†Œì¼“ ${sockIndex + 1})`;
      emblemModal.classList.add('show'); emblemModal.setAttribute('aria-hidden', 'false');
      function pickEmblem(item) {
        state.emblems[slotKey][sockIndex] = item
          ? { img: item.img, level_num: item.level_num, stats: item.stats, tag: item.tag } // â† tag ì¶”ê°€
          : null;
        paintEmblemDot(slotKey, sockIndex);
        recalcAndRenderPanel(); // í•©ì—°ì‚° ë°˜ì˜
        closeEmblemPicker();
      }
    }
    function closeEmblemPicker() { emblemModal.classList.remove('show'); emblemModal.setAttribute('aria-hidden', 'true'); }
    emblemModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeEmblemPicker(); });
    /** ì‘ì€ ì›(ì†Œì¼“) ì£¼ì…: ì¢Œì¸¡ì—´ì€ slot ì˜¤ë¥¸ìª½, ìš°ì¸¡ì—´ì€ slot ì™¼ìª½. ë³´ì¡°ì¥ë¹„ëŠ” 1ê°œ. */
    function injectEmblemDots() {
      // ë©”ì¸ ì¢Œ/ìš° ì—´
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot'); if (!slotEl) return;
        const code = slotEl.getAttribute('data-slot'); const slotKey = SLOT_MAP[code]; if (!slotKey) return;

        // ì¤‘ì•™ ë¯¸ë‹ˆ 4ì¹¸(C1~C4)ì€ ë’¤ì—ì„œ ë”°ë¡œ ì²˜ë¦¬
        if (['aura', 'title', 'creature', 'artifact'].includes(slotKey)) return;

        if (!SOCKET_RULES[slotKey]) return; // ì— ë¸”ë ˜ ë¯¸ì§€ì› ìŠ¬ë¡¯ì€ ìŠ¤í‚µ

        const stack = document.createElement('div'); stack.className = 'emblem-stack';
        const count = SOCKET_COUNT(slotKey);
        for (let i = 0; i < count; i++) {
          const dot = document.createElement('button');
          dot.type = 'button'; dot.className = 'emblem-dot empty';
          dot.setAttribute('data-slot', slotKey); dot.setAttribute('data-sock', String(i));
          dot.onclick = (e) => { e.stopPropagation(); openEmblemPicker(slotKey, i); };
          stack.appendChild(dot);
        }
        ensureEmblemArray(slotKey);
        // ì¢Œì¸¡ì—´(L*) â†’ slot ì˜¤ë¥¸ìª½ / ìš°ì¸¡ì—´(R*) â†’ slot ì™¼ìª½
        if (code && code.startsWith('L')) {
          row.appendChild(stack);
        } else if (code && code.startsWith('R')) {
          row.insertBefore(stack, slotEl);
        }
      });

      // ì¹­í˜¸(Title) ì²˜ë¦¬: ì™¼ìª½ 2ê°œ ì„ íƒì¹¸ ì¤‘ 'ì•„ë˜ ì„ íƒì¹¸' ì œê±°í•˜ê³  ì› 1ê°œ ë„£ê¸° (í”Œë˜í‹°ë„˜)
      const titleSlot = document.querySelector('.slot.mini[data-slot="C2"]');
      if (titleSlot) {
        const miniCell = titleSlot.closest('.mini-cell');
        if (miniCell) {
          const outer = miniCell.querySelector('.outer-rects');
          if (outer) {
            const btns = outer.querySelectorAll('.rect');
            if (btns[1]) btns[1].remove(); // ì•„ë˜ ë²„íŠ¼ ì œê±°
          }
          const stack = document.createElement('div');
          stack.className = 'emblem-stack';
          const dot = document.createElement('button'); dot.type = 'button'; dot.className = 'emblem-dot empty';
          dot.setAttribute('data-slot', 'title'); dot.setAttribute('data-sock', '0');
          dot.onclick = (e) => { e.stopPropagation(); openEmblemPicker('title', 0); };
          stack.appendChild(dot);
          ensureEmblemArray('title');
          miniCell.insertBefore(stack, miniCell.querySelector('.slot.mini'));
        }
      }

      refreshAllDots();
    }
    const runeModal = document.getElementById('runeModal');
    const runeGridEl = document.getElementById('runeGrid');
    function renderRuneGrid() {
      ensureRunesInitialized();
      runeGridEl.innerHTML = '';

      const header = document.createElement('div'); header.className = 'row';
      const headCell = document.createElement('div'); headCell.className = 'head'; headCell.textContent = 'ìŠ¤í‚¬ë£¬';
      header.appendChild(headCell);
      RUNE_LEVELS.forEach(lvl => {
        const c = document.createElement('div'); c.className = 'cell';
        const tag = document.createElement('div'); tag.className = 'head'; tag.textContent = String(lvl);
        tag.style.textAlign = 'center';
        c.appendChild(tag); header.appendChild(c);
      });
      runeGridEl.appendChild(header);

      RUNE_CATS.forEach(cat => {
        const row = document.createElement('div'); row.className = 'row';
        const head = document.createElement('div'); head.className = 'head'; head.textContent = cat.label;
        row.appendChild(head);

        RUNE_LEVELS.forEach(lvl => {
          const c = document.createElement('div'); c.className = 'cell';
          const sel = document.createElement('select'); sel.className = 'rune-select';
          for (let i = 0; i <= 20; i++) { const o = document.createElement('option'); o.value = String(i); o.textContent = String(i); sel.appendChild(o); }
          sel.value = String((state.runes[cat.key] || {})[lvl] || 0);
          sel.addEventListener('change', () => {
            const before = (state.runes[cat.key] || {})[lvl] || 0;
            const after = Number(sel.value) || 0;
            const currentTotal = countSelectedRunes();
            const diff = after - before;
            if (currentTotal + diff > 20) {
              sel.value = String(before);
              sel.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.05)' }, { transform: 'scale(1)' }], { duration: 180 });
              return;
            }
            state.runes[cat.key][lvl] = after;
            updateRuneCountSummary();
            onRunesChanged();
          });
          c.appendChild(sel);
          row.appendChild(c);
        });
        runeGridEl.appendChild(row);
      });
    }

    function openRuneModal() { renderRuneGrid(); runeModal.classList.add('show'); runeModal.setAttribute('aria-hidden', 'false'); }
    function closeRuneModal() { runeModal.classList.remove('show'); runeModal.setAttribute('aria-hidden', 'true'); }
    runeModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeRuneModal(); });
    /* ===== ìŠ¤í‚¬íŠ¸ë¦¬ ë¡œë” & UI (UI ì „ìš©, ê³„ì‚° ë¯¸ì—°ê²°) ===== */
    const DBTree = { loaded: false, rows: [], byChar: new Map() };
    const ST_CONF = { SP_TOTAL: 1210, TP_TOTAL: 35 };
    const LEVEL_BANDS_DEFAULT = [1, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 65, 70, 75, 80];
    function pickCol(r, ...ks) { for (const k of ks) { if (r[k] != null && String(r[k]).trim() !== '') return r[k]; } return ''; }
    function toNum(v) { if (v === '' || v == null) return 0; const n = Number(String(v).replace(/[, ]/g, '')); return isNaN(n) ? 0 : n; }
    function toList(v) { return (v ? String(v).split(/[,;]/).map(s => s.trim()).filter(Boolean) : []); }

    function mapRowToSkill(r) {
      // ë„¤ê°€ ì¤€ ì»¬ëŸ¼ í‚¤ ê·¸ëŒ€ë¡œ ì‚¬ìš©
      const whoRaw = r['ìºë¦­í„°ëª…'];
      const name = String(r['ìŠ¤í‚¬ëª…'] ?? '').trim();
      const band = toNum(r['ìŠ¤í‚¬ë ™ì œ']);
      const cd = toNum(r['ì¿¨íƒ€ì„']);
      const castFrames = toNum(r['ì‹œì „í”„ë ˆì„']);
      const minLv = toNum(r['ìµœì†ŒìŠ¤í‚¬ë ˆë²¨']);
      const maxLv = toNum(r['ìµœëŒ€ìŠ¤í‚¬ë ˆë²¨']);       // (= ë§ˆìŠ¤í„°ìŠ¤í‚¬ë ˆë²¨)
      const sp = toNum(r['ì†Œëª¨ SP']);               // SP ë¹„ìš©(ë ˆë²¨ë‹¹)
      const icon = cleanUrl(r['ì´ë¯¸ì§€']) || PLACEHOLDER_IMG;

      const who = String(whoRaw ?? '').replace(/\s+/g, '').trim();

      const idBase = (r['ìŠ¤í‚¬ID'] ?? name).toString().trim();
      const id = idBase ? `${idBase}#${band || 0}` : (Date.now().toString(36) + Math.random().toString(36).slice(2));

      return {
        id, who, name, icon,
        band: band || 1,
        levelGate: band || 1,     // â† ì¶”ê°€: ìŠ¤í‚¬ë ™ì œ(ë ˆë²¨ë§ ê²Œì´íŠ¸) í†µì¼ í‚¤
        min: Math.max(0, minLv || 0),
        max: Math.max(1, maxLv || 1),
        sp: Math.max(0, sp || 0),
        tp: 0,
        cd,
        castFrames,
        prereq: [],
        desc: ''
      };
    }



    /* ===== ì— ë¸”ë ˜ í•©ì—°ì‚° í¬í•¨ì„ ìœ„í•´ í•©ì‚° í•¨ìˆ˜ í™•ì¥ ===== */
    const _sumSelections_base = sumSelections;
    sumSelections = function () {
      const S = _sumSelections_base();

      // ëˆ„ì ê¸° ì•ˆì „ ë³´ì •(ë² ì´ìŠ¤ê°€ í•­ìƒ ë„£ì§€ë§Œ, í˜¹ì‹œ ëª¨ë¥¼ ì¬ì •ì˜ ëŒ€ë¹„)
      S.__skillMul = S.__skillMul || 1;
      S.__skillAddBuff = S.__skillAddBuff || 0;

      const add = (st, src = 'other') => {
        if (!st) return;

        // 1) ìŠ¤ì¦ë§Œ ë¶„ê¸°
        if (st.skill_atk_inc) {
          if (src === 'buff') S.__skillAddBuff += (st.skill_atk_inc || 0);  // ë²„í”„ëŠ” í•©ì‚°
          else S.__skillMul *= (1 + (st.skill_atk_inc || 0)); // ë‚˜ë¨¸ì§€ëŠ” ê³±ì‚°
        }

        // 2) ë‚˜ë¨¸ì§€ ìŠ¤íƒ¯ì€ ê¸°ì¡´ì²˜ëŸ¼ ê°€ì‚°
        S.phys_atk += st.phys_atk || 0; S.mag_atk += st.mag_atk || 0;
        S.str += st.str || 0; S.int += st.int || 0;
        S.phys_crit += st.phys_crit || 0; S.mag_crit += st.mag_crit || 0;
        S.phys_crit_rate += st.phys_crit_rate || 0; S.mag_crit_rate += st.mag_crit_rate || 0;
        S.add_damage += st.add_damage || 0;
        S.str_pct += st.str_pct || 0; S.int_pct += st.int_pct || 0;
        S.damage_inc += st.damage_inc || 0; S.crit_damage_inc += st.crit_damage_inc || 0;
        S.phys_atk_pct += st.phys_atk_pct || 0; S.mag_atk_pct += st.mag_atk_pct || 0;
        if (st.elem) { S.elem.fire += st.elem.fire || 0; S.elem.water += st.elem.water || 0; S.elem.light += st.elem.light || 0; S.elem.dark += st.elem.dark || 0; }
        S.cdr += st.cdr || 0;
        if (st.speed) { S.speed.attack += st.speed.attack || 0; S.speed.move += st.speed.move || 0; S.speed.cast += st.speed.cast || 0; }
        if (st.other) { S.def_break_inc += st.other.def_break_inc || 0; }
      };


      // ì— ë¸”ë ˜(ê³± ëŒ€ìƒ)
      Object.keys(state.emblems || {}).forEach(slotKey => {
        (state.emblems[slotKey] || []).forEach(it => { if (it?.stats) add(it.stats, 'other'); });
      });

      // ì˜µì…˜(ì•„ë°”íƒ€/ë¬´ê¸°ì••)ë„ ê³± ëŒ€ìƒ
      if (state.options?.avatarEnh?.stats) add(state.options.avatarEnh.stats, 'other');
      if (state.options?.imprintEnh?.stats) add(state.options.imprintEnh.stats, 'other');

      // ë£¬ ê°ì¸(ê³± ëŒ€ìƒ)
      if (state.runeEngrave?.stats) add(state.runeEngrave.stats, 'other');

      // ë²„í”„ ì‹œíŠ¸(í•© ëŒ€ìƒ)
      if (state.__buffStats) add(state.__buffStats, 'buff');

      // â˜… ì•„ì§ S.skill_atk_inc í™•ì •í•˜ì§€ ì•ŠìŒ (5ë²ˆì§¸ì—ì„œ ë§ˆë´‰Â·ë§ˆë¶€ê¹Œì§€ í¬í•¨ í›„ ìµœì¢… í™•ì •)
      return S;
    };
    // ì´ˆê¸°í™”
    document.addEventListener('DOMContentLoaded', () => {
      refreshEnhLabelsFromState();
      renderSpTp();
      // ìŠ¬ë¡¯ í´ë¦­ â†’ ì•„ì´í…œ ì„ íƒ
      document.querySelectorAll('.slot').forEach(el => {
        const code = el.getAttribute('data-slot'); const slotKey = SLOT_MAP[code]; if (!slotKey) return;
        el.addEventListener('click', (e) => { e.stopPropagation(); openItemPicker(slotKey); });
      });

      // ì²« ë²ˆì§¸ ì„ íƒì¹¸ = ê°•í™” ì„ íƒ ì—°ê²°
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot'); const code = slotEl?.getAttribute('data-slot'); const slotKey = SLOT_MAP[code];
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!slotKey || !rects.length) return;
        const firstBtn = rects[0];
        /* â–¼ ì¶”ê°€: ê¸°ë³¸ ë¼ë²¨ì„ 'ê°•í™” ì„¤ì •'ìœ¼ë¡œ ë³´ì´ê²Œ */
        firstBtn.textContent = 'ê°•í™” ì„¤ì •';
        firstBtn.addEventListener('click', (e) => { e.stopPropagation(); openEnhPicker(slotKey, firstBtn); });
      });

      // ë‘ ë²ˆì§¸ ì„ íƒì¹¸ = ë§ˆë´‰ ì„ íƒ ì—°ê²°
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot');
        const code = slotEl?.getAttribute('data-slot');
        const slotKey = SLOT_MAP[code];
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!slotKey || rects.length < 2) return;

        const secondBtn = rects[1];
        // ê¸°ë³¸ ë¼ë²¨
        secondBtn.textContent = 'ë§ˆë´‰ ì„¤ì •';

        // ì¤‘ë³µ ë°”ì¸ë”© ë°©ì§€ (í˜ì´ì§€ ì¬ë Œë” ì‹œ ë‹¤ì¤‘ ë“±ë¡ ì˜ˆë°©)
        if (secondBtn.dataset.boundSeal === '1') return;
        secondBtn.dataset.boundSeal = '1';

        secondBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof openSealModal === 'function') {
            // slotKeyì— ë§ëŠ” 3ë¶„í•  ëª¨ë‹¬ ì—´ê¸° (ê³ ìœ /ì¼ë°˜1/ì¼ë°˜2)
            openSealModal(slotKey, secondBtn);
          } else {
            console.warn('openSealModal í•¨ìˆ˜ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
          }
        });
      });

      // === [REFINE] 4ë²ˆì§¸ ì„¸ë¶€ë²„íŠ¼ ë¼ë²¨/ì—­í•  ì„¸íŒ… ===
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot');
        const code = slotEl?.getAttribute('data-slot');       // ì˜ˆ: R1, R5 ...
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!code || rects.length < 4) return;

        // R1(ë¬´ê¸°)ê³¼ R5(ë³´ì¡°ì¥ë¹„)ë§Œ í™œì„±í™”
        if (code === 'R1' || code === 'R5') {
          const fourth = rects[3]; // 4ë²ˆì§¸ ë²„íŠ¼
          fourth.textContent = 'ì—°ë§ˆ ì„¤ì •';
          fourth.dataset.role = 'refine';
          fourth.removeAttribute('data-unused');
          fourth.removeAttribute('aria-disabled');
          fourth.disabled = false;
          fourth.classList.remove('disabled', 'is-disabled');
          fourth.style.pointerEvents = '';
        }
      });



      // ì¹­í˜¸ ì™¼ìª½ ë‘ ì„ íƒì¹¸ ë¹„í™œì„±í™”
      document.querySelectorAll('[data-unused="true"]').forEach(b => { b.classList.add('disabled'); b.title = 'ì¶”í›„ ì‚¬ìš© ì˜ˆì •'; });
      // ì— ë¸”ë ˜ ì†Œì¼“ ì£¼ì…
      injectEmblemDots();
      const btnRune = document.getElementById('btnRune');
      if (btnRune) { btnRune.addEventListener('click', openRuneModal); }
      ensureRunesInitialized();
      updateRuneCountSummary();

      // ë£¬ ê°ì¸ ë“œë¡­ë‹¤ìš´ ë°”ì¸ë”©
      const selRuneEngrave = document.getElementById('selRuneEngrave');
      const selRuneDetail = document.getElementById('selRuneDetail');

      if (selRuneEngrave) {
        selRuneEngrave.addEventListener('change', async () => {
          // ì´ë¦„ ì„ íƒ/ë³€ê²½ ì‹œ: ì„¸ë¶€ì„¤ì • ì´ˆê¸°í™” + ë¹„í™œì„±í™” â†’ ìƒˆ ëª©ë¡ êµ¬ì„± í›„ í™œì„±í™”
          state.runeEngrave = null;
          if (selRuneDetail) {
            selRuneDetail.innerHTML = `<option value="" selected disabled>ì„¸ë¶€ ì„¤ì •</option>`;
            selRuneDetail.disabled = true;
          }
          const pickedName = selRuneEngrave.value || null;
          if (pickedName) {
            await populateRuneDetailOptions(pickedName);   // ëª©ë¡ ì±„ìš°ê¸°
            if (selRuneDetail) selRuneDetail.disabled = false; // í™œì„±í™”
          }
          // ì„¸ë¶€ ì„¤ì •ì´ ì•„ì§ ì„ íƒë˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ í•©ì‚°ì€ ì—¬ê¸°ì„œ í•˜ì§€ ì•ŠìŒ
        });
      }

      if (selRuneDetail) {
        selRuneDetail.addEventListener('change', () => {
          const name = selRuneEngrave?.value || null;
          const tag = selRuneDetail.value || null;
          if (name && tag) {
            applyRuneEngraveByNameTag(name, tag); // ì¦‰ì‹œ í•©ì‚° ë°˜ì˜
          } else {
            state.runeEngrave = null;
            recalcAndRenderPanel();
          }
        });
      }

      console.log('[Init] Ready. Click slots to load sheets. First select = ê°•í™”. Dots = ì— ë¸”ë ˜.');
    });

    // === ë°ì´í„° ë¡œë”ë“¤ (loadCharacterSheet, loadSkillSheet ë“±) ì •ì˜ ëë‚œ ë’¤ ===
    // ì „ì—­ í•œ ë²ˆë§Œ
    let __preloadingPromise = null;
    let __preloaded = false;

    async function preloadAllSheetsOnce(opts) {
      if (__preloaded) return;
      if (__preloadingPromise) return __preloadingPromise;
      __preloadingPromise = (async () => {
        try { await preloadAllSheets(opts); __preloaded = true; }
        finally { __preloadingPromise = null; }
      })();
      return __preloadingPromise;
    }
    // â˜… ì¶”ê°€: ëª¨ë“  ì‹œíŠ¸ë¥¼ ë¯¸ë¦¬ ë¡œë“œ
    // â¬‡ ê¸°ì¡´ preloadAllSheets ì •ì˜ë¥¼ 'ì™„ì „íˆ' ì•„ë˜ ì½”ë“œë¡œ êµì²´


  </script>
  <div id="autoEnhModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEnhTitle">
      <header>
        <h3 id="autoEnhTitle">ê°•í™” ìë™ ì…ë ¥</h3><button class="close" data-close>âœ•</button>
      </header>
      <div class="list" id="autoEnhList"></div>
    </div>
  </div>
  <div id="autoEnchantModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEnchantTitle">
      <header>
        <h3 id="autoEnchantTitle">ì¶”ì²œ ë§ˆë²•ë¶€ì—¬</h3>
        <button class="close" data-close>âœ•</button>
      </header>
      <div class="body two-col">
        <div class="col left">
          <div class="title">ì†ì„± ì„ íƒ</div>
          <div class="list attrs"></div>
        </div>
        <div class="col right">
          <div class="title">ì¶”ì²œ í‹°ì–´</div>
          <div class="list tiers"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="autoEmblemModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEmblemTitle">
      <header>
        <h3 id="autoEmblemTitle">ì— ë¸”ë ˜ ìë™ ì…ë ¥</h3><button class="close" data-close>âœ•</button>
      </header>
      <div class="list" id="autoEmblemList"></div>
    </div>
  </div>

  <div id="autoSealModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoSealTitle">
      <header>
        <h3 id="autoSealTitle">ì¶”ì²œ ë§ˆë²•ë´‰ì¸</h3>
        <button class="close" data-close>âœ•</button>
      </header>
      <div class="list">
        <button class="opt-btn" data-ele="fire">í™”ì†ì„±</button>
        <button class="opt-btn" data-ele="water">ìˆ˜ì†ì„±</button>
        <button class="opt-btn" data-ele="light">ëª…ì†ì„±</button>
        <button class="opt-btn" data-ele="dark">ì•”ì†ì„±</button>
      </div>
    </div>
  </div>

  <script>

    /* ===== Auto Input: Helpers ===== */

    /* Reflect chosen enhance names on first rect of each slot */
    function refreshEnhLabelsFromState() {
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot');
        const code = slotEl?.getAttribute('data-slot');
        const slotKey = SLOT_MAP[code];
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!slotKey || !rects.length) return;
        const up = state.upgrades?.[slotKey];
        rects[0].textContent = up?.name || 'ê°•í™” ì„¤ì •';
      });
    }

    const REVERSE_SLOT_MAP = Object.fromEntries(Object.entries(SLOT_MAP).map(([k, v]) => [v, k]));
    function firstEnhButtonFor(slotKey) {
      const code = REVERSE_SLOT_MAP[slotKey]; if (!code) return null;
      const row = document.querySelector(`.slot-row .slot[data-slot="${code}"]`)?.closest('.slot-row');
      if (!row) return null;
      return row.querySelector('.outer-rects .rect');
    }

    function matchEnhByLevelName(list, level) {
      const want = Number(level);
      const pattern1 = new RegExp(String.raw`(?:^|[^\d])${want}\s*ê°•`);
      const pattern2 = new RegExp(String.raw`\+\s*${want}(?:[^\d]|$)`);
      const pattern3 = new RegExp(String.raw`(?:^|[^\d])${want}(?:[^\d]|$)`);
      let best = null;
      for (const o of list) {
        const name = (o.name || '').trim();
        if (pattern1.test(name) || pattern2.test(name)) return o;
        if (!best && pattern3.test(name)) best = o;
      }
      return best || list.find(o => String(o.name || '').includes(String(want))) || null;
    }


    async function autoEnhanceApply(level) {
      try {
        await ensureEnhLoaded();
      } catch (e) { console.warn('ensureEnhLoaded failed', e); }
      const lvl = Number(level) || 0;
      const sets = {
        weapon: 'ë¬´ê¸°ê°•í™”',
        headshoulder: 'ë°©ì–´êµ¬ê°•í™”', top: 'ë°©ì–´êµ¬ê°•í™”', bottom: 'ë°©ì–´êµ¬ê°•í™”', belt: 'ë°©ì–´êµ¬ê°•í™”', shoes: 'ë°©ì–´êµ¬ê°•í™”',
        bracelet: 'ì•…ì„¸ê°•í™”', necklace: 'ì•…ì„¸ê°•í™”', ring: 'ì•…ì„¸ê°•í™”',
        support: 'ë³´ì¥ê°•í™”'
      };
      const slots = Object.keys(sets);
      let success = 0;
      for (const sk of slots) {
        const type = sets[sk];
        let list = (DBEnh?.byType?.[type] || []).slice();
        if (!list.length && Array.isArray(DBEnh?.list)) {
          list = DBEnh.list.filter(o => String(o?.type || '').includes(type));
        }
        const pick = matchEnhByLevelName(list, lvl);
        if (!pick) { console.warn('No enhance match for', sk, type, lvl); continue; }
        state.upgrades[sk] = pick;
        success++;
      }
      // Re-render totals/panels
      if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
      // Refresh button labels from state after re-render
      if (typeof refreshEnhLabelsFromState === 'function') refreshEnhLabelsFromState();
      return success;
    }


    /* ===== Auto Emblem Apply: stage 5~15 ===== */
    async function autoEmblemApply(stage) {
      await ensureEnhLoaded();
      const stageNum = Number(stage) || 0;
      const slots = ['headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring', 'weapon'];
      for (const sk of slots) {
        ensureEmblemArray(sk);
        const types = SOCKET_RULES[sk] || [];
        let useTypes = types.slice();
        if (sk === 'weapon') useTypes = ['ë¶‰ì€ë¹›ì— ë¸”ë ˜']; // ìš”êµ¬ì‚¬í•­
        const picks = [];
        useTypes.forEach(t => {
          const arr = (DBEnh.byType[t] || []).filter(it => it.level_num === stageNum);
          if (arr.length) picks.push(arr[0]);
        });
        const pick = picks[0] || null;
        const count = SOCKET_COUNT(sk);
        for (let i = 0; i < count; i++) {
          state.emblems[sk][i] = pick ?
            { img: pick.img, level_num: pick.level_num, stats: pick.stats, tag: pick.tag } : null;
          paintEmblemDot(sk, i);
        }
      }
      recalcAndRenderPanel();
    }
    const AUTO_ATTRS = ['í™”ì†ì„±', 'ìˆ˜ì†ì„±', 'ëª…ì†ì„±', 'ì•”ì†ì„±'];
    const AUTO_TIERS = ['ì¢…ê²°', 'ì¤€ì¢…ê²°', 'ë³´í†µ', 'ê°€ì„±ë¹„'];
    const autoEnchantState = { attr: null, tier: null };

    // ì „ì—­ ìƒíƒœ ì˜ˆì‹œ:
    // const autoEnchantState = { attr: null, tier: null };

    function renderAutoEnchantChoices() {
      const m = document.getElementById('autoEnchantModal');
      const wrapAttrs = m.querySelector('.list.attrs');
      const wrapTiers = m.querySelector('.list.tiers');
      wrapAttrs.innerHTML = '';
      wrapTiers.innerHTML = '';

      const makeBtn = (txt, group) => {
        const b = document.createElement('button');
        b.className = 'opt-btn';
        b.type = 'button';
        b.textContent = txt;
        b.setAttribute('role', 'button');
        b.setAttribute('aria-pressed', 'false');
        b.addEventListener('click', () => {
          if (group === 'attr') autoEnchantState.attr = txt;
          else autoEnchantState.tier = txt;

          updateAutoActive();        // âœ… ì¦‰ì‹œ ì‹œê° ê°•ì¡°
          tryApplyAutoIfReady();     // ë‘ ê°’ì´ ëª¨ë‘ ì„ íƒë˜ë©´ ì ìš©+ë‹«ê¸°
        });
        return b;
      };

      ['í™”ì†ì„±', 'ìˆ˜ì†ì„±', 'ëª…ì†ì„±', 'ì•”ì†ì„±'].forEach(a => wrapAttrs.appendChild(makeBtn(a, 'attr')));
      ['ì¢…ê²°', 'ì¤€ì¢…ê²°', 'ë³´í†µ', 'ê°€ì„±ë¹„'].forEach(t => wrapTiers.appendChild(makeBtn(t, 'tier')));

      // ì—´ ë•Œ ì´ˆê¸°í™” ìƒíƒœ ë°˜ì˜(ë‘˜ ë‹¤ nullì´ë©´ ì „ë¶€ ë¹„í™œì„± í‘œì‹œ)
      updateAutoActive();
    }
    // === [ENCHANT][AUTO] ì§ì—…êµ° í…ìŠ¤íŠ¸ ì–»ê¸°
    function getJobGroupText(opt) {
      if (!opt) return '';
      if (opt.jobGroup) return String(opt.jobGroup).trim();
      const raw = opt.raw || {};
      return String(raw['ì§ì—…êµ°'] ?? raw.jobGroup ?? raw['ë¶„ë¥˜'] ?? '').trim();
    }

    // === [ENCHANT][AUTO] ì§ì—…êµ°ìœ¼ë¡œ ì˜µì…˜ ì°¾ê¸°
    function findEnchantByJobGroup(typeKey, keyword) {
      const list = ENCHANT_CACHE.byType.get(String(typeKey).trim()) || [];
      const kw = String(keyword || '').trim();
      if (!kw) return null;

      // 1ìˆœìœ„: ì§ì—…êµ°ì—´ í¬í•¨
      let hit = list.find(o => getJobGroupText(o).includes(kw));
      if (hit) return hit;

      // 2ìˆœìœ„(í´ë°±): ì´ë¦„ì—ë¼ë„ í¬í•¨
      hit = list.find(o => String(o.name || '').includes(kw));
      return hit || null;
    }

    // ë‘ ê·¸ë£¹ì—ì„œ ë‹¨ì¼ ì„ íƒ ê°•ì¡°
    function updateAutoActive() {
      const modal = document.getElementById('autoEnchantModal');
      const mark = (selector, pickedText) => {
        modal.querySelectorAll(selector).forEach(btn => {
          const on = (btn.textContent.trim() === (pickedText || ''));
          btn.classList.toggle('active', on);
          btn.setAttribute('aria-pressed', on ? 'true' : 'false');
        });
      };
      mark('.list.attrs .opt-btn', autoEnchantState.attr);
      mark('.list.tiers .opt-btn', autoEnchantState.tier);
    }


    // ë§¨ ìœ„ í¸í•œ ê³³ì— ì¶”ê°€
    const $autoEnchantModal = document.getElementById('autoEnchantModal');

    // ê¸°ì¡´ í•¨ìˆ˜ êµì²´
    function tryApplyAutoIfReady() {
      if (autoEnchantState.attr !== null && autoEnchantState.tier !== null) {
        applyAutoEnchant(autoEnchantState.attr, autoEnchantState.tier);
        autoEnchantState.attr = null;
        autoEnchantState.tier = null;
        showModal(document.getElementById('autoEnchantModal'), false);
      }
    }

    // === [ENCHANT][AUTO] ì†ì„±+í‹°ì–´/í‹°ì–´ë§Œ ê·œì¹™ëŒ€ë¡œ ì „ì²´ ìë™ ì ìš©
    async function applyAutoEnchant(attr, tier) {
      await ensureEnchantCache();

      const combo = `${attr}${tier}`;

      // ë¬´ê¸°/íŒ”ì°Œ/ëª©ê±¸ì´/ë°˜ì§€ = ì†ì„±+í‹°ì–´, ê·¸ ì™¸ = í‹°ì–´ë§Œ
      const USE_COMBO = new Set(['ë¬´ê¸°ë§ˆë¶€', 'íŒ”ì°Œë§ˆë¶€', 'ëª©ê±¸ì´ë§ˆë¶€', 'ë°˜ì§€ë§ˆë¶€']);
      const USE_TIER = new Set(['ë¨¸ë¦¬ì–´ê¹¨ë§ˆë¶€', 'ìƒì˜ë§ˆë¶€', 'í•˜ì˜ë§ˆë¶€', 'í—ˆë¦¬ë§ˆë¶€', 'ì‹ ë°œë§ˆë¶€', 'ë³´ì¥ë§ˆë¶€', 'ì¹­í˜¸ë§ˆë¶€']);

      const targetSlots = ['R1', 'R2', 'R3', 'R4', 'R5', 'L1', 'L2', 'L3', 'L4', 'L5', 'C2'];

      const applied = [];
      const prev = state.currentSlotKey;

      for (const slotCode of targetSlots) {
        const typeKey = enchantTypeForSlot(slotCode); // ì˜ˆ: R1 -> 'ë¬´ê¸°ë§ˆë¶€'
        if (!typeKey) continue;

        const keyToUse = USE_COMBO.has(typeKey) ? combo
          : USE_TIER.has(typeKey) ? tier
            : null;
        if (!keyToUse) continue;

        const opt = findEnchantByJobGroup(typeKey, keyToUse); // â† 1)ì—ì„œ ë§Œë“  í—¬í¼
        if (!opt) continue;

        // ì‹¤ì œ ì ìš© (state ì €ì¥ + ë²„íŠ¼ ë¼ë²¨ ê°±ì‹  + ì¬ê³„ì‚°)
        state.currentSlotKey = slotCode;
        applyEnchantSelection(opt);
        applied.push({ slot: slotCode, name: opt.name });
      }

      state.currentSlotKey = prev;

      if (!applied.length) {
        (typeof toast === 'function' ? toast : alert)('ì¡°ê±´ì— ë§ëŠ” ì¶”ì²œ ë§ˆë²•ë¶€ì—¬ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
      }
    }





    /* ===== Bind Auto Panels ===== */
    document.addEventListener('DOMContentLoaded', () => {
      const autoEnhModal = document.getElementById('autoEnhModal');
      const autoEnhList = document.getElementById('autoEnhList');
      const autoEmblemModal = document.getElementById('autoEmblemModal');
      const autoEmblemList = document.getElementById('autoEmblemList');
      const autoEnchantModal = document.getElementById('autoEnchantModal');
      // â–¼ ì¶”ì²œ ë§ˆë²•ë´‰ì¸ ìë™ ì…ë ¥ ë²„íŠ¼ í™œì„±í™” + ëª¨ë‹¬ ì˜¤í”ˆ
      const btnAutoSeal = document.getElementById('btnAutoSeal');
      if (btnAutoSeal) {
        // í˜¹ì‹œ ë‚¨ì•„ìˆì„ì§€ ëª¨ë¥´ëŠ” ì†ì„± ì •ë¦¬(ì´ì¤‘ì•ˆì „)
        btnAutoSeal.disabled = false;
        btnAutoSeal.removeAttribute('title');

        btnAutoSeal.addEventListener('click', () => {
          const modal = document.getElementById('autoSealModal');
          if (modal) {
            modal.classList.add('show');
            modal.setAttribute('aria-hidden', 'false');
          }
        });
      }

      // â–¼ ì¶”ì²œ ë§ˆë²•ë´‰ì¸ ëª¨ë‹¬ ë‹«ê¸° ë° ë²„íŠ¼ í´ë¦­ ì²˜ë¦¬(ì„ íƒ ì‹œ ë‹«ê¸°)
      const autoSealModal = document.getElementById('autoSealModal');
      if (autoSealModal) {
        autoSealModal.addEventListener('click', (e) => {
          if (
            e.target.hasAttribute('data-close') ||
            e.target.classList.contains('backdrop')
          ) {
            autoSealModal.classList.remove('show');
            autoSealModal.setAttribute('aria-hidden', 'true');
          }
        });

        // 4ê°œ ì†ì„± ë²„íŠ¼(í™”/ìˆ˜/ëª…/ì•”) í´ë¦­ ì‹œ ë™ì‘(í˜„ì¬ëŠ” ëª¨ë‹¬ë§Œ ë‹«ê¸°)
        autoSealModal.querySelectorAll('.opt-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            // TODO: ì—¬ê¸°ì„œ ì„ íƒí•œ ì†ì„±ì— ë§ì¶° 'ì¶”ì²œ ë§ˆë²•ë´‰ì¸ ìë™ ì…ë ¥' ë¡œì§ì„ ì´ì–´ê°€ë©´ ë©ë‹ˆë‹¤.
            // const element = btn.dataset.ele; // "fire" | "water" | "light" | "dark"

            autoSealModal.classList.remove('show');
            autoSealModal.setAttribute('aria-hidden', 'true');
          });
        });
      }

      // Build level buttons 10~20
      if (autoEnhList) {
        autoEnhList.innerHTML = '';
        for (let lv = 10; lv <= 20; lv++) {
          const b = document.createElement('button'); b.className = 'opt-btn'; b.textContent = `${lv}ê°•`;
          b.addEventListener('click', async () => { await autoEnhanceApply(lv); autoEnhModal.classList.remove('show'); autoEnhModal.setAttribute('aria-hidden', 'true'); });
          autoEnhList.appendChild(b);
        }
      }
      // Build emblem stage buttons 5~15
      if (autoEmblemList) {
        autoEmblemList.innerHTML = '';
        for (let lv = 5; lv <= 15; lv++) {
          const b = document.createElement('button');
          b.className = 'opt-btn'; b.textContent = `${lv}ë‹¨ê³„`;
          b.addEventListener('click', async () => { await autoEmblemApply(lv); autoEmblemModal.classList.remove('show'); autoEmblemModal.setAttribute('aria-hidden', 'true'); });
          autoEmblemList.appendChild(b);
        }
      }

      // Openers
      document.getElementById('btnAutoEnh')?.addEventListener('click', () => {
        autoEnhModal.classList.add('show'); autoEnhModal.setAttribute('aria-hidden', 'false');
      });
      document.getElementById('btnAutoEmblem')?.addEventListener('click', () => {
        autoEmblemModal.classList.add('show'); autoEmblemModal.setAttribute('aria-hidden', 'false');
      });
      document.getElementById('btnAutoEnchant')?.addEventListener('click', () => {
        // ëª¨ë‹¬ ì—´ê¸°ë§Œ; ë‹«ê¸°ëŠ” tryApplyAutoIfReadyì—ì„œ ë‘ ê°’ì´ ëª¨ë‘ ì„ íƒëì„ ë•Œë§Œ
        autoEnchantState.attr = null;
        autoEnchantState.tier = null;
        renderAutoEnchantChoices();
        showModal(document.getElementById('autoEnchantModal'), true);
      });
      // Modal close bindings
      document.querySelectorAll('#autoEnhModal, #autoEmblemModal, #autoEnchantModal').forEach(modal => {
        modal.addEventListener('click', (e) => {
          if (e.target.hasAttribute('data-close') || e.target.classList.contains('close') || e.target.classList.contains('backdrop')) {
            modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true');
          }
        });
      });
      /* ===== [SEAL][AUTO] ì¶”ì²œ ë§ˆë²•ë´‰ì¸ ìë™ ì…ë ¥ ===== */

      // ìŠ¬ë¡¯ì½”ë“œ â†’ "ë§ˆë²•ë¶€ì—¬ ì¢…ë¥˜í‚¤"ì™€ ë³„ê°œë¡œ, ë´‰ì¸ìš© "ì¢…ë¥˜" ë§¤í•‘
      // - ë¬´ê¸°ë¶€ìœ„: ë¬´ê¸°ê³ ìœ  / ë¬´ê¸°ì¼ë°˜
      // - ë°©ì–´ë¶€ìœ„(L1~L5): ë°©ì–´ê³ ìœ  / ë°©ì–´ì¼ë°˜
      // - ë³´ì¡°ì¥ë¹„(R5): ë³´ì¥ê³ ìœ  / ë³´ì¥ì¼ë°˜
      // - ì•¡ì„¸ì„œë¦¬(R2~R4): ì•…ì„¸ê³ ìœ  / ì•…ì„¸ì¼ë°˜  (â† ì†ì„±ìœ¼ë¡œ ì°¾ê¸°)
      function sealTypeForSlot(slotCode) {
        switch (String(slotCode).toUpperCase()) {
          case 'R1': return { unique: 'ë¬´ê¸°ê³ ìœ ', general: 'ë¬´ê¸°ì¼ë°˜' };
          case 'R5': return { unique: 'ë³´ì¥ê³ ìœ ', general: 'ë³´ì¥ì¼ë°˜' };
          case 'R2':
          case 'R3':
          case 'R4': return { unique: 'ì•…ì„¸ê³ ìœ ', general: 'ì•…ì„¸ì¼ë°˜' };
          default: return { unique: 'ë°©ì–´ê³ ìœ ', general: 'ë°©ì–´ì¼ë°˜' }; // L1~L5
        }
      }

      // í˜„ì¬ ì„ íƒ ìºë¦­í„°ì˜ ê³µê²© ë¶„ë¥˜ë¥¼ 'ë¬¼ë¦¬' / 'ë§ˆë²•'ë¡œ ë³€í™˜
      function jobGroupKeyFromState() {
        const p = state?.currentCharacter?.power;
        return p === 'mag' ? 'ë§ˆë²•' : 'ë¬¼ë¦¬';
      }

      // ì‹œíŠ¸ì˜ ì†ì„± í•œê¸€ í‚¤ ë§¤í•‘
      const ELEM_KOR = { fire: 'í™”', water: 'ìˆ˜', light: 'ëª…', dark: 'ì•”' };

      // byType ìºì‹œì—ì„œ ì¡°ê±´(ì§ì—…êµ°/ì†ì„±)ì— ë§ëŠ” "ì²« ë²ˆì§¸" ë´‰ì¸ ì˜µì…˜ì„ ì°¾ì•„ ë°˜í™˜
      function findSealOption(typeKey, { jobKey, elemKor }) {
        const key = String(typeKey).trim();
        const list = ENCHANT_CACHE.byType.get(String(typeKey).trim()) || [];
        // ì•…ì„¸ëŠ” ì†ì„±ìœ¼ë¡œ, ë‚˜ë¨¸ì§€ëŠ” ì§ì—…êµ°ìœ¼ë¡œ ì°¾ëŠ”ë‹¤
        const isAcc = typeKey.startsWith('ì•…ì„¸');
        if (key === 'ë¬´ê¸°ê³ ìœ ') {
          const isCommon = (v) => {
            const s = String(v || '').trim();
            return ['ê³µìš©', 'ê³µí†µ', 'ALL', 'ë¬´ê¸°ê³µìš©'].includes(s);
          };
          // 1ìˆœìœ„: ì§ì—…êµ°ì—´ì´ ê³µìš©/ALLë¥˜ì¸ í–‰
          const pick =
            list.find(it => isCommon((it.raw && it.raw['ì§ì—…êµ°']) ?? it.jobGroup)) ||
            list[0] || null; // 2ìˆœìœ„: ì²« í–‰(ì—†ìœ¼ë©´ null)
          return pick;
        }
        for (const it of list) {
          const raw = it.raw || {};
          if (isAcc) {
            const v = String(raw['ì§ì—…êµ°'] ?? raw['element'] ?? raw['elem'] ?? '').trim();
            if (v === elemKor) return it;
          } else {
            const v = String(raw['ì§ì—…êµ°'] ?? it.jobGroup ?? '').trim();
            if (v === jobKey) return it;
          }
        }
        return null;
      }

      // ë„ìš°ë¯¸: rawì—ì„œ ìµœì†Œí•œì˜ ìŠ¤íƒ¯ì„ ë½‘ì•„ë‚´ëŠ” ë³´ì¡° (ì‹œíŠ¸ì— statsê°€ ì—†ì„ ë•Œ ëŒ€ë¹„)
      function statsFrom(opt) {
        if (!opt) return null;
        // ENCHANT_CACHE í”„ë¦¬ë¡œë“œì—ì„œ ì´ë¯¸ obj.statsë¥¼ ì‚´ë ¤ë‘ . ì—†ìœ¼ë©´ rawì—ì„œ í•„ìš”í•œ í‚¤ë§Œ ìµœì†Œ ì¶”ì¶œ
        return opt.stats || null; // í•„ìš”ì‹œ raw ê¸°ë°˜ íŒŒì‹± ì¶”ê°€
      }

      // ì‹¤ì œ ì ìš©: ì†ì„± í´ë¦­ ì‹œ ì „ ìŠ¬ë¡¯ì— ë§ëŠ” ê³ ìœ /ì¼ë°˜ì„ ì°¾ì•„ state.sealsì— ì €ì¥ + ìº¡ì…˜ ê°±ì‹ 
      async function applyAutoSeal(elementKey) {
        await ensureEnchantCache();             // ì‹œíŠ¸ ìºì‹œ ë³´ì¥ (ê¸°ì¡´ ìºì‹œ ì‚¬ìš©)
        const elemKor = ELEM_KOR[elementKey] || '';
        const jobKey = jobGroupKeyFromState(); // 'ë¬¼ë¦¬' or 'ë§ˆë²•'
        const targetSlots = ['R1', 'R2', 'R3', 'R4', 'R5', 'L1', 'L2', 'L3', 'L4', 'L5'];

        state.seals = state.seals || {};

        for (const slotCode of targetSlots) {
          const types = sealTypeForSlot(slotCode);
          const u = findSealOption(types.unique, { jobKey, elemKor });
          const g = findSealOption(types.general, { jobKey, elemKor });

          // ìŠ¬ë¡¯í‚¤(SLOT_MAP: 'R1'â†’ì‹¤ì œ ë‚´ë¶€í‚¤ ë“±)ë¥¼ ì–»ì–´ì„œ ìƒíƒœì— ë°˜ì˜
          const slotKey = (window.SLOT_MAP || {})[slotCode];
          if (!slotKey) continue;

          // ì ìš© ê·œì¹™: ê³ ìœ  1ê°œ + ì¼ë°˜ 2ê°œ(ë™ì¼ ì¼ë°˜ì¼ ê²½ìš° gë¥¼ ë‘ ì¹¸ ë³µì œ)
          // (ì‹œíŠ¸ ì„¤ê³„ìƒ ì¼ë°˜ì´ 2ì¢…ìœ¼ë¡œ êµ¬ë¶„ë¼ ìˆë‹¤ë©´ ì—¬ê¸°ë¥¼ í™•ì¥)
          // ì ìš© ê·œì¹™: ê³ ìœ  1 + ì¼ë°˜ 2
          state.seals[slotKey] = {
            unique: u ? { name: u.name, typeKey: u.typeKey, stats: statsFrom(u), raw: u.raw } : null,
            general1: g ? { name: g.name, typeKey: g.typeKey, stats: statsFrom(g), raw: g.raw } : null,
            general2: g ? { name: g.name, typeKey: g.typeKey, stats: statsFrom(g), raw: g.raw } : null,
          };

          // ìŠ¬ë¡¯ ì¹©(ë¼ë²¨) ì¦‰ì‹œ ê°±ì‹ 
          refreshSealCaptionsForSlot(slotKey);
          // ì´ë¯¸ ì½”ë“œì— ì¡´ì¬í•˜ëŠ” ìœ í‹¸ ì¬ì‚¬ìš© :contentReference[oaicite:5]{index=5}
        }
        // âœ… ì—¬ê¸°ì„œ ì „ì²´ ê°±ì‹  + ë²„íŠ¼ ë¼ë²¨ + í•©ì‚°
        // ì „ì²´ ì¹© ë¦¬í”„ë ˆì‹œ(í™”ë©´ ë™ê¸°í™”)
        refreshSealCaptionsFromState();

        // ë‘ ë²ˆì§¸ ë²„íŠ¼ ë¼ë²¨ì„ 'ë§ˆë´‰ ì„¤ì •ì™„ë£Œ'ë¡œ ì¼ê´„ ê°±ì‹ 
        if (typeof refreshSealLabelsFromState === 'function') {
          refreshSealLabelsFromState();
        }

        // í•©ì‚° ì¬ê³„ì‚° + ìš°ì¸¡ íŒ¨ë„ ë Œë”
        if (typeof recalcAndRenderPanel === 'function') {
          recalcAndRenderPanel();
        }

        // ëª¨ë‹¬ ë‹«ê¸°
        const modal = document.getElementById('autoSealModal');
        if (modal) { modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true'); }
      }

      // â–¼ ëª¨ë‹¬ì˜ ì†ì„± ë²„íŠ¼ê³¼ ì—°ê²°
      const $autoSealModal = document.getElementById('autoSealModal');
      if ($autoSealModal) {
        $autoSealModal.querySelectorAll('.opt-btn[data-ele]').forEach(btn => {
          btn.addEventListener('click', () => {
            const ele = btn.getAttribute('data-ele'); // 'fire' | 'water' | 'light' | 'dark'
            applyAutoSeal(ele);
          });
        });
      }

    });

  </script>
  <script>
    // ===== BuffLeveling: "ë ˆë²¨ë§(N)" í•©ì‚° â†’ì˜ ìŠ¤í‚¬ë ™ì œ=Nì— ì ìš© =====
    // (ê¸°ì¡´ ëª¨ë“ˆ êµ¬ì¡° ìœ ì§€, preload()ë§Œ êµì²´)

    window.BuffLeveling = (() => {
      const cache = { ready: false, rows: [] };

      // ìˆ«ì/í¼ì„¼íŠ¸ íŒŒì„œ â€” ê·¸ëŒ€ë¡œ ìœ ì§€
      const num = v => {
        const n = Number(String(v ?? "").replace(/[, ]/g, ""));
        return Number.isFinite(n) ? n : 0;
      };
      const pct = v => num(v) / 100;

      // ë ˆë²¨0 ê¸°ì¤€ stats â€” ê·¸ëŒ€ë¡œ ìœ ì§€
      function rowToBaseStats(r) {
        return {
          phys_atk: num(r["ë¬¼ë€"]), mag_atk: num(r["ë§ˆë€"]),
          str: num(r["í˜"]), int: num(r["ì§€ëŠ¥"]),
          acc: num(r["ì ì¤‘"]),
          phys_crit: num(r["ë¬¼í¬"]) || num(r["ë¬¼/ë§ˆí¬"]),
          mag_crit: num(r["ë§ˆí¬"]) || num(r["ë¬¼/ë§ˆí¬"]),
          phys_crit_rate: pct(r["ë¬¼í¬(%)"]),
          mag_crit_rate: pct(r["ë§ˆí¬(%)"]),
          add_damage: pct(r["ì¶”ë€(%)"]),
          damage_inc: pct(r["ë€ì¦(%)"]),
          crit_damage_inc: pct(r["í¬ì¦ë€(%)"]),
          phys_atk_pct: pct(r["ë¬¼ê³µ(%)"]),
          mag_atk_pct: pct(r["ë§ˆê³µ(%)"]),
          skill_atk_inc: pct(r["ìŠ¤ì¦(%)"]),
          elem: {
            fire: num(r["í™”"]), water: num(r["ìˆ˜"]), light: num(r["ëª…"]), dark: num(r["ì•”"]), all: 0
          },
          elem_add_damage: {
            fire: pct(r["í™”ì†ì¶”"]), water: pct(r["ìˆ˜ì†ì¶”"]), light: pct(r["ëª…ì†ì¶”"]), dark: pct(r["ì•”ì†ì¶”"])
          },
          speed: { attack: pct(r["ê³µì†(%)"]), move: pct(r["ì´ì†(%)"]), cast: pct(r["ìºì†(%)"]) },
          cdr: pct(r["ì¿¨ê°(%)"]),
          dot_add: { poison: 0, bleed: pct(r["ì¶œí˜ˆì¶”ë€"]), burn: pct(r["í™”ìƒì¶”ë€"]), shock: pct(r["ê°ì „ì¶”ë€"]) },
          dot_inc: { poison: 0, bleed: pct(r["ì¶œí˜ˆë€ì¦"]), burn: pct(r["í™”ìƒë€ì¦"]), shock: pct(r["ê°ì „ë€ì¦"]) },
          other: { def_break_inc: pct(r["ë°©ê¹ë€ì¦(%)"]), enchant_bleed: num(r["ì¸ì±ˆì¶œí˜ˆ"]) }
        };
      }

      // í‚¤ ì •ê·œí™” ìœ í‹¸
      function normVal(s) {
        return String(s ?? '')
          .normalize('NFC')
          .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
          .replace(/\s+/g, '');
      }

      // â˜… preload(): CSV â†’ (ë³€ê²½) í”„ë¡ì‹œ&ë°±ì—”ë“œ JSON
      async function preload() {
        if (cache.ready) return;

        // 1) ë¡œê·¸ì¸ í† í° í™•ë³´
        const token = await waitForIdToken();

        // 2) í”„ë¡ì‹œ â†’ Apps Script: ?type=buff
        const r = await fetch(window.WEBAPP_URL + '?type=buff', {
          method: 'POST',
          mode: 'cors',
          cache: 'no-store',
          headers: { 'Content-Type': 'text/plain' },
          body: token
        });
        if (!r.ok) throw new Error('buff_fetch_failed');
        const data = await r.json();
        if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_buff_payload');

        // 3) __charKey ìƒì„±(ì§ì—…êµ°+ìºë¦­í„°ëª… ì •ê·œí™”) + ì›ë³¸ ì»¬ëŸ¼ ìœ ì§€
        const normVal = (v) => String(v ?? '')
          .normalize('NFC')
          .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
          .replace(/\s+/g, '');

        cache.rows = data.rows.map(row => {
          const job = row['ì§ì—…êµ°'] || row['ì§ì—…'] || '';
          const name = row['ìºë¦­í„°'] || row['ìºë¦­í„°ëª…'] || row['ìºë¦­ëª…'] || row['ì§ì—…ëª…'] || '';
          const charKey = normVal(job + name) || normVal(name);
          return { ...row, __charKey: charKey };
        });

        console.log('[BUFF-DEBUG] BUFF rows:', cache.rows.length,
          'ìƒ˜í”Œ __charKey:', cache.rows.slice(0, 5).map(r => r.__charKey));

        cache.ready = true;
      }

      // (ì¤‘ëµ) â€” ë„¤ ì½”ë“œì˜ computeBuffStats(), addStats/scaleAdd ë“± ê¸°ì¡´ ë¡œì§ì€ ê·¸ëŒ€ë¡œ ì‚¬ìš©
      // ë‹¨, computeBuffStats()ê°€ cache.rowsë¥¼ ì°¸ì¡°í•˜ë„ë¡ ìœ ì§€í•˜ë©´ ë¨
      // base Ã— (1 + ì¦ê°€ìœ¨ Ã— level)
      function scale(base, rate, level) {
        const m = 1 + (Number(rate) || 0) * (level | 0);
        const c = structuredClone(base);

        c.phys_atk *= m; c.mag_atk *= m; c.str *= m; c.int *= m; c.acc *= m; c.phys_crit *= m; c.mag_crit *= m;
        c.phys_crit_rate *= m; c.mag_crit_rate *= m; c.add_damage *= m; c.damage_inc *= m; c.crit_damage_inc *= m;
        c.phys_atk_pct *= m; c.mag_atk_pct *= m; c.skill_atk_inc *= m;
        c.elem.fire *= m; c.elem.water *= m; c.elem.light *= m; c.elem.dark *= m;
        c.elem_add_damage.fire *= m; c.elem_add_damage.water *= m; c.elem_add_damage.light *= m; c.elem_add_damage.dark *= m;
        c.speed.attack *= m; c.speed.move *= m; c.speed.cast *= m; c.cdr *= m;
        c.dot_add.bleed *= m; c.dot_add.burn *= m; c.dot_add.shock *= m;
        c.dot_inc.bleed *= m; c.dot_inc.burn *= m; c.dot_inc.shock *= m;
        c.other.def_break_inc *= m; c.other.enchant_bleed *= m;
        return c;
      }

      // stats í•©ì¹˜ê¸° (ë„¤ sumSelectionsì˜ add ê·œì¹™ê³¼ ë™ì¼í•˜ê²Œ ê°€ì‚°)
      function addStats(dst, st) {
        if (!st) return dst;
        dst.phys_atk += st.phys_atk || 0; dst.mag_atk += st.mag_atk || 0;
        dst.str += st.str || 0; dst.int += st.int || 0;
        dst.phys_crit += st.phys_crit || 0; dst.mag_crit += st.mag_crit || 0;
        dst.phys_crit_rate += st.phys_crit_rate || 0; dst.mag_crit_rate += st.mag_crit_rate || 0;
        dst.add_damage += st.add_damage || 0; dst.damage_inc += st.damage_inc || 0; dst.crit_damage_inc += st.crit_damage_inc || 0;
        dst.phys_atk_pct += st.phys_atk_pct || 0; dst.mag_atk_pct += st.mag_atk_pct || 0;
        dst.skill_atk_inc += st.skill_atk_inc || 0;
        if (st.elem) { dst.elem.fire += st.elem.fire || 0; dst.elem.water += st.elem.water || 0; dst.elem.light += st.elem.light || 0; dst.elem.dark += st.elem.dark || 0; }
        dst.cdr += st.cdr || 0;
        if (st.speed) { dst.speed.attack += st.speed.attack || 0; dst.speed.move += st.speed.move || 0; dst.speed.cast += st.speed.cast || 0; }
        if (st.other) { dst.def_break_inc += st.other.def_break_inc || 0; }
        return dst;
      }

      function emptyStatsLikeSum() {
        return {
          phys_atk: 0, mag_atk: 0, str: 0, int: 0, acc: 0,
          phys_crit: 0, mag_crit: 0, phys_crit_rate: 0, mag_crit_rate: 0,
          add_damage: 0, damage_inc: 0, crit_damage_inc: 0,
          phys_atk_pct: 0, mag_atk_pct: 0, skill_atk_inc: 0,
          elem: { fire: 0, water: 0, light: 0, dark: 0, all: 0 },
          speed: { attack: 0, move: 0, cast: 0 },
          cdr: 0, def_break_inc: 0
        };
      }

      // ì„ íƒ ì•„ì´í…œì—ì„œ "ë ˆë²¨ë§(N)" ì»¬ëŸ¼ ì¶”ì¶œ â†’ {N: sum}
      // ë¶™ì¼ ìœ„ì¹˜: ë²„í”„ ëª¨ë“ˆ íŒŒì¼(í˜¹ì€ ê³µìš© util)ì— ì„ ì–¸
      function collectItemLevelings(selections) {
        const out = Object.create(null);

        // ìŠ¬ë¡¯ë³„ë¡œ ë°°ì—´/ë‹¨ì¼ê°ì²´ ì„ì—¬ë„ ëª¨ë‘ ìˆœíšŒ
        const eachItems = (sel) => (
          !sel ? [] :
            Array.isArray(sel) ? sel :
              [sel.selected || sel].filter(Boolean)
        );

        // ìˆ«ì íŒŒì„œ(ì‰¼í‘œ/ë¬¸ì ì œê±°)
        const toNum = (v) => {
          const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
          return Number.isFinite(n) ? n : 0;
        };

        // "ë ˆë²¨ë§(10)", "ë ˆë²¨ë§10", "Lv10", "ë ˆë²¨ 10", "ë²„í”„ë ˆë²¨(10)" ë“± í—ˆìš©
        const isLevelCol = (k) => {
          const s = String(k || '').replace(/\s+/g, '');
          return /^(?:ë ˆë²¨ë§|ë ˆë²¨|ë²„í”„ë ˆë²¨|Lv|LV)\(?\d+\)?$/.test(s);
        };
        const pickLevel = (k) => {
          const m = String(k || '').replace(/\s+/g, '').match(/(\d+)/);
          return m ? Number(m[1]) : NaN;
        };

        for (const [, sel] of Object.entries(selections || {})) {
          for (const it of eachItems(sel)) {
            const raw = it?.raw || it;
            if (!raw || typeof raw !== 'object') continue;

            for (const [k, v] of Object.entries(raw)) {
              if (!isLevelCol(k)) continue;
              const N = pickLevel(k);           // 10 / 15 / 25 / â€¦
              const val = toNum(v);             // 1, 2, â€¦
              if (!Number.isFinite(N) || !val) continue;
              out[N] = (out[N] || 0) + val;
              console.log('[BUFF-DEBUG] ë ˆë²¨ë§ ê°ì§€:', { col: k, N, val, item: it?.name || raw?.ì´ë¦„ || '?' });
            }
          }
        }

        console.log('[BUFF-DEBUG] ë ˆë²¨ë§ í•©ì‚° ë§µ:', out); // ì˜ˆ: {10:8, 15:2}
        return out;
      }

      // 1) ê°•ë ¥ ì •ê·œí™” ìœ í‹¸ (ê¸°ì¡´ cleanUrl í¬í•¨ í™•ì¥)
      function norm(s) {
        // cleanUrl: ì•ë’¤ ê³µë°±/ë”°ì˜´í‘œ ì œê±°, ë°±ìŠ¬ë˜ì‹œ â†’ ìŠ¬ë˜ì‹œ
        const base = cleanUrl(s);
        // ì œë¡œí­/ë¹„ê°€ì‹œ ê³µë°±ë¥˜ ì¶”ê°€ ì œê±° + ëª¨ë“  ê³µë°± ì œê±°
        return String(base)
          .normalize('NFC')
          .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
          .replace(/\s+/g, '');
      }
      // 2) BUFF ë¡œë”: __charKey ìƒì„± ë³´ê°• + ë¡œê¹… ë³´ê°•

      // base ê°ì²´ì—ì„œ ìˆ«ì í•„ë“œ(0ì´ ì•„ë‹Œ ê³³)ì—ë§Œ deltaë¥¼ ë”í•¨ (ì¤‘ì²© ê°ì²´ë„ ì²˜ë¦¬)
      function addDeltaWherePresent(base, delta) {
        const walk = (obj) => {
          if (!obj || typeof obj !== 'object') return obj;
          const out = Array.isArray(obj) ? [] : {};
          for (const [k, v] of Object.entries(obj)) {
            if (v && typeof v === 'object') {
              out[k] = walk(v);
            } else if (typeof v === 'number') {
              out[k] = (v !== 0) ? (v + delta) : v;
            } else {
              out[k] = v;
            }
          }
          return out;
        };
        return walk(base);
      }

      // â˜… ê°€ì‚°í˜• ìŠ¤ì¼€ì¼: "ì›ë˜ê°’ + (ì¦ê°€ìœ¨ * ë ˆë²¨ë§í•©)"
      function scaleAdd(baseStats, incRaw, levelCount) {
        // ë„¤ê°€ ì´ë¯¸ ê°€ì§„ toNum() ì¬ì‚¬ìš© (%, ê¸€ì ë“± ìˆìœ¼ë©´ ìˆ«ìë§Œ ë‚¨ê¸°ê³  ì‹¶ìœ¼ë©´ ì•„ë˜ í•œ ì¤„ í™œì„±í™”)
        // incRaw = String(incRaw).replace(/[^0-9.-]/g, '');
        const inc = toNum(incRaw);      // ì˜ˆ: "4" -> 4
        const steps = toNum(levelCount);  // ì˜ˆ: 8
        const delta = inc * steps;        // ì˜ˆ: 32
        return addDeltaWherePresent(baseStats, delta);
      }


      // 3) ë§¤ì¹­: í˜„ì¬ ì„ íƒ ìºë¦­í„° í‚¤ ë§Œë“¤ê¸° + í•„í„°
      async function computeBuffStats() {
        if (!(state.currentCharacter?.name)) {
          return null; // ìºë¦­í„° ì—†ìœ¼ë©´ ë²„í”„ ë¯¸ì ìš©
        }
        if (!cache.ready) await preload();
        // â˜… ì˜ˆì™¸ê·œì¹™: ë²„í”„ë ˆë²¨ ì ìš©ì„ ìœ„í•´ ë¡œë“œ/í™œì„±í™”
        await ensureExceptionLoaded();   // í† í° ë³´ì¥ í›„ ì˜ˆì™¸ ì‹œíŠ¸ ë¡œë“œ
        refreshActiveExceptions();       // __EXC.buffLvByName ê°±ì‹ 
        console.log('[EXC] buffLvByName =', __EXC?.buffLvByName || {});
        const fullName = normVal(
          (state.currentCharacter?.jobGroupLabel || '') +
          (state.currentCharacter?.name || '')
        );

        // __charKeyëŠ” ì´ë¯¸ ì •ê·œí™”ëœ ìƒíƒœ
        const rows = cache.rows.filter(r => r.__charKey === fullName);
        console.log('[BUFF-DEBUG] ë§¤ì¹­:', { fullName, count: rows.length });

        const levMap = collectItemLevelings?.(state.selections || {}) || {};
        state.leveling = levMap; // â˜… ì¼ë°˜ ìŠ¤í‚¬ ë ˆë²¨ë§ ì ìš©ì„ ìœ„í•œ ì „ì—­ ì €ì¥
        console.log('[BUFF-DEBUG] ë ˆë²¨ë§ í•©ì‚°:', levMap);

        let total = emptyStatsLikeSum();
        for (const r of rows) {
          const skillName = String(r['ìŠ¤í‚¬ëª…'] || r['skillname'] || '').trim();
          const req = Number(r['ìŠ¤í‚¬ë ™ì œ'] || r['skillreq'] || 0);
          // (êµì²´ ì½”ë“œ: ê°€ì‚°í˜• ì ìš©)
          const incRaw = r['ì¦ê°€ìœ¨'] || r['rate'] || 0;  // ì›ë¬¸ ìœ ì§€
          const base = rowToBaseStats(r);
          // ë²„í”„ ì´ë¦„ ì •ê·œí™”(ê³µë°±/ì œë¡œí­ ì œê±°)
          const normName = s => String(s ?? '')
            .normalize('NFC')
            .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
            .replace(/\s+/g, '');

          const baseLevel = toNum(levMap[req] || 0);  // ì•„ì´í…œ ë ˆë²¨ë§ í•©
          const excBonus = Number(__EXC?.buffLvByName?.[normName(skillName)] || 0); // â˜… ì˜ˆì™¸ 'ë²„í”„ë ˆë²¨'
          const level = baseLevel + excBonus;     // â† í•©ì‚° ì ìš©
          const scaled = scaleAdd(base, incRaw, level);  // â˜… ê°€ì‚°í˜•
          // â˜… í™•ì¸ìš© ë¡œê·¸
          if (excBonus) {
            console.log(`[BUFF-BONUS] '${skillName}' ë ˆë²¨ +${excBonus} (base=${baseLevel} â†’ level=${level})`);
          } else {
            console.log(`[BUFF-DEBUG] '${skillName}' ë ˆë²¨ ë³´ë„ˆìŠ¤ ì—†ìŒ (base=${baseLevel})`);
          }
          console.log(
            `[BUFF-DEBUG] req=${req}, level=${level}, inc=${incRaw} â†’ delta=${toNum(incRaw) * level}`,
            { base, scaled }
          );
          total = addStats(total, scaled);
        }
        console.log('[BUFF-DEBUG] ìµœì¢… í•©ì‚° ë²„í”„ ìŠ¤íƒ¯:', total);
        return total;
      }
      return { preload, computeBuffStats };
    })();
  </script>

  <script>
    /* ======== ë§ˆë²•ë´‰ì¸(ìŠ¬ë¡¯ë³„ 3êµ¬ì—­ ë‹¨ì¼ ì„ íƒ) & ë§ˆë²•ë¶€ì—¬ ======== */
    (function () {
      // ìƒíƒœ ìŠ¬ë¡¯
      window.state = window.state || {};
      state.seals = state.seals || {}; // { [slotKey]: { unique, general1, general2 } }
      state.enchants = state.enchants || {}; // { [slotKey]: {name, stats...} }

      /* ===== ë§ˆë²•ë´‰ì¸: ëª¨ë‹¬/ìŠ¤íƒ€ì¼ ë™ì  ìƒì„± ===== */
      function ensureSealModalBuilt() {
        if (document.getElementById('sealModal')) return;
        const html = `
<div id="sealModal" class="modal" aria-hidden="true">
  <div class="backdrop" data-close></div>
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="sealDlgTitle"
       style="width:min(980px,95vw);height:min(1620px,88vh);">
    <header>
      <h2 id="sealDlgTitle">ë§ˆë²•ë´‰ì¸ ì„¤ì •</h2>
    </header>
    <div class="items" style="padding:10px;">
      <div class="seal-grid">
        <div class="seal-col">
          <div class="seal-col-title">ê³ ìœ ì˜µì…˜</div>
          <div id="sealListUnique" class="seal-list"></div>
        </div>
        <div class="seal-col">
          <div class="seal-col-title">ì¼ë°˜ì˜µì…˜ 1</div>
          <div id="sealListGeneral1" class="seal-list"></div>
        </div>
        <div class="seal-col">
          <div class="seal-col-title">ì¼ë°˜ì˜µì…˜ 2</div>
          <div id="sealListGeneral2" class="seal-list"></div>
        </div>
      </div>
    </div>
  </div>
</div>`;
        document.body.insertAdjacentHTML('beforeend', html);
        const modal = document.getElementById('sealModal');
        modal.addEventListener('click', (e) => {
          if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeSealModal();
        });
      }

      function ensureSealStyles() {
        if (document.getElementById('sealStyles')) return;
        const css = `
.seal-grid { display:grid; background: #0e0b09; grid-template-columns:1fr 1fr 1fr; gap:12px; }
.seal-col { border:1px solid var(--border, #333); background: #0e0b09; border-radius:12px; padding:10px; overflow:auto; max-height: calc(88vh - 140px); }
.seal-col-title { font-weight:700; color: #f0e6d2; background: #0e0b09; margin-bottom:8px; }
.seal-option { display:grid; width:100%; text-align:left; padding:8px 10px; color: #f0e6d2; cousor: pointer; margin:4px 0; border-radius:10px;
  border:1px solid var(--border,#333); background:var(--card,#1a130f); cursor:pointer; font-size:13px; }
.seal-option:hover { border-color: #xfa24f; box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset; filter:brightness(1.08); }
.seal-option.selected { outline:2px solid #e7c27a; }
`;
        const s = document.createElement('style'); s.id = 'sealStyles'; s.textContent = css;
        document.head.appendChild(s);
      }

      function closeSealModal() {
        const modal = document.getElementById('sealModal');
        if (modal) { modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true'); }
        state.ui = state.ui || {};
        state.ui.sealTemp = null;
      }

      function sealTypeKeysForSlot(slotKey) {
        if (slotKey === 'weapon') return { u: 'ë¬´ê¸°ê³ ìœ ', g: 'ë¬´ê¸°ì¼ë°˜' };
        if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slotKey))
          return { u: 'ë°©ì–´ê³ ìœ ', g: 'ë°©ì–´ì¼ë°˜' };
        if (['bracelet', 'necklace', 'ring'].includes(slotKey))
          return { u: 'ì•…ì„¸ê³ ìœ ', g: 'ì•…ì„¸ì¼ë°˜' };
        if (slotKey === 'support') return { u: 'ë³´ì¥ê³ ìœ ', g: 'ë³´ì¥ì¼ë°˜' };
        return null;
      }

      /* ===== ë§ˆë²•ë¶€ì—¬: ë¡œì§ ===== */
      function enchantTypeForSlot(slotKey) {
        return ({
          weapon: 'ë¬´ê¸°ë§ˆë¶€', top: 'ìƒì˜ë§ˆë¶€', bottom: 'í•˜ì˜ë§ˆë¶€',
          headshoulder: 'ë¨¸ë¦¬ì–´ê¹¨ë§ˆë¶€', belt: 'í—ˆë¦¬ë§ˆë¶€', shoes: 'ì‹ ë°œë§ˆë¶€',
          bracelet: 'íŒ”ì°Œë§ˆë¶€', necklace: 'ëª©ê±¸ì´ë§ˆë¶€', ring: 'ë°˜ì§€ë§ˆë¶€',
          support: 'ë³´ì¥ë§ˆë¶€'
        })[slotKey] || null;
      }

      function closeEnchantPicker() {
        const modal = document.getElementById('enchantModal');
        if (modal) {
          modal.classList.remove('show');
          modal.setAttribute('aria-hidden', 'true');
        }
      }

      async function openEnchantPicker(slotKey, btnEl) {
        const type = enchantTypeForSlot(slotKey);
        if (!type) return;

        if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

        const list = (DBEnh.byType[type] || []).slice();
        const enchantListEl = document.getElementById('enchantList');
        enchantListEl.innerHTML = '';

        list.forEach(opt => {
          const b = document.createElement('button');
          b.className = 'enh-option';
          b.textContent = opt.name || '(ì´ë¦„ì—†ìŒ)';
          b.onclick = () => {
            state.enchants[slotKey] = opt;
            if (btnEl) btnEl.textContent = opt.name;
            closeEnchantPicker();
            if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
          };
          enchantListEl.appendChild(b);
        });

        const enchantDlgTitle = document.getElementById('enchantDlgTitle');
        if (enchantDlgTitle) {
          enchantDlgTitle.textContent = `${window.labelForSlot(slotKey) || 'ì•„ì´í…œ'} ë§ˆë²•ë¶€ì—¬ ì„ íƒ`;
        }

        const enchantModal = document.getElementById('enchantModal');
        if (enchantModal) {
          enchantModal.classList.add('show');
          enchantModal.setAttribute('aria-hidden', 'false');
        }
      }


      /* ===== ê³µí†µ UI ê°±ì‹  ë¡œì§ ===== */
      function refreshSealLabelsFromState() {
        document.querySelectorAll('.slot-row').forEach(row => {
          const slotEl = row.querySelector('.slot'); const code = slotEl?.getAttribute('data-slot');
          const slotKey = (window.SLOT_MAP || {})[code]; const rects = row.querySelectorAll('.outer-rects .rect');
          if (!slotKey || rects.length < 2) return;
          const has = !!(state.seals?.[slotKey]?.unique && state.seals?.[slotKey]?.general1 && state.seals?.[slotKey]?.general2);
          rects[1].textContent = has ? 'ë§ˆë´‰ ì„¤ì •ì™„ë£Œ' : 'ë§ˆë´‰ ì„¤ì •';
          refreshSealCaptionsForSlot(slotKey);
        });
      }

      function getSealCaptionText(obj) {
        if (!obj) return "";
        return (obj.badge ?? obj.level ?? obj.label ?? obj.text ?? obj.caption ?? obj.name ?? obj.imgText ?? "").toString().trim();
      }

      function refreshSealCaptionsForSlot(slotKey) {
        if (!slotKey) return;
        const el = window.tileElForSlot(slotKey);
        if (!el) return;
        const code = el.getAttribute('data-slot') || "";
        if (el.classList.contains('mini') || /^C[1-4]$/.test(code)) return;

        let cap = el.querySelector('.seal-captions');
        if (!cap) {
          cap = document.createElement('div');
          cap.className = 'seal-captions';
          el.appendChild(cap);
        }
        cap.innerHTML = '';

        const sel = (state.seals || {})[slotKey] || {};
        const u = sel.unique || null;
        const g1 = sel.general1 || null;
        const g2 = sel.general2 || null;

        const uTxt = getSealCaptionText(u);
        const g1Txt = getSealCaptionText(g1);
        const g2Txt = getSealCaptionText(g2);

        if (!uTxt && !g1Txt && !g2Txt) { cap.style.display = 'none'; return; }
        cap.style.display = 'flex';

        if (uTxt) {
          const rowU = document.createElement('div');
          rowU.className = 'seal-row seal-row-unique';
          const chipU = document.createElement('div');
          chipU.className = 'seal-chip';
          chipU.textContent = uTxt;
          rowU.appendChild(chipU);
          cap.appendChild(rowU);
        }

        if (g1Txt || g2Txt) {
          const rowG = document.createElement('div');
          rowG.className = 'seal-row seal-row-general';
          if (g1Txt) {
            const chip1 = document.createElement('div');
            chip1.className = 'seal-chip';
            chip1.textContent = g1Txt;
            rowG.appendChild(chip1);
          }
          if (g2Txt) {
            const chip2 = document.createElement('div');
            chip2.className = 'seal-chip';
            chip2.textContent = g2Txt;
            rowG.appendChild(chip2);
          }
          cap.appendChild(rowG);
        }
      }

      function refreshSealCaptionsFromState() {
        document.querySelectorAll('.slot-row .slot').forEach(slotEl => {
          const code = slotEl.getAttribute('data-slot');
          if (!code) return;
          const slotKey = (window.SLOT_MAP || {})[code];
          if (!slotKey) return;
          if (slotEl.classList.contains('mini') || /^C[1-4]$/.test(code)) return; // ë¯¸ë‹ˆ ì œì™¸
          refreshSealCaptionsForSlot(slotKey);
        });
      }

      function buildSealList(listEl, choices, current, onPick) {
        listEl.innerHTML = '';
        choices.forEach(opt => {
          const b = document.createElement('button');
          b.className = 'seal-option' + ((current && current.name === opt.name) ? ' selected' : '');
          b.textContent = opt.name || '(ì´ë¦„ì—†ìŒ)';
          b.title = opt.tag ? `ë¶„ë¥˜: ${opt.tag}` : '';
          b.addEventListener('click', () => onPick(opt, b));
          listEl.appendChild(b);
        });
      }

      function tryFinalizeSeal(slotKey, btnEl) {
        const tmp = state.ui?.sealTemp;
        if (!tmp) return;
        if (tmp.unique && tmp.general1 && tmp.general2) {
          state.seals[slotKey] = { unique: tmp.unique, general1: tmp.general1, general2: tmp.general2 };
          refreshSealCaptionsForSlot(slotKey);
          if (btnEl) btnEl.textContent = 'ë§ˆë´‰ ì„¤ì •ì™„ë£Œ';
          if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
          closeSealModal();
        }
      }

      async function openSealModal(slotKey, btnEl) {
        ensureSealStyles();
        ensureSealModalBuilt();
        if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

        const keys = sealTypeKeysForSlot(slotKey);
        if (!keys) return;

        const uniq = (DBEnh?.byType?.[keys.u] || (DBEnh?.list || []).filter(o => (o?.type || '') === keys.u)).slice();
        const gen = (DBEnh?.byType?.[keys.g] || (DBEnh?.list || []).filter(o => (o?.type || '') === keys.g)).slice();

        state.ui = state.ui || {};
        const prev = (state.seals?.[slotKey]) || {};
        state.ui.sealTemp = {
          unique: prev.unique || null, general1: prev.general1 || null, general2: prev.general2 || null, slotKey, btnEl
        };

        const $ = (id) => document.getElementById(id);
        const listU = $('sealListUnique'), listG1 = $('sealListGeneral1'), listG2 = $('sealListGeneral2');

        buildSealList(listU, uniq, prev.unique, (opt, btn) => {
          state.ui.sealTemp.unique = opt;
          listU.querySelectorAll('.seal-option').forEach(x => x.classList.remove('selected')); btn.classList.add('selected');
          tryFinalizeSeal(slotKey, btnEl);
        });
        buildSealList(listG1, gen, prev.general1, (opt, btn) => {
          state.ui.sealTemp.general1 = opt;
          listG1.querySelectorAll('.seal-option').forEach(x => x.classList.remove('selected')); btn.classList.add('selected');
          tryFinalizeSeal(slotKey, btnEl);
        });
        buildSealList(listG2, gen, prev.general2, (opt, btn) => {
          state.ui.sealTemp.general2 = opt;
          listG2.querySelectorAll('.seal-option').forEach(x => x.classList.remove('selected')); btn.classList.add('selected');
          tryFinalizeSeal(slotKey, btnEl);
        });

        const modal = document.getElementById('sealModal');
        modal.classList.add('show'); modal.setAttribute('aria-hidden', 'false');
      }

      // DOM ë¡œë“œ í›„ ë°”ì¸ë”©
      document.addEventListener('DOMContentLoaded', () => {
        refreshSealLabelsFromState();

        const enchantModal = document.getElementById('enchantModal');
        if (enchantModal) {
          enchantModal.addEventListener('click', (e) => {
            if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) {
              closeEnchantPicker();
            }
          });
        }

        document.querySelectorAll('.slot-row').forEach(row => {
          const slotEl = row.querySelector('.slot');
          const code = slotEl?.getAttribute('data-slot');
          const slotKey = (window.SLOT_MAP || {})[code];
          const rects = row.querySelectorAll('.outer-rects .rect');
          if (!slotKey) return;

          // ë§ˆë´‰ (ë‘ë²ˆì§¸ ë²„íŠ¼)
          if (rects.length >= 2) {
            const secondBtn = rects[1];
            secondBtn.textContent = 'ë§ˆë´‰ ì„¤ì •';
            secondBtn.addEventListener('click', (e) => { e.stopPropagation(); openSealModal(slotKey, secondBtn); });
          }

          // ë§ˆë²•ë¶€ì—¬ (ì„¸ë²ˆì§¸ ë²„íŠ¼)
          if (rects.length >= 3) {
            const thirdBtn = rects[2];
            if (enchantTypeForSlot(slotKey)) {
              thirdBtn.textContent = 'ë§ˆë²• ë¶€ì—¬';
              thirdBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                openEnchantPicker(slotKey, thirdBtn);
              });
            } else {
              thirdBtn.classList.add('disabled');
            }
          }
        });
      });

      // í•©ì‚° í•¨ìˆ˜ í™•ì¥: ë§ˆë´‰, ë§ˆë¶€ ìŠ¤íƒ¯ í•©ì‚°
      // í•©ì‚° í•¨ìˆ˜ í™•ì¥: ë§ˆë´‰, ë§ˆë¶€ ìŠ¤íƒ¯ í•©ì‚°
      try {
        const _base = window.sumSelections;
        if (typeof _base === 'function') {
          window.sumSelections = function () {
            const S = _base();

            // ëˆ„ì ê¸° ì•ˆì „ ë³´ì •
            S.__skillMul = S.__skillMul || 1;
            S.__skillAddBuff = S.__skillAddBuff || 0;

            const add = (st, src = 'other') => {
              if (!st) return;

              // 1) ìŠ¤ì¦ ë¶„ê¸°
              if (st.skill_atk_inc) {
                if (src === 'buff') S.__skillAddBuff += (st.skill_atk_inc || 0);   // (ì—¬ê¸°ì„  ì•ˆ ì”€)
                else S.__skillMul *= (1 + (st.skill_atk_inc || 0));  // ë§ˆë´‰/ë§ˆë¶€ëŠ” ê³±
              }

              // 2) ë‚˜ë¨¸ì§€ ìŠ¤íƒ¯ ê°€ì‚°
              S.phys_atk += st.phys_atk || 0; S.mag_atk += st.mag_atk || 0;
              S.str += st.str || 0; S.int += st.int || 0;
              S.phys_crit += st.phys_crit || 0; S.mag_crit += st.mag_crit || 0;
              S.phys_crit_rate += st.phys_crit_rate || 0; S.mag_crit_rate += st.mag_crit_rate || 0;
              S.add_damage += st.add_damage || 0;
              if (st.elem_add_damage) {
                S.elem_add.fire += st.elem_add_damage.fire || 0;
                S.elem_add.water += st.elem_add_damage.water || 0;
                S.elem_add.light += st.elem_add_damage.light || 0;
                S.elem_add.dark += st.elem_add_damage.dark || 0;
              }
              S.str_pct += st.str_pct || 0; S.int_pct += st.int_pct || 0;
              S.damage_inc += st.damage_inc || 0; S.crit_damage_inc += st.crit_damage_inc || 0;
              S.phys_atk_pct += st.phys_atk_pct || 0; S.mag_atk_pct += st.mag_atk_pct || 0;
              if (st.elem) { S.elem.fire += st.elem.fire || 0; S.elem.water += st.elem.water || 0; S.elem.light += st.elem.light || 0; S.elem.dark += st.elem.dark || 0; }
              S.cdr += st.cdr || 0;
              if (st.speed) { S.speed.attack += st.speed.attack || 0; S.speed.move += st.speed.move || 0; S.speed.cast += st.speed.cast || 0; }
              if (st.other) { S.def_break_inc += st.other.def_break_inc || 0; }
              S.counter_add_damage += st.counter_add_damage || 0;
              S.counter_damage_inc += st.counter_damage_inc || 0;
            };

            // ë§ˆë´‰(ì‹œì¼/seal)
            Object.values(state.seals || {}).forEach(p => {
              if (p?.unique?.stats) add(p.unique.stats, 'other');
              if (p?.general1?.stats) add(p.general1.stats, 'other');
              if (p?.general2?.stats) add(p.general2.stats, 'other');
            });

            // ë§ˆë¶€(enchants)
            Object.values(state.enchants || {}).forEach(p => {
              if (p?.stats) add(p.stats, 'other');
            });

            // â˜… ì—¬ê¸°ì„œ ìµœì¢… ìŠ¤ì¦ í™•ì •: (ê³±-1) + ë²„í”„í•©
            S.skill_atk_inc = (S.__skillMul - 1) + S.__skillAddBuff;

            // ì„ì‹œ í‚¤ ì •ë¦¬(ì„ íƒ)
            // delete S.__skillMul; delete S.__skillAddBuff;

            return S;
          };
        }
      } catch (e) { console.warn('Seal/Enchant sumSelections extension failed', e); }


      // ì „ì—­ì—ì„œ ì ‘ê·¼ í•„ìš” ì‹œ export
      window.refreshSealLabelsFromState = refreshSealLabelsFromState;
      window.refreshSealCaptionsForSlot = refreshSealCaptionsForSlot;
      window.refreshSealCaptionsFromState = refreshSealCaptionsFromState;
      if (document.readyState !== 'loading') {
        refreshSealCaptionsFromState();
      } else {
        document.addEventListener('DOMContentLoaded', refreshSealCaptionsFromState);
      }

      window.openSealModal = openSealModal;
    })();

    /* === FINAL DERIVED STATS EXTENSION (do this LAST) === */
    try {
      const _base = window.sumSelections;
      if (typeof _base === 'function') {
        window.sumSelections = function () {
          const S = _base();

          // ---- (A) ì†ì¶” í•©ê³„ ì¬í™•ì¸(ì¤‘ë³µ ë°©ì§€: í•©ê³„ëŠ” ì˜¤ì§ ì—¬ê¸°ì„œë§Œ) ----
          S.elem_add_sum =
            (S.elem_add?.fire || 0) +
            (S.elem_add?.water || 0) +
            (S.elem_add?.light || 0) +
            (S.elem_add?.dark || 0);

          // ---- (B) ìœ íš¨ ì†ì¶”: ì†ì¶” * (1.05 + 0.0045 * (ì†ê°• - ì ì €)) ----
          const M = (state && state.monster) ? state.monster : {};
          const eff = (k) => {
            const base = (S.elem_add?.[k] || 0);
            const atk = (S.elem?.[k] || 0);
            const res = (M?.[k] || 0);
            return base * (1.05 + 0.0045 * (atk - res));
          };
          S.elem_add_eff = {
            fire: eff('fire'),
            water: eff('water'),
            light: eff('light'),
            dark: eff('dark'),
          };
          S.elem_add_eff_sum =
            S.elem_add_eff.fire +
            S.elem_add_eff.water +
            S.elem_add_eff.light +
            S.elem_add_eff.dark;

          // ---- (C) ìµœì¢…ì¶”ë€ ----
          S.fin_add_damage =
            (S.add_damage || 0) +
            (S.elem_add_eff_sum || 0) +
            (S.counter_add_damage || 0);

          // ---- (D) ìµœì¢… í¬ë¦¬ìœ¨(ëª¬ìŠ¤í„° ë ˆë²¨ ì ìš©) ----
          const monsterLevel = Number(state?.monster?.level ?? 80);
          const computeFinalCritPct = (critVal, critRateVal) => {
            if (critVal == null || critRateVal == null) return 0;
            const denom = (3.8665 * Math.pow(100 / 97.25, monsterLevel)) * 100;
            const percent = (((critVal || 0) / denom) * 100) + ((critRateVal || 0) * 100) + 3;
            const clamped = Math.max(0, Math.min(100, percent));
            return clamped / 100; // 0~1
          };
          S.final_phys_crit_pct = computeFinalCritPct(S.phys_crit, S.phys_crit_rate);
          S.final_mag_crit_pct = computeFinalCritPct(S.mag_crit, S.mag_crit_rate);

          // ---- (E) ì†ì„± ë³´ì •ê³„ìˆ˜: 4ì† ì¤‘ (ì†ê°•-ì ì €) ìµœëŒ€ ----
          const elemMul = Math.max(
            1.05 + 0.0045 * ((S.elem?.fire || 0) - (M.fire || 0)),
            1.05 + 0.0045 * ((S.elem?.water || 0) - (M.water || 0)),
            1.05 + 0.0045 * ((S.elem?.light || 0) - (M.light || 0)),
            1.05 + 0.0045 * ((S.elem?.dark || 0) - (M.dark || 0)),
          );

          // ---- (F) í™•ë¥ ê³„ìˆ˜ factor (ë¬¼/ë§ˆ ë³„ë„) ----
          // (1 + (ë€ì¦ + ì¹´ìš´í„°ë€ì¦))
          // * ( ìµœì¢…í¬ë¦¬ìœ¨*(1.5+í¬ì¦ë€) + (1-ìµœì¢…í¬ë¦¬ìœ¨) )
          // * (1.05 + 0.0045*(ì†ê°•-ì ì €))
          // * (1 + (ìµœì¢…ì¶”ë€)*1.015)
          const baseMul1 = 1 + (S.damage_inc || 0) + (S.counter_damage_inc || 0);
          const baseMul4 = 1 + (S.fin_add_damage || 0) * 1.015;

          const baseMul2_phys =
            (S.final_phys_crit_pct * (1.5 + (S.crit_damage_inc || 0))) +
            (1 - S.final_phys_crit_pct);

          const baseMul2_mag =
            (S.final_mag_crit_pct * (1.5 + (S.crit_damage_inc || 0))) +
            (1 - S.final_mag_crit_pct);

          S.factor_phys = baseMul1 * baseMul2_phys * elemMul * baseMul4;
          S.factor_mag = baseMul1 * baseMul2_mag * elemMul * baseMul4;
          // ====== [ì¶”ê°€] í˜/ì§€ëŠ¥ ê³„ìˆ˜ì‹ ë° í‰íƒ€/ìŠ¤í‚¬ ë°ë¯¸ì§€ ê³„ì—´ ======

          // 0) ì¤€ë¹„: ì´í•© í˜/ì§€ëŠ¥, ì´í•© ë¬¼/ë§ˆê³µ
          const totalSTR = (S.str || 0) * (1 + (S.str_pct || 0));
          const totalINT = (S.int || 0) * (1 + (S.int_pct || 0));

          const totalPhysAtk = (S.phys_atk || 0) * (1 + (S.phys_atk_pct || 0));
          const totalMagAtk = (S.mag_atk || 0) * (1 + (S.mag_atk_pct || 0));

          // 1) ìŠ¤ì¼€ì¼ëŸ¬(í˜/ì§€ëŠ¥)
          const strScaler = (totalSTR / 250) + 1;
          const intScaler = (totalINT / 250) + 1;

          // 2) ê³ ë€ ìƒìˆ˜(ì‹œíŠ¸ì˜ 100*3.43 ê·¸ëŒ€ë¡œ)
          const GODAM_CONST = 100 * 3.43;

          // 3) â€œì›ì´ˆì‹â€ (ì¥ë¹„/ë²„í”„ ë“±ìœ¼ë¡œ ë§Œë“  ê¸°ì´ˆ ë°°ìˆ˜)
          S.str_perdam = strScaler * totalPhysAtk;   // í˜ í¼ë€
          S.str_godam = strScaler * GODAM_CONST;    // í˜ ê³ ë€
          S.in_perdam = intScaler * totalMagAtk;    // ì§€ëŠ¥ í¼ë€
          S.in_godam = intScaler * GODAM_CONST;    // ì§€ëŠ¥ ê³ ë€

          // 4) ëª¬ìŠ¤í„° ë°©ì–´ ë³´ì •(ë°©ì–´ìœ¨): ê°’ ì—†ìœ¼ë©´ 1ë¡œ ë‘ 
          const armorMul = state?.monster?.defRate ?? 1;

          // 5) í‰íƒ€/ìŠ¤í‚¬ ìµœì¢…ì‹ (í™•ë¥ ê³„ìˆ˜ + ìŠ¤í‚¬ê³µê²©ë ¥ì¦ê°€ ë°˜ì˜)
          //   - í™•ë¥ ê³„ìˆ˜: ë¬¼ë¦¬ = S.factor_phys, ë§ˆë²• = S.factor_mag
          //   - ìŠ¤í‚¬ê³µê²©ë ¥ì¦ê°€: S.skill_atk_inc (ê³±ëˆ„ì -1 + ë²„í”„í•©) ìµœì¢… í™•ì •ê°’
          const skillMul = 1 + (S.skill_atk_inc || 0);

          // í˜(ë¬¼ë¦¬) ë¼ì¸
          S.nor_str_perdam = S.factor_phys * S.str_perdam * armorMul * 1.25;
          S.nor_str_godam = S.factor_phys * S.str_godam * armorMul * 1.25;

          S.ski_str_perdam = S.factor_phys * skillMul * S.str_perdam * 1.25;
          S.ski_str_godam = S.factor_phys * skillMul * S.str_godam * 1.25;

          // ì§€ëŠ¥(ë§ˆë²•) ë¼ì¸
          S.nor_int_perdam = S.factor_mag * S.in_perdam * armorMul * 1.25;
          S.nor_int_godam = S.factor_mag * S.in_godam * armorMul * 1.25;

          S.ski_int_perdam = S.factor_mag * skillMul * S.in_perdam * 1.25;
          S.ski_int_godam = S.factor_mag * skillMul * S.in_godam * 1.25;

          // ===== [ìŠ¤í‚¬ë³„ ìµœì¢… ë°ë¯¸ì§€ ì—°ê²°] =====
          const skillBook = (window.skillDmg || state?.skillDmg || {});
          const p = state?.currentCharacter?.power; // renderStats ì—ì„œ ì“°ë˜ ê²ƒ ê·¸ëŒ€ë¡œ

          // ë°©ê¹ë€ì¦ ë°°ìˆ˜
          const defMul = 1 + (S.def_break_inc || 0);

          Object.entries(skillBook).forEach(([id, sd]) => {
            if (!sd) return;

            const perBase = Number(sd.per || 0);
            const flatBase = Number(sd.flat || 0);
            const uses = Number(sd.uses ?? 1);

            // ê¸°ë³¸ perCoef / goCoef
            let perCoef, goCoef;
            if (p === 'phys') {
              perCoef = S.ski_str_perdam;
              goCoef = S.ski_str_godam;
            } else if (p === 'mag') {
              perCoef = S.ski_int_perdam;
              goCoef = S.ski_int_godam;
            } else {
              perCoef = 0;
              goCoef = 0;
            }

            // === [í‰íƒ€ ì „ìš© ë¶„ê¸°] ===
            if (sd.kind === "í‰íƒ€") {
              if (p === 'phys') {
                perCoef = S.nor_str_perdam;
                goCoef = S.nor_str_godam;
              } else if (p === 'mag') {
                perCoef = S.nor_int_perdam;
                goCoef = S.nor_int_godam;
              } else {
                perCoef = 0;
                goCoef = 0;
              }
            }

            // ìµœì¢… ë°ë¯¸ì§€ ê³„ì‚°
            const final = ((perBase * perCoef) + (flatBase * goCoef)) * defMul * uses;

            sd.final = final;
            sd.finalPer = perBase * perCoef;
            sd.finalFlat = flatBase * goCoef;
          });


          return S;
        };
      }
    } catch (e) {
      console.warn('Finalize(sumSelections) extension failed', e);
    }

    function sumAllSkillFinal() {
      if (typeof sumSelections === 'function') sumSelections(); // ìµœì‹  ë°˜ì˜
      const book = (window.skillDmg || state?.skillDmg || {});
      let total = 0;
      for (const sd of Object.values(book)) total += Number(sd?.final || 0);
      return Math.round(total);
    }

    function setFinalDamageManually(total) {
      const el = document.getElementById('finalDamageValue');
      if (!el) return;
      el.textContent = Number(total).toLocaleString();
    }

    // ë²„íŠ¼: ëˆ„ë¥¼ ë•Œë§Œ ê°’ ì±„ì›€
    document.getElementById('btn-sum-all-final')?.addEventListener('click', () => {
      const total = sumAllSkillFinal();
      setFinalDamageManually(total);
    });

    function setFinalDamageManually2(total) {
      const el = document.getElementById('finalDamageValue2');
      if (!el) return;
      el.textContent = Number(total).toLocaleString();
    }

    // ë²„íŠ¼: ëˆ„ë¥¼ ë•Œë§Œ ê°’ ì±„ì›€
    document.getElementById('btn-sum-all-final2')?.addEventListener('click', () => {
      const total = sumAllSkillFinal();
      setFinalDamageManually2(total);
    });


    (() => {
      // â˜… 1) í´ë¼ì´ì–¸íŠ¸ IDì™€ CSV URLì„ ë„£ì–´ì£¼ì„¸ìš”
      const GOOGLE_CLIENT_ID = "110486887643-3c136grpud2llf2b31d24fqr40s1p44g.apps.googleusercontent.com"; // ë°œê¸‰ë°›ì€ ì›¹ í´ë¼ì´ì–¸íŠ¸ ID
      window.WEBAPP_URL = 'https://gas-proxy.gogo456654.workers.dev';
      //const ALLOW_HEADER = "êµ¬ê¸€ê³„ì •"; // CSVì˜ ì»¬ëŸ¼ëª…

      window.idToken ??= null; // ë¡œê·¸ì¸ í›„ ë°›ì€ ID í† í° ì €ì¥ìš©

      const DBSkill = { loaded: false, headers: [], rows: [] }; // ìŠ¤í‚¬ ë¡œë”© ìƒíƒœ ì €ì¥ìš©(ì›í•˜ëŠ” ë„¤ì´ë° ì‚¬ìš©)

      // === ë¡œê·¸ì¸ ì„±ê³µ ì½œë°±(GSIì—ì„œ í˜¸ì¶œ) ===
      async function onGoogleCredential({ credential }) {
        try {
          if (!credential) throw new Error("ID í† í° ì—†ìŒ");
          window.idToken = credential; // í† í° ë³´ê´€
          // í† í° ì¤€ë¹„ ì•Œë¦¼(ëŒ€ê¸° ì¤‘ì¸ ë¡œë”ë“¤ì´ ë°›ì„ ìˆ˜ ìˆê²Œ)
          document.dispatchEvent(new Event('gsi:issued'));
          const card0 = document.querySelector(".login-card");
          if (card0) {
            card0.innerHTML = `
  <div class="login-title">ì ‘ê·¼ í™•ì¸ ì¤‘â€¦</div>
  <div class="login-desc">ê¶Œí•œ í™•ì¸ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.</div>
  <div class="login-row">
    <button id="btnPC" class="mode-btn" disabled>PC ê³„ì‚°ê¸° ì—´ê¸°</button>
    <button id="btnM" class="mode-btn" disabled>ëª¨ë°”ì¼ ê³„ì‚°ê¸° ì—´ê¸°</button>
  </div>`;
          }
          // ë°±ì—”ë“œì— ê°€ë³ê²Œ 'í•‘'ì„ ë³´ë‚´ í—ˆìš© ì—¬ë¶€ í™•ì¸
          // (ë°±ì—”ë“œì—ì„œ ALLOW í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ë¥¼ ì¼œë†¨ë‹¤ë©´, 200/okê°€ ì•„ë‹ˆë©´ ê±°ë¶€ë¨)
          const res = await fetch(WEBAPP_URL, {
            method: "POST",
            mode: "cors",
            cache: "no-store",
            headers: { "Content-Type": "text/plain" },
            body: idToken
          });

          const data = await res.json().catch(() => ({ ok: false, error: 'bad json' }));
          const allowed = !!data.ok;
          if (!allowed) console.warn("í—ˆìš© ì•ˆ ë¨:", data);
          const card = document.querySelector(".login-card");
          if (card) {
            card.innerHTML = `
<div class="login-title">${allowed ? "ì ‘ê·¼ ìŠ¹ì¸ë¨" : "ì ‘ê·¼ ì œí•œë¨"}</div>
<div class="login-desc">
  ${allowed
                ? "ì•„ë˜ì—ì„œ ì´ìš©í•  í™”ë©´ì„ ì„ íƒí•˜ì„¸ìš”."
                : 'ê²Œì„ì‹¤í—˜ì—°êµ¬ì†Œ ì—°êµ¬ì›ë§Œ ì´ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.<br><a class="join-link" href="https://www.youtube.com/channel/UCijUV3SuVe_qErzBpdOmKIA/join" target="_blank" rel="noopener">ê²Œì„ì‹¤í—˜ì—°êµ¬ì†Œ ì—°êµ¬ì› ê°€ì…í•˜ê¸°</a>'}
</div>
<div class="login-row">
  <button id="btnPC" class="mode-btn">PC ê³„ì‚°ê¸° ì—´ê¸°</button>
  <button id="btnM" class="mode-btn">ëª¨ë°”ì¼ ê³„ì‚°ê¸° ì—´ê¸°</button>
</div>
`;

            if (!document.getElementById("mode-btn-style")) {
              const style = document.createElement("style");
              style.id = "mode-btn-style";
              style.textContent = `
.mode-btn{
  height:40px; padding:0 14px; border-radius:999px;
  border:1px solid rgba(255,255,255,.2); background:#111827; color:#e6e9ef; cursor:pointer;
  transition: box-shadow .15s, border-color .15s, opacity .15s;
}
.mode-btn:hover{ border-color:#6ea8ff; box-shadow:0 0 0 2px rgba(110,168,255,.25) inset; }
.mode-btn:disabled{ opacity:.5; cursor:not-allowed; filter: grayscale(30%); }
.login-desc a.join-link{ color:#8fbaff; text-decoration: underline; }
`;
              document.head.appendChild(style);
            }

            const btnPC = card.querySelector("#btnPC");
            const btnM = card.querySelector("#btnM");

            // ê¸°ë³¸ ì ê¸ˆ
            btnPC?.setAttribute("disabled", "true");
            btnM?.setAttribute("disabled", "true");
            if (allowed) {
              btnPC.removeAttribute("disabled");
              btnM.removeAttribute("disabled");
              btnPC.addEventListener('click', async () => {
                showOverlay('ì¤€ë¹„ ì¤‘â€¦');
                try {
                  await preloadAllSheetsOnce();   // â† ì‹±ê¸€í†¤
                  refreshExceptionSkillIdMap();   // â† ìŠ¤í‚¬ëª… â†’ ID ë§¤í•‘ ê°±ì‹ 
                  refreshActiveExceptions();      // â† í˜„ì¬ ì°©ìš©ì•„ì´í…œ ê¸°ì¤€ìœ¼ë¡œ ì˜ˆì™¸íš¨ê³¼ í™œì„±í™”
                  await initCalculatorOnce();
                  showCalcView('pc');
                } catch (e) {
                  console.error('[INIT] preload ì‹¤íŒ¨:', e);
                  alert('ì´ˆê¸° ë¡œë”©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
                } finally {
                  hideOverlay();
                }
              });

              btnM.addEventListener('click', async () => {
                showOverlay('ì¤€ë¹„ ì¤‘â€¦');
                try {
                  await preloadAllSheetsOnce();
                  refreshExceptionSkillIdMap();   // â† ìŠ¤í‚¬ëª… â†’ ID ë§¤í•‘ ê°±ì‹ 
                  refreshActiveExceptions();      // â† í˜„ì¬ ì°©ìš©ì•„ì´í…œ ê¸°ì¤€ìœ¼ë¡œ ì˜ˆì™¸íš¨ê³¼ í™œì„±í™”
                  await initCalculatorOnce();
                  showCalcView('mobile');
                } catch (e) {
                  console.error('[INIT] preload ì‹¤íŒ¨:', e);
                  alert('ì´ˆê¸° ë¡œë”©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
                } finally {
                  hideOverlay();
                }
              });
            }
          }
        } catch (err) {
          console.warn("[Login] ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:", err);
        }
      }
      // GSIì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ë„ë¡ ì „ì—­ ë…¸ì¶œ ìœ ì§€
      window.onGoogleCredential = onGoogleCredential;

      // === ë·° ì „í™˜(ì—†ìœ¼ë©´ ì¶”ê°€) ===
      //  - ë©”ì¸ ìˆ¨ê¸°ê³  ê³„ì‚°ê¸° ë³´ì—¬ì£¼ê¸° + ëª¨ë“œ í´ë˜ìŠ¤ í† ê¸€
      function hideBlockHard(el) {
        if (!el) return;
        el.setAttribute('hidden', 'hidden');   // hidden ì†ì„±
        el.style.display = 'none';             // ì™„ì „ ì œê±°
        el.style.margin = '0';
        el.style.padding = '0';
        el.style.minHeight = '0';
        el.style.height = '0';
      }

      // â˜… í—¤ë” ê´‘ê³  â€” ì´ ë¸”ë¡ìœ¼ë¡œ êµì²´ (CSV â†’ ë°±ì—”ë“œ JSON ì‚¬ìš©)
      async function initHeaderAds() {
        try {
          const header = document.querySelector("header");
          if (!header) return;

          let ads = header.querySelector(".header-ads");
          if (!ads) {
            ads = document.createElement("div");
            ads.className = "header-ads";
            ads.innerHTML = `<span class="ad-text">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</span>`;
            header.appendChild(ads);
          }
          const adTextEl = ads.querySelector(".ad-text");
          if (ads.dataset.inited) return;
          ads.dataset.inited = "1";

          // ë°±ì—”ë“œì—ì„œ ëª©ë¡(JSON) ë¡œë“œ
          const r = await fetch(WEBAPP_URL + '?public=1', {
            method: "GET",
            mode: "cors",
            cache: "no-store"
          });
          if (!r.ok) throw new Error("ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨");
          const data = await r.json();
          if (!data.ok) throw new Error("ëª©ë¡ ë°ì´í„° ì˜¤ë¥˜");

          // data.itemsëŠ” Apps Scriptê°€ ë‚´ë ¤ì£¼ëŠ” ì •ê·œí™” ê°ì²´ ë°°ì—´
          //  { ingame, position, youtube, google, message }
          // "ìˆ˜ì„" + "ì±…ì„" ëª¨ë‘ í—ˆìš© (ì•ì— ì ‘ë‘ì–´ê°€ ë¶™ì€ "ìˆ˜ì„ì—°êµ¬ì›"/"ì±…ì„ì—°êµ¬ì›"ë„ í¬í•¨)
          function escapeHTML(s = '') {
            return String(s)
              .replace(/&/g, '&amp;').replace(/</g, '&lt;')
              .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;').replace(/`/g, '&#96;');
          }

          function shuffleInPlace(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }

          let messages = (data.items || [])
            .filter(x => {
              const pos = (x.position || '').trim();
              const msg = (x.message || '').trim();
              return !!msg && /^(ìˆ˜ì„|ì±…ì„)/.test(pos);
            })
            .map(x => {
              const pos = (x.position || '').trim();
              const nick = (x.ingame || '').trim() || (x.youtube || '').trim();
              const msg = (x.message || '').trim();
              const isSenior = /^ìˆ˜ì„/.test(pos);
              const roleBadge = isSenior
                ? '<span class="tag tag-senior" aria-label="ìˆ˜ì„" title="ìˆ˜ì„"><span class="badge-emoji">ğŸ‘‘</span></span>'
                : '<span class="tag-lead" aria-hidden="true"></span>';

              return `
      <span class="hdrmsg ${isSenior ? 'senior' : 'lead'}">
        ${roleBadge}
        ${nick ? `<span class="msg-nick">${escapeHTML(nick)} ë‹˜</span>` : ''}
        <span class="msg-bullet">Â·</span>
        <span class="msg-text">${escapeHTML(msg)}</span>
      </span>
    `.trim();
            });

          messages = [...new Set(messages)];
          messages = shuffleInPlace(messages);
          if (!messages.length) {
            adTextEl.textContent = "ë“±ë¡ëœ í•œë§ˆë””ê°€ ì—†ìŠµë‹ˆë‹¤.";
            return;
          }
          // 6ì´ˆë§ˆë‹¤ ìˆœí™˜í•  ì´ëª¨ì§€ ëª©ë¡
          const SENIOR_EMOJIS = ['ğŸ‘‘', 'â­', 'ğŸ…', 'âœ¨'];
          let __emojiIdx = 0;

          // í˜„ì¬ í‘œì‹œëœ í•œë§ˆë”” ì»¨í…Œì´ë„ˆì—ì„œ ìˆ˜ì„ ë°°ì§€ ì´ëª¨ì§€ë§Œ êµì²´
          function applySeniorEmoji(target) {
            const node = target.querySelector('.tag-senior .badge-emoji');
            if (node) node.textContent = SENIOR_EMOJIS[__emojiIdx];
          }
          // ìˆœí™˜ í‘œì‹œ
          let i = 0, timer = null, paused = false;
          function show(idx) {
            adTextEl.classList.add("fade-out");
            setTimeout(() => {
              adTextEl.innerHTML = messages[idx % messages.length];
              adTextEl.classList.remove("fade-out");
              // ğŸ‘‡ ìƒˆ DOMì´ ë“¤ì–´ê°„ ë’¤, í•´ë‹¹ ë¼ìš´ë“œì˜ ì´ëª¨ì§€ë¥¼ ì ìš©
              applySeniorEmoji(adTextEl);
            }, 200); // ì´ ê°’(200ms)ì€ í˜ì´ë“œ ì‹œê°„ê³¼ ë§ì¶”ì„¸ìš”
          }
          const DISPLAY_MS = 6000;

          function start() {
            if (timer) clearInterval(timer);
            timer = setInterval(() => {
              if (paused) return;
              // ğŸ‘‡ ì´ëª¨ì§€ ì¸ë±ìŠ¤ ë¨¼ì € ìˆœí™˜
              __emojiIdx = (__emojiIdx + 1) % SENIOR_EMOJIS.length;
              // ë©”ì‹œì§€ë„ ë‹¤ìŒìœ¼ë¡œ
              i = (i + 1) % messages.length;
              show(i); // show() ì•ˆì—ì„œ ë°©ê¸ˆ ì¸ë±ìŠ¤ì˜ ì´ëª¨ì§€ë¥¼ ì ìš©
            }, DISPLAY_MS);
          }

          // ìµœì´ˆ 1íšŒ í‘œì‹œ ì‹œì—ë„ ì´ëª¨ì§€ ë°˜ì˜ë˜ë„ë¡ show(0)ë§Œ í˜¸ì¶œí•˜ë©´ OK
          show(0);
          start();

          ads.addEventListener("mouseenter", () => { paused = true; });
          ads.addEventListener("mouseleave", () => { paused = false; });

        } catch (e) {
          console.warn("[ADS] ì´ˆê¸°í™” ì‹¤íŒ¨:", e);
        }
      }

      // ë¬¸ì„œ ì¤€ë¹„ í›„ ìë™ ì‹¤í–‰(ê¸°ì¡´ ë¡œì§ ìœ ì§€)
      if (document.readyState === "complete" || document.readyState === "interactive") {
        initHeaderAds();
      } else {
        document.addEventListener("DOMContentLoaded", initHeaderAds);
      }


      if (typeof window.showCalcView !== "function") {
        let calcInited = false;
        window.showCalcView = function (mode) {
          const main = document.getElementById("main-view");
          const calc = document.getElementById("calc-view");
          hideBlockHard(main);                 // â† ìƒë‹¨ ê³µê°„ ì™„ì „ ì œê±°
          hideBlockHard(document.querySelector("section.hero"));
          // .shell ì»¨í…Œì´ë„ˆëŠ” ìœ ì§€, headerë¥¼ ì œì™¸í•œ ìì‹ë§Œ ì ‘ê¸°
          const shell = document.querySelector('div.shell');
          if (shell) {
            shell.querySelectorAll(':scope > :not(header):not(#site-header)').forEach(hideBlockHard);
          }
          // í˜¹ì‹œ .shell ë°–ì— ë‚¨ì•„ ìˆì„ ìˆ˜ ìˆëŠ” ëœë”© ì„¹ì…˜ë“¤ ë³´ê°•
          ['.login-wrap', '.hero', '.spacer', '.notice', '.grid', '#hero']
            .forEach(sel => hideBlockHard(document.querySelector(sel)));
          if (calc) {
            calc.removeAttribute('hidden');
            calc.style.display = 'block';
          }

          document.body.classList.toggle("pc", mode === "pc");
          document.body.classList.toggle("mobile", mode === "mobile");
          if (!calcInited) {
            // í•„ìš” ì‹œ í•œ ë²ˆë§Œ ì´ˆê¸°í™” ë¡œì§ í˜¸ì¶œ (initCalculator ë“±)
            calcInited = true;
          }
          window.scrollTo(0, 0);
        };
      }

      // (ì„ íƒ) #g_id_onloadì— client_idê°€ ë¹„ì–´ìˆìœ¼ë©´ ì±„ì›Œì¤Œ
      const onloadDiv = document.getElementById("g_id_onload");
      if (onloadDiv && !onloadDiv.dataset.clientId) {
        onloadDiv.dataset.clientId = GOOGLE_CLIENT_ID;
      }
    })();

  </script>
</body>

</html>

<!DOCTYPE html>
<html lang="ko">

<head>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>게임실험연구소 계산기 (시즌5)</title>
  <style>
    /*기본 변수 색상*/
    :root {
      --bg: #0f1115;
      --panel: #151922;
      --text: #e6e9ef;
      --muted: #9aa3b2;
      --accent: #6ea8ff;
      --ring: rgba(110, 168, 255, 0.45);
      --gold: #cfa24f;
      --gold-2: #8f6b2b;
      --card-bg: #17120f;
    }

    /*모든 박스*/
    * {
      box-sizing: border-box;
    }

    /*html과 body에 대해 */
    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(1200px 600px at 50% -10%, #1b2130 0%, #0f1115 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial;
      overflow: auto;
    }

    .wrap {
      max-width: 1300px;
      margin: 20px auto;
      padding: 0 16px;
    }

    .top-title {
      text-align: center;
      font-weight: 800;
      font-size: clamp(20px, 2.6vw, 36px);
      margin: 6px 0 4px;
    }

    .sub-alert {
      text-align: center;
      color: #ffb3b3;
      font-size: 13px;
      margin-bottom: 10px;
    }

    .main2 {
      text-align: center;
      color: #ff0000;
      font-size: 12px;
      margin-bottom: 10px;
      font-weight: bold;
      /* 글씨 두께 → 굵게 */
    }

    .grid {
      display: grid;
      grid-template-columns: 1.4fr 0.9fr;
      /* 왼쪽 큰 비주얼 / 오른쪽 공지 */
      gap: 18px;
      align-items: start;
    }

    /* ===== 왼쪽: 메인 비주얼 + 로그인 카드 ===== */
    .hero {
      display: flex;
      align-items: center;
      /* 세로 가운데 */
      position: relative;
      background: #0b0f16;
      border: 1px solid #1f2633;
      border-radius: 14px;
      overflow: hidden;
      min-height: 460px;
    }

    .hero-img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      opacity: .92;
      filter: saturate(1.05) contrast(1.05);
    }

    /* 오른쪽 컬럼: 공지 + 로그인 세로로 쌓기 */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 16px;
      /* 두 박스 사이 간격 */
    }

    /* 스샷의 빨간 타원 위치: 하단 좌측에 뜨는 둥근 직사각형 */
    .login-card {
      position: static;
      /* 고정 해제 */
      width: 100%;
      /* 오른쪽 칼럼 너비 꽉 채우기 */
      background: linear-gradient(180deg, rgba(255, 255, 255, .08), rgba(255, 255, 255, .05));
      border: 1px solid rgba(255, 255, 255, .16);
      border-radius: 16px;
      box-shadow: 0 8px 40px rgba(0, 0, 0, .45), inset 0 0 0 6px rgba(110, 168, 255, .06);
      padding: 14px 16px;
      backdrop-filter: blur(2px);
    }

    .login-title {
      font-weight: 700;
      margin: 2px 0 8px;
      font-size: 15px;
      letter-spacing: .2px;
    }

    .login-desc {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
      margin-bottom: 10px;
    }

    .login-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .login-hint {
      color: #a2ffcf;
      font-size: 12px;
    }

    /* ===== 오른쪽: 업데이트/공지 ===== */
    .notice {
      background: linear-gradient(180deg, rgba(255, 255, 255, .05), rgba(255, 255, 255, .03));
      border: 1px solid rgba(255, 255, 255, .12);
      border-radius: 14px;
      padding: 14px 14px 18px;
    }

    .notice h3 {
      margin: 6px 0 10px;
      font-size: 18px;
    }

    .notice .box {
      background: var(--soft);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px 12px;
      margin-bottom: 10px;
    }

    .notice ul {
      margin: 6px 0 0 18px;
      padding: 0;
      line-height: 1.5;
    }

    .badge-danger {
      color: #ff8b8b;
      font-weight: 700
    }

    .upgrade {
      margin-top: 10px;
      background: #172233;
      border: 1px solid #253148;
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 14px;
    }

    .upgrade a {
      color: #8fbaff;
      text-decoration: underline;
    }

    /* 반응형 */
    @media (max-width: 980px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .hero {
        min-height: 420px;
      }

      .login-card {
        left: 12px;
        right: 12px;
        width: auto;
      }
    }

    /*클래스선택자(색상세트)*/
    .shell {
      height: 100dvh;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    /*맨 위 제목임*/
    /*header는 제목, head는 메타정보*/
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      /*정렬*/
      padding: 12px 18px;
      /*안쪽 여백*/
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0));
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(4px);
    }

    /*header : 태그선택자, title : 클래스, h1 : 태그선택자, header안 -> title안 -> h1만 선택*/
    header .title h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
    }

    /*앞쪽에 태그선택자가 없으므로, 전역에 actions 클래스 사용가능*/
    .actions {
      font-size: 12px;
      color: var(--muted);
    }

    /* 레이아웃: 오른쪽에 합산 패널 열 추가 (고정폭) */
    .layout {
      display: grid;
      grid-template-columns:
        minmax(220px, 1fr)
        /* 1번째 열 (왼쪽) */
        minmax(320px, 36vw)
        /* 2번째 열 (캐릭터) */
        minmax(220px, 1fr)
        /* 3번째 열 (오른쪽) */
        300px
        /* 4번째 열 (옵션) */
        300px;
      /* 5번째 열 (합산스탯) */
      grid-template-rows: auto auto;
      gap: clamp(8px, 2vw, 24px);

      grid-template-areas:
        "left char right options stats"
        "save save right options stats";
    }

    .left-col {
      grid-area: left;
    }

    .char-col {
      grid-area: char;
    }

    .right-col {
      display: flex;
      flex-direction: column;
    }

    .options-col {
      grid-area: options;
      grid-row: 1 / span 2;
    }

    .stats-col {
      grid-area: stats;
      grid-row: 1 / span 2;
    }

    .save-box {
      grid-area: save;
    }

    .save-box {
      grid-area: save;
      background: rgba(110, 168, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 18px;
      padding: 12px 16px;
      display: flex;
      justify-content: flex-start;
      /* ← 왼쪽 정렬 */
      gap: 10px;
      position: relative;
      transform: translateY(-100px);
      /* -6 ~ -20px 등으로 조절 */
      z-index: 2;
      /* 겹칠 때 위에 보이게 */
    }

    .save-box button {
      width: 48px;
      /* 정사각형 */
      height: 48px;
      /* 정사각형 */
      border-radius: 12px;
      /* 둥근 모서리 */
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 24px;
      /* + 기호 크게 */
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .save-box button:hover {
      background: rgba(255, 255, 255, 0.2);
    }


    /* justify-content 는 가로방향정렬, align-items 은 세로방향정렬
 flex-start는 아이템들을 시작지점에 붙여서정렬 가로면 왼쪽정렬, 세로면 위쪽정렬
 flex-end는 아이템들을 끝지점에 붙여서 정렬, 가로면 오른쪽정렬, 세로면 아래쪽정렬*/
    .column {
      display: flex;
      flex-direction: column;
      align-self: start !important;
      /* 세로축 위쪽 정렬 */
      height: max-content !important;
      /* 내용만큼만 높이 */
      gap: 12px;
      padding: 10px 6px;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .slot-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /*slot-row 와 left 두가지 클래스 모두를 가지고 있는것, slot-row와 left 중 하나만 있으면 적용되지 않는다)
//slot-row left 점이 아닌 띄어쓰기를 하면, left가 앞 요소 안의 요소가 되는데, 이때 left는 태그이다. .left로 쓰게되면 클래스가 된다.
//html(클래스)에 넣어서 쓸때는 띄어쓰기로 쓴다. class = "slot-row left" */
    .slot-row.left {
      justify-content: flex-end;
    }

    .slot-row.right {
      justify-content: flex-start;
    }

    .slot {
      width: clamp(64px, 10vh, 120px);
      aspect-ratio: 1/1;
      border-radius: 12px;
      background: radial-gradient(120px 120px at 40% 35%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02) 50%, rgba(255, 255, 255, 0.01) 100%);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: grid;
      place-items: center;
      position: relative;
      cursor: pointer;
      user-select: none;
      transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25) inset, 0 1px 0 rgba(255, 255, 255, 0.04);
    }

    /* :는 의사클래스, hover는 마우스를 위에 올린 상태를 뜻함. 따라서 slot 클래스에 마우스를 올리면 이라는 뜻
// 그외에도 active : 클릭한 순간(마우스 버튼 누르고 있을때), focus : 입력창 클릭했을때, visited : 방문한 링크, link : 방문하지 않은 링크
// first-child : 부모 안에서 첫번째 자식, last-child : 부모 안에서 마지막 자식, ntn-child(n) : 부모 안에서 n번째 자식
//checked : 체크박스나 라디오버튼에 체크된상태, valid, invalid : 입력값이 유효성 검사에 맞거나 아닐때
//root : 문서 최상위 요소 */
    .slot:hover {
      transform: translateY(-2px);
      border-color: rgba(110, 168, 255, 0.5);
      box-shadow: 0 0 0 4px var(--ring), 0 10px 24px rgba(0, 0, 0, 0.35) inset;
    }

    /* slot-label 클래스는 slot의 자손선택자이다. 따라서 slot 클래스를 선언하고 그 안에 또 slot-label 클래스를 선언해야한다. */
    .slot .slot-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      color: var(--muted);
      background: rgba(0, 0, 0, 0.35);
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      white-space: nowrap;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .outer-rects {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .rect {
      width: clamp(52px, 8vh, 96px);
      height: clamp(18px, 3vh, 28px);
      border-radius: 10px;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.06) inset, 0 6px 16px rgba(0, 0, 0, 0.25) inset;
      color: var(--text);
      font-size: 10px;
    }

    .rect:hover {
      border-color: rgba(110, 168, 255, 0.55);
      box-shadow: 0 0 0 3px var(--ring), 0 8px 18px rgba(0, 0, 0, 0.35) inset;
    }

    .rect.disabled {
      opacity: .45;
      pointer-events: none;
    }

    .center {
      display: grid;
      place-items: center;
      min-width: min(34vw, 460px);
      height: 100%;
    }

    .character-card {
      /*메인 캐릭터 박스*/
      /*margin-top: 0px;  /* 원하는 값(px, %, rem 등) */
      align-self: start;
      /* ← 세로축 위쪽에 붙음 */
      width: clamp(20px, 25vw, 520px);
      aspect-ratio: 3/4;
      border-radius: 22px;
      background: radial-gradient(60% 40% at 50% 10%, rgba(110, 168, 255, 0.08), transparent 60%),
        linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: grid;
      place-items: center;
      position: relative;
      overflow: hidden;
      cursor: pointer;
      box-shadow: 0 0 0 6px rgba(110, 168, 255, 0.08) inset, 0 20px 50px rgba(0, 0, 0, 0.45);
    }

    .character-ghost {
      width: 80%;
      height: 80%;
      border-radius: 24px;
      border: 2px dashed rgba(255, 255, 255, 0.18);
      display: grid;
      place-items: center;
      color: var(--muted);
      text-align: center;
    }

    .character-img {
      position: absolute;
      inset: 12px;
      width: calc(100% - 24px);
      height: calc(100% - 24px);
      object-fit: contain;
      filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.45));
      display: none;
    }

    /* ▼ 하단 4개 슬롯 */
    .mini-bar {
      align-self: start;
      /* 그리드 칸에서 위쪽에 붙임 */
      /*margin-top: 10px;*/
      margin-bottom: 70px;
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    .mini-cell {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .slot.mini {
      width: clamp(64px, 10vh, 120px);
      aspect-ratio: 1 / 1;
      border-radius: 12px;
      flex: 0 0 auto;
    }

    /*slot클래스와 mini클래스 동시에 적용하며 그 두 클래스의 자손클래스가 slot-label이 된다.*/
    .slot.mini .slot-label {
      position: absolute;
      top: 50%;
      left: 50%;
      bottom: auto;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      z-index: 50;
    }

    .modal.show {
      display: grid;
    }

    .backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(2px);
    }

    .dialog {
      position: relative;
      width: min(1100px, 95vw);
      height: min(720px, 92vh);
      background: #0e0b09;
      border: 1px solid #2a211a;
      border-radius: 18px;
      padding: 12px 14px;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
    }

    /*header와 h2는 dialog의 자손태그들이다. 태그는 쓰려면 <header> </header>을 써야한다.
//이 코드만 보고는 종속관계를 알수는 없다. header가 더 높은지, h2가 높은지 알수없다. */
    .dialog header {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 10px;
      padding: 6px 4px 8px;
      border-bottom: 1px solid #2a211a;
    }

    .dialog h2 {
      margin: 0;
      font-size: 15px;
      font-weight: 700;
      color: #f0e6d2;
    }

    .input {
      height: 34px;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      padding: 0 10px;
      background: #1a130f;
      color: #f0e6d2;
    }

    /* 캐릭터 카탈로그 */
    .catalog {
      overflow: auto;
      padding: 10px 6px 14px;
    }

    .row {
      display: grid;
      grid-template-columns: 56px 1fr 56px;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    .badge-img {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      object-fit: cover;
      background: #20170f;
      border: 2px solid #6e5124;
    }

    .cards {
      /* 카드의 스타일 */
      display: grid;
      /* 그리드 레이아웃 배치*/
      grid-template-columns: repeat(5, minmax(160px, 1fr));
      /* 가로칸(columns) 4개, 각칸은 최소 160px, 최대 1fr(=남는 공간 균등 분배) 크기 */
      gap: 12px;
      /*카드들 사이 가로/세로 간격 */
    }

    .char-card {
      position: relative;
      display: grid;
      grid-template-rows: auto auto;
      /*세로로 2줄 그리드 (첫줄 이미지, 두번째줄 이름*/
      gap: 6px;
      /* 줄 사이 6px 간격 */
      padding: 8px;
      /* 안쪽 여백 */
      border-radius: 12px;
      background: var(--card-bg);
      cursor: pointer;
      /*마우스 올리면 손가락 모양*/
      border: 1px solid var(--gold-2);
      /* 카드 테두리 (금색 계열 변수) */
    }

    .char-card:hover {
      /*마우스 올렸을때 효과 */
      box-shadow: inset 0 0 0 2px rgba(207, 162, 79, 0.22), 0 8px 22px rgba(0, 0, 0, 0.55);
    }

    .char-card.disabled {
      filter: grayscale(1) saturate(0) brightness(.8);
      opacity: .6;
      cursor: not-allowed;
    }

    .char-card.disabled:hover {
      box-shadow: none;
      /* 호버 효과 제거 */
    }

    .char-card.disabled .char-img {
      filter: grayscale(1) contrast(.9);
    }

    .char-img {
      width: 100%;
      /* 부모 카드의 가로폭을 전부 차지 */
      aspect-ratio: 16/7;
      /* 가로:세로 비율 16:7 유지 */
      object-fit: cover;
      /* 이미지 잘리더라도 영역 꽉 채움 */
      border-radius: 8px;
      border: 1px solid rgba(207, 162, 79, 0.35);
      background: #0c0a08;
    }

    .char-name {
      font-size: 14px;
      color: #f0e6d2;
      font-weight: 700;
    }

    /* 무기 탭 */
    .weapon-tabs {
      display: flex;
      gap: 8px;
      margin: 0 10px;
      flex-wrap: wrap
    }

    .weapon-tabs .tab-btn {
      height: 30px;
      padding: 0 12px;
      border-radius: 999px;
      cursor: pointer;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #c7b589
    }

    .weapon-tabs .tab-btn.active {
      background: #2a211a;
      border-color: #cfa24f;
      color: #f0e6d2;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset
    }

    /*overflow는 요소크기보다 내용이 넘치면 어떻게 처리할지를 나타냄
//auto는 자동 스크롤바 생김, visible은 그냥 밖으로 삐져나옴, hidden은 넘치는 부분 잘라냄, scroll은 항상 스크롤바 표시 */
    /* 리스트형 카드 */
    .items {
      overflow: auto;
      padding: 12px 8px 16px;
      display: grid;
      gap: 14px;
    }

    .item-list {
      display: grid;
      grid-template-columns: repeat(2, minmax(280px, 1fr));
      gap: 12px
    }

    .item-row {
      display: grid;
      grid-template-columns: 72px 1fr 64px;
      align-items: center;
      gap: 12px;
      background: #15100c;
      border: 1px solid #3a2c21;
      border-radius: 12px;
      padding: 10px;
      cursor: pointer
    }

    .item-row:hover {
      border-color: #7c5b37;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset
    }

    .iconbox {
      position: relative;
      width: 64px;
      height: 64px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(207, 162, 79, .35);
      background: #0c0a08
    }

    .iconbox .icon {
      width: 100%;
      height: 100%;
      object-fit: cover
    }

    .badge-lv {
      position: absolute;
      left: 4px;
      top: 4px;
      font-size: 11px;
      padding: 2px 5px;
      border-radius: 6px;
      background: #1e2b1e;
      color: #9fe19f;
      border: 1px solid #254c25
    }

    .meta .meta-top {
      display: flex;
      align-items: baseline;
      gap: 8px
    }

    .meta .lvl {
      color: #9fe19f;
      font-weight: 700;
      font-size: 13px
    }

    .meta .name {
      color: #f0e6d2;
      font-weight: 800;
      font-size: 15px
    }

    .meta-sub {
      color: #c7b589;
      font-size: 12px;
      margin-top: 4px
    }

    .rarity-chip {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid #7c5b37;
      background: #2a211a;
      color: #e7c27a;
      font-weight: 700;
      font-size: 12px;
      text-align: center
    }

    /* === Options panel (우측 옵션 열) === */
    .column.options {
      align-items: stretch;
      /* 너비 꽉 차게 */
      gap: 12px;
    }

    .opt-box {
      width: 100%;
      border-radius: 14px;
      padding: 12px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: grid;
      gap: 10px;
    }

    .opt-title {
      margin: 0 0 2px;
      font-size: 13px;
      font-weight: 800;
      color: #f0e6d2;
      letter-spacing: .2px;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field .label {
      font-size: 11px;
      color: var(--muted);
    }

    .select {
      height: 34px;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      padding: 0 10px;
      background: #1a130f;
      color: #f0e6d2;
      outline: none;
    }

    .select:focus {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    /*@는 모바일 전환시 사용하는 부호. 정확히는 폭이 좁아지면.
    /* 모바일 1열 전환 시 자연스럽게 흐르도록(기존 규칙 유지) */
    @media (max-width: 900px) {
      .column.options {
        order: 3;
      }

      /* 중앙/오른쪽 다음에 위치 */
    }

    /* ▶ 합산 패널 (우측 고정 + 최종데미지) */
    aside.stats {
      align-self: start;
      /* 그리드 안에서 위쪽 정렬 */
      width: 100%;
      position: static;
      /* 기본 흐름으로 */
      top: auto;
      /* sticky 기준 제거 */
      height: 100%;
      /* 불필요한 100% 높이 제거 */
    }

    .stats-panel {
      width: 100%;
      height: 100%;
      border-radius: 18px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
    }

    .stats-panel h3 {
      margin: 4px 0 0;
      font-size: 14px;
      color: #f0e6d2;
    }

    .stat-list {
      overflow: auto;
      padding-right: 6px;
      display: grid;
      gap: 8px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 8px 10px;
    }

    .stat-label {
      color: var(--muted);
      font-size: 12px;
    }

    .stat-value {
      color: #e8edd6;
      font-weight: 800;
      font-size: 14px;
      text-align: right;
    }

    .final-damage {
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      padding-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 6px;
    }

    .final-damage .label {
      color: #f0e6d2;
      font-size: 13px;
      line-height: 1;
      text-align: left;
    }

    .final-damage .value {
      color: #ff5a6a;
      font-weight: 900;
      font-size: 25px;
      letter-spacing: .3px;
      line-height: 1.15;
      align-self: flex-end;
      text-align: right;
    }

    /* #은 고유 id를 뜻한다. 클래스와 다른점은 고유하기때문에 단한번만 사용한다는 차이가 있음 */
    /* 강화 선택 모달(텍스트 리스트) */
    #enhanceModal .dialog {
      width: min(520px, 95vw);
      height: min(520px, 85vh);
    }

    .enh-list {
      overflow: auto;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .enh-option {
      height: 36px;
      padding: 0 12px;
      text-align: left;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #f0e6d2;
      cursor: pointer;
    }

    .enh-option:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
        grid-auto-rows: max-content;
        gap: 18px;
        height: auto;
        overflow: auto;
      }

      .center {
        min-width: 0;
      }

      .cards,
      .item-list {
        grid-template-columns: repeat(2, 1fr);
      }

      .row {
        grid-template-columns: 40px 1fr 40px;
      }

      .badge-img {
        width: 40px;
        height: 40px;
      }

      aside.stats {
        position: static;
      }
    }
    /* ───── 자동 관련 모달들 ───── */
    .auto-box {
      width: 100%;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
      margin-bottom: 10px;
    }

    .auto-box h4 {
      margin: 0 0 8px;
      font-size: 14px;
      color: #e7c27a;
    }

    .auto-box .btnetc {
      width: 100%;
      height: 34px;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #f0e6d2;
      cursor: pointer;
    }

    .auto-box .btnetc:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    .auto-box .btnetc[disabled] {
      opacity: .5;
      cursor: not-allowed;
    }
    /* ───── 기본 모달 크기 조정 ───── */
    .dialogetc {
      position: relative;
      background: #0e0b09;
      border: 1px solid #2a211a;
      border-radius: 18px;
      padding: 12px 14px;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
    }
    #autoEnhModal .dialogetc {
      width: min(300px, 95vw);
      height: min(720px, 92vh);
    }
    #autoSealModal .dialogetc {
      width: min(550px, 95vw);
      height: min(250px, 85vh);
    }
    #autoEnchantModal .dialogetc {
      width: min(1000px, 96vw);
      height: min(250px, 85vh);
    }
    #autoEmblemModal .dialogetc {
  width: min(1200px, 96vw);   /* ✅ 5~10 (6개) 1줄도 여유 */
  height: min(400px, 90vh);  /* ✅ 두 줄 구조에 맞게 높이 조정 */
}
    #castleSealModal .dialogetc {
      width: min(870px, 95vw);
      height: min(770px, 92vh);
    }

    /* 기본 컬럼 중앙 정렬 */
    .cols {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      gap: 14px;
    }

    /* ───── 기본 소제목 조정 ───── */
    .cols .titles {
      margin-bottom: 12px;
      font-size: 16px;
      font-weight: 700;
      color: #e7c27a;
      text-align: center;
    }
    #autoSealModal .cols .titles {
      margin-bottom: 12px;
      font-size: 16px;
      font-weight: 700;
      color: #e7c27a;
      text-align: center;
    }
        /* 타이틀 여백/스타일도 강화설정 모달과 톤을 맞춤 */
    #autoEnchantModal .cols .titles {
      margin-bottom: 12px;
      font-size: 16px;
      font-weight: 700;
      color: #e7c27a;
      text-align: center;
    }

     /* ───── 기본 버튼리스트 조정 ───── */
    .cols .lists {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }
    #autoEnhModal .cols .lists {
      flex-direction: column;
    }
    #autoSealModal .cols .lists {
      align-items: center;
    }

    #autoSealModal .cols {
  display: flex;
  flex-direction: column; /* 세로로 쌓이게 */
  align-items: center;
  width: 100%;
}

    #autoEnchantModal .cols .lists {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }

    #castleSealModal .cols .lists {
      flex-direction: column;
    }

#autoEmblemModal .lists.attrs,
#autoEmblemModal .lists.tiers {
  display: flex;
  flex-direction: column;     /* 각 행(row)을 세로로 쌓기 */
  align-items: center;        /* 행 자체를 중앙 배치 */
  row-gap: 1px;
}

#autoEmblemModal .lists.attrs .row,
#autoEmblemModal .lists.tiers .row {
  display: flex;
  justify-content: center;    /* 행 안의 버튼을 중앙 정렬 */
  row-gap: 6px;
  flex-wrap: nowrap;          /* 정확히 1줄 유지 */
}

    /* ----- 제목 모양 정리 -----*/
    .dialogetc header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      /* 가운데 정렬 */
      padding: 6px 0 8px;
      border-bottom: 1px solid #2a211a;
    }

     #castleSealModal .dialogetc header {
font-size: 17px;
    }

    .dialogetc header h2 {
      margin: 0;
      font-size: 15px;
      color: #f0e6d2;
      font-weight: 700;
      flex: none;
      text-align: center;
    }


    /* 기본 닫기 버튼 크기·모양 정리 */
    .dialogetc header button {
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #f0e6d2;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 26px;
      height: 26px;
    }

    .dialogetc header button:hover {
      background: rgba(255, 255, 255, 0.16);
      border-color: rgba(255, 255, 255, 0.3);
    }

   
    /* ───── 기본 버튼 크기 통일 ───── */
    .opt-btnetc {
      width: 110px;
      height: 38px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      background: #1a130f;
      color: #f0e6d2;
      border: 1px solid #3a2c21;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    #autoEnhModal .opt-btnetc {
      flex-direction: column;
    }
    #autoEnchantModal .opt-btnetc {
      width: 100px;
    }
    #castleSealModal .opt-btnetc {
      width: 300px;
      height: 80px;
      font-size: 15px;
    }

    .opt-btnetc:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.25) inset;
    }

    .opt-btnetc.active {
      border-color: #cfa24f;
      background: rgba(207, 162, 79, 0.1);
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.25) inset;
    }

    #castleSealModal .opt-btnetc .name {
  gap : 2px;
}

    .ui-btnetc {
      display: inline-block;
  padding: 14px 34px;
  border-radius: 6px;           /* 끝이 아주 살짝 둥글게 */
  background: #ecc947;          /* 고급스러운 노란색 */
  color: #111;                  /* 글자는 검은색 */
  font-size: 17px;
  font-weight: 700;
  border: none;
  cursor: pointer;
  transition: background 0.2s ease, box-shadow 0.2s ease;
  text-align: center;
  margin: 12px auto;            /* 가운데 정렬 */
  display: block;               /* 중앙 배치 */
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    /* 마우스 올렸을 때 밝아지는 효과 */
.ui-btnetc:hover {
  background: #ffe263;          /* 조금 더 밝은 노란색 */
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
}

/* 클릭 시 살짝 눌리는 효과 (선택 사항) */
.ui-btnetc:active {
  transform: scale(0.98);
}


    /* ───── 모바일 대응 (1열 전환 시) ───── */
    @media (max-width: 520px) {
      #autoSealModal .body.two-col {
        grid-template-columns: 1fr;
      }

      #autoSealModal .body.two-col::after {
        display: none;
      }
    }

/* (기존) #autoEnchantModal 전용 ↓ 이 줄을 이렇게 바꾼다 */
@media (max-width: 520px) {
  #autoEnchantModal .body.two-col,
  #autoEmblemModal .body.two-col {   /* ✅ 추가 */
    grid-template-columns: 1fr;
  }
  #autoEnchantModal .body.two-col::after,
  #autoEmblemModal .body.two-col::after {  /* ✅ 추가 */
    display: none;
  }
}


 
    /* 추천 마법부여 모달: 속성선택 ↔ 추천티어 구분선 */
    .body.two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      position: relative;
      /* 구분선 기준 위치 지정 */
    }

    .body.two-col::after {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      /* 정확히 가운데 배치 */
      width: 1px;
      background: rgba(255, 255, 255, 0.12);
      /* 은은한 라인 색 */
      pointer-events: none;
      /* 클릭 방해 없음 */
    }

    /* 모바일 좁은 화면에선 1열로 떨어지도록 */
    @media (max-width: 520px) {
      #autoEnchantModal .body.two-col {
        grid-template-columns: 1fr;
      }

      #autoEnchantModal .body.two-col::after {
        display: none;
      }
    }

    /* 고정 높이 아이템 모달 */
    #itemModal .dialog {
      grid-template-rows: auto auto;
    }

    #itemModal .items {
      height: clamp(420px, 60vh, 560px);
      max-height: clamp(420px, 60vh, 560px);
      overflow: auto;
    }

    /* === Emblem sockets & modal — FINAL MERGED === */

    /* Stack of 2 sockets (vertical) */
    .emblem-stack {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    /* Socket dot (small circular button) */
    .emblem-dot {
      width: 28px;
      height: 28px;
      position: relative;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, .25);
      background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35) inset, 0 0 0 3px rgba(110, 168, 255, 0);
      display: grid;
      place-items: center;
      /* Hard guarantee: perfect circle in every browser */
      border-radius: 999px !important;
      overflow: hidden !important;
      clip-path: circle(50% at 50% 50%) !important;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
      background-clip: padding-box;
    }

    .emblem-dot:hover {
      box-shadow: 0 0 0 3px var(--ring);
    }

    /* When an emblem image is applied from JS as CSS var */
    .emblem-dot.has-img {
      background:
        var(--emblem) center/cover no-repeat,
        linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02)) !important;
    }

    .emblem-dot.has-img::after {
      display: none !important;
    }

    /* hide dashed guide when filled */

    /* Empty socket guide */
    .emblem-dot.empty {
      opacity: .45;
    }

    .emblem-dot.empty::after {
      content: "";
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px dashed rgba(255, 255, 255, .3);
    }

    /* Images inside sockets always clipped to circle */
    .emblem-dot img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      border-radius: 999px !important;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
    }

    /* Center number (socket & picker) — bright & legible */
    .emblem-dot .num,
    .em-thumb .num {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      color: #fff;
      font-weight: 900;
      letter-spacing: .2px;
      -webkit-text-stroke: 1px rgba(0, 0, 0, .35);
      text-shadow:
        0 1px 1px rgba(0, 0, 0, .55),
        0 0 4px rgba(255, 255, 255, .65),
        0 0 10px rgba(255, 255, 255, .45);
    }

    .emblem-dot .num {
      font-size: 16px;
    }

    /* 28px socket */
    .em-thumb .num {
      font-size: 22px;
    }

    /* 56px picker */

    /* Subtle center darkening behind number (not too strong) */
    .emblem-dot .num::before,
    .em-thumb .num::before {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 80%;
      border-radius: 999px;
      pointer-events: none;
      background: radial-gradient(circle,
          rgba(0, 0, 0, .18) 0%,
          rgba(0, 0, 0, .10) 45%,
          rgba(0, 0, 0, 0) 70%);
    }

    /* Hover: enhance number legibility */
    .emblem-dot:hover .num,
    .em-thumb:hover .num {
      -webkit-text-stroke: 1px rgba(0, 0, 0, .45);
      text-shadow:
        0 1px 2px rgba(0, 0, 0, .75),
        0 0 6px rgba(255, 255, 255, .60),
        0 0 14px rgba(255, 255, 255, .50);
    }

    /* === Emblem picker rows (horizontal scrollers) === */
    .em-rows {
      display: grid;
      gap: 12px;
      padding: 12px;
    }

    .em-row {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 6px;
    }

    /* Picker thumbnail (badge-like) */
    .em-thumb {
      width: 56px;
      height: 56px;
      position: relative;
      cursor: pointer;
      border-radius: 999px;
      padding: 0;
      border: 1px solid #3a2c21;
      background: #1a130f;
      display: grid;
      place-items: center;
      overflow: hidden;
    }

    .em-thumb:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    /* Always circular images */
    .em-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      border-radius: 999px !important;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
    }

    /* 'None' option as a circular crossed badge */
    .em-thumb.none {
      background: linear-gradient(135deg, #1a130f 0%, #0c0a08 100%);
      border-radius: 999px;
    }

    .em-thumb.none::before,
    .em-thumb.none::after {
      content: "";
      position: absolute;
      left: 10px;
      right: 10px;
      top: 50%;
      height: 2px;
      background: rgba(255, 255, 255, .35);
    }

    .em-thumb.none::after {
      transform: rotate(90deg);
    }

    /* Caption (for accessary/title slots) */
    .emblem-caption {
      margin-top: 4px;
      font-size: 11px;
      line-height: 1.1;
      color: #e7c27a;
      text-align: center;
      max-width: 84px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
    }

    /* === Seal text captions inside slots === */
    .seal-captions {
      position: absolute;
      left: 6px;
      bottom: 6px;
      display: flex;
      flex-direction: column;
      gap: 2px;
      /* 행 간격 2px */
      pointer-events: none;
      /* 비클릭 */
    }

    .seal-captions .seal-row {
      display: flex;
      gap: 2px;
      justify-content: flex-start;
    }

    /* 좌측정렬 */
    .seal-captions .seal-chip {
      max-width: calc(100% - 12px);
      font-size: 9px;
      line-height: 1.2;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(207, 162, 79, 0.35);
      /* 기존 골드 톤과 어울리게 */
      color: inherit;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }



    /* === Skill Rune === */
    .rune-head {
      display: flex;
      gap: 8px;
      align-items: center;
      white-space: nowrap;
      /* ✅ 줄바꿈 방지 */
    }

    .rune-head div {
      font-size: 12px;
      color: var(--muted, #6b7280);
      white-space: nowrap;
      /* ✅ 카운터도 줄바꿈 없음 */
    }

    .rune-head b {
      color: #e7c27a;
    }

    .rune-grid {
      --col-w: minmax(64px, 1fr);
      display: grid;
      grid-auto-rows: 40px;
      gap: 8px;
      overflow: auto;
    }

    .rune-grid .row {
      display: grid;
      grid-template-columns: 120px repeat(8, var(--col-w));
      align-items: center;
      gap: 8px;
    }

    .rune-grid .head {
      position: sticky;
      left: 0;
      z-index: 1;
      padding: 0 10px;
      border: 1px solid #3a2c21;
      border-radius: 10px;
      background: #1a130f;
      color: #f0e6d2;
      font-weight: 800;
      font-size: 13px;
      white-space: nowrap;
    }

    .rune-grid .cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .rune-select {
      width: 100%;
      height: 30px;
      border-radius: 8px;
      border: 1px solid #3a2c21;
      background: #15100c;
      color: #f0e6d2;
      padding: 0 8px;
    }

    .rune-select:focus {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    /* 룬 각인 UI */
    .rune-engrave-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .field.compact {
      flex: 1 1 220px;
    }

    /* === Skill Tree UI — FINAL MERGED === */

    /* Header row */
    .skilltree-head {
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      gap: 15px;
      white-space: nowrap;
      /* ✅ 줄바꿈 금지 */
    }

    .st-counters {
      display: flex;
      flex-direction: column;
      /* ✅ 세로 방향으로 */
      align-items: flex-start;
      gap: 6px;
      /* 위아래 간격 */
      white-space: nowrap;
    }

    .skilltree-head .st-counters span {
      display: inline-flex;
      align-items: center;
      font-size: 14px;
      color: var(--muted, #6b7280);
    }

    .skilltree-head .st-counters b {
      margin-left: 4px;
      color: var(--text, #1f2937);
    }

    /* 공통 버튼(얇은 라운드, 대비 확보) */
    .ui-btn {
      --ui-bg: #fff;
      --ui-fg: #1f2937;
      --ui-bd: #e5e7eb;
      --ui-ring: rgba(37, 99, 235, .15);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 32px;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid var(--ui-bd);
      background: var(--ui-bg);
      color: var(--ui-fg);
      font-size: 13px;
      font-weight: 600;
      letter-spacing: .1px;
      white-space: nowrap;
      /* ✅ 버튼 자체도 줄바꿈 금지 */
      user-select: none;
      cursor: pointer;
      transition: transform .06s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease;
      box-shadow: 0 1px 2px rgba(0, 0, 0, .04);
    }

    .ui-btn:hover {
      box-shadow: 0 4px 14px rgba(31, 41, 55, .08);
    }

    .ui-btn:active {
      transform: translateY(1px);
    }

    .ui-btn:focus-visible {
      outline: 0;
      box-shadow: 0 0 0 3px var(--ui-ring);
    }

    /* 담백한 변형 */
    .ui-btn.ghost {
      background: #f8fafc;
    }

    /* 다크 테마 대비(있으면 적용) */
    @media (prefers-color-scheme: dark) {
      .ui-btn {
        --ui-bg: #0f1115;
        --ui-fg: #e6e9ef;
        --ui-bd: #273041;
      }

      .ui-btn.ghost {
        background: #151922;
      }
    }

    .ui-btn.primary {
      --ui-bg: #2563eb;
      /* 파란 배경 */
      --ui-fg: #fff;
      /* 흰 글씨 */
      --ui-bd: #2563eb;
      background: var(--ui-bg);
      color: var(--ui-fg);
      border: 1px solid var(--ui-bd);
    }

    /* Top utility bar */
    .st-topbar {
      display: flex;
      gap: 14px;
      align-items: center;
      font-size: 12px;
      color: #c7b589;
    }

    /* ===== Universal counter styles (base) ===== */
    .st-counter {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, .25);
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 10px;
      font-size: 13px;
      /* base size; overridden in modal scope */
    }

    .st-counter .label {
      font-weight: 800;
      letter-spacing: .3px;
      font-size: 13px;
    }

    .st-counter .label.sp {
      color: #6ec6ff;
    }

    /* cyan-like */
    .st-counter .label.tp {
      color: #ff4444;
    }

    /* red */
    .st-counter .val {
      min-width: 18px;
      text-align: right;
      color: #e6e9ef;
      font-variant-numeric: tabular-nums;
      font-size: 13px;
    }

    /* Keep modal header balanced */
    .modal .dialog header {
      justify-content: space-between;
    }

    /* ===== Optional large pills elsewhere (kept for compatibility) ===== */
    :root {
      --sp-blue: #2BCCED;
      --tp-red: #F03231;
    }

    .actions .sp-tp {
      display: none;
      gap: 18px;
      align-items: center;
      font-size: 20pt;
    }

    .counter-pill {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-weight: 800;
      letter-spacing: .1px;
      color: var(--text);
      text-shadow: 0 1px 2px rgba(0, 0, 0, .55);
    }

    .counter-pill .lab {
      font-size: 1em;
      font-style: italic;
      font-weight: 900;
    }

    .counter-pill.sp .lab {
      color: var(--sp-blue);
    }

    .counter-pill.tp .lab {
      color: var(--tp-red);
    }

    /* ===== Modal-only: big counters aligned to the right ===== */
    #skillTreeModal .st-counters {
      margin-left: auto;
      font-size: 20pt;
    }

    #skillTreeModal .st-counter,
    #skillTreeModal .st-counter .label,
    #skillTreeModal .st-counter .val {
      font-size: 20pt;
    }

    /* Modal size */
    #skillTreeModal .dialog {
      width: min(1600px, 98vw) !important;
      height: min(920px, 95vh) !important;
    }

    /* ===== SkillTree v1 (legacy banded columns) ===== */
    .st-grid {
      grid-auto-flow: column;
      grid-auto-columns: 320px;
      /* generous column width */
      gap: 12px;
      padding: 12px;
    }

    .st-col {
      gap: 8px;
      align-content: start;
    }

    .st-band {
      position: sticky;
      top: 0;
      z-index: 2;
      padding: 6px 10px;
      border: 1px solid #3a2c21;
      border-radius: 10px;
      background: #1a130f;
      color: #e7c27a;
      font-weight: 800;
      font-size: 13px;
      text-align: center;
    }

    /* ===== SkillTree v2 (bands / coordinate grid) ===== */

    /* Wrapper for bands */
    .st2-wrap {
      display: grid;
      gap: 14px;
    }

    /* Each band's grid sits a bit below its dashed label line */
    .st2-band>.st2-grid {
      margin-top: 3px;
    }

    /* Band container: prevent clipping; add room above/below */
    .st2-band {
      position: relative;
      margin: 1px 0;
      padding-top: 10px;
      /* room for label/dashed line */
      padding-bottom: 1px;
      /* room for controls */
      overflow: visible;
    }

    /* Band dashed line */
    .st2-band::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      border-top: 1px dashed rgba(207, 162, 79, .55);
    }

    /* Band label sitting over dashed line */
    .st2-band-label {
      position: absolute;
      left: 0;
      top: 0;
      transform: translateY(-50%);
      padding: 0 6px;
      border-radius: 8px;
      background: #0e0b09;
      color: #e7c27a;
      font-weight: 800;
      font-size: 12px;
      line-height: 1.4;
      z-index: 1;
    }

    /* 6-column responsive grid; variable row height */
    .st2-grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(100px, 1fr));
      grid-auto-rows: minmax(164px, max-content);
      gap: 10px;
    }

    /* ===== Skill tiles ===== */

    /* Tile: icon (top) / name (middle) / controls (bottom) */
    .st2-tile {
      display: grid;
      grid-template-rows: auto auto auto;
      align-items: center;
      justify-items: center;
      gap: 6px;
      max-width: 100%;
      overflow: hidden;
    }

    /* Skill name */
    .st2-name {
      width: 100%;
      max-width: 340px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 17px;
      font-weight: 800;
      line-height: 1.1;
      color: #e7c27a;
    }

    /* Circular icon */
    .st2-skill {
      width: clamp(68px, 7.6vw, 92px);
      height: clamp(68px, 7.6vw, 92px);
      border-radius: 999px;
      border: 1px solid #3a2c21;
      background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35) inset;
      display: grid;
      place-items: center;
      overflow: hidden;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%);
      mask-image: radial-gradient(circle, #000 99%, transparent 100%);
    }

    .st2-skill img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 999px;
    }

    /* Controls: left stack / center level box / right stack */
    .st2-ctrl2 {
      display: grid;
      grid-template-columns: max-content auto max-content;
      grid-template-rows: auto auto;
      align-items: center;
      justify-items: center;
      column-gap: 8px;
      row-gap: 2px;
    }

    /* Left/Right button stacks */
    .st2-side-left,
    .st2-side-right {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    /* Central level box */
    .st2-lv {
      grid-column: 2;
      grid-row: 1 / span 2;
      min-width: 110px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #f0e6d2;
      text-align: center;
      font-weight: 800;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .st2-lvnums {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .st2-lv .cur,
    .st2-lv .tp {
      font-size: 16px;
      line-height: 1;
    }

    .st2-lv .sep {
      opacity: .6;
      margin: 0;
    }

    /* Buttons */
    .st2-btn {
      height: 24px;
      padding: 0 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #c7b589;
      cursor: pointer;
      white-space: nowrap;
    }

    .st2-btn:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .18) inset;
    }

    .st2-btn:disabled {
      opacity: .5;
      cursor: default;
      border-color: #2a211a;
      box-shadow: none;
    }

    /* Simple list modal */
    .simple-modal .dialog {
      width: min(420px, 92vw);
    }

    .simple-modal .list {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      padding: 10px;
    }

    .simple-modal .list .opt-btn {
      height: 38px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: #1a1b27;
      color: #e6e9ef;
      cursor: pointer;
    }

    .simple-modal .list .opt-btn:hover {
      border-color: #6ea8ff;
      box-shadow: 0 0 0 2px rgba(110, 168, 255, .25) inset;
    }

    /* ========== 로그인 이후 레이아웃 정리(PC/Mobile 공통) ========== */

    /* 공통: hidden은 완전 제거 */
    [hidden] {
      display: none !important;
    }

    /* 1) 로그인 뷰 계열 통째로 접기 (.login-wrap, #main-view, .hero) */
    body:is(.pc, .mobile) :is(.login-wrap, #main-view, section.hero) {
      display: none !important;
      height: 0 !important;
      min-height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    /* 2) .shell은 컨테이너 박스 제거(자식만 흐르게) */
    body:is(.pc, .mobile) .shell {
      display: contents !important;
      height: auto !important;
      min-height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      gap: 0 !important;
      grid-template-rows: none !important;
      grid-auto-rows: auto !important;
    }

    /* 3) 본문 시작 간격(필요 시 숫자만 조절) */
    body:is(.pc, .mobile) #calc-view {
      margin-top: 12px !important;
    }

    /* 4) 안전핀: calc-view는 위로 딱 붙게(상단 마진 초기화) */
    #calc-view {
      margin-top: 0 !important;
    }

    /* ===== Header 광고(오른쪽 텍스트) ===== */
    .header-ads {
      margin-left: auto;
      /* 우측 정렬 */
      margin-right: 40px;
      /* ← 우측 여백 (원하면 12~24px 조절) */
      display: flex;
      align-items: center;
      max-width: 40vw;
    }

    .header-ads .ad-text {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 32vw;
      transition: opacity .25s ease;
      opacity: 1;
    }

    .header-ads .fade-out {
      opacity: 0;
    }

    /* 한마디 공통 */
    .header-ads .line .hdrmsg {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .header-ads .line .hdrmsg .msg-bullet {
      opacity: 0.6;
    }

    .header-ads .line .hdrmsg .msg-text {
      opacity: 0.95;
    }

    /* 배지 기본 */
    .header-ads .line .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
    }

    /* 책임 = 차분한 중립톤 */
    .header-ads .line .tag-lead {
      background: rgba(120, 120, 120, 0.12);
      color: rgba(120, 120, 120, 1);
      border: 1px solid rgba(120, 120, 120, 0.25);
    }

    /* 수석 = 골드 그라데이션 + 은은한 광택 */
    /* 공통 레이아웃 */
    .hdrmsg {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .hdrmsg .msg-bullet {
      opacity: 0.6;
    }

    .hdrmsg .msg-text {
      opacity: 0.95;
    }

    /* 수석 배지(👑만 들어가도 예쁘게 보이게) */
    .tag-senior {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 10px;
      /* pill 모양이 보이도록 패딩 */
      min-width: 32px;
      /* 너무 작게 붙지 않게 최소 폭 */
      height: 20px;
      border-radius: 999px;
      font-size: 13px;
      /* 👑 크기 */
      line-height: 1;
      background: linear-gradient(135deg, #ffe08a 0%, #ffd257 45%, #ffc63a 100%);
      border: 1px solid rgba(172, 124, 22, 0.55);
      color: #2a1b00;
      /* 이모지 외 글자색(혹시 텍스트가 추가되어도) */
      position: relative;
      overflow: hidden;
    }

    /* 은은한 반짝임 */
    .tag-senior::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, .45) 35%, transparent 70%);
      transform: translateX(-120%);
      animation: shimmer 2.4s linear infinite;
      pointer-events: none;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-120%);
      }

      100% {
        transform: translateX(120%);
      }
    }

    /* 책임 배지: 아주 작은 회색 점 */
    .tag-lead {
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(120, 120, 120, .7);
      box-shadow: 0 0 0 1px rgba(120, 120, 120, .25);
      margin-right: 2px;
      /* 닉네임과 살짝 간격 */
      vertical-align: middle;
    }

    /* 수석 닉네임 살짝 강조 (옵션) */
    .hdrmsg.senior .msg-nick {
      font-weight: 600;
      text-decoration: underline;
      text-decoration-color: rgba(255, 198, 58, .7);
      text-underline-offset: 2px;
    }

    /* 책임은 배지 없으니 별도 스타일 불필요 (원하면 아주 옅은 점 배지 추가 가능) */
    .loading {
      opacity: 0.7;
    }

    .loading-overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      background: rgba(0, 0, 0, .55);
      display: grid;
      place-items: center;
    }

    .loading-box {
      width: min(480px, 90vw);
      background: #0f1115;
      color: #e6e9ef;
      border: 1px solid rgba(255, 255, 255, .2);
      border-radius: 14px;
      padding: 20px 24px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .45);
    }

    .loading-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .loading-bar {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .12);
      overflow: hidden;
    }

    .loading-bar__fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #6ea8ff, #8fe3ff);
      transition: width .2s ease;
    }

    .loading-info {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      opacity: .9;
    }

    /* 성안의 봉인 모달 레이아웃 */


    #castleSealModal .opt-row {
      display: block;
      width: 100%;
      text-align: left;
      border: 1px solid rgba(255, 255, 255, .15);
      background: #0f1115;
      border-radius: 8px;
      padding: 12px 14px;
      margin: 8px 0;
    }

    #castleSealModal .opt-row .name {
      font-weight: 600;
      margin-bottom: 4px;
    }

    #castleSealModal .opt-row .desc {
      opacity: .9;
      font-size: 12px;
      line-height: 1.3;
    }

    #castleSealModal .opt-row.active {
      outline: 2px solid #8fe3ff;
      background: #121521;
    }

    .seal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      /* 제목 왼쪽, 버튼 오른쪽 */
      gap: 8px;
    }

    #optSeal .opt-title {
      margin: 0;
      font-size: 14px;
    }
  </style>

<body>
  <!-- 로딩 오버레이 (기본 hidden) -->
  <div id="loadingOverlay" class="loading-overlay" hidden>
    <div class="loading-box">
      <div class="loading-title">데이터 불러오는 중…</div>
      <div class="loading-bar">
        <div class="loading-bar__fill" style="width:0%"></div>
      </div>
      <div class="loading-info">
        <span id="loadingLabel">초기화…</span>
        <span id="loadingPct">0%</span>
      </div>
    </div>
  </div>
  <div class="shell">
    <header>
      <div class="title">
        <div class="dot" aria-hidden="true"></div>
        <h1>게임실험연구소 계산기 (시즌5)</h1>
      </div>
      <!--span 은 한줄에서 특별히 강조 할때 쓴다. div는 한줄이 강제로 나뉘기때문에 쓴다.-->
      <div class="actions">
        <div class="sp-tp" id="spTpTop">
          <span class="counter-pill sp"><span class="lab">SP</span><span id="spLeftTop"
              style="min-width:24px;display:inline-block;text-align:right;">—</span></span>
          <span class="counter-pill tp"><span class="lab">TP</span><span id="tpLeftTop"
              style="min-width:24px;display:inline-block;text-align:right;">—</span></span>

        </div>
      </div>
    </header>
    <section id="main-view">
      <!-- 여기에 네가 만든 메인(배경/우측 공지/빨간 타원 위치 로그인 카드) 마크업 -->
      <!-- PC / 모바일 버튼도 여기 -->
      <div class="wrap">
        <h1 class="top-title">던전앤파이터 모바일 <span style="color:#ffdf6b">시즌 5</span> 데미지 계산기</h1>
        <div class="main2">※ 본 계산기는 게임플레이에 도움이 되고자 만든 것입니다. 순수한 정보공유가 아닌, 상업적 목적으로의 블로그 게재, 개인방송, 유튜브 영상제작 등의 제작자 동의없는
          이용을 금하며, 무단수정 및 도용도 엄격히 금지합니다.</div>

        <div class="grid">
          <!-- 왼쪽: 메인 비주얼 -->
          <section class="hero">
            <!-- 네가 쓰려는 메인 이미지를 넣어줘 -->
            <img class="hero-img" src="img/main/main.png" alt="메인 비주얼" />
          </section>
          <!-- 오른쪽: 공지/업데이트 -->
          <div class="sidebar">
            <aside class="notice">
              <h3>* 계산기는 계속해서 업데이트될 예정입니다!</h3>
              <div class="box">
                <div class="badge-danger">25.10.27 신규 계산기 블레이드 버전 배포</div>
                <ul>
                  <li>게임실험연구소 신규 계산기 오픈!</li>
                  <li>"블레이드" 캐릭 스킬트리 연동 및 최종 계산 반영</li>
                  <li>타캐릭 추후 구현 예정</li>
                  <li>스펙 저장/불러오기 기능 추후 구현 예정 </li>
                </ul>
              </div>
              <div class="upgrade">
                멤버십 업그레이드 시 <span class="main2" style="font-size:16px;">편의 기능</span> 이용가능 <br> →
                <!--멤버십 업그레이드 시 <span class="main2" style="font-size:16px;">저장/불러오기</span> 등 편의 기능 이용 가능 <br> →-->
                <a href="https://www.youtube.com/channel/UCijUV3SuVe_qErzBpdOmKIA/join" target="_blank"
                  rel="noopener">지금 멤버십 업그레이드!!!</a>
              </div>
            </aside>
            <div class="login-card">
              <div class="login-title">계산기 접근을 위해 구글 계정으로 로그인</div>
              <div class="login-desc">
                허용된 계정만 접근 가능합니다. 로그인 후 자동으로 권한을 확인합니다.
              </div>

              <div class="login-row">
                <!-- Google Sign-In 버튼 -->
                <!-- 1) onload 세팅: client_id 교체 필수 -->
                <div id="g_id_onload"
                  data-client_id="110486887643-3c136grpud2llf2b31d24fqr40s1p44g.apps.googleusercontent.com"
                  data-callback="onGoogleCredential" data-auto_prompt="false" data-itp_support="true">
                </div>
                <!-- 2) 버튼 렌더 -->
                <div class="g_id_signin" data-type="standard" data-size="large" data-shape="pill" data-theme="outline"
                  data-text="signin_with" data-logo_alignment="left">
                </div>

                <div class="login-hint">※ 버튼이 보이지 않으면 팝업/추적차단을 확인해 주세요.</div>
              </div>
            </div>
          </div>
        </div>
      </div>
  </div>
  </section>
  <section id="calc-view" hidden>
    <section class="layout">
      <div class="column left">
        <div class="auto-box">
          <h4>자동 입력</h4>
          <button id="btnAutoEnh" class="btnetc">강화 자동 입력</button>
          <div style="height:8px;"></div>
          <button id="btnAutoSeal" class="btnetc">추천 마법봉인 자동 입력</button>
        </div>

        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L1"><span class="slot-label">머리어깨</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L2"><span class="slot-label">상의</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L3"><span class="slot-label">하의</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L4"><span class="slot-label">허리</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L5"><span class="slot-label">신발</span></div>
        </div>
      </div>

      <div class="center">
        <div id="characterCard" class="character-card">
          <img id="characterImg" class="character-img" alt="캐릭터" />
          <div id="characterGhost" class="character-ghost">클릭하여 캐릭터 선택</div>
        </div>
        <div class="mini-bar">
          <div class="mini-cell">
            <div class="outer-rects">
              <button class="rect" data-unused="true">선택</button>
              <button class="rect" data-unused="true">선택</button>
            </div>
            <div class="slot mini" data-slot="C2"><span class="slot-label">칭호</span></div>
          </div>
          <div class="slot mini" data-slot="C1"><span class="slot-label">오라</span></div>
          <div class="slot mini" data-slot="C3"><span class="slot-label">크리쳐</span></div>
          <div class="slot mini" data-slot="C4"><span class="slot-label">아티팩트</span></div>
        </div>
      </div>

      <div class="column right">
        <div class="auto-box">
          <h4>자동 입력</h4>
          <button id="btnAutoEnchant" class="btnetc">추천 마법부여 자동 입력</button>
          <div style="height:8px;"></div>
          <button id="btnAutoEmblem" class="btnetc">엠블렘 자동 입력</button>
        </div>

        <div class="slot-row right">
          <div class="slot" data-slot="R1"><span class="slot-label">무기</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button><button class="rect">선택</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R2"><span class="slot-label">팔찌</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R3"><span class="slot-label">목걸이</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R4"><span class="slot-label">반지</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R5"><span class="slot-label">보조장비</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button><button class="rect">선택</button></div>
        </div>
      </div>
      <div class="save-box">
        <button>+</button>
        <button>+</button>
        <button>+</button>
        <button>+</button>
        <button>+</button>
      </div>

      <div class="column options">
        <div class="opt-box">
          <h4 class="opt-title">아바타 세부 선택</h4>
          <label class="field">
            <span class="label">아바타</span>
            <select id="selAvatar" class="select" aria-label="아바타 선택">
              <option value="" disabled>아바타 선택</option>
              <option value="rare" selected>레어 아바타</option>
              <option value="advanced">상급 아바타</option>
              <option value="empty">없음</option>
            </select>
          </label>
          <label class="field">
            <span class="label">무기압</span>
            <select id="selImprint" class="select" aria-label="무기압 선택">
              <option value="" disabled>무기압 선택</option>
              <option value="add5">추뎀 5% 무기압</option>
              <option value="patkmatk5" selected>물/마공 5% 무기압</option>
              <option value="patkmatk3">물/마공 3% 무기압</option>
              <option value="monster">몬스터 무기압</option>
              <option value="quest">퀘스트 무기압</option>
              <option value="empty">없음</option>
            </select>
          </label>
        </div>

        <div class="opt-box">
          <h4 class="opt-title">계산 세부 옵션 조절</h4>
          <label class="field">
            <span class="label">시간 기준</span>
            <select id="selTime" class="select" aria-label="시간 기준">
              <option value="" disabled>시간 기준</option>
              <option value="30s">30초딜</option>
              <option value="1m" selected>1분딜</option>
              <option value="3m">3분딜</option>
              <option value="5m">5분딜</option>
              <option value="10m">10분딜</option>
            </select>
          </label>
          <!--document.getElementById("selMonster").value 라고 쓰면 설정된 몬스터값 불러올 수 있음-->
          <label class="field">
            <span class="label">몬스터 설정</span>
            <select id="selMonster" class="select" aria-label="몬스터 설정">
              <option value="" disabled>몬스터 설정</option>
              <option value="nugol" selected>거대누골</option>
              <option value="blackdragon">흑룡</option>
              <option value="anton">안톤</option>
              <option value="asmar_calix">아스마르/칼릭스</option>
            </select>
          </label>

          <label class="field">
            <span class="label">던전 난이도</span>
            <select id="selDifficulty" class="select" aria-label="던전 난이도 설정">
              <option value="" disabled>던전 난이도 설정</option>
              <option value="hard">어려움</option>
              <option value="normal">보통</option>
              <option value="easy">쉬움</option>
              <option value="nugol_room" selected>누골방</option>
            </select>
          </label>
        </div>
        <div class="opt-box">
          <h4 class="opt-title">스킬룬</h4>
          <div class="rune-head">
            <button id="btnRune" class="ui-btn ghost" type="button" aria-label="스킬룬 설정">
              스킬룬 설정
            </button>
            <div style="font-size:12px;color:var(--muted);">
              선택한 스킬룬 개수: <b id="runeCount" style="color:#e7c27a;">0</b>
            </div>
          </div>
          <div class="rune-engrave-row">
            <label class="field compact">
              <span class="label">룬 각인 설정</span>
              <select id="selRuneEngrave" class="select" aria-label="룬 각인 설정">
                <option value="" selected disabled>룬 각인 설정</option>
              </select>
            </label>

            <label class="field compact">
              <span class="label">세부 설정</span>
              <select id="selRuneDetail" class="select" aria-label="세부 설정" disabled>
                <option value="" selected disabled>세부 설정</option>
              </select>
            </label>
          </div>


        </div>

        <div class="opt-box">
          <h4 class="opt-title">스킬트리</h4>
          <div class="skilltree-head">
            <button id="btnSkillTree" class="ui-btn primary" type="button" aria-label="스킬트리 설정"
              style="margin-top:2px;">스킬트리 설정</button>
            <div class="st-counters">
              <span>남은 SP: <b id="stSpLeft">—</b></span>
              <span>남은 TP: <b id="stTpLeft">—</b></span>
            </div>
          </div>
        </div>
        <div class="final-damage">
          <span class="label">최종데미지</span>
          <strong class="value" id="finalDamageValue2">&nbsp;</strong>
          <button id="btn-sum-all-final2" type="button">계산하기</button>
        </div>
      </div>

      <aside class="stats">
        <div class="stats-panel">
          <!-- ▼ 성안의 봉인 -->
          <div class="opt-box" id="optSeal">
            <div class="seal-head">
              <h4 class="opt-title">성안의 봉인</h4>
              <button id="btnCastleSeal" class="ui-btn primary" type="button" aria-label="옵션 선택">
                옵션 선택
              </button>
            </div>
          </div>
          <h3>합산 스탯</h3>
          <div id="statList" class="stat-list"></div>
          <div class="final-damage">
            <span class="label">최종데미지</span>
            <strong class="value" id="finalDamageValue">&nbsp;</strong>
            <button id="btn-sum-all-final" type="button">계산하기</button>
          </div>
        </div>
      </aside>
    </section>
  </section>
  </div>
  <!--ㅇ-->
  <div id="charModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div><!--모달 뒤 배경 검정, data-close 속성 붙은 요소 클릭하면 모달 닫힘-->
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="dlgTitle">
      <header>
        <h2 id="dlgTitle">캐릭터 선택</h2>
        <div></div>
      </header>
      <div id="catalog" class="catalog"></div>
    </div>
  </div>

  <div id="itemModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="itemDlgTitle">
      <header>
        <h2 id="itemDlgTitle">아이템 선택</h2>
        <nav id="weaponTabs" class="weapon-tabs" style="display:none"></nav>
        <input id="itemSearch" class="input" type="text" placeholder="아이템 검색 (이름 / 종류)" />
      </header>
      <div class="items">
        <div id="itemList" class="item-list"></div>
      </div>
    </div>
  </div>

  <div id="enhanceModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="enhDlgTitle">
      <header>
        <h2 id="enhDlgTitle">강화 선택</h2>
      </header>
      <div class="items">
        <div id="enhanceList" class="enh-list"></div>
      </div>
    </div>
  </div>

  <div id="enchantModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="enchantDlgTitle">
      <header>
        <h2 id="enchantDlgTitle">마법부여 선택</h2>
      </header>
      <div class="items">
        <div id="enchantList" class="enh-list"></div>
      </div>
    </div>
  </div>

  <div id="refineModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog sm">
      <div class="dialog-head">
        <h3>연마 선택</h3>
        <button class="icon-btn" data-close aria-label="닫기">✕</button>
      </div>
      <div class="dialog-body">
        <div id="refineList" class="v-list"></div>
      </div>
    </div>
  </div>


  <div id="emblemModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="emblemDlgTitle"
      style="width:min(920px,95vw);height:min(620px,88vh);">
      <header>
        <h2 id="emblemDlgTitle">엠블렘 선택</h2>
      </header>
      <div id="emblemRows" class="em-rows"></div>
    </div>
  </div>

  <div id="runeModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="runeDlgTitle"
      style="width:min(980px,95vw);height:min(620px,88vh);">
      <header>
        <h2 id="runeDlgTitle">스킬룬 설정</h2>
        <div style="justify-self:end;font-size:12px;color:#c7b589;">
          선택한 스킬룬 개수: <b id="runeCountLabel" style="color:#ff6b6b;">0</b> / 20
        </div>
      </header>
      <div class="items" style="padding:10px;">
        <div id="runeGrid" class="rune-grid"></div>
      </div>
    </div>
  </div>

  <div id="skillTreeModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="stDlgTitle"
      style="width:min(1100px,96vw);height:min(720px,92vh);">
      <header>
        <h2 id="stDlgTitle">스킬트리</h2>
        <div class="st-counters">
          <div class="st-counter"><span class="label sp">SP</span><span class="val" id="stSpLeftMini">0</span></div>
          <div class="st-counter"><span class="label tp">TP</span><span class="val" id="stTpLeftMini">0</span></div>
        </div>
      </header>
      <div class="items" style="padding:10px;">
        <div id="stGrid"></div>
      </div>
    </div>
  </div>

  <!-- ▼ 성안의 봉인 모달 -->
  <div id="castleSealModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialogetc" role="dialog" aria-modal="true" aria-labelledby="castleSealTitle">
      <header>
        <h3 id="castleSealTitle">성안의 봉인</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body two-col">
        <section class="cols left">
           <div class="titles">◈ 주요 옵션 ◈</div>
          <div id="sealMainList" class="lists"></div>
        </section>
        <section class="cols right">
          <div class="titles">◈ 추가 옵션 ◈</div>
          <div id="sealSubList" class="lists"></div>
        </section>
      </div>

      <div class="modal-foot">
        <button id="sealCommit" class="ui-btnetc">선택 하기</button>
      </div>
    </div>
  </div>


  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>

/** !@#$ ───────── DEV: noload 스위치 ─────────
 *  URL에 ?dev=noload 붙이거나, Alt+D 로 토글 (localStorage('DEV_NOLOAD')=1)
 *  - 로그인/시트 로딩/프리로드 전부 스킵
 *  - calc-view 즉시 진입
 *  - 옵션: 더미데이터 주입으로 모달에 리스트 표시
 */
const DEV_NOLOAD =
  /(?:^|[?&#])dev=noload(?:=1|&|$)/i.test(location.href) ||
  localStorage.getItem('DEV_NOLOAD') === '1';

if (DEV_NOLOAD) {
  console.log('[DEV] NOLOAD 모드 활성화');

  // 1) 로딩 오버레이 강제 끄기
  addEventListener('DOMContentLoaded', () => {
    document.getElementById('loadingOverlay')?.setAttribute('hidden','');
    document.documentElement.classList.add('dev-noload');
  });

  // 2) 로컬 토글: Alt + D
  addEventListener('keydown', (e)=>{
    if (e.altKey && e.code === 'KeyD') {
      const on = !(localStorage.getItem('DEV_NOLOAD') === '1');
      localStorage.setItem('DEV_NOLOAD', on ? '1' : '');
      location.reload();
    }
  });

  // 3) 프리로드/토큰을 호출하더라도 즉시 성공처럼 보이게 가짜 구현
  window.idToken = 'dev-token';
  window.waitForIdToken = async () => 'dev-token';
  window.preloadAllSheets = async () => {};           // 무게 큰 프리로드 전체 skip
  window.preloadAllSheetsOnce = async () => {};       // once 래퍼도 skip

  // 특정 로더를 호출해도 즉시 반환되게 가짜 구현
  window.ensureSkillLoaded2   = async () => { window.ST2 = { loaded:true, rows:[] }; };
  window.ensureEnhLoaded      = async () => { window.DBEnh = window.DBEnh || { }; DBEnh.loaded = true; DBEnh.list = []; DBEnh.byType = {}; };
  window.ensureSetLoaded      = async () => { window.DBSet = { loaded:true, list:[], byType:{} }; };
  window.ensureExceptionLoaded= async () => { window.DBException = { loaded:true, rows:[], byItem:{}, skillIdByName:{} }; };
  window.ensureLoaded         = async (slot) => { window.DB = window.DB || { itemsBySlot:{}, loaded:{} }; DB.itemsBySlot[slot] = DB.itemsBySlot[slot] || []; DB.loaded[slot] = true; };

  // (선택) 모달에 보여줄 더미데이터 — 성안의 봉인 등 리스트가 비어 보일 때 유용
  window.__devSeedModalData = function(){
  // 공통 강화/마봉/마부 시트 더미
  window.DBEnh ??= { byType:{}, list:[] };

  DBEnh.byType['강화'] = [
    { name:'강화 +10', type:'강화', uiText:'모든 공격력 +10%' },
    { name:'증폭 +8', type:'강화', uiText:'힘,지능 +180' },
  ];
  DBEnh.byType['마봉'] = [
    { name:'스킬 공격력 +7%', type:'마봉', uiText:'스킬공격력 증가 7%' },
    { name:'물리크리티컬 +10%', type:'마봉', uiText:'물크 증가 10%' },
  ];
  DBEnh.byType['마법부여'] = [
    { name:'화속성 강화 +20', type:'마법부여', uiText:'화속강 +20' },
    { name:'모든속성강화 +15', type:'마법부여', uiText:'모속강 +15' },
  ];
  DBEnh.byType['주요 옵션'] = [
    { name:'힘,지능 +170', type:'주요 옵션', uiText:'힘,지능 +170' },
    { name:'스킬 공격력 +8%', type:'주요 옵션', uiText:'스증 +8%' },
  ];
  DBEnh.byType['추가 옵션'] = [
    { name:'크리티컬 데미지 +10%', type:'추가 옵션', uiText:'크증 +10%' },
    { name:'모든속성강화 +25', type:'추가 옵션', uiText:'모속강 +25' },
  ];
  DBEnh.list = Object.values(DBEnh.byType).flat();

  window.state ??= {};
  state.castleSeal ??= {
    main: DBEnh.byType['주요 옵션'][0],
    sub:  DBEnh.byType['추가 옵션'][0],
  };

  console.log('[DEV] 강화/마봉/마부/성안의 봉인 더미 데이터 주입 완료');
  };
}
// !@#$ 지워야함 ----------------------------------------------------------------------------------------------


    function detectIsMobile() {
      const uaData = navigator.userAgentData;
      if (uaData && 'mobile' in uaData) return !!uaData.mobile;

      const ua = navigator.userAgent.toLowerCase();
      const isPhoneUA = /iphone|ipod|android.*mobile|windows phone|blackberry|bb10/.test(ua);
      const isTabletUA = /ipad|android(?!.*mobile)/.test(ua);
      const coarsePtr = matchMedia?.('(pointer:coarse)')?.matches;
      const narrowSide = Math.min(screen.width, screen.height) <= 820;
      return isPhoneUA || isTabletUA || (coarsePtr && narrowSide);
    }

    // 파일 상단 어딘가(전역)
    window.__loginPingSent = false;

    async function loginPingOnce() {
      if (window.__loginPingSent) return;        // 중복 방지
      window.__loginPingSent = true;
      try {
        await waitForIdToken?.();                 // id_token 확보
        await fetch(WEBAPP_URL + '?type=login_ping', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id_token: window.idToken,
            ua: navigator.userAgent,
            screen: `${screen.width}x${screen.height}@${(window.devicePixelRatio || 1)}`,
            is_mobile: detectIsMobile()
          })
        });
      } catch (e) {
        console.warn('login_ping failed:', e);    // 로깅 실패해도 무시
      }
    }

    // 전역 플래그
    let __calcInited = false;

    async function initCalculatorOnce() {
      if (__calcInited) return;
      __calcInited = true;

      // 1) 룬 각인 이름 목록 구성
      buildRuneEngraveNameOptions();

      // 2) 옵션 드롭다운 바인딩
      const $ = (id) => document.getElementById(id);
      const bind = (id, key) => {
        const el = $(id);
        if (!el) return;
        el.addEventListener('change', () => {
          state.options[key] = el.value || null;
          if (key === 'avatar') {
            applyAvatarEnhFromState();
          } else if (key === 'weaponImprint') {
            applyImprintEnhFromState();
          } else if (key === 'monster') {
            const txt = el.options[el.selectedIndex]?.textContent ?? el.value;
            onMonsterChange(txt);
          }
        });
      };

      bind('selAvatar', 'avatar');
      bind('selImprint', 'weaponImprint');
      bind('selTime', 'timeWindow');
      bind('selMonster', 'monster');
      bind('selDifficulty', 'difficulty');

      // 3) 기본값을 실제 로직에 반영 (여기가 자동 로딩의 주범이었음 → 지금부터는 버튼 클릭 이후에만 호출)
      document.getElementById('selAvatar')?.dispatchEvent(new Event('change'));
      document.getElementById('selImprint')?.dispatchEvent(new Event('change'));
      onMonsterChange(); // 기본 몬스터 반영

      // === 성안의 봉인 기본값 적용 (정규화 stats 사용) ===
      try {
        // 1) 강화·마봉·마부 데이터 로드 보장
        if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

        const enh = window.DBEnh || {};

        // 2) byType 없으면 list에서 즉석 그룹핑 (구버전 호환)
        let byType = enh.byType;
        if (!byType) {
          const list = Array.isArray(enh.list)
            ? enh.list
            : Array.isArray(enh.rows)
              ? enh.rows.map(r => ({ type: String(r['종류'] || '').trim(), name: String(r['이름'] || '').trim(), stats: r.stats || null, raw: r }))
              : [];
          byType = list.reduce((acc, it) => {
            const t = String(it.type || '').trim();
            (acc[t] ||= []).push(it);
            return acc;
          }, {});
        }

        // 3) 후보 목록 얻기
        const mainList = Array.isArray(byType['주요 옵션']) ? byType['주요 옵션'] : [];
        const subList = Array.isArray(byType['추가 옵션']) ? byType['추가 옵션'] : [];

        // 데이터 없으면 조용히 통과 (계산기 열기만 진행)
        if (!mainList.length || !subList.length) {
          console.info('[SEAL:init] 목록 비어 있음 → 기본값 주입 생략', { mainLen: mainList.length, subLen: subList.length });
        } else {
          // 4) state 준비
          if (!state.castleSeal) state.castleSeal = { main: null, sub: null };

          // 5) 이미 선택돼 있지 않을 때만 기본값 주입
          //    (특정 이름을 원하면 .find(x => x.name === '힘,지능 +170') 형태로)
          const mainPick = state.castleSeal.main
            || mainList.find(x => x.name === '힘,지능 +170')
            || mainList[0];
          const subPick = state.castleSeal.sub
            || subList.find(x => x.name === '힘,지능 +224')
            || subList[0];

          // 6) 정규화된 형태로 저장 (합산 함수가 바로 먹게)
          state.castleSeal.main = mainPick ? { name: mainPick.name, stats: mainPick.stats || null, raw: mainPick.raw || mainPick } : null;
          state.castleSeal.sub = subPick ? { name: subPick.name, stats: subPick.stats || null, raw: subPick.raw || subPick } : null;

          console.info('[SEAL:init] 기본값 적용:', {
            main: state.castleSeal.main?.name || null,
            sub: state.castleSeal.sub?.name || null
          });
        }
      } catch (e) {
        console.warn('[SEAL:init] 기본값 적용 중 오류(무시):', e);
      }

      // 필요 시 첫 렌더
      recalcAndRenderPanel();
    }


    /* ===== 상태/상수 ===== */
    const state = {
      currentCharacter: { jobGroup: null, jobGroupLabel: null, name: null, imgSrc: null, power: null },
      selections: {}, // 장비
      upgrades: {},   // 슬롯별 강화 선택
      enchants: {},   // 슬롯별 마법부여 선택
      ui: { weaponTypeTab: null, enhTargetSlot: null, enhTargetBtn: null },
      currentSlotKey: null
    };
    state.skillLv = state.skillLv || {}; // {skillId: 현재레벨}
    state.stUsedSP = state.stUsedSP || 0;
    state.stUsedTP = state.stUsedTP || 0;
    // ===== SP/TP 상태 및 렌더 =====
    state.sp = state.sp || { total: 0, left: 0 };
    state.tp = state.tp || { total: 0, left: 0 };
    state.skillTpLv = state.skillTpLv || {};   // TP 레벨 저장(사용 중이 아니어도 무해)
    // ===== 레벨링(장비/스탯 합산) =====
    state.leveling = state.leveling || {}; // { 15: n, 20: n, 25: n, ... }
    state.skillDmg = state.skillDmg || {};   // ★ 스킬 현재 데미지 캐시 {id: { per, flat, lv }}


    let __progressPct = 0;

    function setProgressExactMonotonic(nextPct, label) {
      const p = Math.max(__progressPct, Math.min(100, Math.round(nextPct)));
      __progressPct = p;
      const bar = document.querySelector('.loading-bar__fill');
      const txt = document.getElementById('loadingPct');
      const lbl = document.getElementById('loadingLabel');
      if (bar) bar.style.width = p + '%';
      if (txt) txt.textContent = p + '%';
      if (lbl && label) lbl.textContent = String(label);
    }
    function resetProgress(label) {
      __progressPct = 0;
      setProgressExactMonotonic(0, label ?? '데이터 불러오는 중…');
    }

    function incProgress(dx, label) {
      const next = Math.min(100, Math.max(0, Math.round(__progressPct + dx)));
      setProgressExactMonotonic(next, label);
    }
    function showOverlay(label) {
      __progressPct = 0;
      setProgressExactMonotonic(0, label || '데이터 불러오는 중…');
      document.getElementById('loadingOverlay')?.removeAttribute('hidden');
    }
    function hideOverlay() {
      document.getElementById('loadingOverlay')?.setAttribute('hidden', '');
    }
    function hideOverlay() {
      const ov = document.getElementById('loadingOverlay');
      if (ov) ov.setAttribute('hidden', '');
    }
    function setProgress(pct, label) {
      const bar = document.querySelector('.loading-bar__fill');
      const l = document.getElementById('loadingLabel');
      const t = document.getElementById('loadingPct');
      const p = Math.max(0, Math.min(100, Math.round(pct)));
      if (bar) bar.style.width = p + '%';
      if (t) t.textContent = p + '%';
      if (l && label) l.textContent = label;
    }

    // 모든 시트 한 번에 프리로드 (로그인 후에만 호출)
    // 모든 시트 한 번에 프리로드 (로그인 후에만 호출)
    async function preloadAllSheets({ weightCore = 30, weightSlots = 70 } = {}) {
      await waitForIdToken();

      const slots = [
        'weapon', 'headshoulder', 'top', 'bottom', 'belt', 'shoes',
        'bracelet', 'necklace', 'ring', 'support', 'aura', 'title',
        'creature', 'artifact'
      ];
      const totalSlots = slots.length;

      const coreW = Math.max(0, Math.min(100, weightCore | 0));
      const slotsW = Math.max(0, Math.min(100 - coreW, weightSlots | 0));
      // ── 동적 코어 단계 구성 ─────────────────────────────
      const steps = [];
      if (typeof loadCharacterSheet === 'function') steps.push(['캐릭터', () => loadCharacterSheet()]);
      if (typeof ensureSkillLoaded2 === 'function') steps.push(['스킬', () => ensureSkillLoaded2()]);
      else if (typeof loadSkillSheet === 'function') steps.push(['스킬', () => loadSkillSheet()]);
      if (typeof BuffLeveling?.preload === 'function') steps.push(['버프', () => BuffLeveling.preload()]);
      if (typeof ensureEnhLoaded === 'function') steps.push(['강화/엠블렘', () => ensureEnhLoaded()]);
      if (typeof ensureSetLoaded === 'function') steps.push(['세트', () => ensureSetLoaded()]);
      if (typeof ensureExceptionLoaded === 'function') steps.push(['예외규칙', () => ensureExceptionLoaded()]);
      const perCore = steps.length ? (coreW / steps.length) : coreW;
      // 슬롯은 **done/total 기반으로 퍼센트 반영**
      let slotProgress = 0;

      // ── 1. 코어 단계(동적) ───────────────
      const runStep = async (label, fn) => {
        setProgressExactMonotonic(__progressPct, `${label} 불러오는 중…`);
        await fn();
        __progressPct += perCore;
        setProgressExactMonotonic(__progressPct, `${label} 불러오는 중…`);
      };
      for (const [label, fn] of steps) {
        await runStep(label, fn);
      }


      // ── 2. 슬롯들 ───────────────
      const loadSlot = (s) => ensureLoaded(s);

      let done = 0;
      const promises = slots.map(s =>
        Promise.resolve()
          .then(() => {
            const label = labelForSlot(s);
            setProgressExactMonotonic(__progressPct, `${label} 불러오는 중…`);
          })
          .then(() => loadSlot(s))
          .then(() => {
            done += 1;
            // ✅ 비율 기반 진행도
            slotProgress = (done / totalSlots) * slotsW;
            setProgressExactMonotonic(coreW + slotProgress, `아이템 불러오는 중… (${done}/${totalSlots})`);
          })
      );

      await Promise.all(promises);

      // ── 3. 딱 맞춰서 100% ───────────────
      __progressPct = 100;
      setProgressExactMonotonic(100, '모든 데이터 로딩 완료');
    }






    // === [ENCHANT] 전역 캐시 & 프리로드 ===
    const ENCHANT_CACHE = {
      ready: false,            // 프리로드 완료 여부
      byType: new Map(),       // '무기마부' -> [{name, typeKey}, ...]
      version: 'v1',           // 캐시 버전(시트가 바뀌면 여기 문자열만 바꿔 새로 받도록)
    };

    const DBSkill = { loaded: false, headers: [], rows: [] };

    // 강화/마봉/마부(ENHANCE_SHEET) 사전 로드: 백엔드(JSON) 버전
    async function preloadEnchantSheet() {
      if (ENCHANT_CACHE.ready) return;

      // 1) 로그인 토큰
      const token = await waitForIdToken();

      // 2) 프록시 → GAS: ?type=enhance
      const r = await fetch(window.WEBAPP_URL + '?type=enhance', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',                  // 캐시 사용 안 함(버전 관리 원하면 쿼리로)
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('enhance_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_enhance_payload');

      const rows = data.rows || [];
      const byType = new Map();

      // 3) 행 가공: 기존 mapRowToEnhance를 최우선 사용 (있으면)
      for (const raw of rows) {
        const obj = (typeof mapRowToEnhance === 'function') ? mapRowToEnhance(raw) : null;

        const typeKey = String(obj?.type ?? raw['종류'] ?? '').trim();
        if (!typeKey) continue;

        const name = String(obj?.name ?? raw['이름'] ?? raw['name'] ?? '').trim();
        if (!name) continue;

        const stats = obj?.stats ?? null;                     // 안전
        const jobGroup = String(obj?.jobGroup ?? raw['직업군'] ?? '').trim();

        if (!byType.has(typeKey)) byType.set(typeKey, []);
        byType.get(typeKey).push({
          name,
          typeKey,
          stats,
          jobGroup,
          raw: raw                                         // 원본도 보존
        });
      }

      ENCHANT_CACHE.byType = byType;
      ENCHANT_CACHE.ready = true;
    }


    async function ensureEnchantCache() {
      if (!ENCHANT_CACHE.ready) {
        try { await preloadEnchantSheet(); }
        catch (e) { console.warn('[ENCHANT] preload failed:', e); ENCHANT_CACHE.ready = true; }
      }
    }



    // === [ENCHANT] 0) 세부상자(3번째) 기본 라벨 "마법 부여"로 세팅 ===
    // === [ENCHANT] 0) 세부상자 기본 라벨/역할 세팅 ===
    function setDefaultEnchantLabels() {
      // ① 장비 슬롯 행: 세 번째 세부상자 → "마법 부여"
      document.querySelectorAll('.slot-row').forEach(row => {
        const third = row.querySelector('.outer-rects .rect:nth-child(3)');
        if (third) {
          third.textContent = '마법 부여';
          third.dataset.role = 'enchant';
          third.removeAttribute('data-unused');
          third.removeAttribute('aria-disabled');
          third.disabled = false;
          third.classList.remove('disabled', 'is-disabled');
          third.style.pointerEvents = ''; // 혹시 막혀 있으면 해제
        }
      });

      // ② C2(칭호) mini-cell: 첫 번째 세부버튼 활성화 → "마법 부여"
      const c2cell = document.querySelector('.slot.mini[data-slot="C2"]')?.closest('.mini-cell');
      if (c2cell) {
        const firstBtn = c2cell.querySelector('.outer-rects .rect:nth-child(1)');
        if (firstBtn) {
          firstBtn.textContent = '마법 부여';
          firstBtn.dataset.role = 'enchant';
          firstBtn.removeAttribute('data-unused');
          firstBtn.removeAttribute('aria-disabled');
          firstBtn.disabled = false;
          firstBtn.classList.remove('disabled', 'is-disabled');
          firstBtn.style.pointerEvents = '';
        }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      setDefaultEnchantLabels();
      ensureEnchantCache();
    });

    // === [ENCHANT] 1) 슬롯키 → 마법부여 종류키 매핑 ===
    // L1 머리어깨, L2 상의, L3 하의, L4 허리, L5 신발
    // R1 무기, R2 팔찌, R3 목걸이, R4 반지, R5 보조장비
    function enchantTypeForSlot(slotKey) {
      const map = {
        'R1': '무기마부',
        'L2': '상의마부',
        'L3': '하의마부',
        'L1': '머리어깨마부',
        'L4': '허리마부',
        'L5': '신발마부',
        'R2': '팔찌마부',
        'R3': '목걸이마부',
        'R4': '반지마부',
        'R5': '보장마부',
        'C2': '칭호마부',
      };
      return map[String(slotKey).toUpperCase()] || null;
    }

    // === [ENCHANT] 2) ENHANCE_SHEET 로딩 & 옵션 추출 ===
    // === [ENCHANT] 캐시 우선 옵션 로더 ===
    async function loadEnchantOptions(typeKey) {
      await ensureEnchantCache();
      const list = ENCHANT_CACHE.byType.get(String(typeKey).trim());
      return Array.isArray(list) ? list : [];
    }



    // === [ENCHANT] 3) 모달 핸들러 ===
    const $enchantModal = document.getElementById('enchantModal');
    const $enchantList = document.getElementById('enchantList');

    function openEnchantModalFor(slotKey) {
      state.currentSlotKey = slotKey;
      const typeKey = enchantTypeForSlot(slotKey);
      if (!typeKey) { alert('해당 슬롯의 마법부여 종류를 찾을 수 없습니다.'); return; }
      renderEnchantList(typeKey);
      showModal($enchantModal, true);
    }

    async function renderEnchantList(typeKey) {
      const list = await loadEnchantOptions(typeKey);
      if (!list.length) {
        $enchantList.innerHTML = '<div style="color:#c7b589;">해당 부위의 마법부여가 없습니다.</div>';
        return;
      }
      // 캡션 사용하지 않음(요구 5). 이름만 버튼으로.
      $enchantList.innerHTML = '';
      list.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = 'enh-option';
        btn.type = 'button';
        btn.textContent = opt.name;
        btn.addEventListener('click', () => applyEnchantSelection(opt));
        $enchantList.appendChild(btn);
      });
    }
    // === [ENCHANT][AUTO] 속성+티어/티어만 규칙대로 전체 자동 적용
    async function applyAutoEnchant(attr, tier) {
      await ensureEnchantCache(); // 캐시 보장

      const combo = `${attr}${tier}`;

      // 규칙: 무기/팔/목/반지는 "속성+티어"로 찾는다
      const USE_COMBO = new Set(['무기마부', '팔찌마부', '목걸이마부', '반지마부']);
      // 규칙: 머어/상의/하의/허리/신발/보장/칭호는 "티어"만으로 찾는다
      const USE_TIER = new Set(['머리어깨마부', '상의마부', '하의마부', '허리마부', '신발마부', '보장마부', '칭호마부']);

      // 적용 대상 슬롯 코드(좌/우/보조/칭호 포함)
      const targetSlots = ['R1', 'R2', 'R3', 'R4', 'R5', 'L1', 'L2', 'L3', 'L4', 'L5', 'C2'];

      const applied = [];
      // 한 슬롯씩 찾아서 state.enchants에 넣고 버튼 라벨도 갱신
      for (const slotCode of targetSlots) {
        const typeKey = enchantTypeForSlot(slotCode); // 예: R1 -> '무기마부' :contentReference[oaicite:2]{index=2}
        if (!typeKey) continue;

        const keyToUse = USE_COMBO.has(typeKey) ? combo
          : USE_TIER.has(typeKey) ? tier
            : null;
        if (!keyToUse) continue;

        const opt = findEnchantByJobGroup(typeKey, keyToUse);
        if (!opt) continue;

        // 기존 단일 적용 로직을 재사용해서 라벨/합산까지 동일 동작
        const prev = state.currentSlotKey;
        state.currentSlotKey = slotCode;
        applyEnchantSelection(opt); // 이 함수 안에서 버튼명 갱신 + 재계산 + 모달닫기까지 처리됨 :contentReference[oaicite:3]{index=3}
        state.currentSlotKey = prev;

        applied.push({ slot: slotCode, name: opt.name });
      }

      if (!applied.length) {
        // 찾을 수 없는 케이스를 안내(선택한 조합이 시트에 없는 경우)
        if (typeof toast === 'function') toast('조건에 맞는 추천 마법부여를 찾지 못했습니다.');
        else alert('조건에 맞는 추천 마법부여를 찾지 못했습니다.');
      }
    }

    function applyEnchantSelection(opt) {
      const slotKey = state.currentSlotKey;
      if (!slotKey) return;
      state.enchants[slotKey] = {
        name: opt.name,
        typeKey: opt.typeKey,
        stats: opt.stats || null,
        raw: opt.raw || null
      };

      // 1) 장비 슬롯 행(.slot-row)에 있으면: 마법부여 버튼(data-role) 또는 3번째 버튼 갱신
      const row = document.querySelector(`.slot-row .slot[data-slot="${slotKey}"]`)?.closest('.slot-row');
      if (row) {
        const target = row.querySelector('.outer-rects .rect[data-role="enchant"]')
          || row.querySelector('.outer-rects .rect:nth-child(3)');
        if (target) target.textContent = opt.name;
      } else {
        // 2) 미니 셀(C1~C4)에 있으면: 마법부여 버튼(data-role) 또는 1번째 버튼 갱신
        const cell = document.querySelector(`.mini-cell .slot.mini[data-slot="${slotKey}"]`)?.closest('.mini-cell');
        if (cell) {
          const target = cell.querySelector('.outer-rects .rect[data-role="enchant"]')
            || cell.querySelector('.outer-rects .rect:nth-child(1)');
          if (target) target.textContent = opt.name;
        }
      }

      showModal($enchantModal, false);
      recalcAndRenderPanel();
    }

    // 공용 모달 show/hide 유틸(파일 내 다른 모달과 동일 방식 사용)
    function showModal(modal, on) {
      if (!modal) return;
      if (on) { modal.classList.add('show'); modal.setAttribute('aria-hidden', 'false'); }
      else { modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true'); }
    }
    $enchantModal?.querySelector('.backdrop[data-close]')?.addEventListener('click', () => showModal($enchantModal, false));

    // === [ENCHANT] 4) 세 번째 세부상자 클릭 시 모달 ===
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('.rect');
      if (!btn) return;

      // 3번째 버튼만 처리 (dataset.role='enchant'는 A단계에서 부여)
      if (btn.dataset.role === 'enchant') {
        // ★ slot-row 또는 mini-cell(하단 C1~C4 영역) 모두 지원
        const container = btn.closest('.slot-row, .mini-cell, .mini-bar');
        const slotKey = container?.querySelector('.slot')?.getAttribute('data-slot');
        if (!slotKey) return;
        openEnchantModalFor(slotKey);
      }
    });

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('.rect');
      if (!btn) return;

      // [REFINE] 4번째 버튼
      if (btn.dataset.role === 'refine') {
        const container = btn.closest('.slot-row, .mini-cell');
        const slotCode = container?.querySelector('.slot')?.getAttribute('data-slot'); // R1/R5
        if (!slotCode) return;

        // 1단계: 무기(R1)만 먼저 동작. R5는 추후 적용.
        if (slotCode === 'R1') {
          openRefineModalForWeapon(btn);
        } else if (slotCode === 'R5') {
          openRefineModalForSub(btn);   // ★ 새로운 함수로 연결
        }
      }
    });


    const $refineModal = document.getElementById('refineModal');
    const $refineList = document.getElementById('refineList');

    function showRefineModal(on) {
      if (!$refineModal) return;
      if (on) { $refineModal.classList.add('show'); $refineModal.setAttribute('aria-hidden', 'false'); }
      else { $refineModal.classList.remove('show'); $refineModal.setAttribute('aria-hidden', 'true'); }
    }
    $refineModal?.addEventListener('click', (e) => {
      if (e.target.dataset.close != null || e.target.classList.contains('backdrop')) {
        showRefineModal(false);
      }
    });

    async function openRefineModalForWeapon(btnEl) {    //무기연마
      if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

      // 버튼 목록 만들기
      const labels = ['연마없음', '1연마', '2연마', '3연마', '4연마', '5연마', '6연마', '7연마', '8연마', '9연마'];
      $refineList.innerHTML = '';
      labels.forEach(name => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'btn block';    // 네 버튼 규칙에 맞춰 block 표시
        b.textContent = name;
        b.addEventListener('click', () => applyWeaponRefine(name, btnEl));
        $refineList.appendChild(b);
      });

      showRefineModal(true);
    }

    async function openRefineModalForSub(btnEl) {     //보장연마
      if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

      const labels = ['연마없음', '1연마', '2연마', '3연마', '4연마', '5연마', '6연마', '7연마', '8연마', '9연마'];
      $refineList.innerHTML = '';
      labels.forEach(name => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'btn block';
        b.textContent = name;
        b.addEventListener('click', () => applySubRefine(name, btnEl));
        $refineList.appendChild(b);
      });

      showRefineModal(true);
    }


    function applyWeaponRefine(name, btnEl) {   //무기연마 적용
      state.refines = state.refines || {};
      // ‘연마없음’ 이면 해제
      if (name === '연마없음') {
        state.refines.weapon = null;
        if (btnEl) btnEl.textContent = '연마 설정';
        showRefineModal(false);
        recalcAndRenderPanel();
        return;
      }

      // 강화/마봉/마부 시트에 이미 로드해둔 DBEnh에서 종류=무기연마 & 이름=name 행을 찾음
      const list = (DBEnh?.byType?.['무기연마'] || (DBEnh?.list || []).filter(o => (o?.type || '') === '무기연마'));
      const found = Array.isArray(list) ? list.find(o => String(o.name).trim() === name) : null;

      if (!found) {
        if (typeof toast === 'function') toast(`무기연마에서 '${name}'을(를) 찾을 수 없습니다.`);
        else alert(`무기연마에서 '${name}'을(를) 찾을 수 없습니다.`);
        return;
      }

      // 상태 저장(합산 시 곱연산 계열은 addStats에서 자동 처리)
      state.refines.weapon = { name: found.name, stats: found.stats || null, raw: found.raw || null };

      // 버튼 라벨 갱신
      if (btnEl) btnEl.textContent = name;

      showRefineModal(false);
      recalcAndRenderPanel();
    }

    function applySubRefine(name, btnEl) {    //보장연마적용
      state.refines = state.refines || {};

      if (name === '연마없음') {
        state.refines.sub = null;
        if (btnEl) btnEl.textContent = '연마 설정';
        showRefineModal(false);
        recalcAndRenderPanel();
        return;
      }

      const list = (DBEnh?.byType?.['보장연마'] || (DBEnh?.list || []).filter(o => (o?.type || '') === '보장연마'));
      const found = Array.isArray(list) ? list.find(o => String(o.name).trim() === name) : null;

      if (!found) {
        if (typeof toast === 'function') toast(`보장연마에서 '${name}'을(를) 찾을 수 없습니다.`);
        else alert(`보장연마에서 '${name}'을(를) 찾을 수 없습니다.`);
        return;
      }

      state.refines.sub = { name: found.name, stats: found.stats || null, raw: found.raw || null };

      if (btnEl) btnEl.textContent = name;

      showRefineModal(false);
      recalcAndRenderPanel();
    }





    function _setText(id, v) { const el = document.getElementById(id); if (el) el.textContent = String(v); }

    function renderSpTp() {
      const sp = state.sp || {};
      const tp = state.tp || {};
      const set = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = String(v); };
      // Top header (if visible)
      set('spLeftTop', sp.left ?? 0);
      set('tpLeftTop', tp.left ?? 0);
      // Modal right-top mini counters
      set('stSpLeftMini', sp.left ?? 0);
      set('stTpLeftMini', tp.left ?? 0);
      // Any small counters near the button (outside modal)
      set('stSpLeft', sp.left ?? 0);
      set('stTpLeft', tp.left ?? 0);
      // Used/Total for detailed displays
      set('stSpUsed', (sp.total ?? 0) - (sp.left ?? 0));
      set('stSpTotal', sp.total ?? 0);
      set('stTpUsed', (tp.total ?? 0) - (tp.left ?? 0));
      set('stTpTotal', tp.total ?? 0);
    }

    function setTotals(spTotal, tpTotal) {
      const spt = Number(spTotal || 0), tpt = Number(tpTotal || 0);
      state.sp.total = spt;
      state.sp.left = spt;
      state.tp.total = tpt; state.tp.left = tpt;
      renderSpTp();
    }

    function canSpendSp(cost) { return (state.sp.left ?? 0) >= (Number(cost) || 0); }
    function spendSp(cost) { state.sp.left = Math.max(0, (state.sp.left ?? 0) - (Number(cost) || 0)); renderSpTp(); }
    function refundSp(cost) { state.sp.left = Math.min((state.sp.total ?? 0), (state.sp.left ?? 0) + (Number(cost) || 0)); renderSpTp(); }
    function canSpendTp(cost) { return (state.tp.left ?? 0) >= (Number(cost) || 0); }
    function spendTp(cost) { state.tp.left = Math.max(0, (state.tp.left ?? 0) - (Number(cost) || 0)); renderSpTp(); }
    function refundTp(cost) { state.tp.left = Math.min((state.tp.total ?? 0), (state.tp.left ?? 0) + (Number(cost) || 0)); renderSpTp(); }
    function noSpFeedback() { alert('SP가 부족합니다.'); }
    function noTpFeedback() { alert('TP가 부족합니다.'); }
    // ⬇ 기존 loadCharTotalsAndApply 전체를 이걸로 교체
    async function loadCharTotalsAndApply(charName) {
      try {
        // 로그인 토큰 필요
        if (!idToken) { setTotals(0, 35); return; }

        // 프록시 → GAS: 캐릭터시트(JSON)
        const r = await fetch(window.WEBAPP_URL + '?type=char', {
          method: 'POST',
          mode: 'cors',
          cache: 'no-store',
          headers: { 'Content-Type': 'text/plain' },
          body: idToken
        });
        if (!r.ok) throw new Error('char_fetch_fail');
        const data = await r.json();
        const rows = Array.isArray(data?.rows) ? data.rows : [];

        // 이름 정규화해서 1행 찾기
        const key = String(charName || '').replace(/\s+/g, '');
        const row = rows.find(x => String(x?.name || '').replace(/\s+/g, '') === key);

        // 백엔드에서 내려주는 표준 키(spTotal, tpTotal)를 최우선 사용
        const spTotal = Number(row?.spTotal ?? row?.['총SP'] ?? row?.['총스포'] ?? 0) || 0;
        const tpTotal = Number(row?.tpTotal ?? row?.['총TP'] ?? row?.['총티피'] ?? 35) || 35;

        setTotals(spTotal, tpTotal);
      } catch (e) {
        console.warn('[SP/TP] load totals failed', e);
        setTotals(0, 35);
      }
    }



    /* ===== 스킬 시트 로더 & 게임형(가로 칼럼) 렌더러 ===== */
    // CSV -> JSON 전환: ST2.rows 를 JSON 응답으로 채움
    async function loadSkillSheet() {
      if (DBSkill.loaded) return;

      const token = await waitForIdToken();

      const r = await fetch(window.WEBAPP_URL + '?type=skill', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('skill_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_skill_payload');

      // 그대로 보관 (CSV header:true 결과와 동일한 구조)
      DBSkill.headers = Array.isArray(data.headers) ? data.headers : [];
      DBSkill.rows = data.rows;

      // 네가 기존에 쓰던 전역 핸들(ST2)을 유지하고 싶다면:
      window.ST2 = { rows: DBSkill.rows, headers: DBSkill.headers };

      DBSkill.loaded = true;
    }


    // (스킬트리 렌더러 상단 어딘가, 중복 정의 없이 1회 선언)
    const onSkillTreeChanged = (() => {
      let t = null;
      return () => {
        clearTimeout(t);
        t = setTimeout(() => {
          if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
        }, 60); // 너무 자주 돌지 않게 살짝 디바운스
      };
    })();
    const ST_BANDS = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 65, 70, 75, 80];
    const DBSkills = { loaded: false, rows: [] };

    function parseNumber(v) {
      if (v == null) return 0;
      const m = String(v).match(/-?\d+(\.\d+)?/);
      return m ? Number(m[0]) : 0;
    }
    function bandOf(v) {
      const n = parseNumber(v);
      if (!n) return '기본';
      let best = ST_BANDS[0], dmin = 1e9;
      for (const b of ST_BANDS) { const d = Math.abs(n - b); if (d < dmin) { dmin = d; best = b; } }
      return best;
    }

    function skillsForCurrentChar(rows) {
      const key = (state.currentCharacter?.jobGroupLabel || '') + (state.currentCharacter?.name || '');
      const want = key.replace(/\s+/g, '');
      if (!want) return rows;
      const fil = rows.filter(s => !s.ownerKey || s.ownerKey === want);
      return fil.length ? fil : rows;
    }

    /* 25.09.20 스킬트리 추가S */
    /* ===== SkillTree v2: 로더/필터/렌더 ===== */
    /** 캐시 */
    const ST2 = { loaded: false, rows: [] };
    /** 유틸: 안전 숫자 */
    const toInt = (v, def = 0) => {
      const n = Number(String(v || '').trim()); return Number.isFinite(n) ? n : def;
    };
    /** 시트 → 표준 스킬 객체 매핑 */
    // 교체할 함수
    function mapRowToSkill2(r) {        // 시트 컬럼들을 읽습니다. who = 캐릭터명, show = 노출여부, ...
      // 1) 캐릭터 키(시트 '캐릭터명'과 정확히 일치, 공백 제거)
      const who = String(r['캐릭터명'] || '').replace(/\s+/g, '');
      // 2) 노출/정렬/좌표
      const show = Number(String(r['노출여부'] || '').trim()) === 1;
      const level = Number(String(r['스킬렙제'] || '').trim()) || 0;
      const x = Math.min(6, Math.max(1, Number(String(r['가로위치'] || '').trim()) || 1));
      const y = Math.max(1, Number(String(r['세로위치'] || '').trim()) || 1);
      const cd = toNum(r['쿨타임']);
      const castFrames = toNum(r['시전프레임']);
      // ★ 추가: 구분(평타/연결평타/스킬/각성기)
      const rawKind = String(r['구분'] || '').trim();
      // 기본값은 '스킬' (시트에서 비워두면 스킬로 취급)
      const kind = rawKind || '스킬';
      // 3) 핵심 필드(스펙: 스킬명/이미지 사용)
      const name = String(r['스킬명'] || '').trim();
      const img = cleanUrl(r['이미지'] || '') || PLACEHOLDER_IMG;
      // 4) 최소/최대 스킬 레벨
      const minLv = Math.max(0, Number(String(r['최소스킬레벨'] || '').trim()) || 0);
      const maxLv = Math.max(minLv, Number(String(r['최대스킬레벨'] || '').trim()) || minLv); // 최소보다 작지 않게

      // 5) ID(없으면 스킬명 기반 대체)
      const idSrc = String(r['ID'] ?? r['id'] ?? name).trim();
      const id = idSrc || ('SK_' + Math.random().toString(36).slice(2));

      // 6) SP/TP 코스트
      const sp = toInt(r['소모 SP'] ?? r['소모SP'] ?? r['SP'] ?? r['sp'] ?? 0, 0);
      const tpCost = toInt(r['tp설정'] ?? r['TP설정'] ?? r['tp 설정'] ?? r['TP 설정'] ?? r['tp'] ?? r['TP'] ?? 0, 0);

      // 7) ★ 퍼뎀/고뎀 선형 모델(시트 컬럼 그대로)
      //    - '1렙데미지'   : minLv 기준 퍼뎀
      //    - '1렙고정뎀'   : minLv 기준 고뎀
      //    - '1렙당 데미지': 레벨 +1당 퍼뎀 증가치
      //    - '1렙당 고정뎀': 레벨 +1당 고뎀 증가치
      const dmg1Base = toNum(r['1렙데미지'], NaN);
      const fix1Base = toNum(r['1렙고정뎀'], NaN);
      const dmg1PerLv = toNum(r['1렙당 데미지'], NaN);
      const fix1PerLv = toNum(r['1렙당 고정뎀'], NaN);

      return {
        id, name, img, who, show, level, x, y, minLv, maxLv, sp, tpCost,
        // ★ 추가된 4개 필드
        dmg1Base, fix1Base, dmg1PerLv, fix1PerLv, band: level, levelGate: level, cd,             // ★ 추가: 계산에서 바로 쓰도록
        cooldown: cd,
        castFrames,    // ★ 호환용 키
        kind
      };
    }



    /** 시트 로드(1회) — 백엔드(JSON) 버전 */
    async function ensureSkillLoaded2() {     // ST2 표준 스킬 객체를 ST2.rows에 캐시
      if (ST2.loaded) return;

      // 로그인 토큰 확보 (이미 가진 waitForIdToken 재사용)
      const token = await waitForIdToken();

      // 프록시 → Apps Script: ?type=skill
      const r = await fetch(window.WEBAPP_URL + '?type=skill', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('skill_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_skill_payload');

      // CSV 때와 동일: 시트 헤더명 키를 가진 각 행을 ST2 표준 스킬로 매핑
      const rows = data.rows.map(mapRowToSkill2).filter(s => s.id && s.name && s.who);

      ST2.rows = rows;
      ST2.loaded = true;
    }


    /** 현재 캐릭터 키 얻기 (남귀검사+이름) */
    function currentCharKey() {
      const k = currentSkillOwnerKey?.() || '';      // 이미 코드에 있는 함수 재활용
      return String(k).replace(/\s+/g, '') || null;
    }

    /* ===== TP 범위 & 상태 ===== */
    const TP_MIN = 0, TP_MAX = 5;
    state.skillTpLv = state.skillTpLv || {}; // { skillId: tpLevel }

    /* ===== 스킬 데미지 유틸(선형 + TP 배율) ===== */
    // 0) (없으면 추가) 현재 데미지 캐시
    state.skillDmg = state.skillDmg || {};   // { skillId: {per, flat, lv, tpLv, tpIncPercent} }

    // 1) (없으면 추가) 선형 퍼뎀/고뎀 계산
    function calcSkillDamageLinear(skill, lv) {
      // 0과 null/undefined 를 구분: 0은 유효 레벨
      const maxLv = Number(skill.maxLv ?? 0);
      const rawLv = Number(lv ?? 0);

      // 1) 레벨 하한은 0으로 클램프 (0레벨 허용)
      // ✅ 계산상 상한 제거
      const curLv = Math.max(0, rawLv);

      // 2) 0레벨이면 데미지 0 확정
      if (curLv === 0) return { per: 0, flat: 0, lv: 0 };

      // 3) '1렙데미지'를 기준으로 선형 증가
      //    step은 항상 (현재레벨 - 1)
      const dmg1Base = Number.isFinite(skill.dmg1Base) ? skill.dmg1Base : 0;
      const fix1Base = Number.isFinite(skill.fix1Base) ? skill.fix1Base : 0;
      const dmg1PerLv = Number.isFinite(skill.dmg1PerLv) ? skill.dmg1PerLv : 0;
      const fix1PerLv = Number.isFinite(skill.fix1PerLv) ? skill.fix1PerLv : 0;

      const step = curLv - 1; // ★ 1렙 기준
      const per = dmg1Base + dmg1PerLv * step;  // 퍼뎀
      const flat = fix1Base + fix1PerLv * step;  // 고뎀

      return { per, flat, lv: curLv };
    }

    // 2) 외부(아이템/룬 등) TP 보너스 합산 – 초기는 0으로 두고 나중에 구현
    // TP 추가 보정치(기교룬 등)
    function getTpBonusFromSources(skillId) {
      // ① 사용자가 찍은 '기본 TP'가 0이면 → 기교룬 보너스 차단
      const baseUiTp = Number(state.skillTpLv?.[skillId] ?? 0);
      if (!(baseUiTp > 0)) return 0;

      // ② 기교룬(+TP) 합산
      const s = (ST2?.rows || []).find(r => r.id === skillId);
      if (!s) return 0;
      const { enhLvAdd } = runeLevelAdds(s); // 기교룬 수량
      return Number(enhLvAdd || 0);
    }

    // 3) tp설정(1/2)에 따른 TP 증가율(%) 계산 (최대 7레벨)
    function tpIncreasePercent(tpSetting, tpLevel) {
      const lv = Math.max(0, Math.min(7, Number(tpLevel) || 0));
      if (lv === 0 || !Number.isFinite(tpSetting) || tpSetting <= 0) return 0;

      if (tpSetting === 1) return 5 + (lv - 1) * 2; // 1레벨 5%, 이후 +2%
      if (tpSetting === 2) return 8 + (lv - 1) * 3; // 1레벨 8%, 이후 +3%
      return 0;
    }

    // 4) 선형 데미지에 TP 비율을 곱해 최종치 산출

    /* ===== 길게누르기(민감 완화): pointer 이벤트 기반 ===== */
    function attachPressRepeat(btn, stepFn) {
      let timer = null, active = false, interval = 180;
      const start = (e) => {
        e.preventDefault();
        if (btn.disabled) return;
        active = true;
        stepFn(); // 첫 눌림 즉시 1회
        let firstDelay = 500; // 초기 지연
        timer = setTimeout(function kick() {
          if (!active) return;
          stepFn();
          interval = Math.max(120, interval);     // 최소 120ms
          timer = setTimeout(kick, interval);
        }, firstDelay);
      };
      const stop = () => {
        active = false;
        if (timer) { clearTimeout(timer); timer = null; interval = 180; }
      };

      // pointer 계열만 사용해 중복 이벤트 방지
      btn.addEventListener('pointerdown', start);
      ['pointerup', 'pointerleave', 'pointercancel', 'blur'].forEach(ev => btn.addEventListener(ev, stop));
      window.addEventListener('pointerup', stop);
    }

    /* ===== 렌더러 교체 ===== */
    async function renderSkillTreeBands() {   //스킬을 밴드형으로 배치
      await waitForIdToken();
      await ensureSkillLoaded2();

      // 현재 캐릭터 키
      const key = currentCharKey?.();
      const wrap = document.getElementById('stGrid');
      wrap.className = 'st2-wrap';
      wrap.innerHTML = '';

      {
        const nmEl = document.getElementById('stCharName');
        if (nmEl) nmEl.textContent = (state.currentCharacter && state.currentCharacter.name) ? state.currentCharacter.name : '—';
      }
      if (!key) {
        wrap.innerHTML = `<div style="color:#c7b589; padding:8px;">캐릭터를 먼저 선택해 주세요.</div>`;
        return;
      }

      // 1) 캐릭터 일치 + 노출=1
      let list = ST2.rows.filter(s => s.who === String(key).replace(/\s+/g, '') && s.show);
      // 2) 정렬: 스킬렙제 → 세로 → 가로 → 이름
      list.sort((a, b) => a.level - b.level || a.y - b.y || a.x - b.x || a.name.localeCompare(b.name));
      const levels = [...new Set(list.map(s => s.level))];
      if (levels.length === 0) {
        wrap.innerHTML = `<div style="color:#c7b589; padding:8px;">표시할 스킬이 없습니다.</div>`;
        return;
      }

      // 유틸: 경계 보정
      const clampSkill = (s, v) => Math.max(s.minLv ?? 0, Math.min(s.maxLv ?? 0, Number(v) || 0));
      const clampTp = (v) => Math.max(TP_MIN, Math.min(TP_MAX, Number(v) || 0));
      const getSkill = (s) => {
        if (state.skillLv[s.id] === undefined) state.skillLv[s.id] = clampSkill(s, s.minLv ?? 0);
        return clampSkill(s, state.skillLv[s.id]);
      };
      const setSkill = (s, v) => {
        const target = clampSkill(s, v);
        const cur = getSkill(s);
        const delta = target - cur;
        const per = Number(s.sp || 0);

        if (delta > 0) {
          const cost = per * delta;
          if (!canSpendSp(cost)) { noSpFeedback(); return; }
          state.skillLv[s.id] = target;
          spendSp(cost);
        } else if (delta < 0) {
          state.skillLv[s.id] = target;
          refundSp(per * (-delta));
        } else {
          state.skillLv[s.id] = target;
        }

        // ★ 여기부터 교체: 확정 레벨(target)과 TP(없으면 0)를 사용, ??로 안전 처리
        const curTpLv = state.skillTpLv?.[s.id] ?? 0;              // ← 0 그대로 인정
        state.skillDmg[s.id] = calcSkillDamageWithTp(s, curTpLv);
        onSkillTreeChanged();
      };
      const getTp = (s) => {
        if (state.skillTpLv[s.id] === undefined) state.skillTpLv[s.id] = TP_MIN;
        return clampTp(state.skillTpLv[s.id]);
      };
      const setTp = (s, v) => {
        const unit = Number(s.tpCost || 0);
        if (!Number.isFinite(unit) || unit <= 0) return; // TP 강화 미지원

        const target = clampTp(v);
        const cur = getTp(s);

        if (target > cur) {
          const need = (target - cur) * unit;
          if (!canSpendTp(need)) { noTpFeedback(); return; }
          spendTp(need);
        } else if (target < cur) {
          const back = (cur - target) * unit;
          refundTp(back);
        }
        state.skillTpLv[s.id] = target;

        // ★ 여기! TP 확정 후 재계산. minLv=0을 깨지 않도록 ?? 사용
        const curLv = state.skillLv?.[s.id] ?? (s.minLv ?? 1);     // ← 0 그대로 인정
        state.skillDmg[s.id] = calcSkillDamageWithTp(s, target);
        onSkillTreeChanged();
      };

      // 레벨 밴드 단위로 DOM 생성
      levels.forEach(lvl => {
        const group = list.filter(s => s.level === lvl);

        // ✅ 밴드 컨테이너(점선+라벨+그리드 포함)
        const band = document.createElement('div');
        band.className = 'st2-band';

        const label = document.createElement('div');
        label.className = 'st2-band-label';
        label.textContent = String(lvl);
        band.appendChild(label);

        // 이 밴드 안의 6열 그리드
        const grid = document.createElement('div');
        grid.className = 'st2-grid';

        group.forEach(s => {
          const tile = document.createElement('div');
          tile.className = 'st2-tile';
          tile.style.gridColumn = String(s.x);
          tile.style.gridRow = String(s.y || 1);

          // 아이콘(원형)
          const icon = document.createElement('div');
          icon.className = 'st2-skill';
          const img = document.createElement('img');
          img.alt = s.name; img.src = s.img || PLACEHOLDER_IMG;
          img.onerror = () => {
            icon.classList.add('st2-empty');
            img.remove();
            const ini = document.createElement('div');
            ini.className = 'st2-initial';
            ini.textContent = (s.name || '?').slice(0, 1);
            icon.appendChild(ini);
          };
          icon.appendChild(img);

          // ★ 스킬명 (아이콘과 레벨박스 사이의 '독립' 줄)
          const nameEl = document.createElement('div');
          nameEl.className = 'st2-name';
          nameEl.textContent = s.name;
          nameEl.title = s.name; // 말줄임 보완용 툴팁

          // 컨트롤(2행 × 3열)
          const ctrl = document.createElement('div');
          ctrl.className = 'st2-ctrl2';

          // 좌측-상단(스킬: Max 위, + 아래) — 가운데 정렬
          const LTop = document.createElement('div');
          LTop.className = 'st2-side-left';
          const btnSkillMax = document.createElement('button'); btnSkillMax.className = 'st2-btn'; btnSkillMax.textContent = 'Max';
          const btnSkillPlus = document.createElement('button'); btnSkillPlus.className = 'st2-btn'; btnSkillPlus.textContent = '+';
          LTop.appendChild(btnSkillMax);
          LTop.appendChild(btnSkillPlus);

          // 좌측-하단(스킬: − 위, Min 아래)
          const LBot = document.createElement('div');
          LBot.className = 'st2-side-left';
          const btnSkillMinus = document.createElement('button'); btnSkillMinus.className = 'st2-btn'; btnSkillMinus.textContent = '−';
          const btnSkillMin = document.createElement('button'); btnSkillMin.className = 'st2-btn'; btnSkillMin.textContent = 'Min';
          LBot.appendChild(btnSkillMinus);
          LBot.appendChild(btnSkillMin);

          // 중앙 레벨 표시(“스킬 │ TP”)
          // 중앙 레벨 표시(세로 중앙 고정, “스킬명” + “스킬 │ TP”)
          const lvBox = document.createElement('div');
          lvBox.className = 'st2-lv';



          // 숫자 라인(아랫줄): “스킬 │ TP”
          const nums = document.createElement('div');
          nums.className = 'st2-lvnums';

          const spanCur = document.createElement('span');
          spanCur.className = 'cur';
          const spanSep = document.createElement('span'); spanSep.className = 'sep'; spanSep.textContent = '│';
          const spanTp = document.createElement('span');
          spanTp.className = 'tp';

          nums.appendChild(spanCur);
          nums.appendChild(spanSep);
          nums.appendChild(spanTp);


          lvBox.appendChild(nums);


          // 우측-상단(TP: Max 위, + 아래)
          const RTop = document.createElement('div');
          RTop.className = 'st2-side-right';
          const btnTpMax = document.createElement('button'); btnTpMax.className = 'st2-btn'; btnTpMax.textContent = 'Max';
          const btnTpPlus = document.createElement('button'); btnTpPlus.className = 'st2-btn'; btnTpPlus.textContent = '+';
          RTop.appendChild(btnTpMax);
          RTop.appendChild(btnTpPlus);

          // 우측-하단(TP: − 위, Min 아래)
          const RBot = document.createElement('div');
          RBot.className = 'st2-side-right';
          const btnTpMinus = document.createElement('button'); btnTpMinus.className = 'st2-btn'; btnTpMinus.textContent = '−';
          const btnTpMin = document.createElement('button'); btnTpMin.className = 'st2-btn'; btnTpMin.textContent = 'Min';
          RBot.appendChild(btnTpMinus);
          RBot.appendChild(btnTpMin);

          // 컨트롤 그리드 배치
          LTop.style.gridColumn = '1'; LTop.style.gridRow = '1';
          LBot.style.gridColumn = '1'; LBot.style.gridRow = '2';
          lvBox.style.gridColumn = '2'; lvBox.style.gridRow = '1 / span 2';
          RTop.style.gridColumn = '3'; RTop.style.gridRow = '1';
          RBot.style.gridColumn = '3'; RBot.style.gridRow = '2';

          ctrl.appendChild(LTop); ctrl.appendChild(LBot);
          ctrl.appendChild(lvBox);
          ctrl.appendChild(RTop); ctrl.appendChild(RBot);

          tile.appendChild(icon);
          tile.appendChild(nameEl);
          tile.appendChild(ctrl);
          grid.appendChild(tile);

          // 상태 → UI 반영
          const refresh = () => {
            const cur = getSkill(s);
            const tp = getTp(s);
            spanCur.textContent = String(cur);
            spanTp.textContent = String(tp);
            // 스킬 경계
            btnSkillPlus.disabled = (cur >= s.maxLv);
            btnSkillMax.disabled = (cur >= s.maxLv);
            btnSkillMinus.disabled = (cur <= s.minLv);
            btnSkillMin.disabled = (cur <= s.minLv);
            // TP 경계 (스킬별 tpCost 적용)
            const unit = Number(s.tpCost || 0);
            if (!Number.isFinite(unit) || unit <= 0) {
              btnTpPlus.disabled = true;
              btnTpMax.disabled = true;
              btnTpMinus.disabled = true;
              btnTpMin.disabled = true;
            } else {
              btnTpPlus.disabled = (tp >= TP_MAX) || !canSpendTp(unit);
              btnTpMax.disabled = (tp >= TP_MAX) || !canSpendTp((TP_MAX - tp) * unit);
              btnTpMinus.disabled = (tp <= TP_MIN);
              btnTpMin.disabled = (tp <= TP_MIN);
            }
          };
          refresh();
          // 조작 함수
          const stepSkillUp = () => { setSkill(s, getSkill(s) + 1); refresh(); };
          const stepSkillDn = () => { setSkill(s, getSkill(s) - 1); refresh(); };
          const toSkillMax = () => { setSkill(s, s.maxLv); refresh(); };
          const toSkillMin = () => { setSkill(s, s.minLv); refresh(); };

          const stepTpUp = () => { setTp(s, getTp(s) + 1); refresh(); };
          const stepTpDn = () => { setTp(s, getTp(s) - 1); refresh(); };
          const toTpMax = () => { setTp(s, TP_MAX); refresh(); };
          const toTpMin = () => { setTp(s, TP_MIN); refresh(); };

          // 길게누르기(민감도 완화)
          attachPressRepeat(btnSkillPlus, stepSkillUp);
          attachPressRepeat(btnSkillMinus, stepSkillDn);
          attachPressRepeat(btnSkillMax, toSkillMax);
          attachPressRepeat(btnSkillMin, toSkillMin);

          attachPressRepeat(btnTpPlus, stepTpUp);
          attachPressRepeat(btnTpMinus, stepTpDn);
          attachPressRepeat(btnTpMax, toTpMax);
          attachPressRepeat(btnTpMin, toTpMin);
        });

        band.appendChild(grid);
        wrap.appendChild(band);
      });
    }




    /** 버튼 연결 (기존 old 렌더러 바인딩이 있다면 교체) */
    const stModal = document.getElementById('skillTreeModal');

    /* ESC로 닫기(선택 사항) */
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.querySelectorAll('.modal.show').forEach(m => {
          m.classList.remove('show'); m.setAttribute('aria-hidden', 'true');
        });
      }
    });
    /* 25.09.20 스킬트리 추가 F*/

    /* 버튼으로 열기 */
    document.getElementById('btnSkillTree')?.addEventListener('click', async () => {
      await renderSkillTreeBands(); /*25.09.20변경*/
      stModal?.classList.add('show');
      stModal?.setAttribute('aria-hidden', 'false');
    });
    stModal?.addEventListener('click', (e) => {
      if (e.target.classList?.contains('backdrop') || e.target.hasAttribute?.('data-close')) {
        stModal.classList.remove('show');
        stModal.setAttribute('aria-hidden', 'true');
      }
    });
    // 룬 각인 선택 결과(한 개만 유지)
    state.runeEngrave = state.runeEngrave || null; // {name, tag, stats, ...}
    //일반스킬룬
    const RUNE_LEVELS = [15, 20, 25, 30, 35, 40, 45, 65];
    const RUNE_CATS = [
      { key: 'awakening', label: '각성' },
      { key: 'magic', label: '마력' },
      { key: 'illusion', label: '허상' },
      { key: 'training', label: '숙련' },
      { key: 'technique', label: '기교' }
    ];
    state.runes = state.runes || {}; // {catKey: {level: count}}
    function ensureRunesInitialized() {
      RUNE_CATS.forEach(c => {
        state.runes[c.key] ||= {};
        RUNE_LEVELS.forEach(lvl => {
          if (typeof state.runes[c.key][lvl] !== 'number') state.runes[c.key][lvl] = 0;
        });
      });
    }
    /* ===== 스킬룬 코어 ===== */
    // 카테고리 키: RUNE_CATS에서 쓰는 키 그대로 사용(각성/마력/허상/숙련/기교)
    const RUNE_KEYS = {
      awakening: '각성룬',   // 데미지 ×1.04^n
      magic: '마력룬',   // 데미지 ×1.03^n
      illusion: '허상룬',   // 쿨타임 ×0.96^n
      training: '숙련룬',   // 스킬레벨 +n
      technique: '기교룬',   // 스킬강화레벨 +n
    };

    // 선택 개수 가져오기: state.runes[catKey][tier] (없으면 0)
    function getRuneCountByKey(catKey, tier) {
      const row = (state.runes?.[catKey]) || {};
      return Number(row[tier] || 0);
    }

    // 스킬의 렙제(밴드) 알아내기: mapRowToSkill에서 band 필드를 채움
    // (스킬 객체에 band가 없으면 0/기본 취급)
    function skillTierOf(skill) {
      const b = Number(skill?.band || 0);
      return b > 0 ? b : null;
    }

    // (skillTierOf 바로 아래에)
    function getLevelingCountByTier(tier) {
      return Number(state.leveling?.[tier] || 0);
    }

    // cd 값을 '초' 숫자로만 얻기 (문자 섞여 있어도 숫자만 추출)
    function toSec(v) {
      const n = Number(String(v ?? '').replace(/[^\d.]/g, ''));
      return Number.isFinite(n) ? n : 0;
    }

    // 1) 최종 공격력 배수: 각성(1.04^n) × 마력(1.03^n)
    function runeDamageMultiplier(skill) {
      const tier = skillTierOf(skill);
      if (!tier) return 1;
      const nA = getRuneCountByKey('awakening', tier);
      const nM = getRuneCountByKey('magic', tier);
      return Math.pow(1.04, nA) * Math.pow(1.03, nM);
    }

    // 2) 쿨타임 보정: 허상룬 → baseCd × (0.96^n)
    function runeCooldown(skill, baseCd) {
      const tier = skillTierOf(skill);
      if (!tier) return baseCd;
      const nH = getRuneCountByKey('illusion', tier);
      return baseCd * Math.pow(0.96, nH);
    }

    // 3) 레벨 보정: 숙련(+n), 기교(+n)
    function runeLevelAdds(skill) {
      const tier = skillTierOf(skill);
      if (!tier) return { skillLvAdd: 0, enhLvAdd: 0 };
      const nS = getRuneCountByKey('training', tier);
      const nT = getRuneCountByKey('technique', tier);
      return { skillLvAdd: nS, enhLvAdd: nT };
    }

    function countSelectedRunes() {
      let sum = 0;
      Object.values(state.runes).forEach(row => {
        Object.values(row).forEach(v => sum += (Number(v) || 0));
      });
      return sum;
    }
    function updateRuneCountSummary() {
      const n = countSelectedRunes();
      const a = document.getElementById('runeCount'); if (a) a.textContent = n;
      const b = document.getElementById('runeCountLabel'); if (b) b.textContent = n;
    }
    // 룬 변경 시 살짝 디바운스해서 전체 재계산
    const onRunesChanged = (() => {
      let t = null;
      return () => {
        clearTimeout(t);
        t = setTimeout(() => {
          // 전체 합산/스킬 캐시/표시까지 한 번에 처리
          if (typeof recalcAndRenderPanel === 'function') {
            recalcAndRenderPanel();
          }
        }, 60);
      };
    })();

    state.options = state.options || {
      avatar: null,        // 'rare' | 'advanced'
      weaponImprint: null, // 'add5' | 'patkmatk5' | 'patkmatk3' | 'monster' | 'quest'
      timeWindow: null,    // '30s' | '1m' | '3m' | '5m' | '10m'
      monster: null,       // 'nugol' | 'blackdragon' | 'asmar_calix'
      difficulty: null     // 'hard' | 'normal' | 'easy' | 'nugol_room'
    };
    /* ▼ 드롭다운 value → 시트 '이름' 매핑 */
    const AVATAR_NAME = {
      rare: '레어 아바타',
      advanced: '상급 아바타',
      empty: '없음'
    };
    const IMPRINT_NAME = {
      add5: '추뎀 5% 무기압',
      patkmatk5: '물/마공 5% 무기압',
      patkmatk3: '물/마공 3% 무기압',
      monster: '몬스터 무기압',
      quest: '퀘스트 무기압',
      empty: '없음'
    };
    /* ▼ 드롭다운 value → 시트 '몬스터명' 매핑 */
    const MONSTER_NAME = {
      nugol: '거대누골',
      blackdragon: '흑룡',
      anton: '안톤',
      asmar_calix: '아스마르/칼릭스'
    };

    // ★ C) 효과적 스킬 레벨(레벨링 + 숙련룬 적용, 0레벨은 활성화 안 함)
    function effectiveSkillLevelForDamage(skill) {
      // 1) 기본 스킬 레벨
      let baseLv = Number(state.skillLv?.[skill.id] ?? 0);
      const kind = String(skill?.kind || '').trim();

      // 평타/연결평타는 기본 레벨이 없으면 1로 보정
      const isNormal = (kind === '평타' || kind === '연결평타' || kind.startsWith('평타'));
      if ((!Number.isFinite(baseLv) || baseLv <= 0) && isNormal) {
        baseLv = 1;
      }
      // 평타가 아니고, 유효 베이스레벨이 없으면 0 (기존 규칙 유지)
      if (!Number.isFinite(baseLv) || baseLv <= 0) {
        return 0;
      }

      // 2) 스킬렙제(레벨링 게이트) 결정: levelGate → band → 기존 helper 순
      const gate =
        Number(skill?.levelGate ?? 0) ||
        Number(skill?.band ?? 0) ||
        (skillTierOf ? (Number(skillTierOf(skill)) || 0) : 0);

      const lvlAddByLeveling = gate ? getLevelingCountByTier(gate) : 0;

      // 3) 숙련룬(+n)
      const { skillLvAdd } = runeLevelAdds ? runeLevelAdds(skill) : { skillLvAdd: 0 };

      // ★ 예외규칙: 스킬레벨 가산
      const excAdd = Number(__EXC?.addLv?.[skill.id] || 0);
      if (excAdd) baseLv = Math.max(0, baseLv + excAdd);

      // 4) 최종 유효 레벨(상한 없음, 1 이상으로 보정)
      const eff = baseLv + (lvlAddByLeveling || 0) + (skillLvAdd || 0);
      return Math.max(1, eff);
    }


    // ★ D) 최종 데미지: (선형 데미지 at 효과적 레벨) × (TP 배율) × (룬 배율)
    function calcSkillDamageWithTp(skill, baseTpLv) {
      // 1) 초 단위 쿨 계산 (★ 순서 중요)
      const cdBase = (typeof toSec === 'function') ? toSec(skill.cd) : Number(skill.cd || 0);

      // ★ (A) '쿨타임고정감소'(초) — 가장 먼저 적용
      const excCdFlat = Number(__EXC?.addCdFlat?.[skill.id] || 0);
      const cdAfterFlat = (cdBase > 0) ? Math.max(0, cdBase - excCdFlat) : 0;

      // ★ (B) 허상룬/룬 보정 — 고정감소 적용된 값에 대해 수행
      let cdFinal = (cdAfterFlat > 0) ? runeCooldown(skill, cdAfterFlat) : 0;

      // ★ (C) '쿨타임감소'(%) — 그 다음 곱
      const excCdPct = Number(__EXC?.addCdPct?.[skill.id] || 0);
      if (cdFinal > 0 && excCdPct) {
        cdFinal *= Math.max(0, 1 - excCdPct / 100);
      }

      // ★ (D) '쿨초확률'(%) — 기대값 근사
      const resetPct = Math.max(0, Math.min(100, Number(__EXC?.resetPct?.[skill.id] || 0)));
      if (cdFinal > 0 && resetPct) {
        cdFinal *= (1 - resetPct / 100);
      }

      // 최종 배수(원래 기본 쿨 대비)
      const cdMul = (cdBase > 0) ? (cdFinal / cdBase) : 1;

      // 2) 시전 프레임
      const castFrames = Number(skill.castFrames || 0);

      // 3) 유효 스킬 레벨
      let effLv = effectiveSkillLevelForDamage(skill);     // ← (A) let 으로 변경 (보정 위해)
      const kindNorm = String(skill?.kind || '스킬').trim();

      // ★ 옵션 B: 평타(또는 연결평타)는 레벨 미지정이어도 1레벨로 보정
      if (effLv === 0 && (kindNorm === '평타' || kindNorm === '연결평타' || kindNorm.startsWith('평타'))) {
        effLv = 1;
      }
      if (effLv === 0) {
        return {
          per: 0,
          flat: 0,
          lv: 0,
          tpLv: 0,
          tpIncPercent: 0,
          runeMul: 1,
          cdBase,
          cdFinal,
          cdMul,
          castFrames,
          dps: 0,            // ★ 조기 리턴에도 dps 명시
          uses: 0,           // ★ 시뮬 후 덮어씀
          kind: kindNorm,
        };
      }

      // 4) 선형 데미지 기반
      const base = calcSkillDamageLinear(skill, effLv); // {per, flat, lv}

      // 5) TP (TP 0이면 기교룬 무효 규칙 유지)

      // 기존 패턴 유지: 수동 TP는 0~5
      const tpBase = Math.max(0, Math.min(5, Number(state.skillTpLv?.[skill.id] ?? 0)));

      // 예외 규칙에서 온 tp레벨 보너스
      const tpExc = Number(__EXC?.addTp?.[skill.id] || 0);

      // ★ 보너스에 얹어주기 (수동 TP>0일 때만 룬/보너스 적용 규칙 유지)
      const tpBonus = (tpBase > 0) ? (getTpBonusFromSources(skill.id) + tpExc) : 0;

      // 최종 TP 0~7
      const tpLv = Math.max(0, Math.min(7, tpBase + tpBonus));

      const tpPct = tpIncreasePercent(Number(skill.tpCost || 0), tpLv);
      const tpMul = 1 + (tpPct / 100);

      // 6) 룬 배수
      const rMul = runeDamageMultiplier(skill);

      // 7) 최종 per/flat 먼저 산출
      let per = (base.per || 0) * tpMul * rMul;
      let flat = (base.flat || 0) * tpMul * rMul;

      // ★ 예외: 데미지증가(%) 적용 (여러 줄 합산 → 1 + 합계/100)
      const excDmgPct = Number(__EXC?.addDmgPct?.[skill.id] || 0);
      if (excDmgPct) {
        const m = 1 + excDmgPct / 100;
        per *= m;
        flat *= m;
      }

      // 8) 이제 dps 계산 (고뎀 제외, per만)
      const dps = cdFinal > 0 ? (per / cdFinal) : 0;

      // 9) 반환
      return {
        per,
        flat,
        lv: base.lv,
        tpLv,
        tpIncPercent: tpPct,
        runeMul: rMul,
        cdBase,
        cdFinal,
        cdMul,
        castFrames,
        dps,            // ★ 여기서 정의된 dps 사용
        uses: 0,        // ★ 시뮬 후 덮어씀
        kind: kindNorm,
      };
    }


    /* ===== Uses 시뮬레이터(프레임 단위) ===== */
    (function () {
      const FPS = 60;

      function currentCharKey() {
        const k =
          (typeof currentSkillOwnerKey === 'function' ? currentSkillOwnerKey() : null) ??
          [state.currentCharacter?.jobGroupLabel, state.currentCharacter?.name].filter(Boolean).join('');
        return String(k || '').replace(/\s+/g, '');
      }

      // 내부: 대상 스킬 목록 구성(요구사항 8 반영)
      function collectSimCandidates() {
        const key = currentCharKey();
        if (!key || !(ST2?.rows?.length)) return { skills: [], awks: [], normals: [], link: null };

        const rowsAll = ST2.rows.filter(s => s.who === key);

        // 현재 사용 레벨(>=1)인 스킬/각성기
        const isOn = (id) => Number(state.skillLv?.[id] ?? 0) >= 1;

        const skills = rowsAll.filter(s => (s.kind === '스킬') && isOn(s.id));
        const awks = rowsAll.filter(s => (s.kind === '각성기') && isOn(s.id));

        // 평타/연결평타(show와 무관)
        const normals = rowsAll.filter(s => s.kind === '평타');
        const link = rowsAll.find(s => s.kind === '연결평타') || null;

        return { skills, awks, normals, link };
      }

      // 내부: 스킬 엔트리로 변환(데미지 캐시 보강 + cd/캐스트 프레임 산출)
      function toEntry(skill) {
        const tp = Math.max(0, Math.min(5, Number(state.skillTpLv?.[skill.id] ?? 0)));
        const d = calcSkillDamageWithTp(skill, tp); // per, flat, cdFinal(초), castFrames 등
        // state.skillDmg에 병합(uses 초기화/유지)
        const prev = state.skillDmg?.[skill.id] || {};
        state.skillDmg[skill.id] = { ...prev, ...d, uses: Number(prev.uses || 0) };

        const cdF = Math.max(0, Math.round(Number(d.cdFinal || 0) * FPS)); // 쿨(프레임)
        const castF = Math.max(0, Math.round(Number(skill.castFrames || 0))); // 시전(프레임)

        return {
          id: skill.id,
          name: skill.name,
          kind: skill.kind || '스킬',
          per: Number(d.per || 0),
          cdF,
          castF,
          nextReady: 0
        };
      }

      // 내부: DPS 계산(per / cd[초]) — 평타/연결평타에는 사용 안함
      const dps = (e) => {
        const cdSec = e.cdF / FPS;
        return (cdSec > 0) ? (e.per / cdSec) : 0;
      };

      function getTimeWindowSec() {
        const el = document.getElementById('selTime');
        const v = el?.value || '';
        switch (v) {
          case '30s': return 30;
          case '1m': return 60;
          case '3m': return 180;
          case '5m': return 300;
          case '10m': return 600;
          default: return 60; // 선택 전/이상값 → 60초
        }
      }

      document.getElementById('selTime')?.addEventListener('change', () => {
        queueMicrotask(() => window.simulateSkillUsage?.(getTimeWindowSec()));
      });

      // 메인: 60초(=3600프레임) 시뮬
      function simulateSkillUsage(totalSec = 60) {
        const totalF = Math.max(1, Math.floor(totalSec * FPS));

        const { skills, awks, normals, link } = collectSimCandidates();
        let S = skills.map(toEntry);
        let A = awks.map(toEntry);
        let N = normals.map(toEntry);
        let L = link ? toEntry(link) : null;

        // uses 초기화
        for (const e of [...S, ...A, ...N, ...(L ? [L] : [])]) {
          state.skillDmg[e.id].uses = 0;
        }

        const log = [];
        let now = 0;              // 현재 프레임
        let lastKind = null;      // 직전 액션 kind (평타 연속 금지 체크용)

        // nextReady를 tStart + cdF 로 설정하기 위해 start 프레임 별도 변수 사용
        const use = (entry) => {
          const t0 = now; // 시작 프레임
          const t1 = t0 + entry.castF;
          if (t1 > totalF) return false; // 남은 시간 부족 → 시전 불가

          // 로그 축적(자동출력 금지 — 배열에만 저장)
          log.push({
            fStart: t0, fEnd: t1, kind: entry.kind, id: entry.id, name: entry.name
          });

          // uses 증가
          state.skillDmg[entry.id].uses = (state.skillDmg[entry.id].uses || 0) + 1;

          // 쿨다운: “사용 즉시 시작, 캐스팅 중에도 흐름” → nextReady = t0 + cdF
          entry.nextReady = Math.max(entry.nextReady, t0 + entry.cdF);

          // 시간 진행
          now = t1;
          lastKind = entry.kind;
          return true;
        };

        // 다음 ‘비-평타(스킬/각성기)’ 준비까지 남은 프레임 R
        const nextReadyNonNormals = () => {
          const arr = [...S, ...A].map(e => e.nextReady).filter(v => Number.isFinite(v));
          if (!arr.length) return Number.POSITIVE_INFINITY;
          return Math.max(0, Math.min(...arr) - now);
        };

        while (now < totalF) {
          // 1) 스킬(준비됨) 중 DPS 최고
          const readyS = S.filter(e => now >= e.nextReady);
          if (readyS.length) {
            // DPS 최대 선택
            let pick = readyS.reduce((a, b) => (dps(a) >= dps(b) ? a : b));
            if (!use(pick)) break;
            continue;
          }

          // 2) 각성기(준비됨) 중 DPS 최고
          const readyA = A.filter(e => now >= e.nextReady);
          if (readyA.length) {
            let pick = readyA.reduce((a, b) => (dps(a) >= dps(b) ? a : b));
            if (!use(pick)) break;
            continue;
          }

          // 3) 둘 다 쿨이면 평타/연결평타
          let R = nextReadyNonNormals(); // 다음 비-평타까지 남은 프레임
          if (R <= 0) {
            // 이론상 0이하가 나올 수 있으니 한 프레임 진행(혹은 준비 재평가)
            now += 1;
            continue;
          }

          // 평타 연속 금지
          // 3) 둘 다 쿨이면 평타/연결평타


          // ⛔ 규칙 보강: 직전이 '평타'였다면, 평타/연결평타는 전부 금지.
          //    오로지 스킬/각성기가 준비될 때까지 '대기(프레임 점프)'만 허용.
          const canUseAnyNormal = (lastKind !== '평타');
          if (!canUseAnyNormal) {
            if (Number.isFinite(R) && R > 0) {
              now = Math.min(totalF, now + R);
            } else {
              now = Math.min(totalF, now + 1);
            }
            continue;
          }

          // (여기부터는 직전이 평타가 아닐 때만 실행됨)
          // 평타 후보: castF ≤ R, R에 더 근접(|R - castF| 최소), 동률이면 per 큰 것
          let pickN = null;
          if (N.length) {
            const candidates = N
              .filter(e => e.castF > 0 && e.castF <= R)
              .sort((a, b) => {
                const da = Math.abs(R - a.castF);
                const db = Math.abs(R - b.castF);
                if (da !== db) return da - db;           // R 근접 우선
                if (a.per !== b.per) return b.per - a.per; // 동률이면 per 큰 것
                return 0;
              });
            pickN = candidates[0] || null;
          }

          if (pickN) {                 // 평타 1회만 허용 (uses 증가 및 lastKind='평타'로 설정됨)
            if (!use(pickN)) break;
            continue;
          }

          // 평타가 안 맞으면 '연결평타' 고려 (연속 허용)
          //  ⚠️ 주의: 위에서 canUseAnyNormal=false(=직전 평타)였으면 이 블록까지 오지 않음
          if (L && L.castF > 0) {
            if (!use(L)) break;
            continue;
          }

          // 평타/연결평타 둘 다 못 쓰면, 다음 스킬/각성기 준비 시점까지 점프
          if (Number.isFinite(R) && R > 0) {
            now = Math.min(totalF, now + R);
          } else {
            now = Math.min(totalF, now + 1);
          }

        }

        // 로그 저장(자동 출력 X)
        state.skillSimLog = log;
        return log;
      }

      // 외부 노출: 수동 출력용
      window.printSkillSimLog = function () {
        const L = state?.skillSimLog || [];
        if (!L.length) { console.log('[SIM] 로그 없음'); return; }
        for (const row of L) {
          console.log(`[f=${row.fStart}~${row.fEnd}] 사용: [${row.kind}] ${row.name} (${row.id})`);
        }
        // 마지막에 uses 요약
        const summary = {};
        for (const [id, v] of Object.entries(state.skillDmg || {})) {
          if (v?.uses) summary[id] = v.uses;
        }
        console.log('[SIM] uses:', summary);
      };

      // 외부 노출: 실행 함수
      window.simulateSkillUsage = simulateSkillUsage;
      (() => {
        const el = document.getElementById('selTime');
        if (el && !el.value) el.value = '1m';  // 혹시 공백이면 1분으로 보정
        window.simulateSkillUsage?.(getTimeWindowSec());
      })();
    })();


    let __monsterApplyingDefault = false;
    // 드롭다운 변경 시 호출
    async function onMonsterChange(selectedName) {
      await ensureMonsterLoaded();

      // 1) 선택값이 비었으면 (초기 상태 등) 기본값으로 보정
      let name = selectedName || state?.options?.monster || '거대누골';

      // 2) 드롭다운(UI)과 값 동기화 (옵션 목록이 이미 채워졌다고 가정)
      if (!selectedName && !__monsterApplyingDefault) {
        __monsterApplyingDefault = true;
        const sel = document.getElementById('selMonster');
        if (sel) {
          // value 매칭 → 실패 시 텍스트로 매칭
          let v = name;
          const byText = [...sel.options].find(o => o.textContent.trim() === name);
          if (byText) v = byText.value;

          // 값만 세팅 (여기서 change를 다시 쏘면 재귀되므로 '호출 없이' 동기화)
          if (sel.value !== v) sel.value = v;
        }
        __monsterApplyingDefault = false;
      }

      // 3) 상태 반영
      state.options = state.options || {};
      state.options.monster = name;

      // 4) DB에서 행 찾기
      const row = DBMonster.rows.find(r => String(r['몬스터명']).trim() === name);

      if (row) {
        state.monster = {
          level: Number(row['몬스터레벨']) || 0,
          defRate: Number(row['방어율']) || 0,
          fire: Number(row['화속성저항']) || 0,
          water: Number(row['수속성저항']) || 0,
          light: Number(row['명속성저항']) || 0,
          dark: Number(row['암속성저항']) || 0,
        };
      } else {
        state.monster = { level: 0, defRate: 0, fire: 0, water: 0, light: 0, dark: 0 };
      }
    }

    document.getElementById('selMonster').value

    /* 선택된 시트 아이템(스탯 묶음) 보관 슬롯 */
    state.options.avatarEnh = state.options.avatarEnh || null; // {name,type,img,stats...}
    state.options.imprintEnh = state.options.imprintEnh || null;
    /* 몬스터 선택 결과 저장 슬롯(정보/저항 등) */
    state.monster = state.monster || null; // { name, info, stats, raw }
    // 슬롯 키 매핑
    const SLOT_MAP = {    //슬롯 약어, 사용할땐 SLOT_MAP["L1"]; 처럼 씀
      L1: 'headshoulder', L2: 'top', L3: 'bottom', L4: 'belt', L5: 'shoes',
      R1: 'weapon', R2: 'bracelet', R3: 'necklace', R4: 'ring', R5: 'support',
      C1: 'aura', C2: 'title', C3: 'creature', C4: 'artifact'
    };
    window.SLOT_MAP = SLOT_MAP;   // 브라우저 전역 객체, SLOT_MAP을 전역 변수로 등록 = 다른 스크립트 파일이나 브라우저 콘솔에서도 접근 가능

    const ALLOWED_WEAPON_TYPES = {
      slayer: ['소검', '도', '둔기', '대검', '광검'],
      gunner: ['리볼버', '자동권총', '머스켓', '핸드캐넌', '보우건'],
      fighter: ['너클', '건틀릿', '클로', '권투글러브', '통파'],
      priest: ['십자가', '염주', '토템', '낫', '배틀액스'],
      warrior: ['락소드', '윙블레이드'],
      mage: ['스태프', '로드', '봉', '창', '빗자루'],
      spear: ['미늘창', '투창'],
      thief: ['단검', '쌍검', '차크라웨펀']
    };
    // DB
    const DB = { itemsBySlot: {}, loaded: {}, chars: { loaded: false, groups: [] } };
    const DBEnh = { loaded: false, list: [], byType: {} };
    /* ===== 유틸 ===== */
    const num = v => (v === '' || v == null ? 0 : Number(v));
    const pct = v => { if (v === '' || v == null) return 0; const s = String(v).trim().replace('%', ''); const n = Number(s); return isNaN(n) ? 0 : n / 100; };
    const list = v => (v ? String(v).replaceAll(';', ',').split(',').map(s => s.trim()).filter(Boolean) : []);
    const normalizeJobGroup = (s) => {
      s = (s || '').toLowerCase();
      if (['남귀검사', '여귀검사', '귀검사', 'slayer'].some(k => s.includes(k))) return 'slayer';
      if (['마법사', '여마법사', '남마법사', 'mage'].some(k => s.includes(k))) return 'mage';
      if (['남거너', '여거너'].some(k => s.includes(k))) return 'gunner';
      if (['격투가', '남격투가', '여격투가'].some(k => s.includes(k))) return 'fighter';
      if (['프리스트', '여프리스트', '남프리스트'].some(k => s.includes(k))) return 'priest';
      if (['워리어'].some(k => s.includes(k))) return 'warrior';
      if (['마창사'].some(k => s.includes(k))) return 'spear';
      if (['도적'].some(k => s.includes(k))) return 'thief';
      return s || 'slayer';
    };
    const normalizePower = (s) => {     //물 을 phys 로 변경, 마 를 mag 로 변경
      s = (s || '').toLowerCase();
      if (['물', 'phys', 'str', 'physical'].some(k => s.includes(k))) return 'phys';
      if (['마', 'mag', 'int', 'magic', '마법'].some(k => s.includes(k))) return 'mag';
      return null;
    };
    const powerLabel = (p) => p === 'phys' ? '물리' : p === 'mag' ? '마법' : '물리/마법';   // phys 를 물리 로 변경, mag를 마법, ?(이면), :(아니면) 따라서 p가 phys 이면 물리, 아니면 p가 mag 이면 마법 아니면 물리/마법

    const PLACEHOLDER_IMG = 'data:image/svg+xml;utf8,' + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='10' fill='#0c0a08'/><path d='M10 48L26 30l10 12 8-8 10 14' stroke='#9cc7ff' stroke-width='4' fill='none'/></svg>");
    function cleanUrl(u) { if (!u) return ''; return String(u).replace(/^\s+|\s+$/g, '').replace(/^["']|["']$/g, '').replace(/\\/g, '/'); }

    /* ===== 행 → 아이템 매핑 ===== */
    function mapRowToItem(r) {
      const pick = (...ks) => { for (const k of ks) { if (r[k] != null && String(r[k]).trim() !== '') return r[k]; } return ''; };  // 이건 그냥 헬퍼 : 처음으로 값이 제대로 있는 컬럼 반환
      const skill_levels = [];    //레벨링(10), 레벨렝(15) 같은 컬럼 있으면 숫자로 변환하여 누적
      [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 65, 70, 75, 80].forEach(lv => {
        const v = Number(pick(`레벨링(${lv})`));
        if (!isNaN(v) && v !== 0) skill_levels.push({ skill_id: `LV${lv}`, delta: v });
      });
      const jgs = list(pick('직업군', 'job_groups')).map(normalizeJobGroup);    // 직업군 텍스트를 배열화 하고 표준코드로 통일 (귀검사, 남거너 등)
      return {        // 최종 아이템 객체 반환
        id: String(r.id || r.ID || Date.now().toString(36) + Math.random().toString(36).slice(2)),
        slot: 'unknown',
        name: String(pick('이름', 'name')),
        img: cleanUrl(pick('이미지', 'img')) || PLACEHOLDER_IMG,
        job_groups: jgs,
        type: String(pick('종류', 'type')),
        rarity: r.rarity || r.등급 || 'epic',
        rarity_kr: pick('등급') || undefined,
        level: num(pick('렙제', '레벨', 'level')) || 65,
        level_text: (() => { const v = pick('렙제', '레벨', 'level'); return (v === undefined || v === null || String(v).trim() === '') ? '' : String(v).trim(); })(),
        stats: {
          phys_atk: num(pick('물리 데미지', '물리데미지', 'phys_atk')),
          mag_atk: num(pick('마법 데미지', '마법데미지', 'mag_atk')),
          str: num(pick('힘', 'str')),
          int: num(pick('지능', 'int')),
          acc: num(pick('적중', 'acc')),
          phys_crit: num(pick('물리 크리티컬', '물리크리티컬', 'phys_crit')),
          mag_crit: num(pick('마법 크리티컬', '마법크리티컬', 'mag_crit')),
          phys_crit_rate: pct(pick('물리 크리티컬(%)', 'phys_crit_rate%')),
          mag_crit_rate: pct(pick('마법 크리티컬(%)', 'mag_crit_rate%')),
          add_damage: pct(pick('추가데미지(%)', 'add_damage%')),
          counter_add_damage: pct(pick('카운터뎀증(%)', 'counter_add_damage%')) || pct(pick('카운터추뎀(%)')),
          str_pct: pct(pick('힘(%)', 'str_pct%')),
          int_pct: pct(pick('지능(%)', 'int_pct%')),
          damage_inc: pct(pick('뎀증(%)', 'damage_inc%')),
          counter_damage_inc: pct(pick('카운터뎀증(%)', 'counter_damage_inc%')),
          crit_damage_inc: pct(pick('크증뎀(%)', 'crit_damage_inc%')),
          phys_atk_pct: pct(pick('물리 공격력(%)', '물리공격력(%)', 'phys_atk_pct%')),
          mag_atk_pct: pct(pick('마법 공격력(%)', '마법공격력(%)', 'mag_atk_pct%')),
          skill_atk_inc: pct(pick('스증(%)', 'skill_atk_inc%')),
          elem: { fire: num(pick('화', 'elem_fire')), water: num(pick('수', 'elem_water')), light: num(pick('명', 'elem_light')), dark: num(pick('암', 'elem_dark')), all: 0 },
          elem_add_damage: {
            fire: pct(pick('화속추', 'elem_add_fire%')),
            water: pct(pick('수속추', 'elem_add_water%')),
            light: pct(pick('명속추', 'elem_add_light%')),
            dark: pct(pick('암속추', 'elem_add_dark%'))
          },
          speed: { attack: pct(pick('공속', 'speed_attack%')), move: pct(pick('이속', 'speed_move%')), cast: pct(pick('캐속', 'speed_cast%')) },
          cdr: pct(pick('쿨감')),
          dot_add: { poison: pct(pick('중독추뎀')), bleed: pct(pick('출혈추뎀')), burn: pct(pick('화상추뎀')), shock: pct(pick('감전추뎀')) },
          dot_inc: { poison: pct(pick('중독뎀증')), bleed: pct(pick('출혈뎀증')), burn: pct(pick('화상뎀증')), shock: pct(pick('감전뎀증')) },
          other: { def_break_inc: pct(pick('방깎뎀증')), enchant_bleed: num(pick('인챈출혈')) }
        },
        effects: [],
        notes: [pick('설명', 'notes1'), pick('설명2', 'notes2'), pick('설명3', 'notes3')].filter(Boolean),
        skill_levels,
        raw: r
      };
    }

    /* ===== 강화 행 매핑 (이미지/태그/단계 지원) ===== */
    function mapRowToEnhance(r) {
      const get = (k) => r[k] ?? r[k?.toLowerCase()] ?? '';
      const num = (v) => (v === '' || v == null ? 0 : Number(v));
      const pct = (v) => { if (v === '' || v == null) return 0; const s = String(v).trim().replace('%', ''); const n = Number(s); return isNaN(n) ? 0 : n / 100; };
      const name = String(get('이름') || get('강화명') || get('표시명') || '').trim();
      const type = String(get('종류') || '').trim(); // ex) 붉은빛엠블렘 / 플래티넘엠블렘 / 무기강화 ...
      const img = cleanUrl(get('이미지')) || PLACEHOLDER_IMG;
      const tag = String(get('렙제') || '').trim();        // 플래티넘 분류용(화속성/수속성/..)
      const lvlMatch = name.match(/(\d+)\s*단계/);
      const level_num = lvlMatch ? parseInt(lvlMatch[1], 10) : null;

      const stats = {
        phys_atk: num(get('물리 데미지')) || num(get('물리데미지')),
        mag_atk: num(get('마법 데미지')) || num(get('마법데미지')),
        str: num(get('힘')), int: num(get('지능')),
        phys_crit: num(get('물리 크리티컬')) || num(get('물리크리티컬')),
        mag_crit: num(get('마법 크리티컬')) || num(get('마법크리티컬')),
        phys_crit_rate: pct(get('물리 크리티컬(%)')),
        mag_crit_rate: pct(get('마법 크리티컬(%)')),
        add_damage: pct(get('추가데미지(%)')),
        str_pct: pct(get('힘(%)')), int_pct: pct(get('지능(%)')),
        damage_inc: pct(get('뎀증(%)')),
        crit_damage_inc: pct(get('크증뎀(%)')),
        phys_atk_pct: pct(get('물리 공격력(%)')) || pct(get('물리공격력(%)')),
        mag_atk_pct: pct(get('마법 공격력(%)')) || pct(get('마법공격력(%)')),
        skill_atk_inc: pct(get('스증(%)')),
        elem: { fire: num(get('화')), water: num(get('수')), light: num(get('명')), dark: num(get('암')), all: 0 },
        cdr: pct(get('쿨감')),
        speed: { attack: pct(get('공속')), move: pct(get('이속')), cast: pct(get('캐속')) },
        other: { def_break_inc: pct(get('방깎뎀증')) }
      };
      return { name, type, img, tag, level_num, stats };
    }

    (function () {
      function _getTimeWindowSec() {
        // 드롭다운(#selTime)의 값: "30s" | "1m" | "3m" | "5m" | "10m"
        const el = document.getElementById('selTime');
        const v = (el && el.value) ? el.value : '1m'; // 기본 1분
        const n = Number(v.slice(0, -1));             // 앞의 숫자
        return v.endsWith('s') ? n : n * 60;           // s→초, m→분*60
      }

      // ★ 전역에 보증 (module 스코프/중복 로드 대비)
      if (!window.getTimeWindowSec) window.getTimeWindowSec = _getTimeWindowSec;
    })();

    /* ===== 시트 로더 ===== */
    async function loadSheet(slotKey) {
      if (DB.loaded[slotKey]) return;

      const token = await waitForIdToken();
      const r = await fetch(window.WEBAPP_URL + '?type=' + slotKey, {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error(`${slotKey}_fetch_failed`);
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error(`bad_${slotKey}_payload`);

      // rows(시트 원문 행 객체) → 프론트 내부 아이템 구조로 매핑
      const items = data.rows.map(mapRowToItem).map(it => ({ ...it, slot: slotKey }));
      DB.itemsBySlot[slotKey] = items;
      DB.loaded[slotKey] = true;
      console.log(`[Sheets->API] ${slotKey} loaded:`, items.length);
    }
    const __slotState = {};  // 전역에 선언

    async function ensureLoaded(slotKey) {
      const st = (__slotState[slotKey] ||= { loaded: false, inflight: null });

      if (st.loaded) return;             // 이미 끝났으면 바로 리턴
      if (st.inflight) return st.inflight; // 진행 중이면 같은 Promise 반환

      st.inflight = (async () => {
        await loadSheet(slotKey);
        st.loaded = true;
        st.inflight = null;
      })();

      return st.inflight;
    }


    /* 강화/엠블렘 시트 로더 */
    // 강화/엠블렘 시트 로더 (백엔드 JSON 버전)
    async function ensureEnhLoaded() {
      if (DBEnh.loaded) return;

      const token = await waitForIdToken();
      const r = await fetch(window.WEBAPP_URL + '?type=enhance', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('enhance_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_enhance_payload');

      const rows = data.rows.map(mapRowToEnhance).filter(x => (x.name && x.type));
      DBEnh.list = rows;
      DBEnh.byType = rows.reduce((acc, x) => { (acc[x.type] ||= []).push(x); return acc; }, {});
      DBEnh.loaded = true;
      console.log('[Enhance->API] loaded:', rows.length);

      // ▼ 성안의 봉인: 기본값 주입 (이미 선택돼 있으면 건너뜀)
      try {
        const mainList = DBEnh.byType?.['주요 옵션'] || [];
        const subList = DBEnh.byType?.['추가 옵션'] || [];
        if (!state.castleSeal) state.castleSeal = { main: null, sub: null };
        if (!state.castleSeal.main && mainList.length) {
          const m = mainList.find(x => x.name === '힘,지능 +170') || mainList[0];
          state.castleSeal.main = { name: m.name, stats: m.stats, raw: m.raw || m };
        }
        if (!state.castleSeal.sub && subList.length) {
          const s = subList.find(x => x.name === '힘,지능 +224') || subList[0];
          state.castleSeal.sub = { name: s.name, stats: s.stats, raw: s.raw || s };
        }
      } catch (e) { console.warn('[SEAL:init@ensureEnhLoaded] skip:', e); }
    }



    //몬스터 시트 로더
    let DBMonster = { loaded: false, rows: [] };
    async function ensureMonsterLoaded() {
      if (DBMonster.loaded) return;
      const token = await waitForIdToken(); // 이미 네 코드에 있음 (다른 시트 로더에서 사용)
      const r = await fetch(window.WEBAPP_URL + '?type=monster', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('monster_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_monster_payload');
      // 백엔드가 "헤더명을 키로 한 객체"를 그대로 내려주므로 추가 매핑 불필요
      DBMonster.rows = data.rows;
      DBMonster.loaded = true;
      console.log('[Monster->API] loaded:', DBMonster.rows.length);
    }

    // ===== 세트 시트 로더/캐시 =====
    const DBSet = { loaded: false, list: [], byType: {} };

    // 세트 시트는 '강화' 매핑과 컬럼 구성이 동일하다고 가정:
    // => 파싱 로직을 재사용합니다.
    function mapRowToSet(r) {
      // 기본 파싱
      const base = mapRowToEnhance(r);

      // ▶ 세트 전용: type 강제 보정 (종류가 비어 있거나 헤더명이 다를 때 대비)
      const get = (k) => r[k] ?? r[k?.toLowerCase()] ?? '';
      const rawType =
        (get('종류') || get('세트') || get('분류') || get('타입') || get('유형') ||
          get('type') || get('Type') || get('이름') || '').toString().trim();

      // 이름만 있고 종류가 비었을 가능성까지 커버
      base.type = rawType;

      return base;
    }

    async function ensureSetLoaded() {
      if (DBSet.loaded) return;
      const token = await waitForIdToken();
      const r = await fetch(window.WEBAPP_URL + '?type=set', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      if (!r.ok) throw new Error('set_fetch_failed');
      const data = await r.json();
      if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_set_payload');

      const rows = data.rows.map(mapRowToSet).filter(x => (x?.name && x?.type));
      DBSet.list = rows;
      DBSet.byType = rows.reduce((acc, x) => {
        const k = String(x.type || '').trim();
        (acc[k] ||= []).push(x);
        return acc;
      }, {});
      DBSet.loaded = true;
      console.log('[Set->API] loaded:', rows.length);
    }

    // ===== 예외규칙 로더/캐시 =====
    const DBException = { loaded: false, rows: [], byItem: {}, skillIdByName: {} };

    function normalizeType(s) {
      const t = String(s || '').trim().toLowerCase();
      // 표의 '유형' 값 정규화: 스킬레벨 / tp레벨 / 데미지증가 / 쿨타임감소
      if (t.includes('tp')) return 'tp레벨';
      // ★ 먼저 고정감소부터 캐치 (쿨/고정/감소 키워드)
      if ((t.includes('쿨') || t.includes('cool')) && t.includes('고정') && (t.includes('감소') || t.includes('down')))
        return '쿨타임고정감소';
      if (t.includes('버프') && t.includes('레벨')) return '버프레벨';
      if (t.includes('cool') || t.includes('쿨')) return '쿨타임감소';
      if (t.includes('데미') || t === 'dmg' || t === 'damage') return '데미지증가';
      if (t.includes('레벨')) return '스킬레벨';
      // ★ 추가: 쿨초확률
      if (t.includes('리셋') || t.includes('초기화') || t.includes('쿨초')) return '쿨초확률';
      return t;
    }
    function mapRowToException(r) {
      return {
        type: normalizeType(r['유형']),
        item: String(r['아이템명'] || '').trim(),
        skillName: String(r['적용스킬명'] || '').trim(),
        value: toNum(r['옵션수치'])
      };
    }

    async function ensureExceptionLoaded() {
      if (DBException.loaded) return;
      const token = await waitForIdToken();
      if (!token) { console.warn('[EXC] skip: no idToken yet'); return; }

      const r = await fetch(WEBAPP_URL + '?type=exception', {
        method: 'POST',
        mode: 'cors',
        cache: 'no-store',
        headers: { 'Content-Type': 'text/plain' },
        body: token
      });
      const js = await r.json();
      if (!js?.ok) { console.warn('[EXC] load failed:', js); DBException.loaded = true; return; }

      DBException.rows = (js.rows || []).map(mapRowToException);
      DBException.byItem = {};
      DBException.rows.forEach(row => {
        const key = row.item; if (!key) return;
        (DBException.byItem[key] ||= []).push(row);
      });
      DBException.skillIdByName = {};
      DBException.loaded = true;
      console.log('[EXC] rows loaded =', DBException.rows.length);
      console.log('[EXC] sample rows =',
        DBException.rows.slice(0, 10).map(r => `${r.item} | ${r.type} | ${r.skillName} : ${r.value}`));
    }

    // 스킬 시트(ST2.rows)가 준비된 뒤, 스킬명 → id 매핑 구성
    function refreshExceptionSkillIdMap() {
      if (!ST2?.loaded || !(ST2.rows?.length)) return;
      DBException.skillIdByName = {};
      ST2.rows.forEach(s => {
        const name = String(s?.name || '').trim();
        if (!name) return;
        DBException.skillIdByName[name] = s.id;  // 이름이 유일하다는 가정 (동명이인 존재시 우선 일치 첫 항목)
      });
    }

    // 현재 착용 아이템명 배열
    function equippedItemNames() {
      return Object.values(state.selections || {}).map(it => String(it?.name || '').trim()).filter(Boolean);
    }

    // 활성 예외효과 집계(스킬ID 키 기준)
    function collectActiveExceptionMaps() {
      const items = equippedItemNames();  // 착용 중 아이템 이름 배열
      const addLv = {};       // {skillId: +레벨}
      const addTp = {};       // {skillId: +tp레벨}
      const addDmgPct = {};   // {skillId: +데미지증가%}
      const addCdPct = {};    // {skillId: +쿨감%}  // 감소율(%) 그대로 저장
      const resetPct = {};    // 쿨초
      // ★ 추가: 버프레벨 (버프 "이름" 기준)
      const buffLvByName = {};  // {'버프명': +레벨}
      // ★ 추가: 고정 쿨감(초)
      const addCdFlat = {};   // { skillId: secondsToReduce }

      // 이름 정규화(공백/제로폭 제거 정도만)
      const normName = s => String(s ?? '')
        .normalize('NFC')
        .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
        .replace(/\s+/g, '');

      for (const nm of items) {
        const list = DBException.byItem[nm] || [];
        for (const r of list) {
          // 1) '버프레벨'은 스킬ID 없이 "버프 이름"으로 합산
          if (r.type === '버프레벨') {
            const key = normName(r.skillName);
            if (key) buffLvByName[key] = (buffLvByName[key] || 0) + Number(r.value || 0);
            continue; // ★ 이미 처리했으니 다음 규칙으로
          }
          const id = DBException.skillIdByName[r.skillName];
          if (!id) continue;
          switch (r.type) {
            case '스킬레벨':
              addLv[id] = (addLv[id] || 0) + r.value;
              break;
            case 'tp레벨':
              addTp[id] = (addTp[id] || 0) + r.value;
              break;
            case '데미지증가':
              addDmgPct[id] = (addDmgPct[id] || 0) + r.value;
              break;
            case '쿨타임감소':
              addCdPct[id] = (addCdPct[id] || 0) + r.value;
              break;
            // ★ 추가: 쿨초확률(%) 합산
            case '쿨초확률': resetPct[id] = (resetPct[id] || 0) + r.value; break;
            // ★ 신규: 쿨타임고정감소(초)
            case '쿨타임고정감소': addCdFlat[id] = (addCdFlat[id] || 0) + Number(r.value || 0); break;
          }
        }
      }
      console.log('[EXC] equipped items =', equippedItemNames());
      console.log('[EXC] addLv:', addLv, 'addTp:', addTp, 'addDmgPct:', addDmgPct, 'addCdPct:', addCdPct);
      console.log('[EXC] buffLvByName:', buffLvByName);   // ★ 버프레벨 핵심
      return { addLv, addTp, addDmgPct, addCdPct, resetPct, buffLvByName, addCdFlat };
    }

    // 전역 보관(프레임 계산/데미지 캐시에 활용)
    let __EXC = { addLv: {}, addTp: {}, addDmgPct: {}, addCdPct: {}, resetPct: {}, buffLvByName: {}, addCdFlat: {} };
    function refreshActiveExceptions() {
      __EXC = collectActiveExceptionMaps();
    }

    /* ===== 성안의 봉인 ===== */
    const $sealModal = document.getElementById('castleSealModal');
    const $sealMainList = document.getElementById('sealMainList');
    const $sealSubList = document.getElementById('sealSubList');
    let __sealPick = { main: null, sub: null };

    function showSealModal(on) {
      if (!$sealModal) return;
      if (on) { $sealModal.classList.add('show'); $sealModal.setAttribute('aria-hidden', 'false'); }
      else { $sealModal.classList.remove('show'); $sealModal.setAttribute('aria-hidden', 'true'); }
    }
    $sealModal?.addEventListener('click', (e) => {
      if (e.target.dataset.close != null || e.target.classList.contains('backdrop')) showSealModal(false);
    });

    document.getElementById('btnCastleSeal')?.addEventListener('click', openCastleSealModal);
    document.getElementById('sealCommit')?.addEventListener('click', commitCastleSealSelection);

    async function openCastleSealModal() {
      // 강화/마봉/마부 시트 로드(연마에서 쓰던 캐시 재사용)
      if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

      // 시트에서 종류별로 분리
      const mainList = (DBEnh?.byType?.['주요 옵션'] || (DBEnh?.list || []).filter(o => (o?.type || '') === '주요 옵션'));
      const subList = (DBEnh?.byType?.['추가 옵션'] || (DBEnh?.list || []).filter(o => (o?.type || '') === '추가 옵션'));

      // 현재 선택 복구
      __sealPick = {
        main: state.castleSeal?.main || null,
        sub: state.castleSeal?.sub || null
      };

      fillSealList($sealMainList, mainList, 'main');
      fillSealList($sealSubList, subList, 'sub');

      showSealModal(true);
    }

    function fillSealList(host, list, which) {
      host.innerHTML = '';
      list.forEach(row => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'opt-btnetc';
        b.innerHTML = `
      <div class="name">${(row.name || '(이름없음)').replace(/\n/g, '<br>')}</div>
      ${row.uiText ? `<div class="desc">${row.uiText}</div>` : ''}`;
        if (__sealPick[which]?.name === row.name) b.classList.add('active');
        b.addEventListener('click', () => {
          __sealPick[which] = row;
          host.querySelectorAll('.opt-btnetc').forEach(x => x.classList.remove('active'));
          b.classList.add('active');
        });
        host.appendChild(b);
      });
    }

    function commitCastleSealSelection() {
      // state에 저장(합산은 sumSelections에서 addStats 규칙으로 더함)
      state.castleSeal = {
        main: __sealPick.main ? { name: __sealPick.main.name, stats: __sealPick.main.stats, raw: __sealPick.main.raw } : null,
        sub: __sealPick.sub ? { name: __sealPick.sub.name, stats: __sealPick.sub.stats, raw: __sealPick.sub.raw } : null
      };
      showSealModal(false);
      if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
    }


    /* ===== 룬 각인 드롭다운(시트 연동) ===== */

    // 시트에서 '룬각인'만 추리기 (byType 우선, 없으면 filter)
    function getRuneEngraveRows() {
      const base = (DBEnh?.byType?.['룬각인']) || (DBEnh?.list || []).filter(x => x.type === '룬각인');
      return base || [];
    }

    // 이름 목록(중복 제거, “시트 순서 유지”)
    async function buildRuneEngraveNameOptions() {
      await ensureEnhLoaded();
      const rows = getRuneEngraveRows();
      const seen = new Set(); const names = [];
      rows.forEach(r => { const k = (r.name || '').trim(); if (k && !seen.has(k)) { seen.add(k); names.push(k); } });
      const sel1 = document.getElementById('selRuneEngrave');
      if (!sel1) return;
      sel1.innerHTML = `<option value="" selected disabled>룬 각인 설정</option>`;
      names.forEach(n => {
        const op = document.createElement('option'); op.value = n; op.textContent = n; sel1.appendChild(op);
      });
      // 이전 선택 복구가 필요하면 여기서 sel1.value = ... 후 detail 채우기
    }

    // 세부 설정(렙제) 옵션 채우기 — 이름과 종류=룬각인 일치 행들의 tag(렙제)만
    async function populateRuneDetailOptions(name) {
      await ensureEnhLoaded();
      const sel2 = document.getElementById('selRuneDetail');
      if (!sel2) return;

      sel2.disabled = true;
      sel2.innerHTML = `<option value="" selected disabled>세부 설정</option>`;

      if (!name) return;
      const rows = getRuneEngraveRows().filter(r => (r.name || '').trim() === String(name).trim());
      // 중복 제거(시트 순서 유지)
      const seenTag = new Set();
      rows.forEach(r => {
        const t = (r.tag || '').trim(); if (!t) return;
        if (!seenTag.has(t)) { seenTag.add(t); const op = document.createElement('option'); op.value = t; op.textContent = t; sel2.appendChild(op); }
      });
      sel2.disabled = false;
    }

    // (이름, tag)로 정확히 1행 매칭하여 합산에 반영
    function applyRuneEngraveByNameTag(name, tag) {
      const rows = getRuneEngraveRows();
      const row = rows.find(r => (r.name || '').trim() === String(name).trim() && (r.tag || '').trim() === String(tag).trim()) || null;
      state.runeEngrave = row ? { name: row.name, tag: row.tag, stats: row.stats } : null;
      recalcAndRenderPanel();
    }
    /* ENHANCE_SHEET에서 '이름' 정확 일치로 1개 찾기 */
    function findEnhByExactName(name) {
      if (!name) return null;
      const list = DBEnh?.list || [];
      const key = String(name).trim();
      return list.find(x => (x?.name || '').trim() === key) || null;
    }

    /* 아바타/무기압 선택 → 시트에서 찾아 상태에 보관 → 합산 갱신 */
    async function applyAvatarEnhFromState() {
      await ensureEnhLoaded();
      const name = AVATAR_NAME[state.options.avatar] || null;
      state.options.avatarEnh = name ? findEnhByExactName(name) : null;
      recalcAndRenderPanel();
    }
    async function applyImprintEnhFromState() {
      await ensureEnhLoaded();
      const name = IMPRINT_NAME[state.options.weaponImprint] || null;
      state.options.imprintEnh = name ? findEnhByExactName(name) : null;
      recalcAndRenderPanel();
    }
    /* ===== 캐릭터 시트 로더 ===== */
    const characterCard = document.getElementById('characterCard');
    const characterImg = document.getElementById('characterImg');
    const characterGhost = document.getElementById('characterGhost');
    const charModal = document.getElementById('charModal');
    const catalogEl = document.getElementById('catalog'); /*<div id="catalog" class="catalog"></div> 를 JS변수 catalogEl로 참조*/
    const DBChars = { loaded: false, groups: [] }; //전역 캐시 객체, 한번 로드되면 다시 안불러오게함, loaded : 시트가 이미 로드됐는지, groups : 화면에 뿌릴 최종 데이터(그룹배열)

    // 로그인 토큰이 준비될 때까지 기다리는 유틸 (최대 15초)
    async function waitForIdToken(timeout = 15000) {
      if (window.idToken) return window.idToken;
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          document.removeEventListener('gsi:issued', onReady);
          reject(new Error('login_timeout'));
        }, timeout);
        function onReady() {
          if (window.idToken) {
            clearTimeout(timer);
            document.removeEventListener('gsi:issued', onReady);
            resolve(window.idToken);
          }
        }
        document.addEventListener('gsi:issued', onReady);
      });
    }


    // ===== 캐릭터 시트 로더 (백엔드 JSON 버전) =====
    async function loadCharacterSheet() {
      if (DBChars.loaded) return;

      // ⬇ 추가: 로그인 완료까지 대기하고 토큰 확보
      const token = await waitForIdToken();

      try {
        // 프록시 → 백엔드 호출: ?type=char
        const r = await fetch(window.WEBAPP_URL + '?type=char', {
          method: 'POST',
          mode: 'cors',
          cache: 'no-store',
          headers: { 'Content-Type': 'text/plain' },
          body: token                    // ⬅ 전역 idToken 대신 지역 token 사용
        });
        if (!r.ok) throw new Error("char_load_failed");
        const data = await r.json();
        if (!data.ok || !Array.isArray(data.rows)) throw new Error("bad_char_payload");

        // rows: [{jobGroup, name, thumb, full, spTotal?, tpTotal?}]
        const groupsMap = new Map();

        data.rows.forEach(row => {
          const groupTitle = (row.jobGroup || '').trim();
          const name = (row.name || '').trim();
          if (!groupTitle || !name) return;

          const badge = cleanUrl(row.badge || '');  // ⬅ 종류 컬럼(뱃지)
          const thumb = cleanUrl(row.thumb || '');  // ⬅ 렙제 컬럼(카드)
          const full = cleanUrl(row.full || '');  // ⬅ 이미지(선택 후)

          if (!groupsMap.has(groupTitle)) {
            groupsMap.set(groupTitle, { badgeSrc: badge, items: [] });
          }
          const g = groupsMap.get(groupTitle);
          if (!g.badgeSrc && badge) g.badgeSrc = badge; // 첫 유효값 고정(혹시 행마다 달라도 첫값 사용)

          g.items.push({
            name,
            thumbSrc: thumb,
            fullSrc: full,
            power: row.power || 'phys',
            spTotal: Number(row.spTotal ?? 0) || 0,  // 👈 추가
            tpTotal: Number(row.tpTotal ?? 35) || 35, // 👈 추가
            base: row.base,
            // ↓↓↓ 추가: 백엔드에서 보낸 enabled(없으면 기본 true)
            enabled: (row.enabled ?? true)
          });
        });

        // Map → 배열 (뱃지 포함)
        DBChars.groups = Array.from(groupsMap.entries()).map(([title, g]) => ({
          title,
          badgeSrc: g.badgeSrc,   // ⬅ 프론트 렌더에서 group.badgeSrc 사용
          items: g.items
        }));
        DBChars.loaded = true;
      } catch (e) {
        console.error("[CHAR] 로드 실패:", e);
        throw e;
      }
    }


    async function ensureCharactersLoaded() {   //필요 할때만 loadCharactersheet() 호출
      await waitForIdToken();
      if (!DBChars.loaded) await loadCharacterSheet();
    }

    /*실제 캐릭터 선택창 내용을 채우는 로직*/
    function renderCatalog() {
      catalogEl.innerHTML = '';   /*catalog 영역 안에 있는 HTML 모두 지움 = 새로운 목록 그리기 전에 항상 기존 내용 초기화*/
      const groups = DBChars.groups || [];    /*DBChars.groups 라는 배열 가져옴, 없으면 [](빈배열) 사용*/
      if (!groups.length) {   /*위 groups의 배열 길이가 0이면 = 데이터가 없으면 아래코드 실행*/
        const msg = document.createElement('div');    /* 새로운 <div> 요소 만듬*/
        msg.style.color = '#c7b589';    /*글자색 베이지색*/
        msg.textContent = '시트에서 캐릭터 목록을 불러올 수 없습니다.';   /*텍스트 출력*/
        catalogEl.appendChild(msg); /*만든 메시지를 catalog 영역에 추가, appendChild는 자식 요소로 맨 뒤에 붙인다 는 메서드, 즉, catalogEl(부모)에 msg(자식)을 넣는것*/
        return;
      }
      groups.forEach(group => {   /*groups 배열을 돌면서 각 그룹(남귀검사, 여마법사 등)에 대해 <div clas="row" 하나 만든다*/
        const row = document.createElement('div'); row.className = 'row';
        const left = document.createElement('img'); left.className = 'badge-img'; left.src = group.badgeSrc || PLACEHOLDER_IMG; left.alt = '배지';    /*row 왼쪽엔 배지 이미지 넣는다*/
        left.onerror = () => { left.src = PLACEHOLDER_IMG; };
        const cards = document.createElement('div'); cards.className = 'cards';  /*캐릭터 카드들을 담는 <div clas="cards">*/
        group.items.forEach(item => {   /*group.items 배열 안의 캐릭터를 돌면서 캐릭터 카드 버튼을 만듦*/
          const card = document.createElement('button'); card.className = 'char-card';
          const img = document.createElement('img'); img.className = 'char-img'; img.alt = item.name; img.src = item.thumbSrc || PLACEHOLDER_IMG;
          img.onerror = () => { img.src = PLACEHOLDER_IMG; };
          const name = document.createElement('div'); name.className = 'char-name'; name.textContent = item.name;
          card.appendChild(img); card.appendChild(name);
          // ↓↓↓ 추가: 활성화여부에 따라 비활성 처리
          const isDisabled = (item.enabled === false || item.enabled === 0);
          if (isDisabled) {
            card.classList.add('disabled');
            card.setAttribute('aria-disabled', 'true');
            // 클릭 리스너를 아예 붙이지 않음
          } else {

            card.addEventListener('click', () => {    /*이 카드 버튼 클릭하면 applyCharacter() 함수 실행되어 캐릭터 정보 넘김*/
              applyCharacter({
                src: item.fullSrc || PLACEHOLDER_IMG,
                jobGroup: normalizeJobGroup(group.title),
                jobGroupLabel: group.title,
                name: item.name,
                power: item.power,
                spTotal: item.spTotal,   // 👈 추가
                tpTotal: item.tpTotal,    // 👈 추가
                base: item.base
              });
              closeCharacterPicker(); /*모달 닫기*/
            });
          }
          cards.appendChild(card);    //만든 캐릭터 카드들을 cards 컨테이너에 추가
        });
        const right = document.createElement('div'); right.textContent = '✶'; right.style.opacity = '.3'; right.style.textAlign = 'center';
        right.style.color = '#d8c088';    // row 오른쪽에 장식용 별표 하나를 배치
        row.appendChild(left); row.appendChild(cards); //row.appendChild(right);
        catalogEl.appendChild(row);   //최종적으로 한줄(row) 안에, 왼쪽(left) 배지 이미지, 가운데(cards) 캐릭터 카드 목록, 오른쪽(right) 별표 를 넣고 완성된 row를 catalog에 추가.
      });
    }
    async function openCharacterPicker() {    // 모달 열때 씀
      await ensureCharactersLoaded();    // 시트 데이터를 아직 안받았다면 받아올때까지 기다림
      renderCatalog();   // 로드된 데이터로 카탈로그 그리기
      charModal.classList.add('show');   //모달에 show 클래스 추가 - 화면에 보이게, 보통 .modal.show {display:block;} 같이 제어
      charModal.setAttribute('aria-hidden', 'false');    // 스크린리더에 '보이는 상태' 알림, 모달열릴때 false, 모달 닫힐때 true.
    }
    function closeCharacterPicker() {   // 모달 닫을 때 씀
      charModal.classList.remove('show');   // show 제거 - 숨김
      charModal.setAttribute('aria-hidden', 'true');    // 접근성 : 숨김 상태 알림
    }
    async function applyCharacter({ src, jobGroup, jobGroupLabel, name, power, spTotal, tpTotal, base }) {
      //카드 클릭 시 이 함수가 호출됨, ui 이미지 교체 - 상태 업데이트 - 파생 ui업데이트까지 한번에 처리
      characterImg.src = src;   // 메인 캐릭터 이미지 교체
      characterImg.style.display = 'block';   // 실제 이미지 보이기
      characterGhost.style.display = 'none';    // 플레이스홀더(유령 이미지) 숨김
      state.currentCharacter = {    // 전역/상태에 현재 선택 기록
        jobGroup,
        jobGroupLabel: jobGroupLabel || null,  // ← 한글 직업군 라벨(예: 남귀검사)
        name,
        imgSrc: src,
        power: power || null,
        base: base || null
      };
      state.skillLv = {}; state.skillTpLv = {}; // 현재 사용한 SP/TP 초기화
      state.skillDmg = {};
      state.stUsedSP = 0; state.stUsedTP = 0;
      if (Number.isFinite(spTotal) && Number.isFinite(tpTotal)) {
        setTotals(spTotal, tpTotal);        // 👈 즉시 반영 (무네트워크)
      } else {
        await loadCharTotalsAndApply(name); // 👈 예외적으로 값이 없을 때만 백업 경로
      }
      recalcAndRenderPanel();
    }

    characterCard.addEventListener('click', openCharacterPicker);
    charModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeCharacterPicker(); });
    /* 스킬시트 매칭용 키: 직업군(라벨)+이름 → 공백 제거 */
    function currentSkillOwnerKey() {
      const ch = state.currentCharacter || {};
      const key = String((ch.jobGroupLabel || '') + (ch.name || '')).replace(/\s+/g, '');
      return key || null; // 예: '남귀검사소울브링어'
    }

    /* ===== 아이템 피커 (공용) ===== */
    const itemModal = document.getElementById('itemModal');
    const itemList = document.getElementById('itemList');
    const itemSearch = document.getElementById('itemSearch');
    const weaponTabs = document.getElementById('weaponTabs');
    const itemDlgTitle = document.getElementById('itemDlgTitle');
    function getItemsForSlot(slotKey) { return (DB.itemsBySlot[slotKey] || []).slice(); }
    function getWeaponsFilteredByJob(jobGroup) {
      const allowed = new Set(ALLOWED_WEAPON_TYPES[jobGroup] || []);
      return getItemsForSlot('weapon').filter(it => allowed.has(it.type));
    }
    function renderWeaponTabs(jobGroup) {
      const types = ALLOWED_WEAPON_TYPES[jobGroup] || [];
      weaponTabs.innerHTML = '';
      if (!types.length) { weaponTabs.style.display = 'none'; return; }
      if (!state.ui.weaponTypeTab || !types.includes(state.ui.weaponTypeTab)) state.ui.weaponTypeTab = types[0];
      types.forEach(t => {
        const b = document.createElement('button');
        b.className = 'tab-btn' + (t === state.ui.weaponTypeTab ? ' active' : '');
        b.textContent = t;
        b.onclick = () => { state.ui.weaponTypeTab = t; renderItems('weapon', itemSearch.value); updateActive(); };
        weaponTabs.appendChild(b);
      });
      function updateActive() { [...weaponTabs.children].forEach(ch => ch.classList.toggle('active', ch.textContent === state.ui.weaponTypeTab)); }
      weaponTabs.style.display = 'flex';
    }

    function renderItems(slotKey, query = '') {
      itemList.innerHTML = '';
      const q = (query || '').trim().toLowerCase();
      let items = slotKey === 'weapon' && state.currentCharacter.jobGroup ? getWeaponsFilteredByJob(state.currentCharacter.jobGroup) : getItemsForSlot(slotKey);
      if (slotKey === 'weapon' && state.ui.weaponTypeTab) items = items.filter(it => it.type === state.ui.weaponTypeTab);
      if (q) items = items.filter(it => (it.name || '').toLowerCase().includes(q) || (it.type || '').toLowerCase().includes(q));
      if (!items.length) {
        const msg = document.createElement('div'); msg.style.color = '#c7b589';
        msg.textContent = '조건과 일치하는 아이템이 없습니다.'; itemList.appendChild(msg); return;
      }
      items.forEach(it => {
        const row = document.createElement('button');
        row.className = 'item-row';
        const isBottom = (slotKey === 'aura' || slotKey === 'title' || slotKey === 'creature' || slotKey === 'artifact');
        const badge = isBottom ? (it.level_text && String(it.level_text).trim()) : `Lv.${it.level ?? 65}`;
        const lvlLabel = isBottom ? (it.level_text && String(it.level_text).trim()) : `${it.level ?? 65}레벨`;
        row.innerHTML = `
          <div class="iconbox">
            <img class="icon" src="${it.img || PLACEHOLDER_IMG}" alt="${it.name}">
            ${badge ? `<span class="badge-lv">${badge}</span>` : ``}
          </div>
          <div class="meta">
            <div class="meta-top">${lvlLabel ? `<span class="lvl">${lvlLabel}</span>` : ``}<span class="name">${it.name}</span></div>
            <div class="meta-sub">${it.type || ''}</div>
          </div>
          <div class="right"><span class="rarity-chip">${it.rarity_kr || (it.rarity === 'epic' ? '에픽' : (it.rarity || ''))}</span></div>`;
        row.onclick = () => { applyItemToSlot(slotKey, it); closeItemPicker(); };
        const icon = row.querySelector('.icon');
        icon.onerror = () => { icon.src = PLACEHOLDER_IMG; };
        itemList.appendChild(row);
      });
    }

    async function openItemPicker(slotKey) {
      state.currentSlotKey = slotKey;
      await ensureLoaded(slotKey);
      if (slotKey === 'weapon') {
        itemDlgTitle.textContent = '무기 선택';
        if (!state.currentCharacter.jobGroup) { openCharacterPicker(); return; }
        renderWeaponTabs(state.currentCharacter.jobGroup);
      } else {
        itemDlgTitle.textContent = labelForSlot(slotKey) + ' 선택';
        weaponTabs.style.display = 'none';
      }
      renderItems(slotKey);
      itemModal.classList.add('show'); itemModal.setAttribute('aria-hidden', 'false');
      itemSearch.value = ''; itemSearch.oninput = () => renderItems(slotKey, itemSearch.value);
    }
    function closeItemPicker() { itemModal.classList.remove('show'); itemModal.setAttribute('aria-hidden', 'true'); }
    itemModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeItemPicker(); });
    function applyItemToSlot(slotKey, item) {
      if (!item.raw && item._raw) item.raw = item._raw;
      state.selections[slotKey] = item;
      const tile = tileElForSlot(slotKey); if (!tile) return;
      tile.innerHTML = `<img class="item-img" alt="${item.name}" src="${item.img || PLACEHOLDER_IMG}" style="width:70%;height:70%;border-radius:8px;">`;
      const img = tile.querySelector('img');
      if (img) img.onerror = () => { img.src = PLACEHOLDER_IMG; };
      recalcAndRenderPanel();
      refreshSealCaptionsForSlot(slotKey);
      refreshSealLabelsFromState();
    }
    function tileElForSlot(slotKey) { const domKey = Object.keys(SLOT_MAP).find(k => SLOT_MAP[k] === slotKey); return document.querySelector(`.slot[data-slot="${domKey}"]`); }
    function labelForSlot(slotKey) {
      return ({
        weapon: '무기', headshoulder: '머리어깨', top: '상의', bottom: '하의', belt: '허리', shoes: '신발',
        bracelet: '팔찌', necklace: '목걸이', ring: '반지', support: '보조장비',
        aura: '오라', title: '칭호', creature: '크리쳐', artifact: '아티팩트'
      })[slotKey] || '아이템';
    }

    /* ===== 강화 선택 ===== */
    const enhanceModal = document.getElementById('enhanceModal');
    const enhanceListEl = document.getElementById('enhanceList');

    function enhTypeForSlot(slotKey) {
      if (slotKey === 'weapon') return '무기강화';
      if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slotKey)) return '방어구강화';
      if (['bracelet', 'necklace', 'ring'].includes(slotKey)) return '악세강화';
      if (slotKey === 'support') return '보장강화';
      return null;
    }
    async function openEnhPicker(slotKey, btnEl) {
      const type = enhTypeForSlot(slotKey);
      if (!type) return;
      await ensureEnhLoaded();
      const list = (DBEnh.byType[type] || []).slice();
      enhanceListEl.innerHTML = '';
      list.forEach(opt => {
        const b = document.createElement('button'); b.className = 'enh-option'; b.textContent = opt.name || '(이름없음)';
        b.onclick = () => { state.upgrades[slotKey] = opt; if (btnEl) btnEl.textContent = opt.name; closeEnhPicker(); recalcAndRenderPanel(); };
        enhanceListEl.appendChild(b);
      });
      state.ui.enhTargetSlot = slotKey; state.ui.enhTargetBtn = btnEl || null;
      enhanceModal.classList.add('show'); enhanceModal.setAttribute('aria-hidden', 'false');
    }
    function closeEnhPicker() { enhanceModal.classList.remove('show'); enhanceModal.setAttribute('aria-hidden', 'true'); }
    enhanceModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeEnhPicker(); });

    /* ===== 합산 패널 ===== */
    const statListEl = document.getElementById('statList');
    function sumSelections() {
      const S = {     //모든 항목 0으로 시작
        phys_atk: 0, mag_atk: 0, str: 0, int: 0, phys_crit: 0, mag_crit: 0, phys_crit_rate: 0, mag_crit_rate: 0, add_damage: 0, counter_damage_inc: 0, elem_add_sum: 0,
        str_pct: 0, int_pct: 0, damage_inc: 0, crit_damage_inc: 0, phys_atk_pct: 0, mag_atk_pct: 0, skill_atk_inc: 0,
        elem: { fire: 0, water: 0, light: 0, dark: 0 }, cdr: 0, speed: { attack: 0, move: 0, cast: 0 }, def_break_inc: 0,
        counter_add_damage: 0,                        // 카운터추뎀(%)
        elem_add: { fire: 0, water: 0, light: 0, dark: 0 },     // 속성별 ‘기본’ 속추(%) 합
        elem_add_eff_sum: 0,           // 식 적용 후 유효 속추(%) 합
        fin_add_damage: 0,    //최종추뎀(%)
        final_phys_crit_pct: 0,   // 최종 물리크리율(0~1)
        final_mag_crit_pct: 0,    // 최종 마법크리율(0~1)
        factor_phys: 1,           // 물공 기준 확률계수
        factor_mag: 1,             // 마공 기준 확률계수
      };
      // ★ 스증 전용 임시 누적기(베이스부터 누적 시작)
      S.__skillMul = 1;        // 곱연산 대상(아이템/강화/엠블렘/옵션/룬/마봉/마부 등)
      S.__skillAddBuff = 0;    // 합연산 대상(버프 시트에서 온 스증)
      const addStats = (s) => {   // 아이템 하나의 stats를 받아 S에 누적
        if (!s) return;
        S.phys_atk += s.phys_atk || 0; S.mag_atk += s.mag_atk || 0;
        S.str += s.str || 0; S.int += s.int || 0;
        S.phys_crit += s.phys_crit || 0; S.mag_crit += s.mag_crit || 0;
        S.phys_crit_rate += s.phys_crit_rate || 0; S.mag_crit_rate += s.mag_crit_rate || 0;
        S.add_damage += s.add_damage || 0;
        S.counter_add_damage += s.counter_add_damage || 0;
        S.counter_damage_inc += s.counter_damage_inc || 0;

        if (s.elem_add_damage) {
          S.elem_add.fire += s.elem_add_damage.fire || 0;
          S.elem_add.water += s.elem_add_damage.water || 0;
          S.elem_add.light += s.elem_add_damage.light || 0;
          S.elem_add.dark += s.elem_add_damage.dark || 0;
        }

        S.str_pct += s.str_pct || 0; S.int_pct += s.int_pct || 0;
        S.damage_inc += s.damage_inc || 0; S.crit_damage_inc += s.crit_damage_inc || 0;
        S.phys_atk_pct += s.phys_atk_pct || 0; S.mag_atk_pct += s.mag_atk_pct || 0;

        // ★ 스증은 더하지 말고 곱 누적(버프는 아직 안 들어옴)
        if (s.skill_atk_inc) {
          S.__skillMul *= (1 + (s.skill_atk_inc || 0));
        }

        if (s.elem) { S.elem.fire += s.elem.fire || 0; S.elem.water += s.elem.water || 0; S.elem.light += s.elem.light || 0; S.elem.dark += s.elem.dark || 0; }
        S.cdr += s.cdr || 0;
        if (s.speed) { S.speed.attack += s.speed.attack || 0; S.speed.move += s.speed.move || 0; S.speed.cast += s.speed.cast || 0; }
        if (s.other) { S.def_break_inc += s.other.def_break_inc || 0; }
      };

      // === [PATCH] 캐릭터 기본스탯 13개 선적용 ===
      // state.currentCharacter.base는 백엔드 ?type=char 응답에 포함된 base(퍼센트는 0~1로 변환)라고 가정
      {
        const B = state?.currentCharacter?.base;
        if (B) {
          addStats({
            // 주의: 너의 S에는 'phys_dmg/mag_dmg' 키가 없으므로 '물리/마법 데미지'를 'phys_atk/mag_atk'로 더한다
            phys_atk: Number(B.phys_dmg || 0),
            mag_atk: Number(B.mag_dmg || 0),

            str: Number(B.str || 0),
            int: Number(B.int || 0),

            phys_crit: Number(B.phys_crit || 0),
            mag_crit: Number(B.mag_crit || 0),
            phys_crit_rate: Number(B.phys_crit_rate || 0), // 0~1
            mag_crit_rate: Number(B.mag_crit_rate || 0), // 0~1

            // 속성강화(절대값)
            elem: {
              fire: Number(B.elem?.fire || 0),
              water: Number(B.elem?.water || 0),
              light: Number(B.elem?.light || 0),
              dark: Number(B.elem?.dark || 0),
            },

            // 참고: base.acc(적중)는 현재 S 스키마에 키가 없어 합산되지 않음
          });
        }
      }

      Object.values(state.selections).forEach(it => addStats(it?.stats));   //선택 장비들 모두 누적해서 최종 s반환
      // 장비 합
      Object.values(state.upgrades).forEach(up => addStats(up?.stats));   // 선택 강화들 모두 누적해서 최종 s반환
      // [REFINE] 무기연마 (곱연산 계열은 addStats 내부에서 자동 곱)
      if (state.refines?.weapon?.stats) addStats(state.refines.weapon.stats);
      // [REFINE] 보조연마 (덧연산)
      if (state.refines?.sub?.stats) addStats(state.refines.sub.stats);
      // ▼▼▼ 여기 추가: 성안의 봉인(덧연산) ▼▼▼
      if (state.castleSeal?.main?.stats) addStats(state.castleSeal.main.stats);
      if (state.castleSeal?.sub?.stats) addStats(state.castleSeal.sub.stats);
      // 강화 합(요청: 합연산)
      //Object.values(state.enchants || {}).forEach(en => addStats(en?.stats));
      // 마법부여 합산
      // 기본(원시) 총합도 유지
      // ▼▼▼ 세트 옵션 계산/적용 (장비 선택 이후) ▼▼▼
      try {
        // 세트 데이터가 아직이면 비동기 로딩 시도(대기하지 않음)
        if (!DBSet.loaded) { ensureSetLoaded().catch(() => { }); }

        // 세트 카운트 대상 슬롯(방어구 5부위 + 악세 3부위)
        // 동일 기준은 엠블렘 자동 적용 코드에서도 사용 중. :contentReference[oaicite:7]{index=7}
        const SET_SLOTS = ['headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring'];

        // 1) 내가 착용한 아이템들의 "종류" 카운트
        const counts = Object.create(null);
        for (const sk of SET_SLOTS) {
          const it = state?.selections?.[sk];
          const k = String(it?.type || '').trim();      // 각 아이템 시트의 '종류' 컬럼 매핑 값
          if (!k) continue;
          counts[k] = (counts[k] || 0) + 1;
        }

        // 2) 예외 플래그(차단 규칙)
        const blockBaseSets = (counts['엘리트상의'] || 0) >= 1; // 맹공/규율/음율 미적용
        const blockKH = (counts['엘리트팔찌'] || 0) >= 1; // 칼날/함성 미적용

        // 3) 적용할 세트 타입 결정
        const want = [];

        if (!blockBaseSets) {
          if ((counts['맹공'] || 0) >= 3) want.push('맹공');
          if ((counts['규율'] || 0) >= 3) want.push('규율');
          if ((counts['음율'] || 0) >= 3) want.push('음율');
        }
        if (!blockKH) {
          const k = counts['칼날'] || 0;
          if (k >= 3) {                 // 3개 이상이면 2셋+3셋 모두
            want.push('칼날2셋', '칼날3셋');
          } else if (k >= 2) {
            want.push('칼날2셋');
          }

          const h = counts['함성'] || 0;
          if (h >= 3) {                 // 3개 이상이면 2셋+3셋 모두
            want.push('함성2셋', '함성3셋');
          } else if (h >= 2) {
            want.push('함성2셋');
          }
        }

        // 4) 세트 스탯 적용 (여러 행이면 전부 더함)
        if (Array.isArray(DBSet.list) && want.length) {
          for (const t of want) {
            const tt = String(t).trim();
            const list = (DBSet.byType?.[tt] || DBSet.list.filter(o => String(o.type || '').trim() === tt));
            for (const o of list) addStats(o.stats);
          }
        }

        // (디버그/표시용) 이번 합산에 적용된 세트 목록 저장
        state.appliedSets = want.slice();
      } catch (e) {
        console.warn('Set bonus apply failed:', e);
      }
      // ▲▲▲ 세트 옵션 계산/적용 끝 ▲▲▲
      S.skill_atk_inc = (S.__skillMul - 1) + S.__skillAddBuff;
      return S;
    }

    const fmtInt = (v) => (v == null ? '—' : Math.round(v).toString());   // 정수,퍼센트를 ui 표시용 문자열로 바꿈(없으면 -)
    const fmtPct = (v) => (v == null ? '—' : (Math.round((v || 0) * 1000) / 10).toFixed(1) + '%');
    const show = (label, value) => {    // 하나의 통계 행 DOM 을 만들어주는 팩토리
      const row = document.createElement('div'); row.className = 'stat-row';
      const L = document.createElement('div'); L.className = 'stat-label'; L.textContent = label;
      const R = document.createElement('div'); R.className = 'stat-value'; R.textContent = value;
      row.appendChild(L); row.appendChild(R); return row;
    };

    function renderStats(S) {     //물공캐 마공캐에 따라 라벨과 값 선택을 바꿔줌
      statListEl.innerHTML = '';
      const HIDE_MOVE_CAST = true; // ← UI 비표시 플래그
      const p = state.currentCharacter.power; // 'phys' | 'mag' | null
      const atkLabel = (p ? powerLabel(p) : '물리/마법') + ' 공격력';
      const mainStatLabel = (p === 'phys' ? '힘' : p === 'mag' ? '지능' : '힘/지능');
      const critLabel = (p ? powerLabel(p) : '물리/마법') + ' 크리티컬';
      const mainPctLabel = (p === 'phys' ? '힘(%)' : p === 'mag' ? '지능(%)' : '힘/지능(%)');
      const atkPctLabel = (p ? powerLabel(p) : '물리/마법') + ' 공격력(%)';
      const atkVal = p === 'phys' ? S.phys_atk : p === 'mag' ? S.mag_atk : null;
      const mainStatVal = p === 'phys' ? S.str : p === 'mag' ? S.int : null;
      const critVal = p === 'phys' ? S.phys_crit : p === 'mag' ? S.mag_crit : null;
      const critRateVal = p === 'phys' ? S.phys_crit_rate : p === 'mag' ? S.mag_crit_rate : null;
      const finalCritPct =
        p === 'phys' ? (S.final_phys_crit_pct ?? 0)
          : p === 'mag' ? (S.final_mag_crit_pct ?? 0)
            : Math.max(S.final_phys_crit_pct ?? 0, S.final_mag_crit_pct ?? 0); // 미정이면 큰 쪽
      const mainPctVal = p === 'phys' ? S.str_pct : p === 'mag' ? S.int_pct : null;
      const atkPctVal = p === 'phys' ? S.phys_atk_pct : p === 'mag' ? S.mag_atk_pct : null;
      const elems = S.elem; const maxVal = Math.max(elems.fire, elems.water, elems.light, elems.dark);
      const winners = []; const tag = (k) => ({ fire: '화', water: '수', light: '명', dark: '암' }[k]);
      for (const k of ['fire', 'water', 'light', 'dark']) if (elems[k] === maxVal && maxVal > 0) winners.push(tag(k));
      const elemText = winners.length ? (winners.join('/') + ' ' + Math.round(maxVal)) : '—';

      statListEl.appendChild(show(atkLabel, fmtInt(atkVal)));   // 실제 화면 UI에 행추가
      statListEl.appendChild(show(mainStatLabel, fmtInt(mainStatVal)));
      statListEl.appendChild(show(critLabel, fmtInt(critVal)));
      statListEl.appendChild(show('최종 크리티컬(%)', (finalCritPct * 100).toFixed(1) + '%'));
      statListEl.appendChild(show('최종 추가데미지(%)', fmtPct(S.fin_add_damage)));
      statListEl.appendChild(show(mainPctLabel, fmtPct(mainPctVal)));
      statListEl.appendChild(show('데미지증가(%)', fmtPct(S.damage_inc)));
      statListEl.appendChild(show('크리티컬데미지증가(%)', fmtPct(S.crit_damage_inc)));
      statListEl.appendChild(show(atkPctLabel, fmtPct(atkPctVal)));
      statListEl.appendChild(show('스킬공격력증가(%)', fmtPct(S.skill_atk_inc)));
      statListEl.appendChild(show('속성강화', elemText));
      statListEl.appendChild(show('방어력감소(%)', fmtPct(S.def_break_inc)));
      statListEl.appendChild(show('전체 쿨타임 감소(%)', fmtPct(S.cdr)));
      statListEl.appendChild(show('공격속도(%)', fmtPct(S.speed.attack)));
      statListEl.appendChild(show('캐스팅속도', fmtPct(S.speed.cast)));
      if (!HIDE_MOVE_CAST) {
        statListEl.appendChild(show('이동속도', fmtPct(S.speed.move)));
      }

      const row = document.createElement('div');  // 네 UI 구조에 맞게 li/tr 등으로 바꿔도 됨

    }

    async function recalcAndRenderPanel() {
      // 1) 버프 먼저 계산
      await waitForIdToken();
      await BuffLeveling.preload();
      state.__buffStats = await BuffLeveling.computeBuffStats();
      console.log("[BUFF-DEBUG] state.__buffStats 저장됨:", state.__buffStats); //로그값

      // 2) 합산
      const S = sumSelections();
      console.log("[BUFF-DEBUG] sumSelections 최종 합산:", S);  //로그값
      console.log("[SET] applied:", state.appliedSets);

      // ★ 아이템 변경으로 state.leveling이 갱신되었을 수 있으니, 모든 스킬 캐시 재계산
      // ★ 아이템 변경으로 state.leveling이 바뀌었을 수 있으니,
      //    현재 캐릭터의 스킬만 데미지 캐시 재계산
      // ★ 현재 캐릭터 스킬만 데미지 캐시 재계산 (안전 키 생성)
      try {
        // 스킬 시트 준비
        if (typeof ensureSkillLoaded2 === 'function') {
          await waitForIdToken();
          await ensureSkillLoaded2();
          // ★ 스킬시트 로딩 직후: 예외규칙 매핑/활성화
          await ensureExceptionLoaded();
          refreshExceptionSkillIdMap();
          refreshActiveExceptions();
        }

        // 안전 문자열 변환기
        const toStr = (v) => (v == null ? '' : String(v));

        // 현재 캐릭터 키(공백 제거) — 어떤 함수/필드가 비어도 안전
        const rawKey =
          (typeof currentCharKey === 'function' ? currentCharKey() : null)
          ?? (typeof currentSkillOwnerKey === 'function' ? currentSkillOwnerKey() : null)
          ?? [state.currentCharacter?.jobGroupLabel, state.currentCharacter?.name].filter(Boolean).join('');

        const key = toStr(rawKey).replace(/\s+/g, '');

        // 캐릭터 키가 없으면 재계산 스킵
        if (!key) {
          console.warn('[LEVELING] 캐릭터 키 없음: 재계산 스킵');
        } else if (ST2?.rows?.length) {
          // 현재 캐릭터 + 표시 스킬만
          const rows = ST2.rows.filter(s => s.who === key && s.show);

          // 다른 캐릭터 캐시 정리(선택)
          for (const id of Object.keys(state.skillDmg || {})) {
            if (!rows.some(s => s.id === id)) delete state.skillDmg[id];
          }

          // TP 0~5(또는 네 상수)에 맞춰 클램프
          for (const s of rows) {
            const tp = Math.max(0, Math.min(5, Number(state.skillTpLv?.[s.id] ?? 0)));
            state.skillDmg[s.id] = calcSkillDamageWithTp(s, tp);
          }
          // ★★★ 스킬 사용횟수 시뮬레이션(60초 = 3600프레임) — 자동 출력 없음
          queueMicrotask(() => window.simulateSkillUsage?.(getTimeWindowSec()));

        }
      } catch (e) {
        console.warn('[LEVELING] 스킬 일괄 재계산 실패:', e);
      }


      // 3) 렌더링 (네 기존 함수들 그대로)
      renderStats(S);
      // 초기엔 값 비워둠(—). 버튼 누르면 갱신.
      //updateFinalDamageField('—');

    }

    /* ===== 엠블렘 시스템 ===== */

    /** 슬롯별 허용 엠블렘 타입 */
    const SOCKET_RULES = {
      headshoulder: ['노란빛엠블렘'],
      belt: ['노란빛엠블렘'],
      top: ['붉은빛엠블렘'],
      bottom: ['붉은빛엠블렘'],
      shoes: ['푸른빛엠블렘'],
      bracelet: ['푸른빛엠블렘'],
      necklace: ['녹색빛엠블렘'],
      ring: ['녹색빛엠블렘'],
      weapon: ['붉은빛엠블렘', '노란빛엠블렘', '녹색빛엠블렘', '푸른빛엠블렘'],
      support: ['플래티넘엠블렘'],
      title: ['플래티넘엠블렘']  // 칭호 좌측 원 1개
    };
    const SOCKET_COUNT = (slotKey) => (slotKey === 'support' || slotKey === 'title') ? 1 : 2;

    const emblemModal = document.getElementById('emblemModal');
    const emblemRows = document.getElementById('emblemRows');

    state.emblems = state.emblems || {};  // { slotKey: [null, null] }
    state.ui.emblemTarget = { slotKey: null, sockIndex: 0 };
    function ensureEmblemArray(slotKey) {
      if (!state.emblems[slotKey]) state.emblems[slotKey] = new Array(SOCKET_COUNT(slotKey)).fill(null);
    }

    /** 작은 원 UI 업데이트 */
    function paintEmblemDot(slotKey, sockIndex) {
      const dot = document.querySelector(`.emblem-dot[data-slot="${slotKey}"][data-sock="${sockIndex}"]`);
      if (!dot) return;
      const picked = (state.emblems[slotKey] || [])[sockIndex] || null;
      // 초기화
      dot.innerHTML = '';
      dot.classList.toggle('empty', !picked);
      if (picked) {
        // 배경 이미지로 주입 (원형 클리핑 100% 보장)
        const src = (picked.img || PLACEHOLDER_IMG).replace(/"/g, '\\"');
        dot.style.setProperty('--emblem', `url("${src}")`);
        dot.classList.add('has-img');

        // 중앙 숫자
        const n = document.createElement('span');
        n.className = 'num';
        n.textContent = picked.level_num ?? '';
        dot.appendChild(n);
      } else {
        // 비워짐 상태
        dot.classList.remove('has-img');
        dot.style.removeProperty('--emblem');
      }
      /* ▼ 보조장비/칭호(플래티넘)일 때 캡션 표시 */
      const isPlatSocket = (slotKey === 'support' || slotKey === 'title');
      if (isPlatSocket) {
        // dot 바로 아래에 .emblem-caption을 만들거나 찾아서 갱신
        let cap = dot.nextElementSibling;
        if (!cap || !cap.classList.contains('emblem-caption')) {
          cap = document.createElement('div');
          cap.className = 'emblem-caption';
          dot.parentNode.insertBefore(cap, dot.nextSibling);
        }
        // 선택 시엔 '렙제' 텍스트(item.tag), 미선택이면 숨김
        if (picked && picked.tag) {
          cap.textContent = picked.tag;
          cap.style.display = 'block';
        } else {
          cap.textContent = '';
          cap.style.display = 'none';
        }
      }

    }

    /** 모든 점 새로고침 */
    function refreshAllDots() { Object.keys(state.emblems).forEach(slotKey => { (state.emblems[slotKey] || []).forEach((_, i) => paintEmblemDot(slotKey, i)); }); }

    /** 없음 썸네일 */
    function makeNoneThumb(onPick) {
      const b = document.createElement('button');
      b.type = 'button'; b.className = 'em-thumb none'; b.title = '없음'; b.onclick = onPick; return b;
    }
    /** 일반 썸네일(이미지 중앙 숫자) */
    function makeEmblemThumb(item, onPick) {
      const b = document.createElement('button');
      b.type = 'button'; b.className = 'em-thumb';
      const img = document.createElement('img'); img.src = item.img || PLACEHOLDER_IMG;
      img.onerror = () => { img.src = PLACEHOLDER_IMG; };
      const num = document.createElement('span'); num.className = 'num'; num.textContent = item.level_num ?? '';
      b.appendChild(img); b.appendChild(num); b.onclick = onPick; return b;
    }

    /** 플래티넘 7줄 분류 키워드 */
    const PLAT_LINES = [
      { label: '화', key: '화' },
      { label: '수', key: '수' },
      { label: '명', key: '명' },
      { label: '암', key: '암' },
      { label: '모속', key: '모속' },
      { label: '힘', key: '힘' },
      { label: '지능', key: '지능' },
    ];

    /** 엠블렘 모달 열기 */
    async function openEmblemPicker(slotKey, sockIndex) {
      await ensureEnhLoaded();
      ensureEmblemArray(slotKey);

      state.ui.emblemTarget = { slotKey, sockIndex };
      emblemRows.innerHTML = '';

      const allow = SOCKET_RULES[slotKey] || [];
      const isPlatinumOnly = allow.length === 1 && allow[0] === '플래티넘엠블렘';
      if (isPlatinumOnly) {
        const base = DBEnh.byType['플래티넘엠블렘'] || [];
        PLAT_LINES.forEach(line => {
          const row = document.createElement('div'); row.className = 'em-row';
          row.appendChild(makeNoneThumb(() => pickEmblem(null)));
          base.filter(x => (x.tag || '').includes(line.key)).forEach(item => {
            row.appendChild(makeEmblemThumb(item, () => pickEmblem(item)));
          });
          emblemRows.appendChild(row);
        });
      } else {
        // 일반 색 엠블렘: 슬롯 규칙대로 한 줄씩 가로 리스트
        const orderMap = { '붉은빛엠블렘': 0, '노란빛엠블렘': 1, '녹색빛엠블렘': 2, '푸른빛엠블렘': 3 };
        allow.slice().sort((a, b) => (orderMap[a] ?? 9) - (orderMap[b] ?? 9)).forEach(type => {
          const row = document.createElement('div'); row.className = 'em-row';
          row.appendChild(makeNoneThumb(() => pickEmblem(null)));
          (DBEnh.byType[type] || []).forEach(item => {
            row.appendChild(makeEmblemThumb(item, () => pickEmblem(item)));
          });
          emblemRows.appendChild(row);
        });
      }

      document.getElementById('emblemDlgTitle').textContent = `엠블렘 선택 - ${labelForSlot(slotKey)} (소켓 ${sockIndex + 1})`;
      emblemModal.classList.add('show'); emblemModal.setAttribute('aria-hidden', 'false');
      function pickEmblem(item) {
        state.emblems[slotKey][sockIndex] = item
          ? { img: item.img, level_num: item.level_num, stats: item.stats, tag: item.tag } // ← tag 추가
          : null;
        paintEmblemDot(slotKey, sockIndex);
        recalcAndRenderPanel(); // 합연산 반영
        closeEmblemPicker();
      }
    }
    function closeEmblemPicker() { emblemModal.classList.remove('show'); emblemModal.setAttribute('aria-hidden', 'true'); }
    emblemModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeEmblemPicker(); });
    /** 작은 원(소켓) 주입: 좌측열은 slot 오른쪽, 우측열은 slot 왼쪽. 보조장비는 1개. */
    function injectEmblemDots() {
      // 메인 좌/우 열
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot'); if (!slotEl) return;
        const code = slotEl.getAttribute('data-slot'); const slotKey = SLOT_MAP[code]; if (!slotKey) return;

        // 중앙 미니 4칸(C1~C4)은 뒤에서 따로 처리
        if (['aura', 'title', 'creature', 'artifact'].includes(slotKey)) return;

        if (!SOCKET_RULES[slotKey]) return; // 엠블렘 미지원 슬롯은 스킵

        const stack = document.createElement('div'); stack.className = 'emblem-stack';
        const count = SOCKET_COUNT(slotKey);
        for (let i = 0; i < count; i++) {
          const dot = document.createElement('button');
          dot.type = 'button'; dot.className = 'emblem-dot empty';
          dot.setAttribute('data-slot', slotKey); dot.setAttribute('data-sock', String(i));
          dot.onclick = (e) => { e.stopPropagation(); openEmblemPicker(slotKey, i); };
          stack.appendChild(dot);
        }
        ensureEmblemArray(slotKey);
        // 좌측열(L*) → slot 오른쪽 / 우측열(R*) → slot 왼쪽
        if (code && code.startsWith('L')) {
          row.appendChild(stack);
        } else if (code && code.startsWith('R')) {
          row.insertBefore(stack, slotEl);
        }
      });

      // 칭호(Title) 처리: 왼쪽 2개 선택칸 중 '아래 선택칸' 제거하고 원 1개 넣기 (플래티넘)
      const titleSlot = document.querySelector('.slot.mini[data-slot="C2"]');
      if (titleSlot) {
        const miniCell = titleSlot.closest('.mini-cell');
        if (miniCell) {
          const outer = miniCell.querySelector('.outer-rects');
          if (outer) {
            const btns = outer.querySelectorAll('.rect');
            if (btns[1]) btns[1].remove(); // 아래 버튼 제거
          }
          const stack = document.createElement('div');
          stack.className = 'emblem-stack';
          const dot = document.createElement('button'); dot.type = 'button'; dot.className = 'emblem-dot empty';
          dot.setAttribute('data-slot', 'title'); dot.setAttribute('data-sock', '0');
          dot.onclick = (e) => { e.stopPropagation(); openEmblemPicker('title', 0); };
          stack.appendChild(dot);
          ensureEmblemArray('title');
          miniCell.insertBefore(stack, miniCell.querySelector('.slot.mini'));
        }
      }

      refreshAllDots();
    }
    const runeModal = document.getElementById('runeModal');
    const runeGridEl = document.getElementById('runeGrid');
    function renderRuneGrid() {
      ensureRunesInitialized();
      runeGridEl.innerHTML = '';

      const header = document.createElement('div'); header.className = 'row';
      const headCell = document.createElement('div'); headCell.className = 'head'; headCell.textContent = '스킬룬';
      header.appendChild(headCell);
      RUNE_LEVELS.forEach(lvl => {
        const c = document.createElement('div'); c.className = 'cell';
        const tag = document.createElement('div'); tag.className = 'head'; tag.textContent = String(lvl);
        tag.style.textAlign = 'center';
        c.appendChild(tag); header.appendChild(c);
      });
      runeGridEl.appendChild(header);

      RUNE_CATS.forEach(cat => {
        const row = document.createElement('div'); row.className = 'row';
        const head = document.createElement('div'); head.className = 'head'; head.textContent = cat.label;
        row.appendChild(head);

        RUNE_LEVELS.forEach(lvl => {
          const c = document.createElement('div'); c.className = 'cell';
          const sel = document.createElement('select'); sel.className = 'rune-select';
          for (let i = 0; i <= 20; i++) { const o = document.createElement('option'); o.value = String(i); o.textContent = String(i); sel.appendChild(o); }
          sel.value = String((state.runes[cat.key] || {})[lvl] || 0);
          sel.addEventListener('change', () => {
            const before = (state.runes[cat.key] || {})[lvl] || 0;
            const after = Number(sel.value) || 0;
            const currentTotal = countSelectedRunes();
            const diff = after - before;
            if (currentTotal + diff > 20) {
              sel.value = String(before);
              sel.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.05)' }, { transform: 'scale(1)' }], { duration: 180 });
              return;
            }
            state.runes[cat.key][lvl] = after;
            updateRuneCountSummary();
            onRunesChanged();
          });
          c.appendChild(sel);
          row.appendChild(c);
        });
        runeGridEl.appendChild(row);
      });
    }

    function openRuneModal() { renderRuneGrid(); runeModal.classList.add('show'); runeModal.setAttribute('aria-hidden', 'false'); }
    function closeRuneModal() { runeModal.classList.remove('show'); runeModal.setAttribute('aria-hidden', 'true'); }
    runeModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeRuneModal(); });
    /* ===== 스킬트리 로더 & UI (UI 전용, 계산 미연결) ===== */
    const DBTree = { loaded: false, rows: [], byChar: new Map() };
    const ST_CONF = { SP_TOTAL: 1210, TP_TOTAL: 35 };
    const LEVEL_BANDS_DEFAULT = [1, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 65, 70, 75, 80];
    function pickCol(r, ...ks) { for (const k of ks) { if (r[k] != null && String(r[k]).trim() !== '') return r[k]; } return ''; }
    function toNum(v) { if (v === '' || v == null) return 0; const n = Number(String(v).replace(/[, ]/g, '')); return isNaN(n) ? 0 : n; }
    function toList(v) { return (v ? String(v).split(/[,;]/).map(s => s.trim()).filter(Boolean) : []); }

    function mapRowToSkill(r) {
      // 네가 준 컬럼 키 그대로 사용
      const whoRaw = r['캐릭터명'];
      const name = String(r['스킬명'] ?? '').trim();
      const band = toNum(r['스킬렙제']);
      const cd = toNum(r['쿨타임']);
      const castFrames = toNum(r['시전프레임']);
      const minLv = toNum(r['최소스킬레벨']);
      const maxLv = toNum(r['최대스킬레벨']);       // (= 마스터스킬레벨)
      const sp = toNum(r['소모 SP']);               // SP 비용(레벨당)
      const icon = cleanUrl(r['이미지']) || PLACEHOLDER_IMG;

      const who = String(whoRaw ?? '').replace(/\s+/g, '').trim();

      const idBase = (r['스킬ID'] ?? name).toString().trim();
      const id = idBase ? `${idBase}#${band || 0}` : (Date.now().toString(36) + Math.random().toString(36).slice(2));

      return {
        id, who, name, icon,
        band: band || 1,
        levelGate: band || 1,     // ← 추가: 스킬렙제(레벨링 게이트) 통일 키
        min: Math.max(0, minLv || 0),
        max: Math.max(1, maxLv || 1),
        sp: Math.max(0, sp || 0),
        tp: 0,
        cd,
        castFrames,
        prereq: [],
        desc: ''
      };
    }



    /* ===== 엠블렘 합연산 포함을 위해 합산 함수 확장 ===== */
    const _sumSelections_base = sumSelections;
    sumSelections = function () {
      const S = _sumSelections_base();

      // 누적기 안전 보정(베이스가 항상 넣지만, 혹시 모를 재정의 대비)
      S.__skillMul = S.__skillMul || 1;
      S.__skillAddBuff = S.__skillAddBuff || 0;

      const add = (st, src = 'other') => {
        if (!st) return;

        // 1) 스증만 분기
        if (st.skill_atk_inc) {
          if (src === 'buff') S.__skillAddBuff += (st.skill_atk_inc || 0);  // 버프는 합산
          else S.__skillMul *= (1 + (st.skill_atk_inc || 0)); // 나머지는 곱산
        }

        // 2) 나머지 스탯은 기존처럼 가산
        S.phys_atk += st.phys_atk || 0; S.mag_atk += st.mag_atk || 0;
        S.str += st.str || 0; S.int += st.int || 0;
        S.phys_crit += st.phys_crit || 0; S.mag_crit += st.mag_crit || 0;
        S.phys_crit_rate += st.phys_crit_rate || 0; S.mag_crit_rate += st.mag_crit_rate || 0;
        S.add_damage += st.add_damage || 0;
        S.str_pct += st.str_pct || 0; S.int_pct += st.int_pct || 0;
        S.damage_inc += st.damage_inc || 0; S.crit_damage_inc += st.crit_damage_inc || 0;
        S.phys_atk_pct += st.phys_atk_pct || 0; S.mag_atk_pct += st.mag_atk_pct || 0;
        if (st.elem) { S.elem.fire += st.elem.fire || 0; S.elem.water += st.elem.water || 0; S.elem.light += st.elem.light || 0; S.elem.dark += st.elem.dark || 0; }
        S.cdr += st.cdr || 0;
        if (st.speed) { S.speed.attack += st.speed.attack || 0; S.speed.move += st.speed.move || 0; S.speed.cast += st.speed.cast || 0; }
        if (st.other) { S.def_break_inc += st.other.def_break_inc || 0; }
      };


      // 엠블렘(곱 대상)
      Object.keys(state.emblems || {}).forEach(slotKey => {
        (state.emblems[slotKey] || []).forEach(it => { if (it?.stats) add(it.stats, 'other'); });
      });

      // 옵션(아바타/무기압)도 곱 대상
      if (state.options?.avatarEnh?.stats) add(state.options.avatarEnh.stats, 'other');
      if (state.options?.imprintEnh?.stats) add(state.options.imprintEnh.stats, 'other');

      // 룬 각인(곱 대상)
      if (state.runeEngrave?.stats) add(state.runeEngrave.stats, 'other');

      // 버프 시트(합 대상)
      if (state.__buffStats) add(state.__buffStats, 'buff');

      // ★ 아직 S.skill_atk_inc 확정하지 않음 (5번째에서 마봉·마부까지 포함 후 최종 확정)
      return S;
    };
    // 초기화
    document.addEventListener('DOMContentLoaded', () => {
      refreshEnhLabelsFromState();
      renderSpTp();
      // 슬롯 클릭 → 아이템 선택
      document.querySelectorAll('.slot').forEach(el => {
        const code = el.getAttribute('data-slot'); const slotKey = SLOT_MAP[code]; if (!slotKey) return;
        el.addEventListener('click', (e) => { e.stopPropagation(); openItemPicker(slotKey); });
      });

      // 첫 번째 선택칸 = 강화 선택 연결
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot'); const code = slotEl?.getAttribute('data-slot'); const slotKey = SLOT_MAP[code];
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!slotKey || !rects.length) return;
        const firstBtn = rects[0];
        /* ▼ 추가: 기본 라벨을 '강화 설정'으로 보이게 */
        firstBtn.textContent = '강화 설정';
        firstBtn.addEventListener('click', (e) => { e.stopPropagation(); openEnhPicker(slotKey, firstBtn); });
      });

      // 두 번째 선택칸 = 마봉 선택 연결
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot');
        const code = slotEl?.getAttribute('data-slot');
        const slotKey = SLOT_MAP[code];
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!slotKey || rects.length < 2) return;

        const secondBtn = rects[1];
        // 기본 라벨
        secondBtn.textContent = '마봉 설정';

        // 중복 바인딩 방지 (페이지 재렌더 시 다중 등록 예방)
        if (secondBtn.dataset.boundSeal === '1') return;
        secondBtn.dataset.boundSeal = '1';

        secondBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof openSealModal === 'function') {
            // slotKey에 맞는 3분할 모달 열기 (고유/일반1/일반2)
            openSealModal(slotKey, secondBtn);
          } else {
            console.warn('openSealModal 함수가 아직 로드되지 않았습니다.');
          }
        });
      });

      // === [REFINE] 4번째 세부버튼 라벨/역할 세팅 ===
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot');
        const code = slotEl?.getAttribute('data-slot');       // 예: R1, R5 ...
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!code || rects.length < 4) return;

        // R1(무기)과 R5(보조장비)만 활성화
        if (code === 'R1' || code === 'R5') {
          const fourth = rects[3]; // 4번째 버튼
          fourth.textContent = '연마 설정';
          fourth.dataset.role = 'refine';
          fourth.removeAttribute('data-unused');
          fourth.removeAttribute('aria-disabled');
          fourth.disabled = false;
          fourth.classList.remove('disabled', 'is-disabled');
          fourth.style.pointerEvents = '';
        }
      });



      // 칭호 왼쪽 두 선택칸 비활성화
      document.querySelectorAll('[data-unused="true"]').forEach(b => { b.classList.add('disabled'); b.title = '추후 사용 예정'; });
      // 엠블렘 소켓 주입
      injectEmblemDots();
      const btnRune = document.getElementById('btnRune');
      if (btnRune) { btnRune.addEventListener('click', openRuneModal); }
      ensureRunesInitialized();
      updateRuneCountSummary();

      // 룬 각인 드롭다운 바인딩
      const selRuneEngrave = document.getElementById('selRuneEngrave');
      const selRuneDetail = document.getElementById('selRuneDetail');

      if (selRuneEngrave) {
        selRuneEngrave.addEventListener('change', async () => {
          // 이름 선택/변경 시: 세부설정 초기화 + 비활성화 → 새 목록 구성 후 활성화
          state.runeEngrave = null;
          if (selRuneDetail) {
            selRuneDetail.innerHTML = `<option value="" selected disabled>세부 설정</option>`;
            selRuneDetail.disabled = true;
          }
          const pickedName = selRuneEngrave.value || null;
          if (pickedName) {
            await populateRuneDetailOptions(pickedName);   // 목록 채우기
            if (selRuneDetail) selRuneDetail.disabled = false; // 활성화
          }
          // 세부 설정이 아직 선택되지 않았으므로 합산은 여기서 하지 않음
        });
      }

      if (selRuneDetail) {
        selRuneDetail.addEventListener('change', () => {
          const name = selRuneEngrave?.value || null;
          const tag = selRuneDetail.value || null;
          if (name && tag) {
            applyRuneEngraveByNameTag(name, tag); // 즉시 합산 반영
          } else {
            state.runeEngrave = null;
            recalcAndRenderPanel();
          }
        });
      }

      console.log('[Init] Ready. Click slots to load sheets. First select = 강화. Dots = 엠블렘.');
    });

    // === 데이터 로더들 (loadCharacterSheet, loadSkillSheet 등) 정의 끝난 뒤 ===
    // 전역 한 번만
    let __preloadingPromise = null;
    let __preloaded = false;

    async function preloadAllSheetsOnce(opts) {
      if (__preloaded) return;
      if (__preloadingPromise) return __preloadingPromise;
      __preloadingPromise = (async () => {
        try { await preloadAllSheets(opts); __preloaded = true; }
        finally { __preloadingPromise = null; }
      })();
      return __preloadingPromise;
    }
    // ★ 추가: 모든 시트를 미리 로드
    // ⬇ 기존 preloadAllSheets 정의를 '완전히' 아래 코드로 교체


  </script>
  <div id="autoEnhModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialogetc" role="dialog" aria-modal="true" aria-labelledby="autoEnhTitle">
      <header>
        <h3 id="autoEnhTitle">강화 자동 입력</h3><button class="close" data-close>✕</button>
      </header>
      <div class="cols">
        <div class="titles">강화 선택</div> <!-- ✅ 추가 -->
      <div class="lists" id="autoEnhList"></div>
    </div>
  </div>
  </div>
  <div id="autoEnchantModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialogetc" role="dialog" aria-modal="true" aria-labelledby="autoEnchantTitle">
      <header>
        <h3 id="autoEnchantTitle">추천 마법부여</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body two-col">
        <div class="cols left">
          <div class="titles">속성 선택</div>
          <div class="lists attrs"></div>
        </div>
        <div class="cols right">
          <div class="titles">추천 티어</div>
          <div class="lists tiers"></div>
        </div>
      </div>
    </div>
  </div>

<div id="autoEmblemModal" class="modal simple-modal" aria-hidden="true">
  <div class="backdrop" data-close></div>
  <div class="dialogetc" role="dialog" aria-modal="true" aria-labelledby="autoEmblemTitle">
    <header>
      <h3 id="autoEmblemTitle">엠블렘 자동 입력</h3>
      <button class="close" data-close>✕</button>
    </header>
    <!-- ✅ 추천 마법부여 자동입력과 동일한 2열 UI -->
    <div class="body two-col">
      <div class="cols left">
        <div class="titles">속성 선택</div>
        <div class="lists attrs" id="autoEmblemAttrs">
  <div class="row attr-row1">
    <button class="opt-btnetc" data-ele="fire">화속성</button>
    <button class="opt-btnetc" data-ele="water">수속성</button>
    <button class="opt-btnetc" data-ele="light">명속성</button>
    <button class="opt-btnetc" data-ele="dark">암속성</button>
  </div>
  <div class="row attr-row2">
    <button class="opt-btnetc" data-ele="all">모속</button>
    <button class="opt-btnetc" data-ele="str">힘</button>
    <button class="opt-btnetc" data-ele="int">지능</button>
  </div>
</div>
      </div>

      <div class="cols right">
        <div class="titles">단계 선택</div>
        <div class="lists tiers" id="autoEmblemTiers"></div>
      </div>
    </div>
  </div>
</div>

  <div id="autoSealModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialogetc" role="dialog" aria-modal="true" aria-labelledby="autoSealTitle">
      <header>
        <h3 id="autoSealTitle">추천 마법봉인</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="cols">
        <div class="titles">속성 선택</div> <!-- ✅ 추가 -->
        <div class="lists">
          <button class="opt-btnetc" data-ele="fire">화속성</button>
          <button class="opt-btnetc" data-ele="water">수속성</button>
          <button class="opt-btnetc" data-ele="light">명속성</button>
          <button class="opt-btnetc" data-ele="dark">암속성</button>
        </div>
      </div>
    </div>
  </div>

  <script>

    /* ===== Auto Input: Helpers ===== */

    /* Reflect chosen enhance names on first rect of each slot */
    function refreshEnhLabelsFromState() {
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot');
        const code = slotEl?.getAttribute('data-slot');
        const slotKey = SLOT_MAP[code];
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!slotKey || !rects.length) return;
        const up = state.upgrades?.[slotKey];
        rects[0].textContent = up?.name || '강화 설정';
      });
    }

    const REVERSE_SLOT_MAP = Object.fromEntries(Object.entries(SLOT_MAP).map(([k, v]) => [v, k]));
    function firstEnhButtonFor(slotKey) {
      const code = REVERSE_SLOT_MAP[slotKey]; if (!code) return null;
      const row = document.querySelector(`.slot-row .slot[data-slot="${code}"]`)?.closest('.slot-row');
      if (!row) return null;
      return row.querySelector('.outer-rects .rect');
    }

    function matchEnhByLevelName(list, level) {
      const want = Number(level);
      const pattern1 = new RegExp(String.raw`(?:^|[^\d])${want}\s*강`);
      const pattern2 = new RegExp(String.raw`\+\s*${want}(?:[^\d]|$)`);
      const pattern3 = new RegExp(String.raw`(?:^|[^\d])${want}(?:[^\d]|$)`);
      let best = null;
      for (const o of list) {
        const name = (o.name || '').trim();
        if (pattern1.test(name) || pattern2.test(name)) return o;
        if (!best && pattern3.test(name)) best = o;
      }
      return best || list.find(o => String(o.name || '').includes(String(want))) || null;
    }


    async function autoEnhanceApply(level) {
      try {
        await ensureEnhLoaded();
      } catch (e) { console.warn('ensureEnhLoaded failed', e); }
      const lvl = Number(level) || 0;
      const sets = {
        weapon: '무기강화',
        headshoulder: '방어구강화', top: '방어구강화', bottom: '방어구강화', belt: '방어구강화', shoes: '방어구강화',
        bracelet: '악세강화', necklace: '악세강화', ring: '악세강화',
        support: '보장강화'
      };
      const slots = Object.keys(sets);
      let success = 0;
      for (const sk of slots) {
        const type = sets[sk];
        let list = (DBEnh?.byType?.[type] || []).slice();
        if (!list.length && Array.isArray(DBEnh?.list)) {
          list = DBEnh.list.filter(o => String(o?.type || '').includes(type));
        }
        const pick = matchEnhByLevelName(list, lvl);
        if (!pick) { console.warn('No enhance match for', sk, type, lvl); continue; }
        state.upgrades[sk] = pick;
        success++;
      }
      // Re-render totals/panels
      if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
      // Refresh button labels from state after re-render
      if (typeof refreshEnhLabelsFromState === 'function') refreshEnhLabelsFromState();
      return success;
    }


    /* ===== Auto Emblem Apply: stage 5~15 ===== */
    /* ===== [EMBLEM][AUTO] 상태 & 렌더 ===== */
const autoEmblemState = { attr: null, stage: null };

function renderAutoEmblemChoices() {
  const modal = document.getElementById('autoEmblemModal');
  const $attrs = modal?.querySelector('#autoEmblemAttrs');
  const $tiers = modal?.querySelector('#autoEmblemTiers');
  if (!$attrs || !$tiers) return;

  // 속성 버튼 (화/수/명/암)
  $attrs.querySelectorAll('button').forEach(btn => {
    const k = btn.getAttribute('data-ele'); // 'fire'|'water'|'light'|'dark'
    btn.classList.toggle('active', autoEmblemState.attr === k);
    btn.onclick = () => {
      autoEmblemState.attr = k;
      renderAutoEmblemChoices();
      tryApplyAutoEmblemIfReady();
    };
  });

  // 단계 버튼 (5~15) → 2줄(1줄: 5~10, 2줄: 11~15)
$tiers.innerHTML = '';

const makeRow = (from, to, cls) => {
  const row = document.createElement('div');
  row.className = `row ${cls}`;
  for (let lv = from; lv <= to; lv++) {
    const b = document.createElement('button');
    b.className = 'opt-btnetc';
    b.textContent = `${lv}단계`;
    if (autoEmblemState.stage === lv) b.classList.add('active');
    b.onclick = () => {
      autoEmblemState.stage = lv;
      renderAutoEmblemChoices();
      tryApplyAutoEmblemIfReady();
    };
    row.appendChild(b);
  }
  return row;
};

$tiers.appendChild(makeRow(5, 8, 'tier-row1'));
$tiers.appendChild(makeRow(9, 12, 'tier-row2'));
$tiers.appendChild(makeRow(13, 15, 'tier-row3'));

}

function closeAutoEmblemModal() {
  const modal = document.getElementById('autoEmblemModal');
  if (!modal) return;
  modal.classList.remove('show');
  modal.setAttribute('aria-hidden', 'true');
}

async function tryApplyAutoEmblemIfReady() {
  const { attr, stage } = autoEmblemState;
  if (!attr || !stage) return;
  await autoEmblemApply(attr, stage);
  closeAutoEmblemModal();
}

   /* 속성 → 플래티넘 엠블렘 매칭 */
function pickPlatForAttr(attrKey, stageNum) {
  // ENH 데이터(강화/마봉/마부/엠블렘) 로딩 보장
  const list = (DBEnh && DBEnh.byType && DBEnh.byType['플래티넘엠블렘']) ? DBEnh.byType['플래티넘엠블렘'] : [];
  if (!Array.isArray(list) || !list.length) return null;

  // tag(=렙제)에서 속성 분류, name(=이름)에서 "n단계" 파싱된 level_num 사용
  const want = {
    fire: ['화', '화속', '화속성', '불'],
    water: ['수', '수속', '수속성', '물'],
    light: ['명', '명속', '명속성', '빛'],
    dark: ['암', '암속', '암속성', '어둠'],
    all: ['모속', '전체', '모든속성'],
   str: ['힘'],
    int: ['지능'],
  }[attrKey] || [];

    const byAttr = list.filter(o => {
    const tag = String(o.tag || o.raw?.['렙제'] || '');
    return want.length ? want.some(w => tag.includes(w)) : true;
  });

  // 1) 속성+단계 정확 매칭
  const stage = Number(stageNum);
  const hit1 = byAttr.find(o => Number(o.level_num) === stage
    || String(o.name||'').includes(`${stage}단계`));
  if (hit1) return hit1;

  // 2) 속성만 매칭
  if (byAttr.length) return byAttr[0];

  // 3) 아무거나
  return list[0] || null;
}

/* ===== Auto Emblem Apply (attr + stage) ===== */
async function autoEmblemApply(attrKey, stage) {
  await ensureEnhLoaded();

  // 1) 일반 엠블렘: 단계별 자동 주입 (무기는 붉은빛 고정 규칙 유지)
  const stageNum = Number(stage) || 0;
  const slots = ['headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring', 'weapon'];
  for (const sk of slots) {
    ensureEmblemArray(sk);
    const types = SOCKET_RULES[sk] || [];
    let useTypes = types.slice();
    if (sk === 'weapon') useTypes = ['붉은빛엠블렘']; // 무기 강제 규칙 (기존 동작)

    // 해당 단계의 첫 아이템 선택
    const picks = [];
    useTypes.forEach(t => {
      const arr = (DBEnh.byType[t] || []).filter(it => it.level_num === stageNum);
      if (arr.length) picks.push(arr[0]);
    });
    const pick = picks[0] || null;

    const count = SOCKET_COUNT(sk);
    for (let i = 0; i < count; i++) {
      state.emblems[sk][i] = pick
        ? { img: pick.img, level_num: pick.level_num, stats: pick.stats, tag: pick.tag }
        : null;
      paintEmblemDot(sk, i);
    }
  }

  // 2) 속성 기반 플래티넘: 보조장비(support) + 칭호(title)
  const plat = pickPlatForAttr(attrKey, stageNum);
  if (plat) {
    // 보조장비
    ensureEmblemArray('support');
    for (let i = 0; i < SOCKET_COUNT('support'); i++) {
      state.emblems.support[i] = { img: plat.img, level_num: plat.level_num, stats: plat.stats, tag: plat.tag };
      paintEmblemDot('support', i);
    }
    // 칭호(타이틀) — 보통 1개 소켓(주입/표시 로직은 이미 준비됨) :contentReference[oaicite:7]{index=7}
    ensureEmblemArray('title');
    state.emblems.title[0] = { img: plat.img, level_num: plat.level_num, stats: plat.stats, tag: plat.tag };
    paintEmblemDot('title', 0);
  }

  // 3) 재계산/리렌더
  if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
}

    const AUTO_ATTRS = ['화속성', '수속성', '명속성', '암속성'];
    const AUTO_TIERS = ['종결', '준종결', '보통', '가성비'];
    const autoEnchantState = { attr: null, tier: null };

    // 전역 상태 예시:
    // const autoEnchantState = { attr: null, tier: null };

    function renderAutoEnchantChoices() {
      const m = document.getElementById('autoEnchantModal');
      const wrapAttrs = m.querySelector('.lists.attrs');
      const wrapTiers = m.querySelector('.lists.tiers');
      wrapAttrs.innerHTML = '';
      wrapTiers.innerHTML = '';

      const makeBtn = (txt, group) => {
        const b = document.createElement('button');
        b.className = 'opt-btnetc';
        b.type = 'button';
        b.textContent = txt;
        b.setAttribute('role', 'button');
        b.setAttribute('aria-pressed', 'false');
        b.addEventListener('click', () => {
          if (group === 'attr') autoEnchantState.attr = txt;
          else autoEnchantState.tier = txt;

          updateAutoActive();        // ✅ 즉시 시각 강조
          tryApplyAutoIfReady();     // 두 값이 모두 선택되면 적용+닫기
        });
        return b;
      };

      ['화속성', '수속성', '명속성', '암속성'].forEach(a => wrapAttrs.appendChild(makeBtn(a, 'attr')));
      ['종결', '준종결', '보통', '가성비'].forEach(t => wrapTiers.appendChild(makeBtn(t, 'tier')));

      // 열 때 초기화 상태 반영(둘 다 null이면 전부 비활성 표시)
      updateAutoActive();
    }
    // === [ENCHANT][AUTO] 직업군 텍스트 얻기
    function getJobGroupText(opt) {
      if (!opt) return '';
      if (opt.jobGroup) return String(opt.jobGroup).trim();
      const raw = opt.raw || {};
      return String(raw['직업군'] ?? raw.jobGroup ?? raw['분류'] ?? '').trim();
    }

    // === [ENCHANT][AUTO] 직업군으로 옵션 찾기
    function findEnchantByJobGroup(typeKey, keyword) {
      const list = ENCHANT_CACHE.byType.get(String(typeKey).trim()) || [];
      const kw = String(keyword || '').trim();
      if (!kw) return null;

      // 1순위: 직업군열 포함
      let hit = list.find(o => getJobGroupText(o).includes(kw));
      if (hit) return hit;

      // 2순위(폴백): 이름에라도 포함
      hit = list.find(o => String(o.name || '').includes(kw));
      return hit || null;
    }

    // 두 그룹에서 단일 선택 강조
    function updateAutoActive() {
      const modal = document.getElementById('autoEnchantModal');
      const mark = (selector, pickedText) => {
        modal.querySelectorAll(selector).forEach(btn => {
          const on = (btn.textContent.trim() === (pickedText || ''));
          btn.classList.toggle('active', on);
          btn.setAttribute('aria-pressed', on ? 'true' : 'false');
        });
      };
      mark('.lists.attrs .opt-btnetc', autoEnchantState.attr);
      mark('.lists.tiers .opt-btnetc', autoEnchantState.tier);
    }


    // 맨 위 편한 곳에 추가
    const $autoEnchantModal = document.getElementById('autoEnchantModal');

    // 기존 함수 교체
    function tryApplyAutoIfReady() {
      if (autoEnchantState.attr !== null && autoEnchantState.tier !== null) {
        applyAutoEnchant(autoEnchantState.attr, autoEnchantState.tier);
        autoEnchantState.attr = null;
        autoEnchantState.tier = null;
        showModal(document.getElementById('autoEnchantModal'), false);
      }
    }

    // === [ENCHANT][AUTO] 속성+티어/티어만 규칙대로 전체 자동 적용
    async function applyAutoEnchant(attr, tier) {
      await ensureEnchantCache();

      const combo = `${attr}${tier}`;

      // 무기/팔찌/목걸이/반지 = 속성+티어, 그 외 = 티어만
      const USE_COMBO = new Set(['무기마부', '팔찌마부', '목걸이마부', '반지마부']);
      const USE_TIER = new Set(['머리어깨마부', '상의마부', '하의마부', '허리마부', '신발마부', '보장마부', '칭호마부']);

      const targetSlots = ['R1', 'R2', 'R3', 'R4', 'R5', 'L1', 'L2', 'L3', 'L4', 'L5', 'C2'];

      const applied = [];
      const prev = state.currentSlotKey;

      for (const slotCode of targetSlots) {
        const typeKey = enchantTypeForSlot(slotCode); // 예: R1 -> '무기마부'
        if (!typeKey) continue;

        const keyToUse = USE_COMBO.has(typeKey) ? combo
          : USE_TIER.has(typeKey) ? tier
            : null;
        if (!keyToUse) continue;

        const opt = findEnchantByJobGroup(typeKey, keyToUse); // ← 1)에서 만든 헬퍼
        if (!opt) continue;

        // 실제 적용 (state 저장 + 버튼 라벨 갱신 + 재계산)
        state.currentSlotKey = slotCode;
        applyEnchantSelection(opt);
        applied.push({ slot: slotCode, name: opt.name });
      }

      state.currentSlotKey = prev;

      if (!applied.length) {
        (typeof toast === 'function' ? toast : alert)('조건에 맞는 추천 마법부여를 찾지 못했습니다.');
      }
    }





    /* ===== Bind Auto Panels ===== */
    document.addEventListener('DOMContentLoaded', () => {
      const autoEnhModal = document.getElementById('autoEnhModal');
      const autoEnhList = document.getElementById('autoEnhList');
      const autoEmblemModal = document.getElementById('autoEmblemModal');
      const autoEmblemList = document.getElementById('autoEmblemList');
      const autoEnchantModal = document.getElementById('autoEnchantModal');
      // ▼ 추천 마법봉인 자동 입력 버튼 활성화 + 모달 오픈
      const btnAutoSeal = document.getElementById('btnAutoSeal');
      if (btnAutoSeal) {
        // 혹시 남아있을지 모르는 속성 정리(이중안전)
        btnAutoSeal.disabled = false;
        btnAutoSeal.removeAttribute('title');

        btnAutoSeal.addEventListener('click', () => {
          const modal = document.getElementById('autoSealModal');
          if (modal) {
            modal.classList.add('show');
            modal.setAttribute('aria-hidden', 'false');
          }
        });
      }

      // ▼ 추천 마법봉인 모달 닫기 및 버튼 클릭 처리(선택 시 닫기)
      const autoSealModal = document.getElementById('autoSealModal');
      if (autoSealModal) {
        autoSealModal.addEventListener('click', (e) => {
          if (
            e.target.hasAttribute('data-close') ||
            e.target.classList.contains('backdrop')
          ) {
            autoSealModal.classList.remove('show');
            autoSealModal.setAttribute('aria-hidden', 'true');
          }
        });

        // 4개 속성 버튼(화/수/명/암) 클릭 시 동작(현재는 모달만 닫기)
        autoSealModal.querySelectorAll('.opt-btnetc').forEach(btn => {
          btn.addEventListener('click', () => {
            // TODO: 여기서 선택한 속성에 맞춰 '추천 마법봉인 자동 입력' 로직을 이어가면 됩니다.
            // const element = btn.dataset.ele; // "fire" | "water" | "light" | "dark"

            autoSealModal.classList.remove('show');
            autoSealModal.setAttribute('aria-hidden', 'true');
          });
        });
      }

      // Build level buttons 10~20
      if (autoEnhList) {
        autoEnhList.innerHTML = '';
        for (let lv = 10; lv <= 20; lv++) {
          const b = document.createElement('button'); b.className = 'opt-btnetc'; b.textContent = `${lv}강`;
          b.addEventListener('click', async () => { await autoEnhanceApply(lv); autoEnhModal.classList.remove('show'); autoEnhModal.setAttribute('aria-hidden', 'true'); });
          autoEnhList.appendChild(b);
        }
      }

      // Openers
      document.getElementById('btnAutoEnh')?.addEventListener('click', () => {
        autoEnhModal.classList.add('show'); autoEnhModal.setAttribute('aria-hidden', 'false');
      });
      document.getElementById('btnAutoEmblem')?.addEventListener('click', () => {
  const modal = document.getElementById('autoEmblemModal');
  autoEmblemState.attr = null;
  autoEmblemState.stage = null;
  renderAutoEmblemChoices();
  modal.classList.add('show');
  modal.setAttribute('aria-hidden', 'false');
});
      document.getElementById('btnAutoEnchant')?.addEventListener('click', () => {
        // 모달 열기만; 닫기는 tryApplyAutoIfReady에서 두 값이 모두 선택됐을 때만
        autoEnchantState.attr = null;
        autoEnchantState.tier = null;
        renderAutoEnchantChoices();
        showModal(document.getElementById('autoEnchantModal'), true);
      });
      // Modal close bindings
      document.querySelectorAll('#autoEnhModal, #autoEmblemModal, #autoEnchantModal').forEach(modal => {
        modal.addEventListener('click', (e) => {
          if (e.target.hasAttribute('data-close') || e.target.classList.contains('close') || e.target.classList.contains('backdrop')) {
            modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true');
          }
        });
      });
      /* ===== [SEAL][AUTO] 추천 마법봉인 자동 입력 ===== */

      // 슬롯코드 → "마법부여 종류키"와 별개로, 봉인용 "종류" 매핑
      // - 무기부위: 무기고유 / 무기일반
      // - 방어부위(L1~L5): 방어고유 / 방어일반
      // - 보조장비(R5): 보장고유 / 보장일반
      // - 액세서리(R2~R4): 악세고유 / 악세일반  (← 속성으로 찾기)
      function sealTypeForSlot(slotCode) {
        switch (String(slotCode).toUpperCase()) {
          case 'R1': return { unique: '무기고유', general: '무기일반' };
          case 'R5': return { unique: '보장고유', general: '보장일반' };
          case 'R2':
          case 'R3':
          case 'R4': return { unique: '악세고유', general: '악세일반' };
          default: return { unique: '방어고유', general: '방어일반' }; // L1~L5
        }
      }

      // 현재 선택 캐릭터의 공격 분류를 '물리' / '마법'로 변환
      function jobGroupKeyFromState() {
        const p = state?.currentCharacter?.power;
        return p === 'mag' ? '마법' : '물리';
      }

      // 시트의 속성 한글 키 매핑
      const ELEM_KOR = { fire: '화', water: '수', light: '명', dark: '암' };

      // byType 캐시에서 조건(직업군/속성)에 맞는 "첫 번째" 봉인 옵션을 찾아 반환
      function findSealOption(typeKey, { jobKey, elemKor }) {
        const key = String(typeKey).trim();
        const list = ENCHANT_CACHE.byType.get(String(typeKey).trim()) || [];
        // 악세는 속성으로, 나머지는 직업군으로 찾는다
        const isAcc = typeKey.startsWith('악세');
        if (key === '무기고유') {
          const isCommon = (v) => {
            const s = String(v || '').trim();
            return ['공용', '공통', 'ALL', '무기공용'].includes(s);
          };
          // 1순위: 직업군열이 공용/ALL류인 행
          const pick =
            list.find(it => isCommon((it.raw && it.raw['직업군']) ?? it.jobGroup)) ||
            list[0] || null; // 2순위: 첫 행(없으면 null)
          return pick;
        }
        for (const it of list) {
          const raw = it.raw || {};
          if (isAcc) {
            const v = String(raw['직업군'] ?? raw['element'] ?? raw['elem'] ?? '').trim();
            if (v === elemKor) return it;
          } else {
            const v = String(raw['직업군'] ?? it.jobGroup ?? '').trim();
            if (v === jobKey) return it;
          }
        }
        return null;
      }

      // 도우미: raw에서 최소한의 스탯을 뽑아내는 보조 (시트에 stats가 없을 때 대비)
      function statsFrom(opt) {
        if (!opt) return null;
        // ENCHANT_CACHE 프리로드에서 이미 obj.stats를 살려둠. 없으면 raw에서 필요한 키만 최소 추출
        return opt.stats || null; // 필요시 raw 기반 파싱 추가
      }

      // 실제 적용: 속성 클릭 시 전 슬롯에 맞는 고유/일반을 찾아 state.seals에 저장 + 캡션 갱신
      async function applyAutoSeal(elementKey) {
        await ensureEnchantCache();             // 시트 캐시 보장 (기존 캐시 사용)
        const elemKor = ELEM_KOR[elementKey] || '';
        const jobKey = jobGroupKeyFromState(); // '물리' or '마법'
        const targetSlots = ['R1', 'R2', 'R3', 'R4', 'R5', 'L1', 'L2', 'L3', 'L4', 'L5'];

        state.seals = state.seals || {};

        for (const slotCode of targetSlots) {
          const types = sealTypeForSlot(slotCode);
          const u = findSealOption(types.unique, { jobKey, elemKor });
          const g = findSealOption(types.general, { jobKey, elemKor });

          // 슬롯키(SLOT_MAP: 'R1'→실제 내부키 등)를 얻어서 상태에 반영
          const slotKey = (window.SLOT_MAP || {})[slotCode];
          if (!slotKey) continue;

          // 적용 규칙: 고유 1개 + 일반 2개(동일 일반일 경우 g를 두 칸 복제)
          // (시트 설계상 일반이 2종으로 구분돼 있다면 여기를 확장)
          // 적용 규칙: 고유 1 + 일반 2
          state.seals[slotKey] = {
            unique: u ? { name: u.name, typeKey: u.typeKey, stats: statsFrom(u), raw: u.raw } : null,
            general1: g ? { name: g.name, typeKey: g.typeKey, stats: statsFrom(g), raw: g.raw } : null,
            general2: g ? { name: g.name, typeKey: g.typeKey, stats: statsFrom(g), raw: g.raw } : null,
          };

          // 슬롯 칩(라벨) 즉시 갱신
          refreshSealCaptionsForSlot(slotKey);
          // 이미 코드에 존재하는 유틸 재사용 :contentReference[oaicite:5]{index=5}
        }
        // ✅ 여기서 전체 갱신 + 버튼 라벨 + 합산
        // 전체 칩 리프레시(화면 동기화)
        refreshSealCaptionsFromState();

        // 두 번째 버튼 라벨을 '마봉 설정완료'로 일괄 갱신
        if (typeof refreshSealLabelsFromState === 'function') {
          refreshSealLabelsFromState();
        }

        // 합산 재계산 + 우측 패널 렌더
        if (typeof recalcAndRenderPanel === 'function') {
          recalcAndRenderPanel();
        }

        // 모달 닫기
        const modal = document.getElementById('autoSealModal');
        if (modal) { modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true'); }
      }

      // ▼ 모달의 속성 버튼과 연결
      const $autoSealModal = document.getElementById('autoSealModal');
      if ($autoSealModal) {
        $autoSealModal.querySelectorAll('.opt-btnetc[data-ele]').forEach(btn => {
          btn.addEventListener('click', () => {
            const ele = btn.getAttribute('data-ele'); // 'fire' | 'water' | 'light' | 'dark'
            applyAutoSeal(ele);
          });
        });
      }

    });

  </script>
  <script>
    // ===== BuffLeveling: "레벨링(N)" 합산 →의 스킬렙제=N에 적용 =====
    // (기존 모듈 구조 유지, preload()만 교체)

    window.BuffLeveling = (() => {
      const cache = { ready: false, rows: [] };

      // 숫자/퍼센트 파서 — 그대로 유지
      const num = v => {
        const n = Number(String(v ?? "").replace(/[, ]/g, ""));
        return Number.isFinite(n) ? n : 0;
      };
      const pct = v => num(v) / 100;

      // 레벨0 기준 stats — 그대로 유지
      function rowToBaseStats(r) {
        return {
          phys_atk: num(r["물뎀"]), mag_atk: num(r["마뎀"]),
          str: num(r["힘"]), int: num(r["지능"]),
          acc: num(r["적중"]),
          phys_crit: num(r["물크"]) || num(r["물/마크"]),
          mag_crit: num(r["마크"]) || num(r["물/마크"]),
          phys_crit_rate: pct(r["물크(%)"]),
          mag_crit_rate: pct(r["마크(%)"]),
          add_damage: pct(r["추뎀(%)"]),
          damage_inc: pct(r["뎀증(%)"]),
          crit_damage_inc: pct(r["크증뎀(%)"]),
          phys_atk_pct: pct(r["물공(%)"]),
          mag_atk_pct: pct(r["마공(%)"]),
          skill_atk_inc: pct(r["스증(%)"]),
          elem: {
            fire: num(r["화"]), water: num(r["수"]), light: num(r["명"]), dark: num(r["암"]), all: 0
          },
          elem_add_damage: {
            fire: pct(r["화속추"]), water: pct(r["수속추"]), light: pct(r["명속추"]), dark: pct(r["암속추"])
          },
          speed: { attack: pct(r["공속(%)"]), move: pct(r["이속(%)"]), cast: pct(r["캐속(%)"]) },
          cdr: pct(r["쿨감(%)"]),
          dot_add: { poison: 0, bleed: pct(r["출혈추뎀"]), burn: pct(r["화상추뎀"]), shock: pct(r["감전추뎀"]) },
          dot_inc: { poison: 0, bleed: pct(r["출혈뎀증"]), burn: pct(r["화상뎀증"]), shock: pct(r["감전뎀증"]) },
          other: { def_break_inc: pct(r["방깎뎀증(%)"]), enchant_bleed: num(r["인챈출혈"]) }
        };
      }

      // 키 정규화 유틸
      function normVal(s) {
        return String(s ?? '')
          .normalize('NFC')
          .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
          .replace(/\s+/g, '');
      }

      // ★ preload(): CSV → (변경) 프록시&백엔드 JSON
      async function preload() {
        if (cache.ready) return;

        // 1) 로그인 토큰 확보
        const token = await waitForIdToken();

        // 2) 프록시 → Apps Script: ?type=buff
        const r = await fetch(window.WEBAPP_URL + '?type=buff', {
          method: 'POST',
          mode: 'cors',
          cache: 'no-store',
          headers: { 'Content-Type': 'text/plain' },
          body: token
        });
        if (!r.ok) throw new Error('buff_fetch_failed');
        const data = await r.json();
        if (!data.ok || !Array.isArray(data.rows)) throw new Error('bad_buff_payload');

        // 3) __charKey 생성(직업군+캐릭터명 정규화) + 원본 컬럼 유지
        const normVal = (v) => String(v ?? '')
          .normalize('NFC')
          .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
          .replace(/\s+/g, '');

        cache.rows = data.rows.map(row => {
          const job = row['직업군'] || row['직업'] || '';
          const name = row['캐릭터'] || row['캐릭터명'] || row['캐릭명'] || row['직업명'] || '';
          const charKey = normVal(job + name) || normVal(name);
          return { ...row, __charKey: charKey };
        });

        console.log('[BUFF-DEBUG] BUFF rows:', cache.rows.length,
          '샘플 __charKey:', cache.rows.slice(0, 5).map(r => r.__charKey));

        cache.ready = true;
      }

      // (중략) — 네 코드의 computeBuffStats(), addStats/scaleAdd 등 기존 로직은 그대로 사용
      // 단, computeBuffStats()가 cache.rows를 참조하도록 유지하면 됨
      // base × (1 + 증가율 × level)
      function scale(base, rate, level) {
        const m = 1 + (Number(rate) || 0) * (level | 0);
        const c = structuredClone(base);

        c.phys_atk *= m; c.mag_atk *= m; c.str *= m; c.int *= m; c.acc *= m; c.phys_crit *= m; c.mag_crit *= m;
        c.phys_crit_rate *= m; c.mag_crit_rate *= m; c.add_damage *= m; c.damage_inc *= m; c.crit_damage_inc *= m;
        c.phys_atk_pct *= m; c.mag_atk_pct *= m; c.skill_atk_inc *= m;
        c.elem.fire *= m; c.elem.water *= m; c.elem.light *= m; c.elem.dark *= m;
        c.elem_add_damage.fire *= m; c.elem_add_damage.water *= m; c.elem_add_damage.light *= m; c.elem_add_damage.dark *= m;
        c.speed.attack *= m; c.speed.move *= m; c.speed.cast *= m; c.cdr *= m;
        c.dot_add.bleed *= m; c.dot_add.burn *= m; c.dot_add.shock *= m;
        c.dot_inc.bleed *= m; c.dot_inc.burn *= m; c.dot_inc.shock *= m;
        c.other.def_break_inc *= m; c.other.enchant_bleed *= m;
        return c;
      }

      // stats 합치기 (네 sumSelections의 add 규칙과 동일하게 가산)
      function addStats(dst, st) {
        if (!st) return dst;
        dst.phys_atk += st.phys_atk || 0; dst.mag_atk += st.mag_atk || 0;
        dst.str += st.str || 0; dst.int += st.int || 0;
        dst.phys_crit += st.phys_crit || 0; dst.mag_crit += st.mag_crit || 0;
        dst.phys_crit_rate += st.phys_crit_rate || 0; dst.mag_crit_rate += st.mag_crit_rate || 0;
        dst.add_damage += st.add_damage || 0; dst.damage_inc += st.damage_inc || 0; dst.crit_damage_inc += st.crit_damage_inc || 0;
        dst.phys_atk_pct += st.phys_atk_pct || 0; dst.mag_atk_pct += st.mag_atk_pct || 0;
        dst.skill_atk_inc += st.skill_atk_inc || 0;
        if (st.elem) { dst.elem.fire += st.elem.fire || 0; dst.elem.water += st.elem.water || 0; dst.elem.light += st.elem.light || 0; dst.elem.dark += st.elem.dark || 0; }
        dst.cdr += st.cdr || 0;
        if (st.speed) { dst.speed.attack += st.speed.attack || 0; dst.speed.move += st.speed.move || 0; dst.speed.cast += st.speed.cast || 0; }
        if (st.other) { dst.def_break_inc += st.other.def_break_inc || 0; }
        return dst;
      }

      function emptyStatsLikeSum() {
        return {
          phys_atk: 0, mag_atk: 0, str: 0, int: 0, acc: 0,
          phys_crit: 0, mag_crit: 0, phys_crit_rate: 0, mag_crit_rate: 0,
          add_damage: 0, damage_inc: 0, crit_damage_inc: 0,
          phys_atk_pct: 0, mag_atk_pct: 0, skill_atk_inc: 0,
          elem: { fire: 0, water: 0, light: 0, dark: 0, all: 0 },
          speed: { attack: 0, move: 0, cast: 0 },
          cdr: 0, def_break_inc: 0
        };
      }

      // 선택 아이템에서 "레벨링(N)" 컬럼 추출 → {N: sum}
      // 붙일 위치: 버프 모듈 파일(혹은 공용 util)에 선언
      function collectItemLevelings(selections) {
        const out = Object.create(null);

        // 슬롯별로 배열/단일객체 섞여도 모두 순회
        const eachItems = (sel) => (
          !sel ? [] :
            Array.isArray(sel) ? sel :
              [sel.selected || sel].filter(Boolean)
        );

        // 숫자 파서(쉼표/문자 제거)
        const toNum = (v) => {
          const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
          return Number.isFinite(n) ? n : 0;
        };

        // "레벨링(10)", "레벨링10", "Lv10", "레벨 10", "버프레벨(10)" 등 허용
        const isLevelCol = (k) => {
          const s = String(k || '').replace(/\s+/g, '');
          return /^(?:레벨링|레벨|버프레벨|Lv|LV)\(?\d+\)?$/.test(s);
        };
        const pickLevel = (k) => {
          const m = String(k || '').replace(/\s+/g, '').match(/(\d+)/);
          return m ? Number(m[1]) : NaN;
        };

        for (const [, sel] of Object.entries(selections || {})) {
          for (const it of eachItems(sel)) {
            const raw = it?.raw || it;
            if (!raw || typeof raw !== 'object') continue;

            for (const [k, v] of Object.entries(raw)) {
              if (!isLevelCol(k)) continue;
              const N = pickLevel(k);           // 10 / 15 / 25 / …
              const val = toNum(v);             // 1, 2, …
              if (!Number.isFinite(N) || !val) continue;
              out[N] = (out[N] || 0) + val;
              console.log('[BUFF-DEBUG] 레벨링 감지:', { col: k, N, val, item: it?.name || raw?.이름 || '?' });
            }
          }
        }

        console.log('[BUFF-DEBUG] 레벨링 합산 맵:', out); // 예: {10:8, 15:2}
        return out;
      }

      // 1) 강력 정규화 유틸 (기존 cleanUrl 포함 확장)
      function norm(s) {
        // cleanUrl: 앞뒤 공백/따옴표 제거, 백슬래시 → 슬래시
        const base = cleanUrl(s);
        // 제로폭/비가시 공백류 추가 제거 + 모든 공백 제거
        return String(base)
          .normalize('NFC')
          .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
          .replace(/\s+/g, '');
      }
      // 2) BUFF 로더: __charKey 생성 보강 + 로깅 보강

      // base 객체에서 숫자 필드(0이 아닌 곳)에만 delta를 더함 (중첩 객체도 처리)
      function addDeltaWherePresent(base, delta) {
        const walk = (obj) => {
          if (!obj || typeof obj !== 'object') return obj;
          const out = Array.isArray(obj) ? [] : {};
          for (const [k, v] of Object.entries(obj)) {
            if (v && typeof v === 'object') {
              out[k] = walk(v);
            } else if (typeof v === 'number') {
              out[k] = (v !== 0) ? (v + delta) : v;
            } else {
              out[k] = v;
            }
          }
          return out;
        };
        return walk(base);
      }

      // ★ 가산형 스케일: "원래값 + (증가율 * 레벨링합)"
      function scaleAdd(baseStats, incRaw, levelCount) {
        // 네가 이미 가진 toNum() 재사용 (%, 글자 등 있으면 숫자만 남기고 싶으면 아래 한 줄 활성화)
        // incRaw = String(incRaw).replace(/[^0-9.-]/g, '');
        const inc = toNum(incRaw);      // 예: "4" -> 4
        const steps = toNum(levelCount);  // 예: 8
        const delta = inc * steps;        // 예: 32
        return addDeltaWherePresent(baseStats, delta);
      }


      // 3) 매칭: 현재 선택 캐릭터 키 만들기 + 필터
      async function computeBuffStats() {
        if (!(state.currentCharacter?.name)) {
          return null; // 캐릭터 없으면 버프 미적용
        }
        if (!cache.ready) await preload();
        // ★ 예외규칙: 버프레벨 적용을 위해 로드/활성화
        await ensureExceptionLoaded();   // 토큰 보장 후 예외 시트 로드
        refreshActiveExceptions();       // __EXC.buffLvByName 갱신
        console.log('[EXC] buffLvByName =', __EXC?.buffLvByName || {});
        const fullName = normVal(
          (state.currentCharacter?.jobGroupLabel || '') +
          (state.currentCharacter?.name || '')
        );

        // __charKey는 이미 정규화된 상태
        const rows = cache.rows.filter(r => r.__charKey === fullName);
        console.log('[BUFF-DEBUG] 매칭:', { fullName, count: rows.length });

        const levMap = collectItemLevelings?.(state.selections || {}) || {};
        state.leveling = levMap; // ★ 일반 스킬 레벨링 적용을 위한 전역 저장
        console.log('[BUFF-DEBUG] 레벨링 합산:', levMap);

        let total = emptyStatsLikeSum();
        for (const r of rows) {
          const skillName = String(r['스킬명'] || r['skillname'] || '').trim();
          const req = Number(r['스킬렙제'] || r['skillreq'] || 0);
          // (교체 코드: 가산형 적용)
          const incRaw = r['증가율'] || r['rate'] || 0;  // 원문 유지
          const base = rowToBaseStats(r);
          // 버프 이름 정규화(공백/제로폭 제거)
          const normName = s => String(s ?? '')
            .normalize('NFC')
            .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
            .replace(/\s+/g, '');

          const baseLevel = toNum(levMap[req] || 0);  // 아이템 레벨링 합
          const excBonus = Number(__EXC?.buffLvByName?.[normName(skillName)] || 0); // ★ 예외 '버프레벨'
          const level = baseLevel + excBonus;     // ← 합산 적용
          const scaled = scaleAdd(base, incRaw, level);  // ★ 가산형
          // ★ 확인용 로그
          if (excBonus) {
            console.log(`[BUFF-BONUS] '${skillName}' 레벨 +${excBonus} (base=${baseLevel} → level=${level})`);
          } else {
            console.log(`[BUFF-DEBUG] '${skillName}' 레벨 보너스 없음 (base=${baseLevel})`);
          }
          console.log(
            `[BUFF-DEBUG] req=${req}, level=${level}, inc=${incRaw} → delta=${toNum(incRaw) * level}`,
            { base, scaled }
          );
          total = addStats(total, scaled);
        }
        console.log('[BUFF-DEBUG] 최종 합산 버프 스탯:', total);
        return total;
      }
      return { preload, computeBuffStats };
    })();
  </script>

  <script>
    /* ======== 마법봉인(슬롯별 3구역 단일 선택) & 마법부여 ======== */
    (function () {
      // 상태 슬롯
      window.state = window.state || {};
      state.seals = state.seals || {}; // { [slotKey]: { unique, general1, general2 } }
      state.enchants = state.enchants || {}; // { [slotKey]: {name, stats...} }

      /* ===== 마법봉인: 모달/스타일 동적 생성 ===== */
      function ensureSealModalBuilt() {
        if (document.getElementById('sealModal')) return;
        const html = `
<div id="sealModal" class="modal" aria-hidden="true">
  <div class="backdrop" data-close></div>
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="sealDlgTitle"
       style="width:min(980px,95vw);height:min(1620px,88vh);">
    <header>
      <h2 id="sealDlgTitle">마법봉인 설정</h2>
    </header>
    <div class="items" style="padding:10px;">
      <div class="seal-grid">
        <div class="seal-col">
          <div class="seal-col-title">고유옵션</div>
          <div id="sealListUnique" class="seal-list"></div>
        </div>
        <div class="seal-col">
          <div class="seal-col-title">일반옵션 1</div>
          <div id="sealListGeneral1" class="seal-list"></div>
        </div>
        <div class="seal-col">
          <div class="seal-col-title">일반옵션 2</div>
          <div id="sealListGeneral2" class="seal-list"></div>
        </div>
      </div>
    </div>
  </div>
</div>`;
        document.body.insertAdjacentHTML('beforeend', html);
        const modal = document.getElementById('sealModal');
        modal.addEventListener('click', (e) => {
          if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeSealModal();
        });
      }

      function ensureSealStyles() {
        if (document.getElementById('sealStyles')) return;
        const css = `
.seal-grid { display:grid; background: #0e0b09; grid-template-columns:1fr 1fr 1fr; gap:12px; }
.seal-col { border:1px solid var(--border, #333); background: #0e0b09; border-radius:12px; padding:10px; overflow:auto; max-height: calc(88vh - 140px); }
.seal-col-title { font-weight:700; color: #f0e6d2; background: #0e0b09; margin-bottom:8px; }
.seal-option { display:grid; width:100%; text-align:left; padding:8px 10px; color: #f0e6d2; cousor: pointer; margin:4px 0; border-radius:10px;
  border:1px solid var(--border,#333); background:var(--card,#1a130f); cursor:pointer; font-size:13px; }
.seal-option:hover { border-color: #xfa24f; box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset; filter:brightness(1.08); }
.seal-option.selected { outline:2px solid #e7c27a; }
`;
        const s = document.createElement('style'); s.id = 'sealStyles'; s.textContent = css;
        document.head.appendChild(s);
      }

      function closeSealModal() {
        const modal = document.getElementById('sealModal');
        if (modal) { modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true'); }
        state.ui = state.ui || {};
        state.ui.sealTemp = null;
      }

      function sealTypeKeysForSlot(slotKey) {
        if (slotKey === 'weapon') return { u: '무기고유', g: '무기일반' };
        if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slotKey))
          return { u: '방어고유', g: '방어일반' };
        if (['bracelet', 'necklace', 'ring'].includes(slotKey))
          return { u: '악세고유', g: '악세일반' };
        if (slotKey === 'support') return { u: '보장고유', g: '보장일반' };
        return null;
      }

      /* ===== 마법부여: 로직 ===== */
      function enchantTypeForSlot(slotKey) {
        return ({
          weapon: '무기마부', top: '상의마부', bottom: '하의마부',
          headshoulder: '머리어깨마부', belt: '허리마부', shoes: '신발마부',
          bracelet: '팔찌마부', necklace: '목걸이마부', ring: '반지마부',
          support: '보장마부'
        })[slotKey] || null;
      }

      function closeEnchantPicker() {
        const modal = document.getElementById('enchantModal');
        if (modal) {
          modal.classList.remove('show');
          modal.setAttribute('aria-hidden', 'true');
        }
      }

      async function openEnchantPicker(slotKey, btnEl) {
        const type = enchantTypeForSlot(slotKey);
        if (!type) return;

        if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

        const list = (DBEnh.byType[type] || []).slice();
        const enchantListEl = document.getElementById('enchantList');
        enchantListEl.innerHTML = '';

        list.forEach(opt => {
          const b = document.createElement('button');
          b.className = 'enh-option';
          b.textContent = opt.name || '(이름없음)';
          b.onclick = () => {
            state.enchants[slotKey] = opt;
            if (btnEl) btnEl.textContent = opt.name;
            closeEnchantPicker();
            if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
          };
          enchantListEl.appendChild(b);
        });

        const enchantDlgTitle = document.getElementById('enchantDlgTitle');
        if (enchantDlgTitle) {
          enchantDlgTitle.textContent = `${window.labelForSlot(slotKey) || '아이템'} 마법부여 선택`;
        }

        const enchantModal = document.getElementById('enchantModal');
        if (enchantModal) {
          enchantModal.classList.add('show');
          enchantModal.setAttribute('aria-hidden', 'false');
        }
      }


      /* ===== 공통 UI 갱신 로직 ===== */
      function refreshSealLabelsFromState() {
        document.querySelectorAll('.slot-row').forEach(row => {
          const slotEl = row.querySelector('.slot'); const code = slotEl?.getAttribute('data-slot');
          const slotKey = (window.SLOT_MAP || {})[code]; const rects = row.querySelectorAll('.outer-rects .rect');
          if (!slotKey || rects.length < 2) return;
          const has = !!(state.seals?.[slotKey]?.unique && state.seals?.[slotKey]?.general1 && state.seals?.[slotKey]?.general2);
          rects[1].textContent = has ? '마봉 설정완료' : '마봉 설정';
          refreshSealCaptionsForSlot(slotKey);
        });
      }

      function getSealCaptionText(obj) {
        if (!obj) return "";
        return (obj.badge ?? obj.level ?? obj.label ?? obj.text ?? obj.caption ?? obj.name ?? obj.imgText ?? "").toString().trim();
      }

      function refreshSealCaptionsForSlot(slotKey) {
        if (!slotKey) return;
        const el = window.tileElForSlot(slotKey);
        if (!el) return;
        const code = el.getAttribute('data-slot') || "";
        if (el.classList.contains('mini') || /^C[1-4]$/.test(code)) return;

        let cap = el.querySelector('.seal-captions');
        if (!cap) {
          cap = document.createElement('div');
          cap.className = 'seal-captions';
          el.appendChild(cap);
        }
        cap.innerHTML = '';

        const sel = (state.seals || {})[slotKey] || {};
        const u = sel.unique || null;
        const g1 = sel.general1 || null;
        const g2 = sel.general2 || null;

        const uTxt = getSealCaptionText(u);
        const g1Txt = getSealCaptionText(g1);
        const g2Txt = getSealCaptionText(g2);

        if (!uTxt && !g1Txt && !g2Txt) { cap.style.display = 'none'; return; }
        cap.style.display = 'flex';

        if (uTxt) {
          const rowU = document.createElement('div');
          rowU.className = 'seal-row seal-row-unique';
          const chipU = document.createElement('div');
          chipU.className = 'seal-chip';
          chipU.textContent = uTxt;
          rowU.appendChild(chipU);
          cap.appendChild(rowU);
        }

        if (g1Txt || g2Txt) {
          const rowG = document.createElement('div');
          rowG.className = 'seal-row seal-row-general';
          if (g1Txt) {
            const chip1 = document.createElement('div');
            chip1.className = 'seal-chip';
            chip1.textContent = g1Txt;
            rowG.appendChild(chip1);
          }
          if (g2Txt) {
            const chip2 = document.createElement('div');
            chip2.className = 'seal-chip';
            chip2.textContent = g2Txt;
            rowG.appendChild(chip2);
          }
          cap.appendChild(rowG);
        }
      }

      function refreshSealCaptionsFromState() {
        document.querySelectorAll('.slot-row .slot').forEach(slotEl => {
          const code = slotEl.getAttribute('data-slot');
          if (!code) return;
          const slotKey = (window.SLOT_MAP || {})[code];
          if (!slotKey) return;
          if (slotEl.classList.contains('mini') || /^C[1-4]$/.test(code)) return; // 미니 제외
          refreshSealCaptionsForSlot(slotKey);
        });
      }

      function buildSealList(listEl, choices, current, onPick) {
        listEl.innerHTML = '';
        choices.forEach(opt => {
          const b = document.createElement('button');
          b.className = 'seal-option' + ((current && current.name === opt.name) ? ' selected' : '');
          b.textContent = opt.name || '(이름없음)';
          b.title = opt.tag ? `분류: ${opt.tag}` : '';
          b.addEventListener('click', () => onPick(opt, b));
          listEl.appendChild(b);
        });
      }

      function tryFinalizeSeal(slotKey, btnEl) {
        const tmp = state.ui?.sealTemp;
        if (!tmp) return;
        if (tmp.unique && tmp.general1 && tmp.general2) {
          state.seals[slotKey] = { unique: tmp.unique, general1: tmp.general1, general2: tmp.general2 };
          refreshSealCaptionsForSlot(slotKey);
          if (btnEl) btnEl.textContent = '마봉 설정완료';
          if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
          closeSealModal();
        }
      }

      async function openSealModal(slotKey, btnEl) {
        ensureSealStyles();
        ensureSealModalBuilt();
        if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

        const keys = sealTypeKeysForSlot(slotKey);
        if (!keys) return;

        const uniq = (DBEnh?.byType?.[keys.u] || (DBEnh?.list || []).filter(o => (o?.type || '') === keys.u)).slice();
        const gen = (DBEnh?.byType?.[keys.g] || (DBEnh?.list || []).filter(o => (o?.type || '') === keys.g)).slice();

        state.ui = state.ui || {};
        const prev = (state.seals?.[slotKey]) || {};
        state.ui.sealTemp = {
          unique: prev.unique || null, general1: prev.general1 || null, general2: prev.general2 || null, slotKey, btnEl
        };

        const $ = (id) => document.getElementById(id);
        const listU = $('sealListUnique'), listG1 = $('sealListGeneral1'), listG2 = $('sealListGeneral2');

        buildSealList(listU, uniq, prev.unique, (opt, btn) => {
          state.ui.sealTemp.unique = opt;
          listU.querySelectorAll('.seal-option').forEach(x => x.classList.remove('selected')); btn.classList.add('selected');
          tryFinalizeSeal(slotKey, btnEl);
        });
        buildSealList(listG1, gen, prev.general1, (opt, btn) => {
          state.ui.sealTemp.general1 = opt;
          listG1.querySelectorAll('.seal-option').forEach(x => x.classList.remove('selected')); btn.classList.add('selected');
          tryFinalizeSeal(slotKey, btnEl);
        });
        buildSealList(listG2, gen, prev.general2, (opt, btn) => {
          state.ui.sealTemp.general2 = opt;
          listG2.querySelectorAll('.seal-option').forEach(x => x.classList.remove('selected')); btn.classList.add('selected');
          tryFinalizeSeal(slotKey, btnEl);
        });

        const modal = document.getElementById('sealModal');
        modal.classList.add('show'); modal.setAttribute('aria-hidden', 'false');
      }

      // DOM 로드 후 바인딩
      document.addEventListener('DOMContentLoaded', () => {
        refreshSealLabelsFromState();

        const enchantModal = document.getElementById('enchantModal');
        if (enchantModal) {
          enchantModal.addEventListener('click', (e) => {
            if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) {
              closeEnchantPicker();
            }
          });
        }

        document.querySelectorAll('.slot-row').forEach(row => {
          const slotEl = row.querySelector('.slot');
          const code = slotEl?.getAttribute('data-slot');
          const slotKey = (window.SLOT_MAP || {})[code];
          const rects = row.querySelectorAll('.outer-rects .rect');
          if (!slotKey) return;

          // 마봉 (두번째 버튼)
          if (rects.length >= 2) {
            const secondBtn = rects[1];
            secondBtn.textContent = '마봉 설정';
            secondBtn.addEventListener('click', (e) => { e.stopPropagation(); openSealModal(slotKey, secondBtn); });
          }

          // 마법부여 (세번째 버튼)
          if (rects.length >= 3) {
            const thirdBtn = rects[2];
            if (enchantTypeForSlot(slotKey)) {
              thirdBtn.textContent = '마법 부여';
              thirdBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                openEnchantPicker(slotKey, thirdBtn);
              });
            } else {
              thirdBtn.classList.add('disabled');
            }
          }
        });
      });

      // 합산 함수 확장: 마봉, 마부 스탯 합산
      // 합산 함수 확장: 마봉, 마부 스탯 합산
      try {
        const _base = window.sumSelections;
        if (typeof _base === 'function') {
          window.sumSelections = function () {
            const S = _base();

            // 누적기 안전 보정
            S.__skillMul = S.__skillMul || 1;
            S.__skillAddBuff = S.__skillAddBuff || 0;

            const add = (st, src = 'other') => {
              if (!st) return;

              // 1) 스증 분기
              if (st.skill_atk_inc) {
                if (src === 'buff') S.__skillAddBuff += (st.skill_atk_inc || 0);   // (여기선 안 씀)
                else S.__skillMul *= (1 + (st.skill_atk_inc || 0));  // 마봉/마부는 곱
              }

              // 2) 나머지 스탯 가산
              S.phys_atk += st.phys_atk || 0; S.mag_atk += st.mag_atk || 0;
              S.str += st.str || 0; S.int += st.int || 0;
              S.phys_crit += st.phys_crit || 0; S.mag_crit += st.mag_crit || 0;
              S.phys_crit_rate += st.phys_crit_rate || 0; S.mag_crit_rate += st.mag_crit_rate || 0;
              S.add_damage += st.add_damage || 0;
              if (st.elem_add_damage) {
                S.elem_add.fire += st.elem_add_damage.fire || 0;
                S.elem_add.water += st.elem_add_damage.water || 0;
                S.elem_add.light += st.elem_add_damage.light || 0;
                S.elem_add.dark += st.elem_add_damage.dark || 0;
              }
              S.str_pct += st.str_pct || 0; S.int_pct += st.int_pct || 0;
              S.damage_inc += st.damage_inc || 0; S.crit_damage_inc += st.crit_damage_inc || 0;
              S.phys_atk_pct += st.phys_atk_pct || 0; S.mag_atk_pct += st.mag_atk_pct || 0;
              if (st.elem) { S.elem.fire += st.elem.fire || 0; S.elem.water += st.elem.water || 0; S.elem.light += st.elem.light || 0; S.elem.dark += st.elem.dark || 0; }
              S.cdr += st.cdr || 0;
              if (st.speed) { S.speed.attack += st.speed.attack || 0; S.speed.move += st.speed.move || 0; S.speed.cast += st.speed.cast || 0; }
              if (st.other) { S.def_break_inc += st.other.def_break_inc || 0; }
              S.counter_add_damage += st.counter_add_damage || 0;
              S.counter_damage_inc += st.counter_damage_inc || 0;
            };

            // 마봉(시일/seal)
            Object.values(state.seals || {}).forEach(p => {
              if (p?.unique?.stats) add(p.unique.stats, 'other');
              if (p?.general1?.stats) add(p.general1.stats, 'other');
              if (p?.general2?.stats) add(p.general2.stats, 'other');
            });

            // 마부(enchants)
            Object.values(state.enchants || {}).forEach(p => {
              if (p?.stats) add(p.stats, 'other');
            });

            // ★ 여기서 최종 스증 확정: (곱-1) + 버프합
            S.skill_atk_inc = (S.__skillMul - 1) + S.__skillAddBuff;

            // 임시 키 정리(선택)
            // delete S.__skillMul; delete S.__skillAddBuff;

            return S;
          };
        }
      } catch (e) { console.warn('Seal/Enchant sumSelections extension failed', e); }


      // 전역에서 접근 필요 시 export
      window.refreshSealLabelsFromState = refreshSealLabelsFromState;
      window.refreshSealCaptionsForSlot = refreshSealCaptionsForSlot;
      window.refreshSealCaptionsFromState = refreshSealCaptionsFromState;
      if (document.readyState !== 'loading') {
        refreshSealCaptionsFromState();
      } else {
        document.addEventListener('DOMContentLoaded', refreshSealCaptionsFromState);
      }

      window.openSealModal = openSealModal;
    })();

    /* === FINAL DERIVED STATS EXTENSION (do this LAST) === */
    try {
      const _base = window.sumSelections;
      if (typeof _base === 'function') {
        window.sumSelections = function () {
          const S = _base();

          // ---- (A) 속추 합계 재확인(중복 방지: 합계는 오직 여기서만) ----
          S.elem_add_sum =
            (S.elem_add?.fire || 0) +
            (S.elem_add?.water || 0) +
            (S.elem_add?.light || 0) +
            (S.elem_add?.dark || 0);

          // ---- (B) 유효 속추: 속추 * (1.05 + 0.0045 * (속강 - 적저)) ----
          const M = (state && state.monster) ? state.monster : {};
          const eff = (k) => {
            const base = (S.elem_add?.[k] || 0);
            const atk = (S.elem?.[k] || 0);
            const res = (M?.[k] || 0);
            return base * (1.05 + 0.0045 * (atk - res));
          };
          S.elem_add_eff = {
            fire: eff('fire'),
            water: eff('water'),
            light: eff('light'),
            dark: eff('dark'),
          };
          S.elem_add_eff_sum =
            S.elem_add_eff.fire +
            S.elem_add_eff.water +
            S.elem_add_eff.light +
            S.elem_add_eff.dark;

          // ---- (C) 최종추뎀 ----
          S.fin_add_damage =
            (S.add_damage || 0) +
            (S.elem_add_eff_sum || 0) +
            (S.counter_add_damage || 0);

          // ---- (D) 최종 크리율(몬스터 레벨 적용) ----
          const monsterLevel = Number(state?.monster?.level ?? 80);
          const computeFinalCritPct = (critVal, critRateVal) => {
            if (critVal == null || critRateVal == null) return 0;
            const denom = (3.8665 * Math.pow(100 / 97.25, monsterLevel)) * 100;
            const percent = (((critVal || 0) / denom) * 100) + ((critRateVal || 0) * 100) + 0;
            const clamped = Math.max(0, Math.min(100, percent));
            return clamped / 100; // 0~1
          };
          S.final_phys_crit_pct = computeFinalCritPct(S.phys_crit, S.phys_crit_rate);
          S.final_mag_crit_pct = computeFinalCritPct(S.mag_crit, S.mag_crit_rate);

          // ---- (E) 속성 보정계수: 4속 중 (속강-적저) 최대 ----
          const elemMul = Math.max(
            1.05 + 0.0045 * ((S.elem?.fire || 0) - (M.fire || 0)),
            1.05 + 0.0045 * ((S.elem?.water || 0) - (M.water || 0)),
            1.05 + 0.0045 * ((S.elem?.light || 0) - (M.light || 0)),
            1.05 + 0.0045 * ((S.elem?.dark || 0) - (M.dark || 0)),
          );

          // ---- (F) 확률계수 factor (물/마 별도) ----
          // (1 + (뎀증 + 카운터뎀증))
          // * ( 최종크리율*(1.5+크증뎀) + (1-최종크리율) )
          // * (1.05 + 0.0045*(속강-적저))
          // * (1 + (최종추뎀)*1.015)
          const baseMul1 = 1 + (S.damage_inc || 0) + (S.counter_damage_inc || 0);
          const baseMul4 = 1 + (S.fin_add_damage || 0) * 1.015;

          const baseMul2_phys =
            (S.final_phys_crit_pct * (1.5 + (S.crit_damage_inc || 0))) +
            (1 - S.final_phys_crit_pct);

          const baseMul2_mag =
            (S.final_mag_crit_pct * (1.5 + (S.crit_damage_inc || 0))) +
            (1 - S.final_mag_crit_pct);

          S.factor_phys = baseMul1 * baseMul2_phys * elemMul * baseMul4;
          S.factor_mag = baseMul1 * baseMul2_mag * elemMul * baseMul4;
          // ====== [추가] 힘/지능 계수식 및 평타/스킬 데미지 계열 ======

          // 0) 준비: 총합 힘/지능, 총합 물/마공
          const totalSTR = (S.str || 0) * (1 + (S.str_pct || 0));
          const totalINT = (S.int || 0) * (1 + (S.int_pct || 0));

          const totalPhysAtk = (S.phys_atk || 0) * (1 + (S.phys_atk_pct || 0));
          const totalMagAtk = (S.mag_atk || 0) * (1 + (S.mag_atk_pct || 0));

          // 1) 스케일러(힘/지능)
          const strScaler = (totalSTR / 250) + 1;
          const intScaler = (totalINT / 250) + 1;

          // 2) 고뎀 상수(시트의 100*3.43 그대로)
          const GODAM_CONST = 100 * 3.43;

          // 3) “원초식” (장비/버프 등으로 만든 기초 배수)
          S.str_perdam = strScaler * totalPhysAtk;   // 힘 퍼뎀
          S.str_godam = strScaler * GODAM_CONST;    // 힘 고뎀
          S.in_perdam = intScaler * totalMagAtk;    // 지능 퍼뎀
          S.in_godam = intScaler * GODAM_CONST;    // 지능 고뎀

          // 4) 몬스터 방어 보정(방어율): 값 없으면 1로 둠
          const armorMul = state?.monster?.defRate ?? 1;

          // 5) 평타/스킬 최종식 (확률계수 + 스킬공격력증가 반영)
          //   - 확률계수: 물리 = S.factor_phys, 마법 = S.factor_mag
          //   - 스킬공격력증가: S.skill_atk_inc (곱누적-1 + 버프합) 최종 확정값
          const skillMul = 1 + (S.skill_atk_inc || 0);

          // 힘(물리) 라인
          S.nor_str_perdam = S.factor_phys * S.str_perdam * armorMul * 1.25;
          S.nor_str_godam = S.factor_phys * S.str_godam * armorMul * 1.25;

          S.ski_str_perdam = S.factor_phys * skillMul * S.str_perdam * 1.25;
          S.ski_str_godam = S.factor_phys * skillMul * S.str_godam * 1.25;

          // 지능(마법) 라인
          S.nor_int_perdam = S.factor_mag * S.in_perdam * armorMul * 1.25;
          S.nor_int_godam = S.factor_mag * S.in_godam * armorMul * 1.25;

          S.ski_int_perdam = S.factor_mag * skillMul * S.in_perdam * 1.25;
          S.ski_int_godam = S.factor_mag * skillMul * S.in_godam * 1.25;

          return S;
        };
      }
    } catch (e) {
      console.warn('Finalize(sumSelections) extension failed', e);
    }


    // 전역 1줄(파일 어딘가 상단): 최신 호출만 반영하기 위한 시퀀스
    window.__computeReqSeq = 0;

    async function computeViaBackend(targetId) {
      // ── 0) UI: 로딩 표시 선반영 ─────────────────────────────
      const box = document.getElementById(targetId);
      const prevText = box ? box.textContent : '';
      if (box) {
        box.dataset.prev = prevText || '';
        box.textContent = '계산중입니다…';
        box.classList.add('loading');          // 원하면 CSS로 스피너 스타일링
      }

      // 계산 버튼들 잠깐 비활성화(원하면 HTML에 data-compute-btn 달아두세요)
      const computeBtns = document.querySelectorAll('[data-compute-btn]');
      computeBtns.forEach(btn => { btn.disabled = true; btn.dataset._wasDisabledByCompute = '1'; });

      // 최신 호출 식별자 (race condition 방지)
      const myReqId = ++window.__computeReqSeq;

      try {
        // ── 1) 입력 수집 ──────────────────────────────────────
        await waitForIdToken?.();

        const S = (typeof sumSelections === 'function') ? (sumSelections() || {}) : {};
        const p = (state?.currentCharacter?.power) || 'phys';

        const bookObj = (state?.skillDmg || skillDmg || {});
        const book = Object.values(bookObj).map(sd => ({
          per: Number(sd?.per || 0),
          flat: Number(sd?.flat || 0),
          uses: Number(sd?.uses ?? 1),
          kind: String(sd?.kind || '')
        }));

        const payload = {
          p,
          S: {
            nor_str_perdam: Number(S.nor_str_perdam || 0),
            nor_str_godam: Number(S.nor_str_godam || 0),
            ski_str_perdam: Number(S.ski_str_perdam || 0),
            ski_str_godam: Number(S.ski_str_godam || 0),
            nor_int_perdam: Number(S.nor_int_perdam || 0),
            nor_int_godam: Number(S.nor_int_godam || 0),
            ski_int_perdam: Number(S.ski_int_perdam || 0),
            ski_int_godam: Number(S.ski_int_godam || 0),
            defMul: 1 + Number(S.def_break_inc || 0),
          },
          book
        };

        // ── 2) 서버 호출 ───────────────────────────────────────
        const r = await fetch(WEBAPP_URL + '?type=compute', {
          method: 'POST',
          mode: 'cors',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id_token: window.idToken, type: 'compute', payload })
        });

        const data = await r.json().catch(() => ({ ok: false, error: 'bad_json' }));
        if (!data.ok) {
          if (data.code === 403 && data.error === 'forbidden_role') {
            alert('권한이 없습니다. (허용 직책: 수석 / 책임 / 선임 / 전임)\n내 직책: ' + (data.role || '—'));
            return;
          }
          throw new Error(data.error || 'compute_failed');
        }

        // ── 3) 최신 호출만 반영 (연타 시 이전 응답 무시) ────────
        if (myReqId !== window.__computeReqSeq) return;

        // ── 4) UI: 결과 반영 ───────────────────────────────────
        if (box) {
          const v = Number(data.total || 0);
          box.textContent = new Intl.NumberFormat().format(v);
          box.classList.remove('loading');
        }
      } catch (e) {
        console.error('[COMPUTE] 실패:', e);
        if (box) {
          box.textContent = '계산 실패';
          box.classList.remove('loading');
          // 필요하면 이전 값 복구:
          // box.textContent = box.dataset.prev || '—';
        }
        alert('서버 계산 실패: ' + (e.message || e));
      } finally {
        // ── 5) 버튼 되살리기 ──────────────────────────────────
        computeBtns.forEach(btn => {
          if (btn.dataset._wasDisabledByCompute === '1') {
            btn.disabled = false;
            delete btn.dataset._wasDisabledByCompute;
          }
        });
      }
    }

    document.getElementById('btn-sum-all-final')?.setAttribute('data-compute-btn', '');
    document.getElementById('btn-sum-all-final2')?.setAttribute('data-compute-btn', '');

    // 버튼: 누를 때만 값 채움
    document.getElementById('btn-sum-all-final')?.addEventListener('click', () => {
      computeViaBackend('finalDamageValue');
    });

    // 버튼: 누를 때만 값 채움
    document.getElementById('btn-sum-all-final2')?.addEventListener('click', () => {
      computeViaBackend('finalDamageValue2');
    });


    (() => {
      // ★ 1) 클라이언트 ID와 CSV URL을 넣어주세요
      const GOOGLE_CLIENT_ID = "110486887643-3c136grpud2llf2b31d24fqr40s1p44g.apps.googleusercontent.com"; // 발급받은 웹 클라이언트 ID
      window.WEBAPP_URL = 'https://gas-proxy.gogo456654.workers.dev';
      //const ALLOW_HEADER = "구글계정"; // CSV의 컬럼명

      window.idToken ??= null; // 로그인 후 받은 ID 토큰 저장용

      const DBSkill = { loaded: false, headers: [], rows: [] }; // 스킬 로딩 상태 저장용(원하는 네이밍 사용)

      // === 로그인 성공 콜백(GSI에서 호출) ===
      async function onGoogleCredential({ credential }) {
        try {
          if (!credential) throw new Error("ID 토큰 없음");
          window.idToken = credential; // 토큰 보관
          // 토큰 준비 알림(대기 중인 로더들이 받을 수 있게)
          document.dispatchEvent(new Event('gsi:issued'));
          const card0 = document.querySelector(".login-card");
          if (card0) {
            card0.innerHTML = `
  <div class="login-title">접근 확인 중…</div>
  <div class="login-desc">권한 확인 중입니다. 잠시만 기다려 주세요.</div>
  <div class="login-row">
    <button id="btnPC" class="mode-btn" disabled>PC 계산기 열기</button>
    <button id="btnM" class="mode-btn" disabled>모바일 계산기 열기</button>
  </div>`;
          }
          // 백엔드에 가볍게 '핑'을 보내 허용 여부 확인
          // (백엔드에서 ALLOW 화이트리스트를 켜놨다면, 200/ok가 아니면 거부됨)
          const res = await fetch(WEBAPP_URL, {
            method: "POST",
            mode: "cors",
            cache: "no-store",
            headers: { "Content-Type": "text/plain" },
            body: idToken
          });

          const data = await res.json().catch(() => ({ ok: false, error: 'bad json' }));
          const allowed = !!data.ok;
          await loginPingOnce();
          if (!allowed) console.warn("허용 안 됨:", data);
          const card = document.querySelector(".login-card");
          if (card) {
            card.innerHTML = `
<div class="login-title">${allowed ? "접근 승인됨" : "접근 제한됨"}</div>
<div class="login-desc">
  ${allowed
                ? "아래에서 이용할 화면을 선택하세요."
                : '게임실험연구소 연구원만 이용 가능합니다.<br><a class="join-link" href="https://www.youtube.com/channel/UCijUV3SuVe_qErzBpdOmKIA/join" target="_blank" rel="noopener">게임실험연구소 연구원 가입하기</a>'}
</div>
<div class="login-row">
  <button id="btnPC" class="mode-btn">PC 계산기 열기</button>
  <button id="btnM" class="mode-btn">모바일 계산기 열기</button>
</div>
`;

            if (!document.getElementById("mode-btn-style")) {
              const style = document.createElement("style");
              style.id = "mode-btn-style";
              style.textContent = `
.mode-btn{
  height:40px; padding:0 14px; border-radius:999px;
  border:1px solid rgba(255,255,255,.2); background:#111827; color:#e6e9ef; cursor:pointer;
  transition: box-shadow .15s, border-color .15s, opacity .15s;
}
.mode-btn:hover{ border-color:#6ea8ff; box-shadow:0 0 0 2px rgba(110,168,255,.25) inset; }
.mode-btn:disabled{ opacity:.5; cursor:not-allowed; filter: grayscale(30%); }
.login-desc a.join-link{ color:#8fbaff; text-decoration: underline; }
`;
              document.head.appendChild(style);
            }

            const btnPC = card.querySelector("#btnPC");
            const btnM = card.querySelector("#btnM");

            // 기본 잠금
            btnPC?.setAttribute("disabled", "true");
            btnM?.setAttribute("disabled", "true");
            if (allowed) {
              btnPC.removeAttribute("disabled");
              btnM.removeAttribute("disabled");

              // (로그인 허가 후) PC/모바일 버튼 !@#$ 여기부터 없애기
if (DEV_NOLOAD) {
  btnPC?.addEventListener('click', () => {
    document.getElementById('loadingOverlay')?.setAttribute('hidden','');
    // (선택) 모달에 리스트를 보고 싶으면 더미데이터 주입
    window.__devSeedModalData?.();
    showCalcView('pc');   // 즉시 진입
  });
  btnM?.addEventListener('click', () => {
    document.getElementById('loadingOverlay')?.setAttribute('hidden','');
    window.__devSeedModalData?.();
    showCalcView('mobile'); // 즉시 진입
  });
} else {    // !@#$여기까지 없애기 
              btnPC.addEventListener('click', async () => {
                showOverlay('준비 중…');
                try {
                  await preloadAllSheetsOnce();   // ← 싱글톤
                  refreshExceptionSkillIdMap();   // ← 스킬명 → ID 매핑 갱신
                  refreshActiveExceptions();      // ← 현재 착용아이템 기준으로 예외효과 활성화
                  await initCalculatorOnce();
                  showCalcView('pc');
                } catch (e) {
                  console.error('[INIT] preload 실패:', e);
                  alert('초기 로딩에 실패했습니다. 잠시 후 다시 시도해 주세요.');
                } finally {
                  hideOverlay();
                }
              });

              btnM.addEventListener('click', async () => {
                showOverlay('준비 중…');
                try {
                  await preloadAllSheetsOnce();
                  refreshExceptionSkillIdMap();   // ← 스킬명 → ID 매핑 갱신
                  refreshActiveExceptions();      // ← 현재 착용아이템 기준으로 예외효과 활성화
                  await initCalculatorOnce();
                  showCalcView('mobile');
                } catch (e) {
                  console.error('[INIT] preload 실패:', e);
                  alert('초기 로딩에 실패했습니다. 잠시 후 다시 시도해 주세요.');
                } finally {
                  hideOverlay();
                }
              });
            }}    // !@#$중괄호 하나 없애기
          }
        } catch (err) {
          console.warn("[Login] 처리 중 오류:", err);
        }
      }
      // GSI에서 호출 가능하도록 전역 노출 유지
      window.onGoogleCredential = onGoogleCredential;

      // === 뷰 전환(없으면 추가) ===
      //  - 메인 숨기고 계산기 보여주기 + 모드 클래스 토글
      function hideBlockHard(el) {
        if (!el) return;
        el.setAttribute('hidden', 'hidden');   // hidden 속성
        el.style.display = 'none';             // 완전 제거
        el.style.margin = '0';
        el.style.padding = '0';
        el.style.minHeight = '0';
        el.style.height = '0';
      }

      // ★ 헤더 광고 — 이 블록으로 교체 (CSV → 백엔드 JSON 사용)
      async function initHeaderAds() {
        try {
          const header = document.querySelector("header");
          if (!header) return;

          let ads = header.querySelector(".header-ads");
          if (!ads) {
            ads = document.createElement("div");
            ads.className = "header-ads";
            ads.innerHTML = `<span class="ad-text">불러오는 중…</span>`;
            header.appendChild(ads);
          }
          const adTextEl = ads.querySelector(".ad-text");
          if (ads.dataset.inited) return;
          ads.dataset.inited = "1";

          // 백엔드에서 목록(JSON) 로드
          const r = await fetch(WEBAPP_URL + '?public=1', {
            method: "GET",
            mode: "cors",
            cache: "no-store"
          });
          if (!r.ok) throw new Error("목록 로드 실패");
          const data = await r.json();
          if (!data.ok) throw new Error("목록 데이터 오류");

          // data.items는 Apps Script가 내려주는 정규화 객체 배열
          //  { ingame, position, youtube, google, message }
          // "수석" + "책임" 모두 허용 (앞에 접두어가 붙은 "수석연구원"/"책임연구원"도 포함)
          function escapeHTML(s = '') {
            return String(s)
              .replace(/&/g, '&amp;').replace(/</g, '&lt;')
              .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;').replace(/`/g, '&#96;');
          }

          function shuffleInPlace(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }

          let messages = (data.items || [])
            .filter(x => {
              const pos = (x.position || '').trim();
              const msg = (x.message || '').trim();
              return !!msg && /^(수석|책임)/.test(pos);
            })
            .map(x => {
              const pos = (x.position || '').trim();
              const nick = (x.ingame || '').trim() || (x.youtube || '').trim();
              const msg = (x.message || '').trim();
              const isSenior = /^수석/.test(pos);
              const roleBadge = isSenior
                ? '<span class="tag tag-senior" aria-label="수석" title="수석"><span class="badge-emoji">👑</span></span>'
                : '<span class="tag-lead" aria-hidden="true"></span>';

              return `
      <span class="hdrmsg ${isSenior ? 'senior' : 'lead'}">
        ${roleBadge}
        ${nick ? `<span class="msg-nick">${escapeHTML(nick)} 님</span>` : ''}
        <span class="msg-bullet">·</span>
        <span class="msg-text">${escapeHTML(msg)}</span>
      </span>
    `.trim();
            });

          messages = [...new Set(messages)];
          messages = shuffleInPlace(messages);
          if (!messages.length) {
            adTextEl.textContent = "등록된 한마디가 없습니다.";
            return;
          }
          // 6초마다 순환할 이모지 목록
          const SENIOR_EMOJIS = ['👑', '⭐', '🏅', '✨'];
          let __emojiIdx = 0;

          // 현재 표시된 한마디 컨테이너에서 수석 배지 이모지만 교체
          function applySeniorEmoji(target) {
            const node = target.querySelector('.tag-senior .badge-emoji');
            if (node) node.textContent = SENIOR_EMOJIS[__emojiIdx];
          }
          // 순환 표시
          let i = 0, timer = null, paused = false;
          function show(idx) {
            adTextEl.classList.add("fade-out");
            setTimeout(() => {
              adTextEl.innerHTML = messages[idx % messages.length];
              adTextEl.classList.remove("fade-out");
              // 👇 새 DOM이 들어간 뒤, 해당 라운드의 이모지를 적용
              applySeniorEmoji(adTextEl);
            }, 200); // 이 값(200ms)은 페이드 시간과 맞추세요
          }
          const DISPLAY_MS = 6000;

          function start() {
            if (timer) clearInterval(timer);
            timer = setInterval(() => {
              if (paused) return;
              // 👇 이모지 인덱스 먼저 순환
              __emojiIdx = (__emojiIdx + 1) % SENIOR_EMOJIS.length;
              // 메시지도 다음으로
              i = (i + 1) % messages.length;
              show(i); // show() 안에서 방금 인덱스의 이모지를 적용
            }, DISPLAY_MS);
          }

          // 최초 1회 표시 시에도 이모지 반영되도록 show(0)만 호출하면 OK
          show(0);
          start();

          ads.addEventListener("mouseenter", () => { paused = true; });
          ads.addEventListener("mouseleave", () => { paused = false; });

        } catch (e) {
          console.warn("[ADS] 초기화 실패:", e);
        }
      }

      // 문서 준비 후 자동 실행(기존 로직 유지)
      if (document.readyState === "complete" || document.readyState === "interactive") {
        initHeaderAds();
      } else {
        document.addEventListener("DOMContentLoaded", initHeaderAds);
      }


      if (typeof window.showCalcView !== "function") {
        let calcInited = false;
        window.showCalcView = function (mode) {
          const main = document.getElementById("main-view");
          const calc = document.getElementById("calc-view");
          hideBlockHard(main);                 // ← 상단 공간 완전 제거
          hideBlockHard(document.querySelector("section.hero"));
          // .shell 컨테이너는 유지, header를 제외한 자식만 접기
          const shell = document.querySelector('div.shell');
          if (shell) {
            shell.querySelectorAll(':scope > :not(header):not(#site-header)').forEach(hideBlockHard);
          }
          // 혹시 .shell 밖에 남아 있을 수 있는 랜딩 섹션들 보강
          ['.login-wrap', '.hero', '.spacer', '.notice', '.grid', '#hero']
            .forEach(sel => hideBlockHard(document.querySelector(sel)));
          if (calc) {
            calc.removeAttribute('hidden');
            calc.style.display = 'block';
          }

          document.body.classList.toggle("pc", mode === "pc");
          document.body.classList.toggle("mobile", mode === "mobile");
          if (!calcInited) {
            // 필요 시 한 번만 초기화 로직 호출 (initCalculator 등)
            calcInited = true;
          }
          window.scrollTo(0, 0);
        };
      }

      // (선택) #g_id_onload에 client_id가 비어있으면 채워줌
      const onloadDiv = document.getElementById("g_id_onload");
      if (onloadDiv && !onloadDiv.dataset.clientId) {
        onloadDiv.dataset.clientId = GOOGLE_CLIENT_ID;
      }

      if (DEV_NOLOAD) { //!@#$ 삭제요망
  // 전체 로드 끝나면 바로 계산기 화면으로
  window.addEventListener('load', () => {
    // 로딩 오버레이 강제 OFF
    document.getElementById('loadingOverlay')?.setAttribute('hidden','');
    // 모달 목록이 비어 보이면 더미 주입(선택)
    window.__devSeedModalData?.();
    // PC 레이아웃로 바로 진입 (원하면 'mobile'로 바꿔도 됨)
    showCalcView('pc');
  });
}   // !@#$ 삭제요망
    })();

  </script>
</body>

</html>
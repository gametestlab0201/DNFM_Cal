<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>게임실험연구소 계산기 (시즌5) - Mobile</title>

  <style>
    :root {
  --bg: #070a12;
  --card: rgba(255, 255, 255, 0.06);
  --card2: rgba(255, 255, 255, 0.10);
  --line: rgba(255, 255, 255, 0.10);
  --text: #e9eef7;
  --muted: rgba(233, 238, 247, 0.70);
  --btn: #2563eb;
  --btn2: #111827;
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-top: env(safe-area-inset-top, 0px);

  /* ✅ 푸터 높이 축소 */
  --footer-h: 80px;

  /* ✅ 저장슬롯(푸터 위 고정) 높이: JS가 실제 높이를 넣어줌 */
  --presetbar-h: 0px;
}

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 700px at 50% -20%, rgba(37, 99, 235, 0.28), transparent 55%), var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", sans-serif;
      overflow: hidden;
      /* 스와이프 컨텐츠 내부 스크롤만 */
    }

    /* ====== Layout ====== */
    .m-shell {
      height: 100dvh;
      display: flex;
      flex-direction: column;
    }

    .m-header {
      position: sticky;
      top: 0;
      z-index: 50;
      padding: calc(10px + var(--safe-top)) 12px 2px 12px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.15));
      backdrop-filter: blur(10px);
    }

    .m-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    /* ====== 한마디 (헤더 바로 아래) ====== */
.m-oneliner {
  margin-top: 6px !important;      /* 간격도 같이 축소 */
  padding: 6px 10px !important;    /* 내부도 축소 */

  border-radius: 12px;
  border: 1px solid var(--line);
  background: rgba(255, 255, 255, 0.04);

  display: flex;
  align-items: center !important;  /* ✅ 핵심: 가운데 정렬로 높이 흔들림 방지 */
  gap: 6px !important;

  height: 35px !important;         /* ✅ 핵심: 고정 높이 */
  min-height: 35px !important;     /* 혹시 min-height가 다른 곳에서 살아있을 때 대비 */
  max-height: 35px !important;

  overflow: hidden !important;     /* ✅ 내용이 커도 박스가 늘지 않게 */
}
    .m-oneliner .bullet {
      opacity: 0.65;
      line-height: 1.2;
      flex: 0 0 auto;
      padding-top: 1px;
    }
    .m-oneliner .text {
      font-size: 12px;
      line-height: 1.25;
      color: rgba(233, 238, 247, 0.92);
      overflow: hidden;

      /* 2줄까지만 보여주기 */
      display: -webkit-box;
      -webkit-box-orient: vertical;
    }
    .m-oneliner .muted {
      color: var(--muted);
    }

/* ===== 한마디(PC 배지/아이콘 스타일 이식) ===== */
.m-oneliner .text.fade-out { opacity: 0; transition: opacity .18s ease; }
.m-oneliner .text { opacity: 1; transition: opacity .18s ease; }

.m-oneliner .hdrmsg{
  display:inline-flex;
  align-items:center;
  gap:6px;
  white-space:nowrap;
    /* ✅ 중요: inline-flex 자식이 줄어들 수 있게 */
  min-width: 0;
  max-width: 100%;
}
.m-oneliner .msg-nick{ font-weight:900; }
.m-oneliner .msg-bullet{ opacity:.7; padding:0 2px; }
.m-oneliner .msg-text{
  /* ✅ 중요: inline(span) 상태면 max-width/overflow 측정이 틀어짐 */
  display: inline-block;

  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;

  /* 기존 유지 */
  max-width: 72vw;

  /* (선택) 더 안정적으로 하고 싶으면 아래도 추가 가능
     vertical-align: bottom; */
}
/* ===== 한마디 마퀴(전광판) ===== */
.m-oneliner .msg-text{
  position: relative;
}

/* 기본(inner) */
.m-oneliner .msg-text .marquee{
  display: inline-block;
  padding-right: 7px;   /* ✅ 항상 동일 여백을 포함시켜 sw 계산과 실제 렌더가 같게 */
}

/* ✅ 넘칠 때만 마퀴 동작 */
.m-oneliner .msg-text.is-marquee{
  overflow: hidden;              /* ellipsis 대신 잘라내기 */
  text-overflow: clip;           /* … 사용 안 함 */
}

.m-oneliner .msg-text.is-marquee .marquee{
  white-space: nowrap;
  will-change: transform;
  /* ✅ 처음에는 그대로(0) 보이고, 이후에만 이동 */
  animation: m_one_marquee var(--marquee-dur, 14s) linear infinite;
}

/* ✅ 0~15%: 정지(보이는 만큼 먼저 보여줌)
   ✅ 15~70%: 왼쪽으로 스크롤 (넘친 만큼만)
   ✅ 70~85%: 끝에서 잠깐 정지
   ✅ 85~100%: 0으로 복귀(다음 루프 준비) */
@keyframes m_one_marquee{
  0%   { transform: translateX(0); }
  15%  { transform: translateX(0); }
  70%  { transform: translateX(calc(-1px * var(--marquee-dist, 0))); }
  85%  { transform: translateX(calc(-1px * var(--marquee-dist, 0))); }
  100% { transform: translateX(0); }
}

/* 접근성: 모션 최소화 설정이면 애니메이션 끔 */
@media (prefers-reduced-motion: reduce){
  .m-oneliner .msg-text.is-marquee .marquee{
    animation: none !important;
    padding-left: 0 !important;
    transform: none !important;
  }
}


/* ===== 한마디 배지 (PC 수석 스타일 이식) ===== */

/* 공통: hdrmsg 라인 정렬 */
.m-oneliner .hdrmsg{
  display:inline-flex;
  align-items:center;
  gap:6px;
  white-space:nowrap;
}

/* ✅ 수석 배지: PC처럼 골드 pill + 은은한 반짝임 */
.m-oneliner .tag-senior{
  display: inline-flex;
  align-items: center;
  justify-content: center;

  padding: 2px 10px;
  min-width: 32px;
  height: 20px;
  border-radius: 999px;

  font-size: 13px;
  line-height: 1;

  background: linear-gradient(135deg, #ffe08a 0%, #ffd257 45%, #ffc63a 100%);
  border: 1px solid rgba(172, 124, 22, 0.55);
  color: #2a1b00;

  position: relative;
  overflow: hidden;
}

/* shimmer */
.m-oneliner .tag-senior::after{
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, .45) 35%, transparent 70%);
  transform: translateX(-120%);
  animation: m_one_shimmer 2.4s linear infinite;
  pointer-events: none;
}

@keyframes m_one_shimmer{
  0% { transform: translateX(-120%); }
  100% { transform: translateX(120%); }
}

/* 이모지 살짝 정렬 */
.m-oneliner .badge-emoji{
  transform: translateY(-.5px);
}

/* ✅ 책임은 아이콘/배지가 아예 없으니 tag-lead 스타일은 필요 없음 (남겨도 되지만 사용 안 됨) */

/* ===== 수석 한마디: PC 네온 스타일 이식 ===== */
.m-oneliner .hdrmsg.senior{
  position: relative;
  filter: drop-shadow(0 0 4px rgba(250, 204, 21, 0.35));
}

/* 수석 본문 텍스트 네온 */
.m-oneliner .hdrmsg.senior .msg-text{
  color: #fef9c3;
  text-shadow:
    0 0 4px rgba(250, 204, 21, 0.65),
    0 0 8px rgba(250, 204, 21, 0.82),
    0 0 14px rgba(250, 204, 21, 0.95);
}

/* 수석 닉네임도 PC처럼 푸른 그림자 */
.m-oneliner .hdrmsg.senior .msg-nick{
  color: #e5e7eb;
  font-weight: 600; /* PC가 600쪽 느낌 */
  text-shadow:
    0 0 3px rgba(59, 130, 246, 0.55),
    0 0 7px rgba(59, 130, 246, 0.75);
  text-decoration: underline;
  text-decoration-color: rgba(255, 198, 58, .7);
  text-underline-offset: 2px;
}

/* (참고) 수석은 원칙상 점이 없지만, 혹시 남아있을 때만 색 보정 */
.m-oneliner .hdrmsg.senior .msg-bullet{
  color: #facc15;
  opacity: 0.9;
}

/* ===== 책임 한마디: 닉네임만 진하게(PC 규칙) ===== */
.m-oneliner .hdrmsg.lead .msg-nick{
  font-weight: 700;
}

/* 책임 점(·)은 닉네임 앞에서 너무 튀지 않게 */
.m-oneliner .hdrmsg.lead .msg-bullet{
  opacity: .7;
  padding: 0 4px 0 0; /* 닉네임과 간격 (앞에 붙으니 오른쪽만) */
}
/* ✅ 책임: 닉네임 앞 ‘두꺼운 점’(PC의 tag-lead 원형 도트 이식) */
.m-oneliner .tag-lead{
  display: inline-block;
  width: 6px;
  height: 6px;
  border-radius: 999px;
  background: rgba(120, 120, 120, .75);
  box-shadow: 0 0 0 1px rgba(120, 120, 120, .28);
  margin-right: 2px;
  vertical-align: middle;
}


    .m-title {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .m-title .txt {
      font-weight: 800;
      letter-spacing: -0.2px;
      font-size: 15px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .m-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .m-action-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .m-action-btn:active {
      transform: translateY(1px);
    }

    .m-action-btn svg {
      width: 16px;
      height: 16px;
    }

    .m-action-btn svg path,
    .m-action-btn svg rect {
      fill: none;
      stroke: var(--text);
      stroke-width: 1.6;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    /* ====== Swipe Pages ====== */
/* ===== PC 저장슬롯과 동일 스타일 (save-box/preset-btn/preset-trash/페이지버튼) ===== */
.save-box {
  background: rgba(110, 168, 255, 0.08);
  border: 1px solid rgba(110, 168, 255, 0.35);
  border-radius: 14px;

  /* ✅ 위/아래 패딩을 조금 줄여서 “상자 ↔ 슬롯” 여백 감소 */
  padding: 6px 10px;

  display: grid;
  grid-template-columns: repeat(5, 44px);
  /* ✅ 칸을 고정폭으로 */
  justify-content: center;
  /* ✅ 남는 공간은 양옆으로 */
  gap: 8px;
  /* ✅ 슬롯 간 간격 고정 */
  position: relative;
  width: min(560px, calc(100vw - 20px));
}

.preset-slot {
  display: flex;
  flex-direction: column;
  align-items: center;

  /* ✅ 슬롯(버튼) 위/아래 내부 간격(세로)을 조금 줄임 */
  gap: 2px;

  width: 44px;
  /* ✅ 칸 고정폭과 맞춤 */
  position: relative;
  /* ✅ 휴지통 absolute 기준도 더 안전 */
}

.preset-btn {
  width: 38px;
  height: 38px;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(148, 163, 184, 0.55);
  color: rgba(255, 255, 255, 0.9);
  font-weight: 700;
  cursor: pointer;
  background-size: cover;
  /* ✅ 초상화가 살짝 왼쪽으로 치우쳐 보이는 문제 보정 */
  background-position: 15% center;
}

.preset-btn.has-data {
  border-color: rgba(250, 204, 21, 0.7);
  box-shadow: 0 0 0 2px rgba(250, 204, 21, 0.12) inset;
}

/* ✅ 휴지통 버튼: 슬롯 우측상단에 작게 겹치기 (PC 동일) */
.save-box .preset-slot .preset-trash {
  position: absolute;
  right: -4px;
  top: -4px;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: none;
  background: rgba(15, 23, 42, 0.85);
  color: #9ca3af;
  font-size: 11px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  padding: 0;

  /* 기본은 숨김 */
  opacity: 0;
  pointer-events: none;
}

/* ✅ 해당 슬롯에 데이터가 있을 때만 휴지통 표시 */
.save-box .preset-slot .preset-btn.has-data+.preset-trash {
  opacity: 1;
  pointer-events: auto;
}

.preset-page-btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 34px;
  height: 34px;
  border-radius: 12px;
  border: 1px solid rgba(148, 163, 184, 0.45);
  background: rgba(17, 24, 39, 0.55);
  color: rgba(255, 255, 255, 0.9);
  cursor: pointer;
}

.preset-page-btn.prev {
  left: -10px;
}

.preset-page-btn.next {
  right: -10px;
}

.preset-page-btn:disabled {
  opacity: 0.35;
  cursor: not-allowed;
}

.preset-page-ind {
  position: absolute;
  left: 50%;
  bottom: 6px;
  transform: translateX(-50%);
  font-size: 10px;
  /* ✅ 조금 더 작게 */
  padding: 1px 6px;
  /* ✅ 조금 더 작게 */
  border-radius: 999px;
  background: rgba(0, 0, 0, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.10);
  color: rgba(255, 255, 255, 0.80);
  pointer-events: none;
  display: none;
  /* JS에서 필요할 때 켬 */
}

/* ✅ 저장슬롯 바(푸터 바깥, 푸터 바로 위 고정) */
.m-presetbar-bottom {
  position: fixed;
  left: 0;
  right: 0;

  /* ✅ 푸터의 safe-bottom 패딩 영역까지 고려해서 더 위로 올림 */
  bottom: calc(var(--footer-h) + var(--safe-bottom));

  /* ✅ 푸터(z-index:60)보다 확실히 위로 */
  z-index: 70;

  display: flex;
  justify-content: center;

  /* ✅ 바 자체의 위/아래 여백도 “아주 조금” 더 줄임 */
  padding: 2px 10px;

  pointer-events: auto;
}


    .m-main {
      flex: 1 1 auto;
      position: relative;
      padding-bottom: calc(var(--footer-h) + var(--presetbar-h) + var(--safe-bottom));
      overflow: hidden;
    }


    .m-pages {
      height: 100%;
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;

      touch-action: pan-y;
      /* ✅ 추가: 가로는 우리가 제어, 세로 스크롤은 허용 */
      overscroll-behavior-x: contain;
      /* ✅ 추가: 가로 스와이프 튐 방지 */
    }

    .m-pages::-webkit-scrollbar {
      display: none;
    }

    .m-page {
      flex: 0 0 100%;
      height: 100%;
      scroll-snap-align: start;
      padding: 2px 12px 0px 12px;
      /* ✅ 16px → 10px */
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;

      /* ✅ 추가: 페이지 안에서 카드가 남은 높이를 채우도록 */
      display: flex;
      flex-direction: column;
      scroll-snap-stop: always;
      /* ✅ 추가: 스냅이 더 안정적으로 걸리게 */
    }

    .m-card {
      border: 1px solid var(--line);
      background: var(--card);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
    }

    /* ✅ 1페이지(캐릭터 선택) 카드가 남은 높이를 꽉 채우게 */
    #pageChar .m-card {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
    }

    /* ✅ big-pick 영역도 같이 늘어나서 버튼이 아래 고정 푸터 위까지 길어짐 */
    #pageChar .big-pick {
      flex: 1 1 auto;
      min-height: 0;
      /* flex에서 과도한 min-height 방지 */
    }

    #pageChar .hint {
      margin-top: 1px;
    }

    /* ===== 모바일 캐릭터 목록: 좌 썸네일 / 우 이름 ===== */
    /* ✅ 모달 내용: 손가락 드래그로 스크롤, 스크롤바는 숨김 */
    #charModal .dialog {
      overflow: hidden;
      /* dialog 자체는 숨기고 */
    }

    /* 실제 스크롤은 catalog에서 */
    #charModal #catalog {
      max-height: min(78vh, 720px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      /* iOS 관성 */
      scrollbar-width: none;
      /* Firefox */
    }

    #charModal #catalog::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    #charModal #catalog {
      touch-action: pan-y;
      /* 세로 스크롤 제스처 우선 */
    }

    #charModal .mchar-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #charModal .mchar-row {
      width: 100%;
      display: grid;
      grid-template-columns: 72px 1fr;
      gap: 12px;
      align-items: center;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.06);
      color: #fff;
      text-align: left;
      cursor: pointer;
    }

    #charModal .mchar-row:active {
      transform: translateY(1px);
    }

    #charModal .mchar-thumb {
      width: 72px;
      height: 44px;
      border-radius: 10px;
      object-fit: cover;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.10);
    }

    #charModal .mchar-name {
      font-weight: 900;
      font-size: 15px;
      letter-spacing: -0.2px;
    }

    /* ===== 직업군 그룹 구분(배지 + 직업군명) ===== */
    #charModal .mchar-group {
      padding: 10px 0 14px 0;
      border-top: 1px solid rgba(255, 255, 255, 0.10);
    }

    #charModal .mchar-group:first-child {
      border-top: 0;
      padding-top: 0;
    }

    #charModal .mchar-group-head {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 2px 2px 10px 2px;
    }

    #charModal .mchar-badge {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.06);
      flex: 0 0 auto;
    }

    #charModal .mchar-group-title {
      font-weight: 900;
      font-size: 14px;
      letter-spacing: -0.2px;
      color: rgba(233, 238, 247, 0.95);
    }

    #charModal .mchar-group-sub {
      margin-left: 6px;
      font-size: 11px;
      color: rgba(233, 238, 247, 0.60);
      font-weight: 800;
    }

    #charModal .mchar-group-body {
      display: flex;
      flex-direction: column;
      gap: 10px;
      /* 기존 row 간격 유지 */
    }



    .big-pick {
      margin-top: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 190px;
      border-radius: 18px;
      border: 1px dashed rgba(255, 255, 255, 0.22);
      background: rgba(255, 255, 255, 0.03);

      position: relative;
      /* ✅ 추가 */
      overflow: hidden;
      /* ✅ 추가 (넘치는 부분 잘라서 꽉 찬 느낌) */
    }

    .big-pick button {
      width: 100%;
      max-width: 520px;
      border: none;
      border-radius: 16px;
      padding: 18px 16px;
      font-size: 22px;
      font-weight: 900;
      letter-spacing: -0.4px;
      color: #ffffff;
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.95), rgba(29, 78, 216, 0.95));
      box-shadow: 0 10px 24px rgba(37, 99, 235, 0.25);
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .big-pick button:active {
      transform: translateY(1px);
    }

    /* ✅ 선택된 캐릭 이미지 표시 */
    #pickedCharImg.picked-char-img {
      display: none;
      /* 기본 숨김 (선택 후 block) */
      position: absolute;
      inset: 0;
      /* ✅ big-pick을 꽉 덮음 */
      width: 100%;
      height: 100%;
      max-width: none;
      max-height: none;

      object-fit: cover;
      /* ✅ 핵심: 잘려도 되니 꽉 채움 */
      object-position: center;

      border-radius: inherit;
      /* big-pick 라운드 그대로 */
      border: 0;
      background: rgba(0, 0, 0, 0.18);
    }

    .hint {
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .page-title {
      font-size: 13px;
      font-weight: 800;
      color: rgba(233, 238, 247, 0.9);
      margin-bottom: 10px;
    }

    .ghost {
      padding: 14px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0, 0, 0, 0.22);
      color: var(--muted);
      font-size: 13px;
      line-height: 1.6;
    }

    /* ====== Page 2: 장비 슬롯 ====== */
    #pageEquip .m-card {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
    }

    /* ====== Page 2: 장비(1열 상세 row) ====== */
    #pageEquip .equip-body {
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 2px 0;
    }

    #pageEquip .equip-group {
      padding-top: 14px;
      border-top: 1px solid rgba(255, 255, 255, 0.10);
    }

    #pageEquip .equip-group:first-child {
      padding-top: 0;
      border-top: 0;
    }

    #pageEquip .equip-group-head {
      font-weight: 900;
      font-size: 13px;
      letter-spacing: -0.2px;
      color: rgba(233, 238, 247, 0.92);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    #pageEquip .equip-group-head .equip-u-mini {
      margin: 0;
    }

    /* ✅ 자동 입력 아래 '무기' 제목(= 구분선 다음) 윗 여백만 더 주기 */
#pageEquip .equip-auto-sep + .equip-group-head{
  margin-top: 12px;  /* 8~14px 사이 취향 */
}



    /* ✅ 무기 상단: 자동 입력 버튼 4개 */
    #pageEquip .equip-auto-bar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin: 0 0 0px 0;
    }

    #pageEquip .equip-auto-btn {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(233, 238, 247, 0.92);
      border-radius: 12px;
      padding: 10px 10px;
      font-size: 12px;
      font-weight: 900;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      text-align: center;
      line-height: 1.2;
    }

    #pageEquip .equip-auto-sep {
      height: 1px;
      background: rgba(255, 255, 255, 0.10);
      margin: 6px 0;
    }

    #pageEquip .equip-auto-btn.primary {
      background: rgba(37, 99, 235, 0.85);
    }

    #pageEquip .equip-auto-btn:active {
      transform: translateY(1px);
    }

    #pageEquip .equip-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #pageEquip .equip-row {
      width: 100%;
      display: grid;
      grid-template-columns: 72px 1fr;
      gap: 10px;
      align-items: center;

      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      border-radius: 14px;
      padding: 8px;
      text-align: left;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    #pageEquip .equip-row:active {
      transform: translateY(1px);
    }

    /* 좌측: 이미지 + 이미지 아래 장비명 */
    #pageEquip .equip-left {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    /* 좌측 이미지: 둥근 정사각형(선택 전 빈 박스) */
    #pageEquip .equip-img {
      width: 56px;
      height: 56px;
      /* ✅ 정사각형 */
      border-radius: 14px;
      /* ✅ 끝이 둥근 정사각형 */
      background: rgba(0, 0, 0, 0.20);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    #pageEquip .equip-name {
      font-weight: 900;
      font-size: 12px;
      color: rgba(233, 238, 247, 0.95);
      text-align: center;
    }

    /* ✅ 고유효과(개별) 미니 버튼 */
    .equip-u-mini {
      margin-top: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, .04);
      font-size: 11px;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    .equip-u-mini:active {
      transform: translateY(1px);
    }

    .equip-u-mini .tag {
      font-weight: 700;
      color: var(--text);
    }

    /* ✅ (추가) 개별 고유효과 버튼 색상: data-ucolor로 제어 */
    .equip-u-mini[data-ucolor="강타"] {
      border-color: #facc15;
      color: #facc15;
      background: rgba(250, 204, 21, 0.08);
    }

    .equip-u-mini[data-ucolor="광채"] {
      border-color: #38bdf8;
      color: #38bdf8;
      background: rgba(56, 189, 248, 0.08);
    }

    .equip-u-mini[data-ucolor="분쇄"] {
      border-color: #f97373;
      color: #f97373;
      background: rgba(248, 113, 113, 0.08);
    }

    .equip-u-mini[data-ucolor="선명"] {
      border-color: #4ade80;
      color: #4ade80;
      background: rgba(74, 222, 128, 0.08);
    }

    .equip-u-mini[data-ucolor="none"] {
      border-color: var(--line);
      color: var(--muted);
      background: rgba(255, 255, 255, .04);
    }

    /* ✅ (추가) 색이 들어가면 tag도 같이 물들게 */
    .equip-u-mini[data-ucolor="강타"] .tag,
    .equip-u-mini[data-ucolor="광채"] .tag,
    .equip-u-mini[data-ucolor="분쇄"] .tag,
    .equip-u-mini[data-ucolor="선명"] .tag {
      color: inherit;
    }

    /* (선택) 모달의 '선봉/의지/이상' 버튼도 요청 매핑대로 색 적용 */
    .unique-options-other .unique-btn[data-value="선봉"] {
      border-color: #f97373;
      color: #f97373;
      background: rgba(248, 113, 113, 0.08);
      /* 분쇄색 */
    }

    .unique-options-other .unique-btn[data-value="의지"] {
      border-color: #38bdf8;
      color: #38bdf8;
      background: rgba(56, 189, 248, 0.08);
      /* 광채색 */
    }

    .unique-options-other .unique-btn[data-value="이상"] {
      border-color: #4ade80;
      color: #4ade80;
      background: rgba(74, 222, 128, 0.08);
      /* 선명색 */
    }

    .unique-options-other .unique-btn[data-value="없음"] {
      border-color: var(--line);
      color: var(--muted);
      background: rgba(15, 23, 42, 0.6);
    }



    /* 우측: 강화(연마) | 마법봉인 | 마법부여 | 엠블렘 */
#pageEquip .equip-right {
  min-width: 0;
  display: grid;
  grid-template-columns:
    minmax(52px, 0.85fr)
    minmax(0, 1.20fr)
    minmax(52px, 1.05fr)
    minmax(48px, 0.60fr);
  gap: 4px;
  align-items: start;
}

/* =========================
   오칭크아(오라/칭호/크리쳐/아티팩트)
   - 오라/크리쳐/아티팩트: 우측 옵션 UI 없음
   - 칭호: 마법부여 + 플래티넘 엠블렘 1개만
   ========================= */

/* 오라/크리쳐/아티팩트: 우측 영역 자체를 숨김 */
#pageEquip .equip-row[data-slot="aura"] .equip-right,
#pageEquip .equip-row[data-slot="creature"] .equip-right,
#pageEquip .equip-row[data-slot="artifact"] .equip-right {
  display: none;
}

/* 칭호: 강화/연마 + 마법봉인 칸은 '표시만' 숨기고, 칸(그리드)은 유지해서 정렬을 다른 슬롯과 동일하게 */
#pageEquip .equip-row[data-slot="title"] .equip-enh,
#pageEquip .equip-row[data-slot="title"] .equip-opts {
  visibility: hidden;    /* 공간은 유지 */
  pointer-events: none;  /* 터치/클릭 방지 */
}

/* 칭호도 기본 4칸 그리드 그대로 사용 → 마법부여가 다른 슬롯과 같은 위치로 */
#pageEquip .equip-row[data-slot="title"] .equip-right {
  grid-template-columns:
    minmax(52px, 0.85fr)
    minmax(0, 1.20fr)
    minmax(52px, 1.05fr)
    minmax(48px, 0.60fr);
}

/* ✅ 오라/크리쳐/아티팩트 한 줄 묶음 */
#pageEquip .equip-oca-row{
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
  margin-top: 8px;
}

#pageEquip .oca-item{
  width: 100%;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius: 14px;
  padding: 8px 6px;
}

#pageEquip .oca-item:active{
  transform: translateY(1px);
}

#pageEquip .oca-item .equip-left{
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}

#pageEquip .oca-item .equip-name{
  text-align: center;
}


    /* 강화/연마 */
    #pageEquip .equip-enh {
      font-weight: 900;
      font-size: 11px;
      color: rgba(233, 238, 247, 0.95);
      line-height: 1.2;
    }

    #pageEquip .equip-grind {
      margin-top: 6px;
      font-weight: 850;
      font-size: 11px;
      color: rgba(233, 238, 247, 0.70);
      display: none;
      /* 기본 숨김 */
    }

    #pageEquip .equip-row[data-grind="1"] .equip-grind {
      display: block;
    }

    /* 옵션(고유/일반) */
    #pageEquip .equip-opts {
      min-width: 0;
    }

    #pageEquip .equip-unique,
    #pageEquip .equip-normal {
      font-weight: 900;
      font-size: 10px;
      /* ✅ 11px → 10px */
      line-height: 1.15;
      white-space: normal;
      /* ✅ 줄바꿈 허용 */
      overflow: hidden;

      display: -webkit-box;
      /* ✅ 2줄까지만 보이게 */
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      /* 표준 */
      overflow-wrap: anywhere;
      /* 긴 문자열 강제 줄바꿈 */
      word-break: keep-all;
      /* 한글 단어 잘림 완화(원하면 제거 가능) */
    }

    #pageEquip .equip-unique {
      color: rgba(233, 238, 247, 0.92);
    }

    #pageEquip .equip-normal {
      margin-top: 6px;
      /* ✅ 기존 간격 유지 */
      font-weight: 850;
      color: rgba(233, 238, 247, 0.65);
    }

    /* 마법부여 / 엠블렘 공통 */
    #pageEquip .equip-col-title {
      font-weight: 900;
      font-size: 10px;
      /* ✅ 11px → 10px */
      color: rgba(233, 238, 247, 0.70);
      margin-bottom: 6px;
    }

    #pageEquip .equip-col-body {
      font-weight: 900;
      font-size: 10px;
      /* ✅ 12px → 11px */
      line-height: 1.15;
      color: rgba(233, 238, 247, 0.92);

      white-space: normal;
      /* ✅ 줄바꿈 허용 */
      overflow: hidden;

      display: -webkit-box;
      /* ✅ 2줄까지만 보이게 */
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 3;
      line-clamp: 3;

      overflow-wrap: anywhere;
      /* ✅ 긴 문자열 대비 */
      word-break: keep-all;
    }

    /* 엠블렘 아이콘 자리 */
    #pageEquip .equip-emblem-icons {
      display: flex;
      flex-direction: column;
      /* ✅ 세로로 */
      gap: 6px;
      align-items: center;
    }

    #pageEquip .equip-emblem-icons .emb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(0, 0, 0, 0.20);
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      /* ✅ 이상한 타일/크롭 방지 */
    }

    #pageEquip .equip-emblem-icons .emb,
    #equipModal .equip-topbtn .top-embs .emb {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 900;
      color: rgba(255, 255, 255, 0.95);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.75);
    }

    /* ✅ 특수장비(플래티넘) 엠블렘 속성 텍스트(미리보기) */
    #pageEquip .equip-emblem-desc {
      margin-top: 4px;
      font-size: 10.5px;
      font-weight: 850;
      color: rgba(233, 238, 247, 0.70);
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #pageEquip .equip-emblem-desc:empty {
      display: none;
    }

    /* ✅ (NEW) Set Equipment Bar (Page2) */
    #pageEquip .equip-set-bar {
      display: flex;
      gap: 8px;
      margin: 2px 0 0px;
    }

    /* 4개가 한 줄에서 동일 비율로 나뉘게 */
    #pageEquip .equip-set-btn {
      flex: 1 1 0;
      min-width: 0;
      /* flex 안에서 글자 줄바꿈/삐져나옴 방지 */
      white-space: nowrap;
      /* “악세사리/특수장비” 줄바꿈 방지 */
      font-size: 12px;
      /* 4개 한줄용 약간 축소 (원하면 13px로 다시) */
    }


    #pageEquip .equip-set-btn {
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, .14);
      background: rgba(255, 255, 255, .06);
      color: #fff;
      font-size: 13px;
      font-weight: 700;
      letter-spacing: -.2px;
    }

    #pageEquip .equip-set-btn:active {
      transform: translateY(1px);
    }


    /* ===== Equip list (Modal) ===== */
    .meq-wrap {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .meq-row {
      width: 100%;
      border: 0;
      background: var(--card2);
      color: var(--text);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      grid-template-columns: 54px 1fr;
      gap: 10px;
      align-items: center;
      text-align: left;
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.05) inset;
    }

    .meq-thumb {
      width: 54px;
      height: 54px;
      border-radius: 14px;
      background: #0b1220;
      border: 1px solid rgba(255, 255, 255, 0.08);
      object-fit: cover;
      display: block;
    }

    .meq-name {
      font-size: 14px;
      line-height: 1.25;
      font-weight: 700;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      overflow: hidden;

      /* ✅ 경고 방지용(표준 속성) */
      line-clamp: 2;
    }

    /* ✅ 2중 모달: 강화 모달은 장비 모달 위에 */
    #equipEnhModal {
      z-index: 1100;
    }

    #equipSealUModal {
      z-index: 1110;
    }

    #equipSealNModal {
      z-index: 1110;
    }

    #equipEnchantModal {
      z-index: 1120;
    }

    #equipEmblemModal {
      z-index: 1130;
    }

    #equipGrindModal {
      z-index: 1108;
    }


    /* ✅ (PC와 유사한 리스트 스타일) 강화 + 마법봉인(고유/일반) + 마법부여 공통 */
    #equipEnhModal .dialog,
    #equipSealUModal .dialog,
    #equipSealNModal .dialog,
    #equipEnchantModal .dialog,
    /* ✅ 추가 */
    #equipEmblemModal .dialog,
    #equipGrindModal .dialog {
      width: min(320px, 95vw);
      height: min(520px, 85vh);
    }


    /* 리스트(1열) */
    #equipEnhModal .enh-list,
    #equipSealUModal .enh-list,
    #equipSealNModal .enh-list,
    #equipEnchantModal .enh-list,
    #equipGrindModal .enh-list {
      overflow: auto;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr;
      /* ✅ 1열 고정 */
      gap: 8px;
    }

    /* 버튼 (마법부여는 .enh-btn 이라 같이 포함) */
    #equipEnhModal .enh-option,
    #equipSealUModal .enh-option,
    #equipSealNModal .enh-option,
    #equipEnchantModal .enh-btn,
    #equipGrindModal .enh-option {
      height: 36px;
      padding: 0 12px;
      text-align: left;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(0, 0, 0, 0.25);
      color: rgba(240, 230, 210, 0.95);
      cursor: pointer;
    }

    /* active (마법부여는 .enh-btn.active) */
    #equipEnhModal .enh-option.active,
    #equipSealUModal .enh-option.active,
    #equipSealNModal .enh-option.active,
    #equipEnchantModal .enh-btn.active,
    #equipGrindModal .enh-option.active {
      border-color: rgba(207, 162, 79, 0.9);
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.18) inset;
    }





    /* ====== Bottom Fixed ====== */
.m-footer {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 60;

  /* ✅ 상하 패딩을 줄여 실제 체감 높이도 같이 감소 */
  padding: 8px 12px calc(8px + var(--safe-bottom)) 12px;

  border-top: 1px solid var(--line);
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.10), rgba(0, 0, 0, 0.55));
  backdrop-filter: blur(10px);
}

.m-footer-row {
  display: flex;

  /* ✅ 버튼/결과 사이 간격도 살짝 축소 */
  gap: 8px;

  align-items: stretch;
}

.m-calc-btn {
  flex: 0 0 clamp(108px, 28vw, 126px);
  border: none;

  /* ✅ 라운드 살짝 축소(높이 줄인 느낌에 맞춤) */
  border-radius: 14px;

  background: linear-gradient(135deg, rgba(37, 99, 235, 0.95), rgba(29, 78, 216, 0.95));
  color: #fff;
  font-weight: 900;

  /* ✅ 글씨/터치감 유지하면서 아주 조금만 축소 */
  font-size: 17px;

  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}

.m-calc-btn:active {
  transform: translateY(1px);
}

.m-result {
  flex: 1 1 auto;
  border-radius: 14px;
  border: 1px solid var(--line);
  background: rgba(255, 255, 255, 0.06);

  /* ✅ 결과 박스 패딩도 축소 */
  padding: 10px 12px;

  display: flex;
  flex-direction: column;
  justify-content: center;
  min-width: 0;
}

.m-result .label {
  font-size: 11px;
  color: var(--muted);

  /* ✅ 라벨-값 간격 축소 */
  margin-bottom: 4px;
}


    .m-result .value {
      /* ✅ PC처럼: 더 크고, 붉은색, 중앙 */
      font-size: 24px;
      font-weight: 900;
      letter-spacing: -0.4px;
      color: #ff5a6a;
      /* 붉은색(원하면 다른 빨강으로도 조정 가능) */
      text-align: right;
      /* ✅ 우측정렬 */
      width: 100%;

      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      /* (선택) 숫자 폭 고정으로 흔들림 줄이기 */
      font-variant-numeric: tabular-nums;
    }


    /* ====== Toast ====== */
    .toast {
      position: fixed;
      left: 50%;
      bottom: calc(var(--footer-h) + 14px + var(--safe-bottom));
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.70);
      border: 1px solid rgba(255, 255, 255, 0.14);
      color: #fff;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 12px;
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(-2px);
    }

    /* (선택) 모달은 나중에 PC에서 그대로 복붙할 예정이면,
       여기선 최소한의 기본만 둠 */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 1000;
    }

    .modal.show {
      display: flex;
    }

    /* ===== Auto Input Modals (PC 동일 기능) ===== */
    .simple-auto .dialog {
      max-width: 520px;
    }

    .simple-auto .body {
      padding: 12px;
    }

    .simple-auto .grid {
      display: grid;
      gap: 8px;
    }

    .simple-auto .two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .simple-auto .titles {
      font-size: 12px;
      font-weight: 900;
      opacity: .75;
      margin-bottom: 6px;
    }

    .simple-auto .lists {
      display: grid;
      gap: 8px;
    }

    .simple-auto .opt-btn {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(17, 24, 39, .50);
      color: rgba(240, 230, 210, .95);
      border-radius: 10px;
      padding: 10px 10px;
      font-size: 13px;
      font-weight: 850;
      text-align: center;
    }

    .simple-auto .opt-btn.active {
      outline: 2px solid rgba(37, 99, 235, .65);
      border-color: rgba(37, 99, 235, .35);
      background: rgba(37, 99, 235, .20);
    }

    .simple-auto .opt-btn:disabled {
      opacity: .6;
    }

    /* ✅ Auto Input Modal footer */
    .simple-auto .footer {
      padding: 10px 12px 14px;
      border-top: 1px solid rgba(0, 0, 0, 0.08);
      display: flex;
      justify-content: center;
    }

    .simple-auto .confirm-btn {
      width: min(240px, 70%);
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(37, 99, 235, 0.35);
      background: rgba(37, 99, 235, 0.92);
      color: #fff;
      font-weight: 900;
      letter-spacing: -0.2px;
      cursor: pointer;
    }

    .simple-auto .confirm-btn:disabled {
      opacity: .45;
      cursor: not-allowed;
    }


    .modal .backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.62);
    }

    .modal .dialog {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(720px, 92vw);
      max-height: min(80vh, 720px);
      overflow: auto;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(10, 14, 24, 0.96);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
    }

    .modal .dialog header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.10);
    }

    .modal .dialog header h2 {
      margin: 0;
      font-size: 14px;
      font-weight: 900;
      letter-spacing: -0.2px;
    }

    .modal .dialog header .close {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: #fff;
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
    }

    .modal .contact-body {
      padding: 14px;
    }

    .contact-notice {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.55;
      margin-bottom: 12px;
    }

    .contact-textarea {
      width: 100%;
      min-height: 130px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      padding: 10px 12px;
      resize: vertical;
      outline: none;
      font-size: 13px;
      line-height: 1.5;
    }

    .contact-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .ui-btnetc {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(37, 99, 235, 0.85);
      color: #fff;
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 800;
    }

        .faq-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
    }

    .faq-q-btn {
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.16);
      color: #e5e7eb;
      cursor: pointer;
    }

    .faq-q-btn:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    /* ✅ FAQ 답변 이미지: 모바일에서는 너무 커지지 않게 캡 */
    #faqAnswerModal img.faq-img,
    #faqAnswerModal .faq-img {
      width: auto !important;                 /* 100%로 강제 확대되는 것 방지 */
      max-width: min(100%, 280px) !important; /* ✅ 여기 숫자(280px)로 크기 조절 */
      height: auto !important;
      display: block;
      margin: 10px 0;
      border-radius: 10px;
    }

    /* ✅ 여러 이미지가 있을 때 자동 그리드(모바일용) */
    #faqAnswerModal .faq-img-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
      margin: 10px 0;
      justify-items: start;
      align-items: start;
    }

    /* 그리드 안에서는 마진 겹침 방지 */
    #faqAnswerModal .faq-img-grid .faq-img {
      margin: 0;
    }

    /* ===== Emblem Modal UI ===== */
    #equipEmblemModal .items {
      overflow: auto;
      padding: 10px;
    }


    /* 상단: 현재 슬롯/소켓 선택 영역 */
    #equipEmblemTarget {
      position: sticky;
      top: 0;
      z-index: 2;
      padding: 8px;
      margin: 0 0 10px 0;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(6px);
    }

    .em-target-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .em-slot-title {
      font-size: 13px;
      font-weight: 800;
      color: rgba(240, 230, 210, 0.95);
    }

    .em-sockets {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* ✅ 상단 소켓 왼쪽에 플래티넘 속성 배지 */
    .em-sock-wrap {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .em-line-badge {
      font-size: 11px;
      font-weight: 900;
      line-height: 1;
      padding: 2px 6px;
      border-radius: 999px;

      color: rgba(240, 230, 210, 0.92);
      background: rgba(0, 0, 0, 0.40);
      border: 1px solid rgba(255, 255, 255, 0.16);

      /* 클릭 방해 방지 */
      pointer-events: none;
    }

    .em-sock {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(0, 0, 0, 0.25);
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }

    .em-sock.active {
      outline: 2px solid rgba(255, 220, 140, 0.55);
    }

    .em-sock.has-img {
      background-size: cover;
      background-position: center;
    }

    .em-sock {
      position: relative;
      /* 혹시 빠져있으면 보장 */
    }

    .em-sock .num {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);

      font-size: 13px;
      font-weight: 900;
      line-height: 1;

      padding: 3px 7px;
      border-radius: 999px;

      color: rgba(255, 255, 255, 0.95);
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.20);

      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.9);
      pointer-events: none;
      /* 클릭 방해 방지 */
    }

    /* ===== Emblem Modal (세로 리스트 버전) ===== */
    #equipEmblemList {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .em-group {
      border: 1px solid rgba(255, 255, 255, 0.10);
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.18);

      /* ✅ 잘림 방지 */
      overflow: visible;
      height: auto;
      max-height: none;
    }

    .em-group-title {
      padding: 10px 12px;
      font-size: 12px;
      font-weight: 900;
      color: rgba(240, 230, 210, 0.92);
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.18);
    }

    /* ✅ 특수장비 플래티넘: 속성 선택 UI */
    .em-group-title.plat {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .em-line-btn {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(240, 230, 210, 0.92);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 900;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .em-line-btn:active {
      transform: translateY(1px);
    }

    .em-line-choices {
      display: none;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(255, 255, 255, 0.03);
    }

    .em-line-choices.show {
      display: flex;
    }

    .em-line-opt {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(0, 0, 0, 0.25);
      color: rgba(240, 230, 210, 0.92);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 900;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .em-line-opt.active {
      border-color: rgba(207, 162, 79, 0.9);
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.18) inset;
    }

    .em-plat-hint {
      padding: 10px 12px;
      font-size: 12px;
      color: rgba(240, 230, 210, 0.65);
    }

    .em-vlist {
      display: flex;
      flex-direction: column;
    }

    .em-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: transparent;
      cursor: pointer;
      text-align: left;
    }

    .em-item:last-child {
      border-bottom: none;
    }

    .em-item:hover {
      background: rgba(255, 255, 255, 0.04);
    }

    .em-item .thumb {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(0, 0, 0, 0.25);
      background-size: cover;
      background-position: center;
      flex: 0 0 auto;
      position: relative;
      overflow: hidden;
    }

    .em-item.none .thumb {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 900;
      color: rgba(240, 230, 210, 0.75);
      background: rgba(0, 0, 0, 0.18);
    }

    .em-item .meta {
      flex: 1 1 auto;
      min-width: 0;
    }

    .em-item .name {
      font-size: 13px;
      font-weight: 900;
      color: rgba(240, 230, 210, 0.95);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .em-item .sub {
      margin-top: 2px;
      font-size: 12px;
      color: rgba(240, 230, 210, 0.65);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .em-item .badge {
      flex: 0 0 auto;
      font-size: 12px;
      font-weight: 900;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: rgba(250, 240, 220, 0.95);
      background: rgba(0, 0, 0, 0.25);
    }


    /* 장비 리스트의 엠블렘 표시(오른쪽 작은 원) */
    .equip-emblem-icons {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .equip-emblem-icons .emb {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(0, 0, 0, 0.18);
      background-size: cover;
      background-position: center;
    }

    .equip-emblem-icons .emb.has-img {
      box-shadow: 0 0 0 1px rgba(255, 220, 140, 0.25) inset;
    }

    /* 무기 종류 필터 바 (equipModal 안) */
    .weapon-typebar {
      display: none;
      /* 기본 숨김, 무기에서만 show */
      gap: 8px;

      /* ✅ 높이(세로) 키우기 */
      padding: 12px 12px 12px 12px;
      min-height: 56px;
      align-items: center;

      /* ✅ 종류가 많으면 2줄로 내려가게 (영역이 더 넓어 보임) */
      display: flex;
      flex-wrap: wrap;

      /* ✅ 너무 많아져도 모달을 침범하지 않게 제한 */
      max-height: 92px;
      overflow-y: auto;

      /* 스크롤바 숨김(스크롤은 유지) */
      scrollbar-width: none;
      /* firefox */
      -ms-overflow-style: none;
      /* ie/edge */
    }

    .weapon-typebar::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    .weapon-typebtn {
      flex: 0 0 auto;
      border: 1px solid rgba(255, 255, 255, .14);
      background: rgba(255, 255, 255, .06);
      color: rgba(233, 238, 247, .92);
      border-radius: 999px;
      padding: 9px 12px;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: -0.2px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .weapon-typebtn.active {
      background: rgba(37, 99, 235, .35);
      border-color: rgba(37, 99, 235, .55);
    }


    /* ✅ 장비 선택 모달만: 상단(헤더+버튼바) 고정, 목록만 스크롤 */
    #equipModal .dialog {
      overflow: hidden;
      /* dialog 전체 스크롤 금지 */
      display: flex;
      flex-direction: column;
    }

    /* 상단 버튼바 */
    #equipModal .equip-topbar {
      flex: 0 0 auto;
      display: flex;
      flex-wrap: wrap;
      /* ✅ 버튼들이 다음 줄로 내려감 */
      gap: 8px;
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(10, 14, 24, 0.96);

      overflow-x: hidden;
      /* ✅ 가로 스크롤 제거 */
      overflow-y: hidden;
    }

    /* 버튼 스타일(작고 촘촘하게) */
    #equipModal .equip-topbtn {
      flex: 0 0 auto;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(233, 238, 247, 0.92);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 900;
      font-size: 12px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      white-space: nowrap;
    }

    #equipModal .equip-topbtn.active {
      background: rgba(37, 99, 235, 0.85);
      border-color: rgba(37, 99, 235, 0.65);
      color: #fff;
    }

    /* ✅ 상단바: 엠블렘 버튼은 구멍만 표시 */
    #equipModal .equip-topbtn.is-emblems {
      padding: 6px 10px;
      min-width: 48px;
    }

    #equipModal .equip-topbtn .top-embs {
      display: flex;
      flex-direction: column;
      /* 세로 배치 */
      gap: 6px;
      align-items: center;
      justify-content: center;
    }

    #equipModal .equip-topbtn .top-embs .emb {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(0, 0, 0, 0.22);
      display: block;
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      /* ✅ */
    }


    /* ✅ topbar 엠블렘: 버튼이 아니라 "구멍 2개" */
    #equipModal .equip-topemblem {
      flex: 0 0 auto;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.90);
      font-size: 12px;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
    }

    #equipModal .equip-topemblem .label {
      font-size: 11px;
      font-weight: 900;
      letter-spacing: -0.2px;
    }

    #equipModal .equip-topemblem .holes {
      display: inline-flex;
      flex-direction: column;
      /* ✅ 세로로 2개 */
      gap: 6px;
      align-items: center;
    }

    #equipModal .equip-topemblem .hole {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.10), rgba(0, 0, 0, 0.45) 72%);
      box-shadow:
        inset 0 2px 5px rgba(0, 0, 0, 0.55),
        0 1px 0 rgba(255, 255, 255, 0.06);
    }

    #equipModal .equip-topemblem.active {
      background: rgba(37, 99, 235, 0.85);
      border-color: rgba(37, 99, 235, 0.95);
      color: #fff;
    }

    #equipModal .equip-topemblem.active .hole {
      border-color: rgba(255, 255, 255, 0.32);
    }

    #equipModal .equip-topemblem:focus {
      outline: 2px solid rgba(37, 99, 235, 0.7);
      outline-offset: 2px;
    }


    /* ✅ 목록만 스크롤 */
    #equipModal #equipCatalog {
      flex: 1 1 auto;
      min-height: 0;
      /* flex에서 overflow 작동 필수 */
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }

    /* ✅ 모달 내부 리스트: 스크롤바(막대)만 숨기고, 터치 스와이프 스크롤은 유지 */
    #equipCatalog,
    #equipEnhList,
    #equipSealUList,
    #equipSealNList,
    #equipEnchantList,
    #equipGrindList {
      overflow: auto;
      /* 스크롤은 가능해야 손으로 밀림 */
      -webkit-overflow-scrolling: touch;
      /* iOS 관성 스크롤 */
      scrollbar-width: none;
      /* Firefox: 스크롤바 숨김 */
    }


    /* ✅ (선택모달) dialog 자체는 스크롤 금지: 스크롤은 리스트에서만 */
    dialog,
    #equipEnhModal .dialog,
    #equipSealUModal .dialog,
    #equipSealNModal .dialog,
    #equipEnchantModal .dialog,
    #equipEmblemModal .dialog,
    #equipGrindModal .dialog {
      overflow: hidden;
      display: flex;
      /* ✅ 추가 */
      flex-direction: column;
      /* ✅ 추가 */
    }

    /* ✅ 헤더 아래 남은 공간을 items가 먹고, 그 안의 리스트만 스크롤되게 */
    #equipEnhModal .items,
    #equipSealUModal .items,
    #equipSealNModal .items,
    #equipEnchantModal .items,
    #equipEmblemModal .items,
    #equipGrindModal .items {
      flex: 1 1 auto;
      /* ✅ 추가 */
      min-height: 0;
      /* ✅ 핵심: flex 환경에서 내부 overflow가 작동하려면 필요 */
      overflow: hidden;
      /* ✅ dialog은 숨기고, 실제 스크롤은 리스트에서만 */
    }

    /* ✅ 리스트: “스크롤바는 숨기되” 터치 스크롤은 허용 */
    #equipCatalog,
    #equipEnhList,
    #equipSealUList,
    #equipSealNList,
    #equipEnchantList,
    #equipEmblemList,
    #equipGrindList {
      height: 100%;
      /* ✅ 추가: items 높이를 꽉 채움 */
      overflow: auto;
      overflow-x: hidden;
      /* ✅ 가로 스크롤 방지 */
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      touch-action: pan-y;
      /* ✅ 모바일에서 위/아래 드래그를 스크롤로 확실히 */
      overscroll-behavior: contain;
      /* ✅ 바운스/배경 스크롤 간섭 줄이기 */
    }

    /* Chrome/Safari/Edge: 스크롤바 숨김 */
    #equipCatalog::-webkit-scrollbar,
    #equipEnhList::-webkit-scrollbar,
    #equipSealUList::-webkit-scrollbar,
    #equipSealNList::-webkit-scrollbar,
    #equipEnchantList::-webkit-scrollbar,
    #equipEmblemList::-webkit-scrollbar,
    #equipGrindList::-webkit-scrollbar {
      width: 0;
      height: 0;
      display: none;
    }

    /* ===== Page 3: Options ===== */
    #pageEtc .opt-box {
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(0, 0, 0, 0.18);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 10px;
    }

    #pageEtc .opt-title {
      margin: 0 0 10px;
      font-size: 14px;
      font-weight: 900;
      letter-spacing: -0.2px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    #pageEtc .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin: 10px 0;
    }

    #pageEtc .label {
      font-size: 12px;
      opacity: .85;
    }

    #pageEtc {
      --dd-bg: #0D0E15;
      --dd-text: #ffffff;
      --dd-gold: #cfa24f;
    }

    #pageEtc .select {
      width: 100%;
      height: 40px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: var(--dd-bg);
      color: var(--dd-text);
      padding: 0 12px;
      outline: none;
    }

    /* ✅ 드롭다운 목록(option)도 셀렉트와 동일 톤으로 */
    #pageEtc .select option,
    #pageEtc .select optgroup {
      background: var(--dd-bg);
      color: var(--dd-text);
    }

    /* ✅ 드롭다운 펼쳐져 있는 동안(=focus 유지) 금색 테두리 */
    #pageEtc .select:focus {
      border-color: #cfa24f;
      /* gold */
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.22) inset;
    }

    /* 클릭 중에도 유지되는 느낌(브라우저별 보강) */
    #pageEtc .select:active {
      border-color: #cfa24f;
    }

    #pageEtc .row {
      display: flex;
      gap: 8px;
    }

    #pageEtc .row .field {
      margin: 0;
      flex: 1 1 0;
    }

    #pageEtc .btn {
      height: 40px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(0, 0, 0, 0.28);
      color: #fff;
      padding: 0 12px;
      font-weight: 800;
    }

    #pageEtc .btn:focus {
      outline: none;
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.22) inset;
    }

    #pageEtc .btn.primary {
      background: rgba(37, 99, 235, 0.92);
      border-color: rgba(37, 99, 235, 0.55);
    }

    /* ✅ 성안의 봉인 모달 드롭다운도 무기압(=pageEtc) 스타일과 동일하게 */
    #castleSealModalM {
      --dd-bg: #0D0E15;
      --dd-text: #ffffff;
      --dd-gold: #cfa24f;
    }

    #castleSealModalM .select {
      width: 100%;
      height: 40px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: var(--dd-bg);
      color: var(--dd-text);
      padding: 0 12px;
      outline: none;
    }

    #castleSealModalM .select option,
    #castleSealModalM .select optgroup {
      background: var(--dd-bg);
      color: var(--dd-text);
    }

    #castleSealModalM .select:focus {
      border-color: var(--dd-gold);
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.22) inset;
    }

    #castleSealModalM .select:active {
      border-color: var(--dd-gold);
    }

    /* ✅ 성안의 봉인: 선택된 옵션값만 진하게 */
    #castleSealSummaryM #castleSealMainPickM,
    #castleSealSummaryM #castleSealSubPickM {
      font-weight: 900;
      color: rgba(233, 238, 247, 0.95);
    }

    /* =========================
   Skill Rune Modal (Mobile) - PC 톤 통일
   ========================= */

    /* 모달 자체 톤(갈색/금색) */
    #runeModalM .dialog {
      width: min(980px, 95vw);
      height: min(820px, 88vh);
      background: #0f0b08;
      color: #f0e6d2;
      border: 1px solid #3a2c21;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
    }

    #runeModalM header {
      border-bottom: 1px solid rgba(58, 44, 33, 0.9);
    }

    #runeModalM header h2 {
      color: #f0e6d2;
    }

    /* 공통: select(드롭다운) PC톤 */
    #runeModalM .rune-select {
      width: 100%;
      height: 38px;
      border-radius: 10px;
      padding: 0 10px;
      background: #1a130f;
      color: #f0e6d2;
      border: 1px solid #3a2c21;
      outline: none;
    }

    #runeModalM .rune-select:focus {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.25) inset;
    }

    /* ✅ 간편 스킬룬 선택(3 드롭다운) */
    #runeModalM .rune-picker-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }

    #runeModalM .rune-picker-row .rune-select {
      flex: 1 1 0;
      height: 40px;
      /* 간편 UI는 살짝 키움 */
      border-radius: 12px;
    }

    /* 그리드 */
    #runeModalM .rune-grid {
      display: grid;
      grid-auto-rows: minmax(46px, auto);
      gap: 8px;
      overflow: auto;
    }

    #runeModalM .rune-grid .row {
      display: grid;
      grid-template-columns: 96px repeat(8, minmax(54px, 1fr));
      gap: 6px;
      align-items: center;
    }

    #runeModalM .rune-grid .head {
      position: sticky;
      left: 0;
      z-index: 1;
      padding: 6px 8px;
      border: 1px solid #3a2c21;
      border-radius: 10px;
      background: rgba(207, 162, 79, 0.10);
      font-weight: 800;
      font-size: 12px;
      white-space: nowrap;
    }

    #runeModalM .rune-grid .cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* 카테고리 헤더(아이콘+라벨) */
    #runeModalM .rune-cat-head {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    #runeModalM .rune-cat-icon {
      width: 18px;
      height: 18px;
      object-fit: contain;
      flex: 0 0 auto;
    }

    #runeModalM .rune-cat-label {
      font-size: 12px;
      font-weight: 800;
    }

    /* 특수 스킬룬 */
    #runeModalM .special-runes {
      margin-top: 14px;
      padding-top: 12px;
      border-top: 1px solid rgba(58, 44, 33, 0.9);
    }

    #runeModalM .special-runes-title {
      font-weight: 800;
      font-size: 13px;
      margin-bottom: 10px;
      color: #c7b589;
    }

    #runeModalM .special-rune-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border: 1px solid #3a2c21;
      border-radius: 12px;
      background: rgba(207, 162, 79, 0.06);
      margin-bottom: 8px;
    }

    #runeModalM .special-rune-icon {
      width: 22px;
      height: 22px;
      object-fit: contain;
      flex: 0 0 auto;
    }

    #runeModalM .special-rune-row label {
      width: 42px;
      font-size: 12px;
      font-weight: 800;
      opacity: .95;
      color: #f0e6d2;
    }

    /* 버튼(모달 내부 전용) - PC opt-btnetc 느낌 */
    #runeModalM .btn,
    #castleSealModalM .btn {
      height: 38px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 700;
      background: #1a130f;
      color: #f0e6d2;
      border: 1px solid #3a2c21;
      cursor: pointer;
      transition: all .15s ease;
    }

    #runeModalM .btn:hover,
    #castleSealModalM .btn:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.25) inset;
    }

    /* 적용 버튼 - PC ui-btnetc 느낌 */
    #runeModalM .btn.primary,
    #castleSealModalM .btn.primary {
      background: #ecc947;
      color: #111;
      border: none;
      font-size: 15px;
      font-weight: 800;
      padding: 12px 16px;
      height: auto;
      /* 버튼 텍스트에 맞춰 */
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25);
    }

    #runeModalM .btn.primary:hover {
      background: #ffe263;
    }

    /* (있다면) 행 삭제 버튼을 눈에 띄게 */
    #runeModalM .rune-row-del {
      border-color: rgba(255, 107, 107, 0.55);
      color: #ff6b6b;
    }

    #runeModalM .rune-row-del:hover {
      border-color: #ff6b6b;
      box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.18) inset;
    }

    /* × 아이콘 버튼을 컴팩트하게 */
    #runeModalM .rune-icon-btn {
      width: 30px;
      min-width: 30px;
      height: 30px;
      /* 기본 .btn 높이(38px) 덮어씀 */
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 900;
      line-height: 1;
    }

    #runeModalM .rune-icon-btn:active {
      transform: translateY(1px);
    }

    /* ✅ 3드롭다운 상단 라벨(헤더) */
    #runeModalM .rune-picker-head {
      display: flex;
      gap: 8px;
      align-items: flex-end;
      margin: 2px 0 6px;
      padding: 0 2px;
    }

    #runeModalM .rune-picker-head .col {
      flex: 1 1 0;
      font-size: 11px;
      font-weight: 800;
      color: #c7b589;
      opacity: .95;
      letter-spacing: -0.2px;
      white-space: nowrap;
    }

    /* 우측 삭제(×) 버튼 자리와 폭 맞추기 */
    #runeModalM .rune-picker-head .spacer {
      flex: 0 0 38px;
      /* 삭제 버튼이 38px 느낌이면 딱 맞음 */
    }

    /* ✅ 상단바용 작은 btn (고유효과 '선택 적용' 느낌 유지 + 크기만 축소) */
    .btn.btn-mini {
      flex: 0 0 auto;
      /* .btn의 flex:1 무력화 (상단바에서 늘어나지 않게) */
      height: 28px;
      padding: 0 12px;
      font-size: 12px;
      border-radius: 999px;
    }

    /* ✅ Page4: 초기화 버튼(고유효과 '선택 적용' 느낌 + 배경 투명) */
    #btnSkillResetM.btn.btn-mini {
      background: transparent !important;
      border: 1px solid rgba(231, 199, 125, .35);
      color: #e9d7a6;
      box-shadow: none;
    }

    #btnSkillResetM.btn.btn-mini:active {
      transform: translateY(1px);
    }

    #btnSkillResetM.btn.btn-mini:hover {
      background: rgba(231, 199, 125, .08) !important;
    }


    /* ===== Page4 Skill ===== */
    .skill-topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .skill-topbar-title {
      font-size: 15px;
      font-weight: 700;
      color: #e9d7a6;
      letter-spacing: -0.2px;
    }

    .skill-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .skill-row {
      display: flex;
      align-items: stretch;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px;
      border: 1px solid rgba(231, 199, 125, .22);
      border-radius: 10px;
      background: rgba(12, 16, 24, .55);
    }

    .skill-left {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
      /* 아이콘-이름 간격 */
    }

    /* (추가) 스킬 아이콘 */
    .skill-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid rgba(231, 199, 125, .28);
      background: rgba(18, 22, 32, .60);
    }

    .skill-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .skill-name {
      font-size: 14px;
      font-weight: 700;
      color: #f3e6c1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .skill-right {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 172px;
    }

    .skill-ctrl {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
    }

    .skill-ctrl .lbl {
      font-size: 12px;
      color: rgba(233, 215, 166, .85);
      width: 22px;
      text-align: left;
    }
    /* ✅ Page4 Skill: SP/TP 라벨을 '남은 SP/TP'와 동일한 톤으로 */
.skill-ctrl .lbl.c-sp {
  color: #6ec6ff;
  font-weight: 800;
  letter-spacing: -0.2px;
}
.skill-ctrl .lbl.c-tp {
  color: #ff6b6b;
  font-weight: 800;
  letter-spacing: -0.2px;
}

    .skill-val {
      min-width: 26px;
      text-align: center;
      font-size: 12px;
      font-weight: 800;
      color: #e9d7a6;
    }

    .skill-mini {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(231, 199, 125, .25);
      background: rgba(18, 22, 32, .65);
      color: #e9d7a6;
      font-size: 12px;
      font-weight: 800;
      line-height: 1;
    }

    .skill-mini:active {
      transform: translateY(1px);
    }

    .skill-mini.is-wide {
      padding: 6px 10px;
    }

    .skill-mini[disabled] {
      opacity: .35;
      cursor: not-allowed;
    }

    .skill-footnote {
      margin-top: 10px;
      font-size: 12px;
      color: rgba(233, 215, 166, .65);
    }

    /* 렙제 구분 헤더(구분선) */
    .skill-divider {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 2px 2px;

      margin-top: 14px;
      /* ✅ 구간 사이 간격 */
      margin-bottom: 4px;
      /* ✅ 헤더-첫 스킬 간격 */
    }

    .skill-divider .txt {
      font-size: 12px;
      font-weight: 900;
      color: rgba(233, 215, 166, .9);
      white-space: nowrap;
    }

    .skill-divider .line {
      height: 1px;
      flex: 1 1 auto;
      background: rgba(231, 199, 125, .22);
    }

    /* ✅ 상단 고정(스크롤 내려도 보이게) */
    .skill-sticky {
      position: sticky;
      top: 0;
      z-index: 6;
      margin: -16px -16px 10px;
      padding: 12px 16px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.10);
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.12));
      backdrop-filter: blur(10px);
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
    }

    .skill-remaining {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-top: 8px;
      margin-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.10);
    }

    .skill-remaining.is-hidden {
      display: none;
    }

    .skill-remaining .item {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-size: 12px;
      font-weight: 900;
      color: rgba(233, 238, 247, 0.78);
      letter-spacing: -0.2px;
    }

    .skill-remaining .num {
      font-size: 14px;
      font-weight: 900;
      color: rgba(233, 238, 247, 0.96);
    }

    /* Skill remaining bar */
#skillRemainBarM.is-hidden { display: none; }

/* ✅ 공통 숨김 유틸(모바일 전역) */
.is-hidden { display: none !important; }

    /* ✅ Page4: 남은 SP/TP (PC 느낌) */
    .st-counters {
      display: flex;
      gap: 10px;
      justify-content: flex-start;
      align-items: center;
      margin: 0 0 10px;
      padding: 8px 10px;
      border: 1px solid rgba(231, 199, 125, .18);
      border-radius: 10px;
      background: rgba(12, 16, 24, .45);
    }

    .st-counters span {
      display: inline-flex;
      align-items: baseline;
      gap: 6px;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: -0.2px;
    }

    .st-counters span i {
      font-style: normal;
      font-weight: 900;
      opacity: .95;
    }

    /* SP / TP 라벨 색 (PC 느낌 참고용) */
    .st-counters .c-sp i {
      color: #6ec6ff;
    }

    /* 파란 SP */
    .st-counters .c-tp i {
      color: #ff6b6b;
    }

    /* 빨간 TP */

    .st-counters span b {
      font-size: 14px;
      font-weight: 900;
      color: #f3e6c1;
      opacity: .95;
    }


    /* =========================
   ✅ (Mobile) PC풍 세트 모달 스타일
========================= */

    /* =========================
   ✅ (Mobile) Set Modal: header 고정 + body만 스크롤
========================= */
    .armor-set-dialog {
      width: min(980px, 96vw);
      height: min(720px, 90vh);

      /* ✅ 핵심: dialog는 스크롤 금지, 레이아웃은 column */
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* ✅ 상단(소제목+토글) 고정 */
    .armor-set-titlebar {
      position: sticky;
      /* 혹시 dialog가 스크롤되는 케이스까지 대비 */
      top: 0;
      z-index: 10;

      display: flex;
      align-items: center;
      justify-content: center;

      padding: 6px 0 8px;
      border-bottom: 1px solid #2a211a;

      /* ✅ 스크롤 중에도 배경이 비치지 않게 */
      background: #15100c;
    }

    /* ✅ 리스트 영역만 스크롤 */
    .armor-set-body {
      flex: 1;
      min-height: 0;
      /* ✅ 모바일에서 flex 자식 스크롤 필수 */
      overflow: auto;
      -webkit-overflow-scrolling: touch;

      padding: 8px 6px 14px;
    }


    /* 카드 그리드: ✅ 모바일 전용 1열 */
    .armor-set-list {
      display: grid;
      grid-template-columns: 1fr;
      /* ✅ 1열로 고정 */
      gap: 10px;
    }

    /* ✅ 1열에서는 스페이서가 필요 없으니 항상 숨김 */
    .armor-set-spacer {
      display: none !important;
    }

    /* ✅ 세트 그룹 구분선 + 소제목(PC처럼) */
    .armor-set-divider {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 12px 0 6px;

      font-size: 12px;
      font-weight: 900;
      color: rgba(246, 231, 210, 0.78);
      letter-spacing: -0.2px;
    }

    .armor-set-divider::before,
    .armor-set-divider::after {
      content: "";
      height: 1px;
      flex: 1 1 auto;
      background: rgba(255, 255, 255, 0.14);
    }

    .armor-set-divider .txt {
      white-space: nowrap;
      padding: 0 2px;
    }


    /* (PC처럼) 첫 줄 정렬 맞추기용 스페이서 */
    .armor-set-spacer {
      display: none;
    }

    @media (min-width: 720px) {
      .armor-set-spacer {
        display: block;
      }
    }

    /* 세트 카드 */
    .armor-set-card {
      background: #15100c;
      border: 1px solid #3b2b1e;
      border-radius: 14px;
      padding: 10px;
    }

    /* 카드 헤더: 세트명 + 적용버튼 */
    .armor-set-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 13px;
      font-weight: 900;
      color: #f6e7d2;
    }

    /* “세트 적용” 버튼(PC 토글 느낌) */
    .set-auto-toggle {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(250, 204, 107, .9);
      background: rgba(250, 204, 21, 0.10);
      color: #facc6b;
      font-weight: 900;
    }

    /* 카드 안 아이템들 */
    .armor-set-items {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    /* 아이템 버튼 */
    .armor-set-item {
      background: none;
      border: 0;
      padding: 0;
      cursor: pointer;
    }

    /* 아이콘 박스 */
    .iconbox {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(255, 255, 255, .10);
      background: rgba(255, 255, 255, .05);
    }

    .icon {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    /* 레벨 배지 */
    .badge-lv {
      position: absolute;
      left: 4px;
      bottom: 4px;
      font-size: 10px;
      font-weight: 900;
      padding: 2px 5px;
      border-radius: 999px;
      color: #fff;
      background: rgba(0, 0, 0, .55);
      border: 1px solid rgba(255, 255, 255, .14);
    }

    /* =========================
   ✅ PC 고유효과 모달 스타일 이식 (Mobile)
========================= */

    /* PC의 titlebar */
    .armor-set-titlebar h2 {
      margin: 0;
      font-size: 15px;
      color: #f0e6d2;
      font-weight: 700;
      text-align: center;
    }

    .armor-set-titlebar .close {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 26px;
      height: 26px;
      display: grid;
      place-items: center;
      line-height: 1;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.08);
      color: #fff;
      cursor: pointer;
      transition: all .2s ease;
    }

    /* ✅ 고유효과 일괄 적용: 상단 '선택 적용' 버튼(닫기 버튼 좌측) */
    #mUniqueBulkModal .armor-set-titlebar .bulk-apply {
      position: absolute;
      right: 46px;
      top: 50%;
      transform: translateY(-50%);

      height: 26px;
      padding: 0 10px;
      border-radius: 999px;

      /* ✅ 색깔 제거(중립 톤) */
      border: 1px solid rgba(255, 255, 255, 0.28);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.88);

      font-size: 11px;
      font-weight: 900;
      cursor: pointer;
      transition: all .2s ease;
    }

    #mUniqueBulkModal .armor-set-titlebar .bulk-apply:hover {
      background: rgba(255, 255, 255, 0.10);
      border-color: rgba(255, 255, 255, 0.40);
    }

    .armor-set-titlebar .close:hover {
      background: rgba(255, 255, 255, 0.16);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .armor-set-titlebar .close:hover {
      background: rgba(255, 255, 255, 0.16);
      border-color: rgba(255, 255, 255, 0.3);
    }

    /* =========================
   ✅ 익시드/에픽 토글 (Mobile)
========================= */
    .armor-set-titlebar .armor-toggle {
      position: absolute;
      right: 46px;
      /* close(오른쪽 10px) 왼쪽에 붙임 */
      top: 50%;
      transform: translateY(-50%);
    }

    /* 토글 트랙 */
    .armor-toggle {
      position: relative;
      width: 120px;
      height: 26px;
      border-radius: 999px;
      padding: 2px;
      display: flex;
      align-items: stretch;
      overflow: hidden;
      user-select: none;
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.30),
        0 3px 8px rgba(0, 0, 0, 0.35);
    }

    /* 상태별 배경 */
    .armor-toggle.mode-exceed {
      /* ✅ PC와 동일한 익시드 파란 계열 */
      background: linear-gradient(135deg, #1d4ed8, #38bdf8);
    }

    .armor-toggle.mode-epic {
      background: linear-gradient(135deg, #facc15, #f97316);
    }

    /* 라벨 */
    .armor-toggle-label {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      z-index: 2;
      transition: color .2s ease;
    }

    .armor-toggle.mode-exceed .armor-toggle-label-exceed {
      color: #0f172a;
      font-weight: 700;
    }

    .armor-toggle.mode-exceed .armor-toggle-label-epic {
      color: rgba(15, 23, 42, 0.45);
      font-weight: 600;
    }

    .armor-toggle.mode-epic .armor-toggle-label-exceed {
      color: rgba(15, 23, 42, 0.45);
      font-weight: 600;
    }

    .armor-toggle.mode-epic .armor-toggle-label-epic {
      color: #0f172a;
      font-weight: 700;
    }

    /* 손잡이 */
    .armor-toggle-thumb {
      position: absolute;
      top: 2px;
      bottom: 2px;
      width: 50%;
      border-radius: 999px;
      background: #fff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
      transition: transform .25s ease;
      z-index: 1;
    }

    .armor-toggle.mode-exceed .armor-toggle-thumb {
      transform: translateX(0%);
    }

    .armor-toggle.mode-epic .armor-toggle-thumb {
      transform: translateX(100%);
    }

    /* 키보드 포커스 (mode별 색상) */
    .armor-toggle:focus {
      outline-offset: 2px;
    }

    /* ✅ 익시드 = 파란 포커스 */
    .armor-toggle.mode-exceed:focus {
      outline: 2px solid rgba(56, 189, 248, 0.80);
    }

    /* ✅ 에픽 = 노란 포커스 */
    .armor-toggle.mode-epic:focus {
      outline: 2px solid rgba(250, 204, 21, 0.65);
    }


    /* ✅ PC 개별 고유효과 모달 닫기버튼 느낌(원형) */
    #mUniquePickModal .armor-set-titlebar .close {
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #f0e6d2;
      font-size: 14px;
      font-weight: 700;
    }

    #mUniquePickModal .armor-set-titlebar .close:hover {
      background: rgba(255, 255, 255, 0.16);
      border-color: rgba(255, 255, 255, 0.3);
    }

    /* ✅ 고유효과 모달 레이아웃 */
    .unique-dialog {
      width: min(600px, 95vw);
      max-height: 80vh;
    }

    .unique-body {
      padding: 12px 10px 14px;
      display: grid;
      gap: 12px;
    }

    .unique-section {
      border-radius: 10px;
      border: 1px solid #3a2c21;
      background: #15100c;
      padding: 8px 10px;
    }

    .unique-section-title {
      font-size: 14px;
      margin: 0 0 12px;
      color: #facc6b;
    }

    /* 고유효과 옵션 목록 */
    .unique-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* 한 줄: [버튼] [설명] */
    .unique-row {
      display: flex;
      align-items: flex-start;
      gap: 16px;
      padding: 4px 6px;
      border-radius: 8px;
      transition: background .12s ease, box-shadow .12s ease;
    }

    .unique-row:hover,
    .unique-row.is-selected {
      background: rgba(148, 163, 184, 0.12);
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.25);
    }

    .unique-row:hover .unique-btn,
    .unique-row.is-selected .unique-btn {
      transform: translateY(-1px);
      box-shadow: 0 0 0 1px rgba(248, 250, 252, 0.35);
    }

    .unique-row:hover .unique-desc,
    .unique-row.is-selected .unique-desc {
      color: #e5e7eb;
    }

    /* 버튼/설명 */
    .unique-btn {
      min-width: 60px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #3a2c21;
      background: rgba(15, 23, 42, 0.85);
      color: var(--muted);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      align-self: flex-start;
      transition: background .12s ease, color .12s ease, box-shadow .12s ease, border-color .12s ease;
    }

    .unique-btn:hover {
      background: rgba(15, 23, 42, 1);
    }

    .unique-btn.is-active {
      box-shadow: 0 0 0 1px rgba(250, 250, 250, 0.12);
    }

    .unique-desc {
      flex: 1;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      white-space: normal;
    }

    .unique-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 4px;
    }

    /* ───── 무기 고유효과 색상 ───── */
    .unique-options-weapon .unique-btn[data-value="강타"] {
      border-color: #facc15;
      color: #facc15;
      background: rgba(250, 204, 21, 0.08);
    }

    .unique-options-weapon .unique-btn[data-value="광채"] {
      border-color: #38bdf8;
      color: #38bdf8;
      background: rgba(56, 189, 248, 0.08);
    }

    .unique-options-weapon .unique-btn[data-value="분쇄"] {
      border-color: #f97373;
      color: #f97373;
      background: rgba(248, 113, 113, 0.08);
    }

    .unique-options-weapon .unique-btn[data-value="선명"] {
      border-color: #4ade80;
      color: #4ade80;
      background: rgba(74, 222, 128, 0.08);
    }

    .unique-options-weapon .unique-btn[data-value="없음"] {
      border-color: var(--line);
      color: var(--muted);
      background: rgba(15, 23, 42, 0.6);
    }

    /* (기존 .confirm-actions 는 이제 안 쓰므로 삭제해도 됨) */

/* ✅ confirmModal 바디(내용영역)에도 presetModal과 동일한 여백/정렬을 준다 */
#confirmModal .confirm-body{
  position: relative;
  padding: 16px 14px 14px;   /* ✅ 상/좌우/하 여백 추가 */
  display:flex;
  flex-direction: column;
  gap: 10px;
  align-items:center;
}

#confirmModal .confirm-msg {
  white-space: pre-line;
  font-size: 13px;
  line-height: 1.55;
  color: #c7b589;
  /* PC preset-user-name 톤과 맞춤 */
  text-align: center;
  /* PC 모달 느낌 */
  opacity: 1;
  padding: 4px 6px;
}

/* ===== Confirm Modal Preview (PC preset 미리보기 느낌) ===== */
#confirmModal .confirm-preview {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  margin: 2px 0 10px;
}

#confirmModal .preset-thumb {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  overflow: hidden;
  border: 2px solid #cfa24f;
  background: #15100c;
  display: flex;
  align-items: center;
  justify-content: center;
}

#confirmModal .preset-thumb img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: 13% center;
  /* PC 느낌 */
}

#confirmModal .preset-char-name {
  margin-top: 6px;
  font-weight: 700;
  color: #f0e6d2;
  font-size: 15px;
  text-align: center;
}

#confirmModal .preset-user-name {
  font-size: 13px;
  color: #c7b589;
  text-align: center;
}

/* =========================
   Preset Modal (Mobile) - PC 스타일로 고정
   ========================= */

/* 다이얼로그 */
#presetModal .preset-dialog{
  width: min(520px, 92vw);
  background: rgba(18, 18, 18, 0.96);
  border: 1px solid rgba(255,255,255,0.14);
  border-radius: 16px;
  box-shadow: 0 18px 60px rgba(0,0,0,0.55);
  overflow: hidden;
}

/* 헤더 */
#presetModal header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding: 12px 14px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
}

#presetModal header h2{
  margin:0;
  font-size: 15px;
  font-weight: 900;
  letter-spacing: -0.2px;
}

/* ✅ 실제 HTML 닫기 버튼은 .close가 아니라 .btn[data-preset-close] */
#presetModal header .btn[data-preset-close]{
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: rgba(233,238,247,0.92);
  cursor: pointer;
  padding: 6px 10px;
  border-radius: 999px;
}

#presetModal header .btn[data-preset-close]:active{
  transform: translateY(1px);
}

/* 바디: PC처럼 중앙 정렬(세로) */
#presetModal .preset-body{
  position: relative;
  padding: 16px 14px 14px;
  display:flex;
  flex-direction: column;
  gap: 10px;
  align-items:center;
}

/* 휴지통 버튼: 좌상단 고정 느낌 */
#presetModal .preset-clear-btn{
  position:absolute;
  left: 14px;
  top: 14px;
  width: 34px;
  height: 34px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: rgba(233,238,247,0.90);
  cursor:pointer;
}
#presetModal .preset-clear-btn:disabled{
  opacity: .35;
  cursor: default;
}

/* ✅ 썸네일: "슬롯 초기화(확인) 모달"과 동일 스타일 */
#presetModal .preset-thumb{
  width: 120px;
  height: 120px;
  border-radius: 50%;
  overflow: hidden;

  border: 2px solid #cfa24f;   /* ✅ 노란 원형 */
  background: #15100c;         /* ✅ confirmModal과 동일 */

  display: flex;
  align-items: center;
  justify-content: center;
}


/* ✅ 썸네일 이미지도 confirmModal과 동일 */
#presetModal .preset-thumb img{
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: 13% center; /* ✅ 얼굴 위치 보정(PC 느낌) */
}


/* 이름들 */
#presetModal .preset-char-name{
  font-weight: 900;
  font-size: 15px;
  color: rgba(233,238,247,0.95);
  text-align:center;
}

#presetModal .preset-user-name{
  margin-top: -4px;
  font-weight: 800;
  font-size: 12px;
  color: rgba(233,238,247,0.55);
  text-align:center;
}

/* 액션: PC처럼 하단 가로 버튼 (presetModal + confirmModal 동일 적용) */
#presetModal .preset-actions,
#confirmModal .preset-actions{
  width: 100%;
  margin-top: 6px;
  display:flex;
  gap: 10px;
  align-items:center;
  justify-content:space-between;
}

#presetModal .preset-actions .btn,
#confirmModal .preset-actions .btn{
  flex: 1 1 auto;
  height: 42px;
  padding: 0 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: rgba(233,238,247,0.92);
  font-weight: 900;
  cursor: pointer;
}

#presetModal .preset-actions .btn:active,
#confirmModal .preset-actions .btn:active{
  transform: translateY(1px);
}

#presetModal .preset-actions .btn:disabled,
#confirmModal .preset-actions .btn:disabled{
  opacity: .35;
  cursor: default;
}

/* main/ghost 톤 */
#presetModal .preset-actions .btn.main,
#confirmModal .preset-actions .btn.main{
  background: rgba(255, 215, 0, 0.14);
  border-color: rgba(255, 215, 0, 0.22);
}

#presetModal .preset-actions .btn.ghost,
#confirmModal .preset-actions .btn.ghost{
  background: rgba(255,255,255,0.04);
}

/* ✅ 와일드베인 스킬트리 선택 UI (모바일) */
.wb-tree-box{
  margin:12px 0;
  padding:12px;
  border:1px solid rgba(255,255,255,.12);
  border-radius:12px;
  background:rgba(0,0,0,.25);
}
.wb-tree-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:8px;
}
.wb-tree-title{ font-weight:800; }
.wb-tree-summary{
  font-size:13px;
  opacity:.92;
  line-height:1.5;
}
.wb-tree-hint{ font-size:12px; opacity:.75; margin-left:6px; }

.wb-tree-grid{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:10px;
  margin-top:12px;
}
.wb-tree-btn{
  width:100%;
  padding:12px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(255,255,255,.06);
  color:#fff;
  font-weight:800;
}
.wb-tree-btn.wb-active{
  border-color:#5aa9ff;
  box-shadow:0 0 0 2px rgba(90,169,255,.25) inset;
}

.wb-cycle-wrap{ margin-top:12px; }
.wb-cycle-label{ font-size:12px; opacity:.85; margin-bottom:6px; }
.wb-cycle-input{
  width:100%;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(0,0,0,.22);
  color:#fff;
}

/* ===== 로딩 오버레이(PC와 동일) ===== */
.loading {
  opacity: 0.7;
}

.loading-overlay {
  position: fixed;
  inset: 0;
  z-index: 9999;
  background: rgba(0, 0, 0, .55);
  display: grid;
  place-items: center;
}

.loading-box {
  width: min(480px, 90vw);
  background: #0f1115;
  color: #e6e9ef;
  border: 1px solid rgba(255, 255, 255, .2);
  border-radius: 14px;
  padding: 20px 24px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, .45);
}

.loading-title {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 12px;
}

.loading-bar {
  width: 100%;
  height: 10px;
  border-radius: 999px;
  background: rgba(255, 255, 255, .12);
  overflow: hidden;
}

.loading-bar__fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #6ea8ff, #8fe3ff);
  transition: width .2s ease;
}

.loading-info {
  margin-top: 10px;
  display: flex;
  justify-content: space-between;
  font-size: 13px;
  opacity: .9;
}

  </style>
</head>

<body>
  <!-- 로딩 오버레이 (기본 hidden) -->
  <div id="loadingOverlay" class="loading-overlay" hidden>
    <div class="loading-box">
      <div class="loading-title">데이터 불러오는 중…</div>
      <div class="loading-bar">
        <div class="loading-bar__fill" style="width:0%"></div>
      </div>
      <div class="loading-info">
        <span id="loadingLabel">초기화…</span>
        <span id="loadingPct">0%</span>
      </div>
    </div>
  </div>

  <div class="m-shell">

    <!-- ====== Header ====== -->
    <header class="m-header">
      <div class="m-header-row">
        <div class="m-title">
          <div class="txt">게임실험연구소 계산기 (시즌5)</div>
        </div>

        <div class="m-actions">
          <!-- 문의하기 (PC와 동일 id 유지) -->
          <button id="btnContactAdmin" class="m-action-btn" type="button" title="문의하기">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <rect x="3" y="6" width="18" height="13" rx="2"></rect>
              <path d="M3 8l9 6 9-6"></path>
            </svg>
            <span>문의하기</span>
          </button>

          <!-- Q&A (PC와 동일 id 유지) -->
          <button id="btnFaq" class="m-action-btn" type="button" title="문의 전 자주하는 Q&A">
            <span>Q&amp;A</span>
          </button>
        </div>
      </div>
      <div id="mOneLiner" class="m-oneliner" aria-live="polite">
  <div class="text muted">한마디 불러오는 중…</div>
</div>

    </header>

    <!-- ====== Main (Swipe) ====== -->
    <main class="m-main">
      <div id="mobilePages" class="m-pages">

        <!-- Page 1: 캐릭터 -->
        <section class="m-page" id="pageChar">
          <div class="m-card">
            <div class="page-title">1 / 4</div>
            <div class="big-pick">
              <button id="btnPickChar" type="button">캐릭터 선택하기</button>
              <!-- ✅ 선택 후 표시될 캐릭터 이미지 -->
              <img id="pickedCharImg" class="picked-char-img" alt="" />
            </div>
            <div class="hint">
            </div>
          </div>
        </section>
        <!-- 캐릭터 선택 모달 (PC와 동일 id) -->
        <div id="charModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-char-close></div>
          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="charModalTitle">
            <header>
              <h2 id="charModalTitle">캐릭터 선택</h2>
              <button type="button" class="close" data-char-close>닫기</button>
            </header>

            <!-- PC 스크립트가 여기에 카드들을 렌더링함 -->
            <div id="catalog" class="catalog"></div>
          </div>
        </div>


        <!-- Page 2: 장비 -->
        <!-- =========================
     ✅ (NEW) Set Modals (Mobile)
========================= -->

        <div id="mArmorSetModal" class="modal" aria-hidden="true">
          <div class="backdrop"></div>
          <div class="dialog armor-set-dialog" role="dialog" aria-modal="true" aria-labelledby="mArmorSetTitle">
            <header class="armor-set-titlebar">
              <h2 id="mArmorSetTitle">방어구 세트 선택</h2>

              <!-- ✅ 익시드/에픽 토글 -->
              <div id="mArmorSetToggle" class="armor-toggle mode-exceed" role="button" tabindex="0"
                aria-label="익시드/에픽 토글(방어구)">
                <span class="armor-toggle-label armor-toggle-label-exceed">익시드</span>
                <span class="armor-toggle-label armor-toggle-label-epic">에픽</span>
                <div class="armor-toggle-thumb"></div>
              </div>

              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="armor-set-body">
              <div id="mArmorSetList" class="armor-set-list"></div>
            </div>
          </div>
        </div>

        <div id="mAccSetModal" class="modal" aria-hidden="true">
          <div class="backdrop"></div>
          <div class="dialog armor-set-dialog" role="dialog" aria-modal="true" aria-labelledby="mAccSetTitle">
            <header class="armor-set-titlebar">
              <h2 id="mAccSetTitle">악세사리 세트 선택</h2>
              <!-- ✅ 익시드/에픽 토글 -->
              <div id="mAccSetToggle" class="armor-toggle mode-exceed" role="button" tabindex="0"
                aria-label="익시드/에픽 토글(악세)">
                <span class="armor-toggle-label armor-toggle-label-exceed">익시드</span>
                <span class="armor-toggle-label armor-toggle-label-epic">에픽</span>
                <div class="armor-toggle-thumb"></div>
              </div>
              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="armor-set-body">
              <div id="mAccSetList" class="armor-set-list"></div>
            </div>
          </div>
        </div>

        <div id="mSpecSetModal" class="modal" aria-hidden="true">
          <div class="backdrop"></div>
          <div class="dialog armor-set-dialog" role="dialog" aria-modal="true" aria-labelledby="mSpecSetTitle">
            <header class="armor-set-titlebar">
              <h2 id="mSpecSetTitle">특수장비 세트 선택</h2>
              <!-- ✅ 익시드/에픽 토글 -->
              <div id="mSpecSetToggle" class="armor-toggle mode-exceed" role="button" tabindex="0"
                aria-label="익시드/에픽 토글(특수)">
                <span class="armor-toggle-label armor-toggle-label-exceed">익시드</span>
                <span class="armor-toggle-label armor-toggle-label-epic">에픽</span>
                <div class="armor-toggle-thumb"></div>
              </div>
              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="armor-set-body">
              <div id="mSpecSetList" class="armor-set-list"></div>
            </div>
          </div>
        </div>


        <div id="mUniqueBulkModal" class="modal" aria-hidden="true">
          <!-- ✅ 바깥 터치 = '선택 적용'과 동일 동작 -->
          <div class="backdrop" data-unique-bulk-apply></div>

          <div class="dialog unique-dialog" role="dialog" aria-modal="true" aria-labelledby="mUniqueBulkTitle">
            <header class="armor-set-titlebar">
              <h2 id="mUniqueBulkTitle">고유효과 일괄 적용</h2>

              <!-- ✅ '닫기' 버튼 좌측에 '선택 적용' 배치 -->
              <button type="button" class="bulk-apply" id="mUniqueBulkApplyBtn">선택 적용</button>

              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="unique-body">
              <!-- 무기 고유효과 -->
              <section class="unique-section">
                <h3 class="unique-section-title">무기 고유효과</h3>
                <div class="unique-options unique-options-weapon">
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="강타">강타</button>
                    <div class="unique-desc" data-kind="weapon" data-value="강타"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="광채">광채</button>
                    <div class="unique-desc" data-kind="weapon" data-value="광채"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="분쇄">분쇄</button>
                    <div class="unique-desc" data-kind="weapon" data-value="분쇄"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="선명">선명</button>
                    <div class="unique-desc" data-kind="weapon" data-value="선명"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="없음">없음</button>
                    <div class="unique-desc" data-kind="weapon" data-value="없음"></div>
                  </div>
                </div>
              </section>

              <!-- 기타 고유효과 -->
              <section class="unique-section">
                <h3 class="unique-section-title">기타 고유효과</h3>
                <div class="unique-options unique-options-other">
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="선봉">선봉</button>
                    <div class="unique-desc" data-kind="other" data-value="선봉"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="의지">의지</button>
                    <div class="unique-desc" data-kind="other" data-value="의지"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="이상">이상</button>
                    <div class="unique-desc" data-kind="other" data-value="이상"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="없음">없음</button>
                    <div class="unique-desc" data-kind="other" data-value="없음"></div>
                  </div>
                </div>
              </section>
            </div>
          </div>
        </div>
        <!-- ✅ 개별 고유효과 선택 모달 -->
        <div id="mUniquePickModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-mset-close></div>

          <div class="dialog unique-dialog" role="dialog" aria-modal="true" aria-labelledby="mUniquePickTitle">
            <header class="armor-set-titlebar">
              <h2 id="mUniquePickTitle">고유효과</h2>
              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="unique-body">
              <section class="unique-section">
                <h3 class="unique-section-title">고유효과 선택</h3>

                <!-- ✅ 리스트를 unique-options로 감싸면 PC처럼 줄 간격/hover/선택 강조 전부 먹음 -->
                <div id="mUniquePickList" class="unique-options"></div>
              </section>

              <div class="unique-actions">
                <button type="button" class="btn" data-mset-close>닫기</button>
              </div>
            </div>
          </div>
        </div>



        <!-- ✅ 장비 선택 모달 -->
        <div id="equipModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-close></div>
          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipModalTitle">
            <header>
              <h2 id="equipModalTitle">장비 선택</h2>
              <button type="button" class="close" data-equip-close>닫기</button>
            </header>
            <div class="equip-topbar" id="equipTopbar">
              <button type="button" class="equip-topbtn active" data-eqtab="enh">강화</button>

              <!-- ✅ 추가: 보조장비(sub)에서만 보여줄 연마 버튼 -->
              <button type="button" class="equip-topbtn equip-topbtn-grind" data-eqtab="grind"
                style="display:none;">연마</button>

              <!-- ✅ 마법봉인 = 고유옵션/일반옵션 2개 -->
              <button type="button" class="equip-topbtn" data-eqtab="seal_u">고유옵션</button>
              <button type="button" class="equip-topbtn" data-eqtab="seal_n">일반옵션</button>

              <button type="button" class="equip-topbtn" data-eqtab="enchant">마법부여</button>

              <!-- ✅ 엠블렘: 글자 없이 “구멍”만 (구멍 자체가 버튼) -->
              <button type="button" class="equip-topbtn is-emblems" data-eqtab="emblem" aria-label="엠블렘 선택">
                <span class="top-embs">
                  <!-- JS에서 슬롯 종류에 따라 1개/2개로 다시 그려줌 -->
                  <span class="emb"></span>
                  <span class="emb"></span>
                </span>
              </button>
            </div>


            <div id="equipCatalog" class="catalog"></div>
          </div>
        </div>

        <!-- ✅ (방법B) 강화 선택 2중 모달 -->
        <div id="equipEnhModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-enh-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipEnhModalTitle">
            <header>
              <h2 id="equipEnhModalTitle">강화 선택</h2>
              <button type="button" class="close" data-equip-enh-close>✕</button>
            </header>

            <div class="items">
              <div id="equipEnhList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (방법B) 마법봉인: 고유옵션 2중 모달 -->
        <div id="equipSealUModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-seal-u-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipSealUModalTitle">
            <header>
              <h2 id="equipSealUModalTitle">고유옵션 선택</h2>
              <button type="button" class="close" data-equip-seal-u-close>✕</button>
            </header>

            <div class="items">
              <div id="equipSealUList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (방법B) 마법봉인: 일반옵션 2중 모달 -->
        <div id="equipSealNModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-seal-n-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipSealNModalTitle">
            <header>
              <h2 id="equipSealNModalTitle">일반옵션 선택</h2>
              <button type="button" class="close" data-equip-seal-n-close>✕</button>
            </header>

            <div class="items">
              <div id="equipSealNList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (방법B) 마법부여 선택 2중 모달 -->
        <div id="equipEnchantModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-enchant-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipEnchantModalTitle">
            <header>
              <h2 id="equipEnchantModalTitle">마법부여 선택</h2>
              <button type="button" class="close" data-equip-enchant-close>✕</button>
            </header>

            <div class="items">
              <div id="equipEnchantList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (추가) 엠블렘 선택 2중 모달 -->
        <div id="equipEmblemModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-emblem-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipEmblemModalTitle">
            <header>
              <h2 id="equipEmblemModalTitle">엠블렘 선택</h2>
              <button type="button" class="close" data-equip-emblem-close>✕</button>
            </header>

            <div class="items">
              <div id="equipEmblemTarget"></div>
              <div id="equipEmblemList"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (방법B) 연마 선택 2중 모달 -->
        <div id="equipGrindModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-grind-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipGrindModalTitle">
            <header>
              <h2 id="equipGrindModalTitle">연마 선택</h2>
              <button type="button" class="close" data-equip-grind-close>✕</button>
            </header>

            <div class="items">
              <div id="equipGrindList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <section class="m-page" id="pageEquip">
          <div class="m-card">
            <div class="page-title">2 / 4</div>

            <div class="equip-body">

              <!-- 무기 -->
              <div class="equip-group">
                <!-- ✅ (NEW) Set Equipment Buttons -->
                <div class="equip-set-bar">
                  <button type="button" id="btnMSetArmor" class="equip-set-btn">방어구</button>
                  <button type="button" id="btnMSetAcc" class="equip-set-btn">악세사리</button>
                  <button type="button" id="btnMSetSpec" class="equip-set-btn">특수장비</button>
                  <button type="button" id="btnMOchingkra" class="equip-set-btn">오칭크아</button>
                  <button type="button" id="btnMUniqueBulk" class="equip-set-btn">고유효과</button>
                </div>

                <!-- ✅ (NEW) separator between "set buttons" and "auto input buttons" -->
                <div class="equip-auto-sep"></div>

                <div class="equip-auto-bar" data-for="weapon">
                  <button type="button" class="equip-auto-btn" id="btnWeaponAutoEnh">강화 자동 입력</button>
                  <button type="button" class="equip-auto-btn" id="btnWeaponAutoSeal">추천 마법봉인 자동 입력</button>
                  <button type="button" class="equip-auto-btn" id="btnWeaponAutoEnchant">추천 마법부여 자동 입력</button>
                  <button type="button" class="equip-auto-btn" id="btnWeaponAutoEmblem">엠블렘 자동 입력</button>
                </div>
                <div class="equip-auto-sep"></div>
                <div class="equip-group-head">
                  <span>무기</span>

                  <div class="equip-u-mini" role="button" tabindex="0" data-utarget="weaponType" data-uslot="weapon">
                    <span class="tag">고유효과</span>
                    <span class="val" data-uval="weaponType">-</span>
                  </div>
                </div>
                <div class="equip-list">
                  <button type="button" class="equip-row" data-slot="weapon" data-grind="1" aria-label="무기 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">무기</div>
                    </div>

                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>

                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>

                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>

                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>
                </div>
              </div>

              <!-- 방어구 -->
              <div class="equip-group">
                <div class="equip-group-head">
                  <span>방어구</span>

                  <div class="equip-u-mini" role="button" tabindex="0" data-utarget="armorType" data-uslot="top">
                    <span class="tag">고유효과</span>
                    <span class="val" data-uval="armorType">-</span>
                  </div>
                </div>

                <div class="equip-list">

                  <button type="button" class="equip-row" data-slot="headshoulder" aria-label="머리어깨 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">머리어깨</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="top" aria-label="상의 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">상의</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="bottom" aria-label="하의 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">하의</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="belt" aria-label="허리 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">허리</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="shoes" aria-label="신발 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">신발</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                </div>
              </div>

              <!-- 악세사리 -->
              <div class="equip-group">
                <div class="equip-group-head">
                  <span>악세사리</span>

                  <div class="equip-u-mini" role="button" tabindex="0" data-utarget="braceletType"
                    data-uslot="bracelet">
                    <span class="tag">고유효과</span>
                    <span class="val" data-uval="braceletType">-</span>
                  </div>
                </div>
                <div class="equip-list">

                  <button type="button" class="equip-row" data-slot="bracelet" aria-label="팔찌 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">팔찌</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="necklace" aria-label="목걸이 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">목걸이</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="ring" aria-label="반지 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">반지</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                </div>
              </div>

              <!-- 특수장비 -->
              <div class="equip-group">
                <div class="equip-group-head">
                  <span>특수장비</span>

                  <div class="equip-u-mini" role="button" tabindex="0" data-utarget="earringType" data-uslot="earring">
                    <span class="tag">고유효과</span>
                    <span class="val" data-uval="earringType">-</span>
                  </div>
                </div>

                <div class="equip-list">

                  <button type="button" class="equip-row" data-slot="sub" data-grind="1" aria-label="보조장비 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">보조장비</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="magestone" aria-label="마법석 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">마법석</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="earring" aria-label="귀걸이 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">귀걸이</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                                </div>
              </div>

              <!-- ✅ 오칭크아 (오라/칭호/크리쳐/아티팩트) -->
              <div class="equip-group">
                <div class="equip-group-head">
                  <span>오칭크아</span>
                </div>

                <div class="equip-list">

                  <!-- 칭호: 마법부여 + 플래티넘 엠블렘 1개 -->
                  <button type="button" class="equip-row" data-slot="title" aria-label="칭호 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">칭호</div>
                    </div>

                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>

                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>

                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>

                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                 <!-- ✅ 오라/크리쳐/아티팩트: 한 슬롯 묶음 -->
<div class="equip-oca-row" aria-label="오라/크리쳐/아티팩트">
  <button type="button" class="oca-item" data-slot="aura" aria-label="오라 선택">
    <div class="equip-left">
      <div class="equip-img"></div>
      <div class="equip-name">오라</div>
    </div>
  </button>

  <button type="button" class="oca-item" data-slot="creature" aria-label="크리쳐 선택">
    <div class="equip-left">
      <div class="equip-img"></div>
      <div class="equip-name">크리쳐</div>
    </div>
  </button>

  <button type="button" class="oca-item" data-slot="artifact" aria-label="아티팩트 선택">
    <div class="equip-left">
      <div class="equip-img"></div>
      <div class="equip-name">아티팩트</div>
    </div>
  </button>
</div>


                </div>
              </div>
              <!-- ✅ 오칭크아 끝 -->

            </div>
          </div>
        </section>

        <section class="m-page" id="pageEtc">
          <div class="m-card">
            <div class="page-title">3 / 4</div>

            <!-- 1) 아바타 / 무기압 -->
            <div class="opt-box">
              <h4 class="opt-title">아바타 세부 선택</h4>

              <label class="field">
                <span class="label">아바타</span>
                <select id="selAvatarM" class="select">
                  <option value="" selected>아바타 선택</option>
                </select>
              </label>

              <label class="field">
                <span class="label">무기압</span>
                <select id="selImprintM" class="select">
                  <option value="" selected>무기압 선택</option>
                </select>
              </label>
            </div>

            <!-- 2) 계산 세부 옵션 -->
            <div class="opt-box">
              <h4 class="opt-title">계산 세부 옵션 조절</h4>

              <label class="field">
                <span class="label">시간 기준</span>
                <select id="selTimeM" class="select">
                  <option value="30s">30초딜</option>
                  <option value="1m" selected>1분딜</option>
                  <option value="3m">3분딜</option>
                  <option value="5m">5분딜</option>
                  <option value="10m">10분딜</option>
                </select>
              </label>

              <label class="field">
                <span class="label">몬스터 설정</span>
                <select id="selMonsterM" class="select">
                  <option value="" selected>몬스터 선택</option>
                </select>
              </label>

              <label class="field">
                <span class="label">던전 난이도(미구현)</span>
                <select id="selDungeonM" class="select" disabled>
                  <option value="" selected>누골방 고정(미구현)</option>
                </select>
              </label>
            </div>

            <!-- 3) 스킬룬 / 룬각인 -->
            <div class="opt-box">
              <div class="opt-title">
                <span>스킬룬 / 룬 각인</span>
                <span style="font-size:12px;opacity:.8;">
                  선택 룬: <b id="runeCountM">0</b>
                </span>
              </div>

              <button id="btnRuneM" class="btn primary" type="button">스킬룬 설정</button>

              <div style="height:8px;"></div>

              <div class="row">
                <label class="field">
                  <span class="label">룬 각인 설정</span>
                  <select id="selRuneEngraveM" class="select">
                    <option value="" selected>룬 각인 선택</option>
                  </select>
                </label>

                <label class="field">
                  <span class="label">세부 설정</span>
                  <select id="selRuneDetailM" class="select" disabled>
                    <option value="" selected>세부 설정</option>
                  </select>
                </label>
              </div>
            </div>

            <!-- 4) 성안의 봉인 -->
            <div class="opt-box">
              <div class="opt-title">
                <span>성안의 봉인</span>
                <button id="btnCastleSealM" class="btn primary" type="button">옵션 선택</button>
              </div>
              <div id="castleSealSummaryM" style="font-size:12px;opacity:.85; line-height:1.35;">
                <div>주요 옵션 : <span id="castleSealMainPickM">-</span></div>
                <div>추가 옵션 : <span id="castleSealSubPickM">-</span></div>
              </div>
            </div>

          </div>
        </section>

        <!-- ✅ Page 4: Skill -->
        <section class="m-page" id="pageSkill">
          <div class="page-title">4 / 4</div>

          <div class="m-card">
            <div class="skill-sticky">
              <div class="skill-topbar">
                <div class="skill-topbar-title">스킬</div>
                <button id="btnSkillResetM" type="button" class="btn btn-mini">초기화</button>
              </div>

              <div id="skillRemainBarM" class="st-counters is-hidden">
                <span class="c-sp"><i>SP</i> <b id="skillRemainSpM">-</b></span>
                <span class="c-tp"><i>TP</i> <b id="skillRemainTpM">-</b></span>
              </div>
            </div>

            <!-- ✅ 와일드베인/윈드시어 전용: 스킬트리 선택 -->
<div id="wildbaneTreeBoxM" class="wb-tree-box is-hidden">
  <div class="wb-tree-head">
    <div class="wb-tree-title">스킬선택</div>
    <button id="btnWildbaneTreeM" class="btn primary" type="button">선택</button>
  </div>

  <div class="wb-tree-summary">
    <div>선택 스킬트리 : <b id="wildbaneTreePickM">-</b></div>
    <div>사이클 횟수 : <b id="wildbaneCyclePickM">-</b> <span class="wb-tree-hint">(0이면 자동)</span></div>
  </div>
</div>

<div id="windshearTreeBoxM" class="wb-tree-box is-hidden">
  <div class="wb-tree-head">
    <div class="wb-tree-title">스킬선택</div>
    <button id="btnWindshearTreeM" class="btn primary" type="button">선택</button>
  </div>

  <div class="wb-tree-summary">
    <div>선택 스킬트리 : <b id="windshearTreePickM">-</b></div>
    <div>사이클 횟수 : <b id="windshearCyclePickM">-</b> <span class="wb-tree-hint">(0이면 자동)</span></div>
  </div>
</div>
            <div id="skillListM" class="skill-list"></div>

            <div class="skill-footnote">
              * SP = 스킬 레벨, TP = TP 레벨 (각 행에서 MIN/MAX/±로 조절)
            </div>
          </div>
        </section>


      </div>
    </main>

    <!-- ✅ 저장슬롯: 푸터 바깥 / 푸터 바로 위 (PC 저장슬롯과 동일 UI) -->
    <div id="mobilePresetBar" class="m-presetbar-bottom" aria-label="저장슬롯">
      <div class="save-box">
        <div class="preset-slot">
          <button type="button" class="preset-btn" data-slot="1">+</button>
          <button type="button" class="preset-trash" data-slot="1" aria-label="슬롯 1 초기화">🗑</button>
        </div>
        <div class="preset-slot">
          <button type="button" class="preset-btn" data-slot="2">+</button>
          <button type="button" class="preset-trash" data-slot="2" aria-label="슬롯 2 초기화">🗑</button>
        </div>
        <div class="preset-slot">
          <button type="button" class="preset-btn" data-slot="3">+</button>
          <button type="button" class="preset-trash" data-slot="3" aria-label="슬롯 3 초기화">🗑</button>
        </div>
        <div class="preset-slot">
          <button type="button" class="preset-btn" data-slot="4">+</button>
          <button type="button" class="preset-trash" data-slot="4" aria-label="슬롯 4 초기화">🗑</button>
        </div>
        <div class="preset-slot">
          <button type="button" class="preset-btn" data-slot="5">+</button>
          <button type="button" class="preset-trash" data-slot="5" aria-label="슬롯 5 초기화">🗑</button>
        </div>

        <button type="button" class="preset-page-btn prev" id="presetPagePrev" aria-label="이전 저장슬롯 페이지">‹</button>
        <button type="button" class="preset-page-btn next" id="presetPageNext" aria-label="다음 저장슬롯 페이지">›</button>
        <div class="preset-page-ind" id="presetPageInd" aria-hidden="true"></div>
      </div>
    </div>

    <!-- ====== Bottom Fixed ====== -->
    <footer class="m-footer" style="height: var(--footer-h);">
      <div class="m-footer-row">
        <button id="btnMobileCompute" class="m-calc-btn" type="button">계산하기</button>

        <div class="m-result">
          <div class="label">계산 결과</div>
          <div id="mobileFinalDamage" class="value">-</div>
        </div>
      </div>
    </footer>

  </div>

  <!-- ====== Modals (PC 것을 그대로 가져오기 쉬운 형태) ====== -->
  <!-- 관리자 문의 모달 -->
  <div id="contactModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-contact-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="contactTitle">
      <header>
        <h2 id="contactTitle">게임실험연구소에 문의하기</h2>
        <button type="button" class="close" data-contact-close>닫기</button>
      </header>

      <div class="contact-body">
        <div class="contact-notice">
          계산기 이용 중 정상적이지 않은 동작/오류/버그를 제보해주세요.<br />
          실시간 문의: 게임실험연구소 오픈채팅
        </div>

        <textarea id="contactTalk" class="contact-textarea" placeholder="문의하실 내용을 최대한 상세하게 적어주셔야
빠르고 정확한 답변이 가능합니다.

소울 계산이 안됩니다.  (X)
소울, 암흑의 별 선택시
계산값이 0으로 나옵니다.  (O)"></textarea>
        <div class="contact-actions">
          <button id="btnContactSend" class="ui-btnetc" type="button">문의 보내기</button>
        </div>
      </div>
    </div>
  </div>

  <!-- FAQ 목록 모달 -->
  <div id="faqModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-faq-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="faqTitle">
      <header>
        <h2 id="faqTitle">문의하기 전 자주하는 Q&amp;A</h2>
        <button type="button" class="close" data-faq-close>닫기</button>
      </header>

      <div class="contact-body">
        <div class="contact-notice">
          가장 많이 하시는 질문들을 모아두었습니다.
        </div>
        <div id="faqList" class="faq-list"></div>
      </div>
    </div>
  </div>

  <!-- FAQ 답변 모달 (일단 placeholder) -->
  <div id="faqAnswerModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-faqans-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="faqAnswerTitle">
      <header>
        <h2 id="faqAnswerTitle">Q&amp;A</h2>
        <button type="button" class="close" data-faqans-close>닫기</button>
      </header>
      <div class="contact-body">
        <div id="faqAnswerText" class="contact-notice"></div>
      </div>
    </div>
  </div>


  <!-- ✅ 스킬룬 설정 모달 (모바일) -->
  <div id="runeModalM" class="modal" aria-hidden="true">
    <div class="backdrop" data-rune-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="runeDlgTitleM">
      <header style="display:flex;align-items:center;gap:10px;">
        <h2 id="runeDlgTitleM" style="flex:1;">
          스킬룬 설정
          <span style="font-size:12px;opacity:.75;font-weight:600;display:block;margin-top:2px;">
            선택한 스킬룬 개수: <b id="runeCountLabelM" style="color:#ef4444;">0</b> / 20
          </span>
        </h2>
        <button type="button" class="close" data-rune-close>닫기</button>
      </header>

      <div class="items" style="padding:10px;">
        <!-- ✅ 3드롭다운 헤더 라벨 -->
        <div class="rune-picker-head" aria-hidden="true">
          <div class="col">스킬룬 종류</div>
          <div class="col">스킬 레벨</div>
          <div class="col">스킬룬 갯수</div>
          <div class="spacer"></div> <!-- (우측 × 삭제 버튼 자리 정렬용) -->
        </div>
        <div id="runePickRowsM" class="rune-picker-rows"
          style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;"></div>
        <button id="btnRuneRowAddM" class="btn" type="button" style="width:100%;margin:0 0 10px;">+ 스킬룬 행 추가</button>

        <div class="special-runes">
          <div class="special-runes-title">특수 스킬룬</div>

          <div class="special-rune-row">
            <img src="./img/etc/skillrune/왜가지.png" alt="왜가지" class="special-rune-icon">
            <label for="specialRune_gahoM">가호</label>
            <select id="specialRune_gahoM" class="select rune-select" aria-label="가호 개수">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>

          <div class="special-rune-row">
            <img src="./img/etc/skillrune/왜가지.png" alt="왜가지" class="special-rune-icon">
            <label for="specialRune_jiheM">지혜</label>
            <select id="specialRune_jiheM" class="select rune-select" aria-label="지혜 개수">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>

          <div class="special-rune-row">
            <img src="./img/etc/skillrune/왜가지.png" alt="왜가지" class="special-rune-icon">
            <label for="specialRune_waegokM">왜곡</label>
            <select id="specialRune_waegokM" class="select rune-select" aria-label="왜곡 개수">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>
        </div>

        <div style="height:10px;"></div>
        <button id="runeCommitM" class="btn primary" type="button" style="width:100%;">설정 하기</button>
      </div>
    </div>
  </div>
  <!-- ✅ 성안의 봉인 설정 모달 (모바일) -->
  <div id="castleSealModalM" class="modal" aria-hidden="true">
    <div class="backdrop" data-seal-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="castleSealDlgTitleM">
      <header style="display:flex;align-items:center;gap:10px;">
        <h2 id="castleSealDlgTitleM" style="flex:1;">성안의 봉인</h2>
        <button type="button" class="close" data-seal-close>닫기</button>
      </header>

      <div class="items" style="padding:10px;">
        <div style="display:flex;flex-direction:column;gap:10px;">
          <div>
            <div style="font-size:12px;font-weight:800;color:#c7b589;margin-bottom:6px;">주요 옵션</div>
            <select id="castleSealMainSelM" class="select" aria-label="주요 옵션"></select>
          </div>

          <div>
            <div style="font-size:12px;font-weight:800;color:#c7b589;margin-bottom:6px;">추가 옵션</div>
            <select id="castleSealSubSelM" class="select" aria-label="추가 옵션"></select>
          </div>

          <div style="height:6px;"></div>
          <button id="castleSealCommitM" class="btn primary" type="button" style="width:100%;">설정 하기</button>
        </div>
      </div>
    </div>
  </div>

    <!-- ▼ 워리어 와일드베인: 스킬트리 2안 선택 모달 (모바일) -->
  <div id="wildbaneTreeModalM" class="modal" aria-hidden="true">
    <div class="backdrop" data-wb-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="wbTreeTitleM" style="width:min(520px,92vw);">
      <header style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
        <h2 id="wbTreeTitleM" style="margin:0;">스킬트리 선택</h2>
        <button type="button" class="close" data-wb-close>닫기</button>
      </header>

      <div class="items" style="padding:14px;">
        <div style="font-size:13px;color:#fff;line-height:1.45;opacity:.95;">
          워리어 와일드베인은 <b>스킬을 직접 찍을 수 없고</b>,<br>
          정형화된 2가지 스킬트리 중 하나를 선택 한 뒤 <b>사이클 횟수</b>를 입력합니다.<br><br>
          ※ 사이클 횟수 = 0 이면 “시간 기준”으로 자동 계산됩니다.
        </div>

        <div class="wb-tree-grid">
          <button type="button" class="wb-tree-btn" data-wb-tree="파파초">파파초</button>
          <button type="button" class="wb-tree-btn" data-wb-tree="파빨초">파빨초</button>
        </div>

        <div class="wb-cycle-wrap">
          <div class="wb-cycle-label">사이클 횟수 직접 입력</div>
          <input id="wbCycleCountM" class="wb-cycle-input" type="number" inputmode="numeric" min="0" step="1" value="0" placeholder="0">
        </div>

        <button id="btnWildbaneTreeApplyM" class="btn primary" type="button" style="width:100%;margin-top:12px;">
          선택하기
        </button>
      </div>
    </div>
  </div>

  <!-- ▼ 워리어 윈드시어: 스킬트리 3안 선택 모달 (모바일) -->
<div id="windshearTreeModalM" class="modal" aria-hidden="true">
  <div class="backdrop" data-ws-close></div>
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="wsTreeTitleM" style="width:min(520px,92vw);">
    <header style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
      <h2 id="wsTreeTitleM" style="margin:0;">스킬트리 선택</h2>
      <button type="button" class="close" data-ws-close>닫기</button>
    </header>

    <div class="items" style="padding:14px;">
      <div style="font-size:13px;color:#fff;line-height:1.45;opacity:.95;">
        워리어 윈드시어는 <b>스킬을 직접 찍는 방식이 아니라</b>,<br>
        정형화된 3가지 스킬트리 중 하나를 선택 한 뒤 <b>사이클 횟수</b>를 입력합니다.<br><br>
        ※ 사이클 횟수 = 0 이면 “시간 기준”으로 자동 계산됩니다.
      </div>

      <div class="wb-tree-grid" style="margin-top:12px;">
        <button type="button" class="wb-tree-btn" data-ws-tree="A">A (파파파파빨)</button>
        <button type="button" class="wb-tree-btn" data-ws-tree="B">B (파파파빨)</button>
        <button type="button" class="wb-tree-btn" data-ws-tree="C">C (파파빨)</button>
      </div>

      <!-- ✅ 사이클 횟수 입력 -->
      <div class="wb-cycle-wrap" style="margin-top:12px;">
        <div class="wb-cycle-label">사이클 횟수 직접 입력</div>
        <div class="wb-cycle-row">
          <input id="wsCycleCountM" class="wb-cycle-input"
                 type="number" inputmode="numeric" min="0" step="1" value="0" placeholder="0">
        </div>
      </div>

      <div class="modal-foot" style="margin-top:12px;">
        <button id="btnWindshearTreeApplyM" class="st-apply-btn" type="button" style="width:100%;">설정 하기</button>
      </div>
    </div>
  </div>
</div>


  <div id="toast" class="toast"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    window.idToken = sessionStorage.getItem('id_token') || null;
    window.WEBAPP_URL = window.WEBAPP_URL || 'https://dnf-backend.gogo456654.workers.dev';
    const WEBAPP_URL = window.WEBAPP_URL;   // 기존 코드들이 쓰는 식별자 보존
     // ✅ 한마디(헤더 아래) 표시
    // ✅ 한마디(헤더 아래) 표시 - PC 로직 이식(아이콘/배지/순환)
async function initOneLinerMobile() {
  const box = document.getElementById('mOneLiner');
  if (!box) return;

  const textEl = box.querySelector('.text');
  if (!textEl) return;

  // 중복 호출 방지
  if (box.dataset.inited === '1') return;
  box.dataset.inited = '1';

  // PC처럼 fade 효과를 쓰려면(선택)
  const FADE_MS = 200;
  const DISPLAY_MS = 6000;

  function escapeHTML(s = '') {
    return String(s)
      .replace(/&/g, '&amp;').replace(/</g, '&lt;')
      .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;').replace(/`/g, '&#96;');
  }
  function shuffleInPlace(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  try {
    // PC와 동일 endpoint
    const r = await fetch(WEBAPP_URL + '?type=phrase&public=1', {
      method: 'GET',
      mode: 'cors',
      cache: 'no-store'
    });
    if (!r.ok) throw new Error('phrase_fetch_failed');

    const data = await r.json().catch(() => ({ ok: false }));
    const items = Array.isArray(data?.items) ? data.items : [];

    // ✅ items가 없으면 message 단일 fallback
    if (!items.length) {
      const msg = (data && data.ok && data.message) ? String(data.message).trim() : '';
      if (!msg) {
        textEl.classList.add('muted');
        textEl.textContent = '등록된 한마디가 없습니다.';
      } else {
        textEl.classList.remove('muted');
        textEl.textContent = msg;
      }
      return;
    }

    // PC와 같은 필터/가공(“수석/책임(이벤트 포함)” 허용)
    let messages = items
      .filter(x => {
        const pos = String(x?.position || '').trim();
        const pos0 = pos.replace(/^\[이벤트\]\s*/, '');
        const msg = String(x?.message || '').trim();
        if (!msg) return false;
        return /수석|책임/.test(pos0);
      })
      .map(x => {
        const pos = String(x?.position || '').trim();
        const pos0 = pos.replace(/^\[이벤트\]\s*/, '');
        const isSenior = /수석/.test(pos0);

        // 닉네임 우선순위(PC쪽 규칙을 그대로 흉내)
        const nick = String(x?.ingame || x?.youtube || x?.google || '').trim();
        const msg = String(x?.message || '').trim();

        // ✅ 수석: 아이콘(골드 pill) / 책임: 닉네임 앞 두꺼운 점(원형 도트)
const prefixMark = isSenior
  ? '<span class="tag tag-senior" aria-label="수석" title="수석"><span class="badge-emoji">👑</span></span>'
  : '<span class="tag-lead" aria-hidden="true"></span>';

// ✅ 수석/책임 공통: 닉네임과 한마디 사이에는 항상 점(·)
const midBullet = '<span class="msg-bullet" aria-hidden="true">·</span>';

return `
  <span class="hdrmsg ${isSenior ? 'senior' : 'lead'}">
    ${prefixMark}
    ${nick ? `<span class="msg-nick">${escapeHTML(nick)} 님</span>` : ''}
    ${midBullet}
    <span class="msg-text"><span class="marquee">${escapeHTML(msg)}</span></span>
  </span>
`.trim();
      });

    // 중복 제거
    messages = Array.from(new Set(messages));

    // 수석/책임 가중치(PC처럼 수석이 약 1.5배 더 자주)
    const seniorMsgs = messages.filter(html => html.includes('hdrmsg senior'));
    const leadMsgs = messages.filter(html => html.includes('hdrmsg lead'));
    if (seniorMsgs.length && leadMsgs.length) {
      const weighted = [];
      seniorMsgs.forEach(m => weighted.push(m, m, m)); // 수석 3회
      leadMsgs.forEach(m => weighted.push(m, m));      // 책임 2회
      messages = weighted;
    }

    shuffleInPlace(messages);

    if (!messages.length) {
      textEl.classList.add('muted');
      textEl.textContent = '등록된 한마디가 없습니다.';
      return;
    }

    // 수석 이모지 순환(PC와 동일)
    const SENIOR_EMOJIS = ['👑', '⭐', '🏅', '✨'];
    let emojiIdx = 0;
    function applySeniorEmoji(target) {
      const node = target.querySelector('.tag-senior .badge-emoji');
      if (node) node.textContent = SENIOR_EMOJIS[emojiIdx];
    }

    // 순환 표시
    let i = 0;
    let timer = null;

    function show(idx) {
      textEl.classList.remove('muted');
      textEl.classList.add('fade-out');
      setTimeout(() => {
        textEl.innerHTML = messages[idx % messages.length];
        applyMarqueeIfOverflow(textEl);
        textEl.classList.remove('fade-out');
        applySeniorEmoji(textEl);
      }, FADE_MS);
    }
function applyMarqueeIfOverflow(rootEl) {
  const msgText = rootEl.querySelector('.msg-text');
  const inner = msgText ? msgText.querySelector('.marquee') : null;
  if (!msgText || !inner) return;

  // 초기화
  msgText.classList.remove('is-marquee');
  msgText.style.removeProperty('--marquee-dur');
  msgText.style.removeProperty('--marquee-dist');

  requestAnimationFrame(() => {
  const cw = msgText.getBoundingClientRect().width;  // ✅ 더 안정적인 실측
  const sw = inner.scrollWidth;

  const rawDist = sw - cw;
  const overflow = rawDist > 2;
  if (!overflow) return;

  const TRAIL_PX = 7;
  const dist = Math.max(0, rawDist + TRAIL_PX);

  const SPEED_PX_PER_SEC = 110;
  const moveSec = Math.max(1.2, dist / SPEED_PX_PER_SEC);

  const holdStart = 0.8;
  const holdEnd   = 0.6;
  const dur = holdStart + moveSec + holdEnd + 0.4;

  msgText.classList.add('is-marquee');
  msgText.style.setProperty('--marquee-dur', `${dur}s`);
  msgText.style.setProperty('--marquee-dist', `${dist}`);
});
}

    // 첫 표시
    show(0);

    timer = setInterval(() => {
      i++;
      emojiIdx = (emojiIdx + 1) % SENIOR_EMOJIS.length;
      show(i);
    }, DISPLAY_MS);

    // (선택) 페이지가 백그라운드면 멈추고 다시 오면 재시작
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (timer) clearInterval(timer);
        timer = null;
      } else {
        if (!timer) {
          timer = setInterval(() => {
            i++;
            emojiIdx = (emojiIdx + 1) % SENIOR_EMOJIS.length;
            show(i);
          }, DISPLAY_MS);
        }
      }
    }, { passive: true });

  } catch (e) {
    textEl.classList.add('muted');
    textEl.textContent = '한마디를 불러오지 못했습니다.';
    console.warn('[oneLiner] init fail', e);
  }
}

    // DB
    const DB = { itemsBySlot: {}, loaded: {}, chars: { loaded: false, groups: [] } };
    // ✅ 전역이 없으면 만들고
    window.DBEnh = window.DBEnh || { loaded: false, list: [], byType: {} };
    // ✅ 지역 별칭은 전역을 가리키게
    const DBEnh = window.DBEnh;
    // 1) 토큰만 보내는 API (시트/목록 로딩 계열)
    function getStoredToken() {
      return (
        window.idToken ||
        sessionStorage.getItem('id_token') ||
        localStorage.getItem('id_token') ||
        null
      );
    }

    async function waitForIdToken(timeoutMs = 1500) {
      // 1) 즉시 꺼내기
      const now = getStoredToken();
      if (now) {
        window.idToken = now;
        return now;
      }

      // 2) 짧게 폴링(PC에서 넘어오는 타이밍이 애매할 때 대비)
      const t0 = Date.now();
      while (Date.now() - t0 < timeoutMs) {
        const tok = getStoredToken();
        if (tok) {
          window.idToken = tok;
          return tok;
        }
        await new Promise(r => setTimeout(r, 60));
      }

      throw new Error('no_id_token');
    }

    async function apiText(type) {
      const token = await waitForIdToken();
      const res = await fetch(`${WEBAPP_URL}?type=${encodeURIComponent(type)}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'text/plain',
          'Authorization': `Bearer ${token}`,
        },
        body: token, // ✅ 하위호환 유지
      });

      if (!res.ok) {
        if (res.status === 401 || res.status === 403) {
          // 토큰이 만료/거부일 때 대비(선택)
          // sessionStorage.removeItem('id_token'); localStorage.removeItem('id_token');
        }
        throw new Error(`${type}_http_${res.status}`);
      }

      // 응답이 JSON이라고 가정하지만, 안전하게 처리
      const text = await res.text();
      try { return JSON.parse(text); }
      catch { throw new Error(`${type}_bad_json`); }
    }

    async function apiJSON(type, payload = {}) {
      const token = await waitForIdToken();

      // ✅ 네 기존 형식 유지: Authorization + body.id_token
      const body = { id_token: token, ...payload };

      const res = await fetch(`${WEBAPP_URL}?type=${encodeURIComponent(type)}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(body),
      });

      if (!res.ok) {
        if (res.status === 401 || res.status === 403) {
          // sessionStorage.removeItem('id_token'); localStorage.removeItem('id_token');
        }
        throw new Error(`${type}_http_${res.status}`);
      }

      const text = await res.text();
      try { return JSON.parse(text); }
      catch { throw new Error(`${type}_bad_json`); }
    }

    // ✅ 모바일: 최초 1회 init 호출로 경량리스트(=CORE.lists) 전부 확보
    let __mobileInitPromise = null;

    async function initMobileAllLightListsOnce() {
      if (__mobileInitPromise) return __mobileInitPromise;

      __mobileInitPromise = (async () => {
        const res = await apiJSON('init', {});
        if (!res?.ok) {
          __mobileInitPromise = null;
          throw new Error(res?.error || 'init_failed');
        }

        window.CORE = window.CORE || {};
        CORE.lists = res.lists || {};
        CORE.userEmail = res.email || null;

        return CORE.lists;
      })();

      return __mobileInitPromise;
    }
/* ===== 로딩 오버레이 제어(모바일) ===== */
let __progressPct_mobile = 0;

function setProgressExactMonotonic_mobile(nextPct, label) {
  const p = Math.max(__progressPct_mobile, Math.min(100, Math.round(nextPct)));
  __progressPct_mobile = p;

  const bar = document.querySelector('.loading-bar__fill');
  const txt = document.getElementById('loadingPct');
  const lbl = document.getElementById('loadingLabel');

  if (bar) bar.style.width = p + '%';
  if (txt) txt.textContent = p + '%';
  if (lbl && label) lbl.textContent = String(label);
}

function showOverlay_mobile(label) {
  __progressPct_mobile = 0;
  setProgressExactMonotonic_mobile(0, label || '데이터 불러오는 중…');

  const ov = document.getElementById('loadingOverlay');
  if (ov) {
    ov.removeAttribute('hidden');
    // 혹시 이전에 display:none을 강제로 박아둔 케이스 복구
    ov.style.display = '';
  }
}

function hideOverlay_mobile() {
  const ov = document.getElementById('loadingOverlay');
  if (!ov) return;

  // 1) 표준 hidden 처리
  ov.setAttribute('hidden', '');

  // 2) 혹시라도 hidden이 CSS/렌더링 문제로 안 먹는 상황까지 대비(강제)
  ov.style.display = 'none';
}


function startFakeProgress_mobile(from, to, label, intervalMs = 250, step = 2) {
  let cur = from;
  let stopped = false;

  const id = setInterval(() => {
    if (stopped) { clearInterval(id); return; }
    if (cur >= to) { clearInterval(id); return; }
    cur += step;
    setProgressExactMonotonic_mobile(cur, label);
  }, intervalMs);

  return function stopFakeProgress() {
    stopped = true;
    clearInterval(id);
  };
}

    // ===== 캐릭터 선택 (모바일 전용: 좌 썸네일 / 우 이름) =====
    window.state = window.state || {};

// ✅ PC/모바일 프리셋 이미지 키 호환용: 가능한 이미지 필드를 최대한 폭넓게 찾기
function _pickAnyImg(obj) {
  if (!obj || typeof obj !== 'object') return '';
  const cand = [
    obj.image, obj.img, obj.icon, obj.thumb, obj.thumbUrl,
    obj.full, obj.fullSrc, obj.imgSrc,
    obj.saveFace, obj.face, obj.src, obj.url,
    obj['이미지'],
  ];
  for (const v of cand) {
    if (typeof v === 'string' && v.trim()) return v.trim();
  }
  return '';
}

// ✅ PC에서 저장된 state를 "모바일 UI가 기대하는 키(image/fullSrc 등)"로 보정
function normalizePresetStateForMobile(state) {
  if (!state || typeof state !== 'object') return state;

  // 깊은복사 (원본 훼손 방지)
  const s = (typeof structuredClone === 'function')
    ? structuredClone(state)
    : JSON.parse(JSON.stringify(state));

// 1) 캐릭터 이미지 보정 (⚠️ 썸네일을 메인 이미지로 승격시키지 않기)
if (s.currentCharacter && typeof s.currentCharacter === 'object') {
  const c = s.currentCharacter;

  // PC 저장본에서 들어올 수 있는 썸네일 값
  const thumb = String(
    (c.thumbnail ?? c['썸네일'] ?? c.thumb ?? c.thumbSrc ?? c.thumbUrl ?? '') || ''
  ).trim();

  // 혹시 PC 저장본이 썸네일을 image/imgSrc/fullSrc/이미지 등에 박아둔 경우,
  // thumb와 "동일"하면 메인 후보에서 제외되게 필드를 지운다.
  if (thumb) {
    const keys = ['fullSrc', 'imgSrc', 'image', 'img', '이미지', '이미지 '];
    for (const k of keys) {
      if (c[k] != null && String(c[k]).trim() === thumb) {
        try { delete c[k]; } catch (e) { c[k] = ''; }
      }
    }
  }

  // ✅ 메인 후보는 thumb 계열을 제외한 키에서만 선택
  const mainCandidate =
    (c.fullSrc ?? c['이미지'] ?? c['이미지 '] ?? c.image ?? c.img ?? c.imgSrc ?? c.full ?? c.src ?? c.url ?? '');

  const img = (typeof mainCandidate === 'string') ? mainCandidate.trim() : '';

  // 메인 후보가 있으면 모바일이 쓰는 키들만 채워준다(썸네일로는 채우지 않음)
  if (img) {
    if (!c.fullSrc) c.fullSrc = img;
    if (!c.imgSrc)  c.imgSrc  = img;
    if (!c.image)   c.image   = img;
    if (!c['이미지']) c['이미지'] = img;
  }

  // img가 비어있으면(=PC 저장본이 썸네일만 가진 경우)
  // 여기서는 일부러 아무 것도 안 채움.
  // -> 이후 _getCharMainImage()가 CORE.lists에서 '이미지'를 재탐색하는 루트로 가야 함.
}

  // 2) 장비 객체 보정 (selections/equips 어디에 있든 최대한 커버)
  const patchMap = (m) => {
    if (!m || typeof m !== 'object') return;
    for (const k of Object.keys(m)) {
      const it = m[k];
      if (!it || typeof it !== 'object') continue;
      const img = _pickAnyImg(it);
      if (img) {
        if (!it.image) it.image = img;
        if (!it.imgSrc) it.imgSrc = img;
        if (!it['이미지']) it['이미지'] = img;
      }
    }
  };

    patchMap(s.equips);
  patchMap(s.selections);
  patchMap(s.equip); // 혹시 단수 키 대비

  // ✅ (추가) PC 프리셋 호환: customSkills.type(무기) → weaponType(모바일 UI)
  if (s.customSkills && typeof s.customSkills === 'object') {
    const cs = s.customSkills;

    // 1) 무기: PC는 type/customType/kind, 모바일 UI는 weaponType
    const pcWeapon = String(cs.type || cs.customType || cs.kind || '').trim();
    if (!String(cs.weaponType || '').trim() && pcWeapon) {
      cs.weaponType = pcWeapon;
    }

    // 2) 기타(상의/팔찌/귀걸이): 혹시 일부 누락되면 하나로 채움(PC는 보통 다 들어있음)
    const otherCand = String(
      cs.armorType || cs.braceletType || cs.earringType || s.customArmorLabel || ''
    ).trim();

    if (otherCand) {
      if (!String(cs.armorType || '').trim()) cs.armorType = otherCand;
      if (!String(cs.braceletType || '').trim()) cs.braceletType = otherCand;
      if (!String(cs.earringType || '').trim()) cs.earringType = otherCand;
    }
  }

    // ✅ (추가) PC 프리셋 avatar ↔ 모바일 avatarSel 키 정규화
  // - PC 저장본: state.avatar.avatarName / state.avatar.imprintName
  // - 모바일/계산: state.avatarSel.avatarName / state.avatarSel.imprintName
  try {
    // PC -> 모바일
    if (s.avatar && typeof s.avatar === 'object') {
      s.avatarSel = s.avatarSel || {};
      const a = String(s.avatar.avatarName || '').trim();
      const i = String(s.avatar.imprintName || '').trim();
      if (!String(s.avatarSel.avatarName || '').trim() && a) s.avatarSel.avatarName = a;
      if (!String(s.avatarSel.imprintName || '').trim() && i) s.avatarSel.imprintName = i;
    }

    // 모바일 -> PC (겸용/역호환)
    if (s.avatarSel && typeof s.avatarSel === 'object') {
      s.avatar = s.avatar || {};
      const a2 = String(s.avatarSel.avatarName || '').trim();
      const i2 = String(s.avatarSel.imprintName || '').trim();
      if (!String(s.avatar.avatarName || '').trim() && a2) s.avatar.avatarName = a2;
      if (!String(s.avatar.imprintName || '').trim() && i2) s.avatar.imprintName = i2;
    }
  } catch (e) {
    console.warn('[preset] avatar normalize fail', e);
  }

   // ✅ (추가) PC 프리셋 스킬룬/특수룬/룬각인 키 호환 정규화
  try {
    // 1) 스킬룬: 구버전/PC 키(skillrune/skillRune) → runes
    if ((!s.runes || typeof s.runes !== 'object') && s.skillrune && typeof s.skillrune === 'object') {
      s.runes = s.skillrune;
    }
    if ((!s.runes || typeof s.runes !== 'object') && s.skillRune && typeof s.skillRune === 'object') {
      s.runes = s.skillRune;
    }

    // 2) 특수룬: specialRune/specialrunes → specialRunes
    if ((!s.specialRunes || typeof s.specialRunes !== 'object')) {
      const src =
        (s.specialRune && typeof s.specialRune === 'object') ? s.specialRune :
        (s.specialrunes && typeof s.specialrunes === 'object') ? s.specialrunes :
        null;
      if (src) s.specialRunes = src;
    }

    // 한글 키가 들어오는 저장본도 방어
    if (s.specialRunes && typeof s.specialRunes === 'object') {
      if (s.specialRunes['가호'] != null && s.specialRunes.gaho == null) s.specialRunes.gaho = s.specialRunes['가호'];
      if (s.specialRunes['지혜'] != null && s.specialRunes.jihe == null) s.specialRunes.jihe = s.specialRunes['지혜'];
      if (s.specialRunes['왜곡'] != null && s.specialRunes.waegok == null) s.specialRunes.waegok = s.specialRunes['왜곡'];
    }

    // 3) 룬각인: levelVal/tag/렙제 등을 level로 승격
    if (s.runeEngrave && typeof s.runeEngrave === 'object') {
      const re = s.runeEngrave;
      if (!re.type) re.type = '룬각인';
      if (!String(re.level || '').trim()) {
        const lv = (re.levelVal ?? re.tag ?? re['렙제'] ?? re.level ?? '');
        if (String(lv || '').trim()) re.level = String(lv).trim();
      }
    } else if (s.runeengrave && typeof s.runeengrave === 'object') {
      // 혹시 키가 소문자로 오는 저장본
      const re = s.runeengrave;
      s.runeEngrave = {
        type: '룬각인',
        name: String(re.name || '').trim(),
        level: String(re.level || re.levelVal || re.tag || re['렙제'] || '').trim()
      };
    }
   } catch (e) {
    console.warn('[preset] rune normalize fail', e);
  }

  // ✅ (추가) PC 프리셋 성안의 봉인(castleSeal) → 모바일 표준(mainName/subName) 정규화
  try {
    const pickName = (v) => {
      if (!v) return '';
      if (typeof v === 'string') return v.trim();
      if (typeof v === 'object') {
        const n = v.name ?? v['이름'] ?? v.label ?? v.value ?? v.text ?? '';
        return String(n || '').trim();
      }
      return '';
    };

    let mainName = '';
    let subName = '';

    // 1) PC/모바일 어느 형태든 있을 수 있는 castleSeal 우선 처리
    if (s.castleSeal && typeof s.castleSeal === 'object') {
      const cs = s.castleSeal;

      // 모바일형(mainName/subName) 우선
      mainName = pickName(cs.mainName) || mainName;
      subName  = pickName(cs.subName)  || subName;

      // PC형(main/sub)
      if (!mainName) mainName = pickName(cs.main);
      if (!subName)  subName  = pickName(cs.sub);

      // 가끔 키가 다르게 들어오는 케이스 방어
      if (!mainName) mainName = pickName(cs.mainPick ?? cs.mainSeal ?? cs.primary);
      if (!subName)  subName  = pickName(cs.subPick  ?? cs.subSeal  ?? cs.secondary);
    }

    // 2) 혹시 다른 키명으로 저장된 경우(대문자/스네이크 등)도 방어
    if ((!mainName && !subName) && s.CastleSeal && typeof s.CastleSeal === 'object') {
      const cs2 = s.CastleSeal;
      mainName = pickName(cs2.mainName) || pickName(cs2.main);
      subName  = pickName(cs2.subName)  || pickName(cs2.sub);
    }
    if ((!mainName && !subName) && s.castle_seal && typeof s.castle_seal === 'object') {
      const cs3 = s.castle_seal;
      mainName = pickName(cs3.mainName) || pickName(cs3.main);
      subName  = pickName(cs3.subName)  || pickName(cs3.sub);
    }

    // 3) 최종 반영: 모바일 표준 형태로 강제
    // (UI/계산 모두 mainName/subName을 기준으로 쓰게 만드는 게 핵심)
    if (mainName || subName) {
      s.castleSeal = { mainName, subName };
    } else {
      // 없으면 기본 형태라도 보장(코드가 안전하게 돌아가게)
      if (!s.castleSeal || typeof s.castleSeal !== 'object') {
        s.castleSeal = { mainName: '', subName: '' };
      } else {
        if (typeof s.castleSeal.mainName !== 'string') s.castleSeal.mainName = '';
        if (typeof s.castleSeal.subName  !== 'string') s.castleSeal.subName  = '';
      }
    }
  } catch (e) {
    console.warn('[preset] castleSeal normalize fail', e);
  }

  return s;
}

    function _normImg(src) {
      const s = String(src || '').trim();
      if (!s) return '';
      if (/^https?:\/\//i.test(s)) return s;
      // img/xxx 형태면 현재 경로 기준으로 로딩되게
      if (s.startsWith('img/')) return './' + s.replace(/^\.?\//, '');
      return s;
    }

    function _pick(obj, keys) {
      for (const k of keys) {
        if (obj && obj[k] != null && String(obj[k]).trim() !== '') return obj[k];
      }
      return '';
    }

    function _getCharName(c) {
      return String(_pick(c, ['name', '이름', 'charName', '캐릭터명']) || '').trim();
    }
    function _getCharThumb(c) {
      return _normImg(_pick(c, ['thumbnail', '썸네일', 'thumb', 'thumbSrc']));
    }

    // ✅ 메인 표시용: 반드시 '이미지' 컬럼만 사용(썸네일 fallback 금지)
function _getCharMainImage(c) {
  // 혹시 컬럼명이 공백 포함(예: "이미지 " )으로 들어오는 경우까지 커버
  const direct = _pick(c, ['fullSrc', '이미지', 'image', 'img', 'imgSrc']);
  if (direct) return _normImg(direct);

  // 느슨한 매칭(키의 공백 제거 후 비교)
  const target = new Set(['이미지', 'image', 'img', 'imgsrc'].map(s => s.toLowerCase()));
  for (const k in (c || {})) {
    const nk = String(k).replace(/\s+/g, '').toLowerCase();
    if (target.has(nk) && String(c[k] || '').trim() !== '') return _normImg(c[k]);
  }
  return '';
}


    function applyPickedCharacterUI(c) {
      const pickBtn = document.getElementById('btnPickChar');
      const imgEl = document.getElementById('pickedCharImg');

      if (!pickBtn || !imgEl) return;

      const name = _getCharName(c) || '';
      const imgSrc = _getCharMainImage(c);  // ✅ 메인은 '이미지'만

      // 이미지가 없으면(예외) 기존 버튼 유지
      if (!imgSrc) {
        pickBtn.style.display = '';
        pickBtn.textContent = name || '캐릭터 선택하기';
        imgEl.style.display = 'none';
        imgEl.removeAttribute('src');
        imgEl.alt = '';
        return;
      }

      // ✅ 요구사항: 선택버튼은 사라지고 이미지가 들어감
      pickBtn.style.display = 'none';
      imgEl.src = imgSrc;
      imgEl.alt = name ? `${name} 이미지` : '';
      imgEl.style.display = 'block';

      if (!imgEl.dataset.boundPick) {
        imgEl.dataset.boundPick = '1';
        imgEl.addEventListener('click', () => openMobileCharacterPicker());
      }
    }

    function _getCharJobGroup(c) {
      return String(_pick(c, ['jobGroup', '직업군', 'group', 'job_group']) || '').trim();
    }
    function _getCharBadge(c) {
      // ‘종류’ 컬럼(배지 이미지)
      return _normImg(_pick(c, ['type', '종류', 'badge', 'badgeSrc', 'kind']) || '');
    }

    function renderMobileCharList(items) {
      const catalog = document.getElementById('catalog');
      if (!catalog) return;

      catalog.innerHTML = '';

      if (!Array.isArray(items) || items.length === 0) {
        catalog.innerHTML = `<div style="opacity:.8;padding:12px;">캐릭터 목록이 비어있습니다.</div>`;
        return;
      }

      // 1) 직업군별로 그룹 만들기(등장 순서 유지)
      const order = [];
      const groups = new Map(); // jobGroup -> { title, badge, list: [] }

      for (const c of items) {
        const name = _getCharName(c);
        if (!name) continue;

        const job = _getCharJobGroup(c) || '기타';
        const badge = _getCharBadge(c);

        if (!groups.has(job)) {
          groups.set(job, { title: job, badge: badge || '', list: [] });
          order.push(job);
        }
        const g = groups.get(job);
        if (!g.badge && badge) g.badge = badge; // 비어있으면 채워두기

        g.list.push(c);
      }

      // 2) 렌더
      const frag = document.createDocumentFragment();

      for (const job of order) {
        const g = groups.get(job);

        const groupEl = document.createElement('div');
        groupEl.className = 'mchar-group';

        // 헤더(배지 + 직업군명)
        const head = document.createElement('div');
        head.className = 'mchar-group-head';

        const img = document.createElement('img');
        img.className = 'mchar-badge';
        img.loading = 'lazy';
        img.alt = job;
        // 배지 없을 때 깨짐 방지(투명 1x1)
        img.src = g.badge || 'data:image/gif;base64,R0lGODlhAQABAAAAACw=';

        const titleWrap = document.createElement('div');
        titleWrap.innerHTML = `
      <span class="mchar-group-title">${job}</span>
      <span class="mchar-group-sub">(${g.list.length})</span>
    `;

        head.appendChild(img);
        head.appendChild(titleWrap);

        // 바디(기존 row를 그대로 사용)
        const body = document.createElement('div');
        body.className = 'mchar-group-body';

        for (const c of g.list) {
          const name = _getCharName(c);
          const thumb = _getCharThumb(c);

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'mchar-row';
          btn.innerHTML = `
        <img class="mchar-thumb" src="${thumb}" alt="">
        <div class="mchar-name">${name}</div>
      `;



          btn.addEventListener('click', () => {
            const job = String(c.jobGroupLabel || c.jobGroup || c.job || '').trim();
            const nm = String(name || c.name || '').trim();
            const ownerKey = (job + nm).replace(/\s+/g, '');
            // 선택 저장
            window.state.currentCharacter = { ...c, name: nm, ownerKey };

            // ✅ 버튼 숨기고, 캐릭 이미지 표시
            applyPickedCharacterUI(window.state.currentCharacter);

            // ✅ 스킬 페이지 갱신
            ensurePage4Init();
            renderSkillPageMobile(window.state.currentCharacter);

            // 모달 닫기
            const m = document.getElementById('charModal');
            if (m) {
              m.classList.remove('show');
              m.setAttribute('aria-hidden', 'true');
            }
          });

          body.appendChild(btn);
        }

        groupEl.appendChild(head);
        groupEl.appendChild(body);
        frag.appendChild(groupEl);
      }

      catalog.appendChild(frag);
    }

    async function openMobileCharacterPicker() {
      // init에서 경량리스트들 받아온다
      await initMobileAllLightListsOnce();

      // 핵심: char:list 배열
      const items = window.CORE?.lists?.['char:list'];

      renderMobileCharList(items);

      const m = document.getElementById('charModal');
      if (m) {
        m.classList.add('show');
        m.setAttribute('aria-hidden', 'false');
      }
    }

    // 닫기(backdrop + 닫기 버튼)
    document.querySelectorAll('[data-char-close]').forEach(el => {
      el.addEventListener('click', () => {
        const m = document.getElementById('charModal');
        m?.classList.remove('show');
        m?.setAttribute('aria-hidden', 'true');
      });
    });


    // ===== Toast =====
    function toast(msg) {
      const el = document.getElementById('toast');
      if (!el) return alert(msg);
      el.textContent = msg;
      el.classList.add('show');
      clearTimeout(el._t);
      el._t = setTimeout(() => el.classList.remove('show'), 1400);
    }

// ✅ 페이지 열리면 즉시 경량리스트 전부 로드
// - 0→70%: 경량리스트 로딩과 "동시에" 올라감
// - 70% 도달 후: 2초 뒤 80%, 그 후 3초 뒤 90%
// - 단, 그 사이(또는 그 이전)에 경량리스트 로딩이 끝나면 즉시 100% + 오버레이 닫기
(async () => {
  let stopFake = null;
  let t80 = null;
  let t90 = null;
  let loaded = false;

  // progress가 target 이상이 되거나(=70 도달), 혹은 로딩이 끝나면(loaded) 풀리는 대기
  const waitUntilPctOrLoaded = (targetPct) => new Promise((resolve) => {
    const id = setInterval(() => {
      const pct = (typeof __progressPct_mobile === 'number') ? __progressPct_mobile : 0;
      if (loaded || pct >= targetPct) {
        clearInterval(id);
        resolve();
      }
    }, 50);
  });

  try {
    // 1) 오버레이 표시
    showOverlay_mobile('데이터 불러오는 중…');

    // 2) ✅ 실제 경량 로딩 "시작"
    const lightLoadPromise = initMobileAllLightListsOnce()
      .then(() => { loaded = true; });

    // 3) ✅ 로딩 동안 0 → 70% 가짜 진행률
    stopFake = startFakeProgress_mobile(0, 70, '모바일 버전 로딩중…', 60, 1);

    // 4) 70% 도달 또는 로딩 완료 중 먼저 일어나는 것까지 대기
    await waitUntilPctOrLoaded(70);

    // 5) 가짜 진행 멈추기(70까지 가는 구간 종료)
    if (typeof stopFake === 'function') stopFake();

    // 6) 로딩이 너무 빨리 끝나서 70 전에 종료된 경우: 70까지 빠르게 보정
    if (typeof __progressPct_mobile === 'number' && __progressPct_mobile < 70) {
      const stopFast = startFakeProgress_mobile(__progressPct_mobile, 70, '모바일 버전 로딩중…', 16, 4);
      await new Promise(r => setTimeout(r, 200));
      stopFast();
    }
    setProgressExactMonotonic_mobile(70, '모바일 버전 로딩중…');

    // 7) ✅ 70 이후 단계: 2초 뒤 80%, (추가 3초 뒤) 90%
    //    단, 그 사이에 loaded가 true가 되면 타이머는 무시/취소되고 즉시 100%로 감
    if (!loaded) {
      t80 = setTimeout(() => {
        if (!loaded) setProgressExactMonotonic_mobile(80, '모바일 버전 로딩중…');
      }, 2000);

      t90 = setTimeout(() => {
        if (!loaded) setProgressExactMonotonic_mobile(90, '모바일 버전 로딩중…');
      }, 5000); // 70 도달 기준 2초 후 80, 추가 3초 후 90 => 총 5초
    }

    // 8) ✅ 실제 경량 로딩 완료 대기 (완료되는 순간 즉시 100%)
    await lightLoadPromise;

    // 9) 타이머 정리 후 완료 처리
    if (t80) { clearTimeout(t80); t80 = null; }
    if (t90) { clearTimeout(t90); t90 = null; }

    setProgressExactMonotonic_mobile(100, '완료');
    await new Promise(r => setTimeout(r, 180));

    ensurePage3Init();
    ensurePage4Init();

  } catch (e) {
    console.error(e);
    toast('초기 데이터 로딩 실패');
  } finally {
    // ✅ 어떤 경우에도 오버레이는 닫는다 + 타이머/가짜진행 정리
    try { if (typeof stopFake === 'function') stopFake(); } catch (_) {}
    try { if (t80) clearTimeout(t80); } catch (_) {}
    try { if (t90) clearTimeout(t90); } catch (_) {}
    hideOverlay_mobile();
  }
})();


    function fillSelectOptions_(sel, items, placeholder) {
      if (!sel) return;

      // 초기화
      sel.innerHTML = '';

      // placeholder
      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = placeholder;
      opt0.selected = true;
      sel.appendChild(opt0);

      // items
      for (const n of (items || [])) {
        const name = String(n ?? '').trim();
        if (!name) continue;
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
      }
    }

    // 3페이지: 아바타/무기압 드롭다운 채우기 (ENH list 기반)
    async function populateAvatarImprintMobile() {
      await initMobileAllLightListsOnce();

      const aSel = document.getElementById('selAvatarM');
      const iSel = document.getElementById('selImprintM');

      const rows = Array.isArray(CORE?.lists?.['enh:list']) ? CORE.lists['enh:list'] : [];
      // 샘플 3개만 구조 확인

      // 타입/이름이 실제로 어떤 키로 들어오는지 “자동 탐색”용
      const probe = rows.slice(0, 50).map(r => ({
        type: r?.type, 종류: r?.['종류'],
        name: r?.name, 이름: r?.['이름'],
        keys: Object.keys(r || {}).slice(0, 10)
      }));

      const pickNames = (wantType) => {
        const out = [];
        const seen = new Set();
        for (const r of rows) {
          const type = String(r?.type ?? r?.['종류'] ?? '').trim();
          if (type !== wantType) continue;
          const name = String(r?.name ?? r?.['이름'] ?? '').trim();
          if (!name || seen.has(name)) continue;
          seen.add(name);
          out.push(name);
        }
        return out;
      };

      const avatars = pickNames('아바타');
      const imprints = pickNames('무기압');

      try {
        fillSelectOptions_(aSel, avatars, '아바타 선택');
        fillSelectOptions_(iSel, imprints, '무기압 선택');
      } catch (e) {
      }

      /* ✅✅✅ [추가 시작] 선택값을 window.state.avatarSel에 저장/복원 + change 바인딩 */
      window.state = window.state || {};
      const s = window.state;

      // state 슬롯 준비
      s.avatarSel = s.avatarSel || { avatarName: '', imprintName: '' };

      // 1) 기존 state 값이 있으면 UI에 복원, 없으면 첫 옵션을 기본값으로 state에 저장
      if (aSel) {
        const savedA = String(s.avatarSel.avatarName || '').trim();
        if (savedA && avatars.includes(savedA)) {
          aSel.value = savedA;
        } else if (avatars.length) {
          aSel.value = avatars[0];
          s.avatarSel.avatarName = String(aSel.value || '').trim();
        }
      }

      if (iSel) {
        const savedI = String(s.avatarSel.imprintName || '').trim();
        if (savedI && imprints.includes(savedI)) {
          iSel.value = savedI;
        } else if (imprints.length) {
          iSel.value = imprints[0];
          s.avatarSel.imprintName = String(iSel.value || '').trim();
        }
      }

      // 2) change 이벤트(중복 바인딩 방지)
      if (aSel && !aSel.dataset.boundAvatar) {
        aSel.addEventListener('change', () => {
  const st = (window.state = window.state || {});
  st.avatarSel = st.avatarSel || {};
  st.avatarSel.avatarName = String(aSel.value || '').trim();
});
        aSel.dataset.boundAvatar = '1';
      }

      if (iSel && !iSel.dataset.boundImprint) {
        iSel.addEventListener('change', () => {
  const st = (window.state = window.state || {});
  st.avatarSel = st.avatarSel || {};
  st.avatarSel.imprintName = String(iSel.value || '').trim();
});
        iSel.dataset.boundImprint = '1';
      }

      /* ✅✅✅ [추가 끝] */

    }

    // 3페이지: 몬스터 목록 (CORE.lists['monster:list'])
    async function populateMonsterMobile() {
      await initMobileAllLightListsOnce();

      const sel = document.getElementById('selMonsterM');
      if (!sel) return;

      const list = CORE?.lists?.['monster:list'] || [];
      //console.log('[M3][MON] raw list len =', Array.isArray(list) ? list.length : -1, 'sample =', list?.[0]);

      // ✅ monster 시트는 '몬스터명' 컬럼이 핵심
      const names = (Array.isArray(list) ? list : [])
        .map(x => {
          if (typeof x === 'string') return x.trim();
          return String(
            x?.['몬스터명'] ?? x?.monName ?? x?.monsterName ?? x?.name ?? ''
          ).trim();
        })
        .filter(Boolean);

      //console.log('[M3][MON] parsed names len =', names.length, 'head =', names.slice(0, 5));

      fillSelectOptions_(sel, names.length ? names : ['(데이터 없음)'], '몬스터 선택');

      window.state = window.state || {};
      const s = window.state;



      // ✅ 기존 선택 복원 + 기본값(맨 윗값) 자동 적용
      if (s.monsterName && names.includes(s.monsterName)) {
        sel.value = s.monsterName;
      } else if (names.length) {
        // ✅ 기본값: 가장 윗값
        sel.value = names[0];
        s.monsterName = String(sel.value || '').trim();
        //console.log('[M3][MON] default applied:', s.monsterName);
      }


      // ✅ init이 여러 번 호출돼도 리스너 중복 등록 방지
      if (!sel.dataset.bound) {
  sel.addEventListener('change', () => {
    // ✅ PC프리셋을 모바일에 불러온 경우 s.monster(객체)가 함께 들어오는 케이스가 있음.
    //    이후 드롭다운을 바꿔도 compute 단계에서 s.monster가 우선되어 몬스터가 "고정"되는 문제가 생김.
    //    -> monsterName 변경 시, monster 객체도 같이 갱신(또는 덮어쓰기)해서 항상 최신 선택이 반영되게 한다.
    const nm = (sel.value || '').trim();
    s.monsterName = nm;
    s.monster = nm ? { name: nm } : null;
  });
  sel.dataset.bound = '1';
}
    }


    // 3페이지: 룬각인 목록/세부설정 (ENH list의 '룬각인')
    async function populateRuneEngraveMobile() {
      await initMobileAllLightListsOnce();
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const sel1 = document.getElementById('selRuneEngraveM');
      const sel2 = document.getElementById('selRuneDetailM');
      if (!sel1 || !sel2) return;

      const rows = DBEnh?.byType?.['룬각인'] || [];

      // ✅ 이름 목록(중복 제거)
      const seen = new Set();
      const names = [];
      rows.forEach(r => {
        const n = String(r?.name ?? r?.['이름'] ?? '').trim();
        if (n && !seen.has(n)) { seen.add(n); names.push(n); }
      });

      // 룬각인 이름 드롭다운 채우기
      fillSelectOptions_(sel1, names, '룬 각인 선택');

      // ✅ 세부 설정 채우기 (escapeHtml 없이 DOM으로)
      const fillDetail = (name) => {
        // 초기화
        sel2.innerHTML = '';
        const opt0 = document.createElement('option');
        opt0.value = '';
        opt0.textContent = '세부 설정';
        opt0.selected = true;
        sel2.appendChild(opt0);

        const keyName = String(name || '').trim();
        if (!keyName) {
          sel2.disabled = true;
          return;
        }

        const hit = rows.filter(r => String(r?.name ?? r?.['이름'] ?? '').trim() === keyName);

        // ✅ PC와 동일한 우선순위: levelVal > tag > 렙제(등)
        const ds = [];
        const dseen = new Set();
        hit.forEach(r => {
          const v = String(
            r?.levelVal ??
            r?.['levelVal'] ??
            r?.tag ??
            r?.['렙제'] ??
            r?.level ??
            r?.['레벨'] ??
            ''
          ).trim();

          if (v && !dseen.has(v)) {
            dseen.add(v);
            ds.push(v);
          }
        });

        for (const v of ds) {
          const op = document.createElement('option');
          op.value = v;
          op.textContent = v;
          sel2.appendChild(op);
        }

        sel2.disabled = (ds.length === 0);
      };

      // state 준비
      window.state = window.state || {};
      const s = window.state;
      s.runeEngrave = s.runeEngrave || { type: '룬각인', name: '', level: '' };

      // 복원
      if (s.runeEngrave.name && names.includes(s.runeEngrave.name)) sel1.value = s.runeEngrave.name;
      if (sel1.value) fillDetail(sel1.value);
      if (s.runeEngrave.level && !sel2.disabled) sel2.value = s.runeEngrave.level;

      // ✅ 리스너 중복 방지
      if (!sel1.dataset.bound) {
        sel1.addEventListener('change', () => {
          s.runeEngrave.name = (sel1.value || '').trim();
          s.runeEngrave.level = '';
          fillDetail(s.runeEngrave.name);
        });
        sel1.dataset.bound = '1';
      }

      if (!sel2.dataset.bound) {
        sel2.addEventListener('change', () => {
          s.runeEngrave.level = (sel2.value || '').trim();
        });
        sel2.dataset.bound = '1';
      }
    }


    // 3페이지: 시간 기준 저장
    function bindTimeMobile() {
      const sel = document.getElementById('selTimeM');
      if (!sel) return;
      window.state = window.state || {};
      const s = window.state;
      if (s.timeKey) sel.value = s.timeKey;
      sel.addEventListener('change', () => { s.timeKey = sel.value; });
      if (!s.timeKey) s.timeKey = sel.value;
    }

    // 3페이지: 스킬룬(모달)
    const RUNE_LEVELS = [15, 20, 25, 30, 35, 40, 45, 65];
    const RUNE_CATS = [
      { key: 'awakening', label: '각성', icon: './img/etc/skillrune/각성.png' },
      { key: 'magic', label: '마력', icon: './img/etc/skillrune/마력.png' },
      { key: 'illusion', label: '허상', icon: './img/etc/skillrune/허상.png' },
      { key: 'training', label: '숙련', icon: './img/etc/skillrune/숙련.png' },
      { key: 'technique', label: '기교', icon: './img/etc/skillrune/기교.png' },
    ];

    function _emptyRunes_() {
      const o = {};
      RUNE_CATS.forEach(c => {
        o[c.key] = {};
        RUNE_LEVELS.forEach(lv => { o[c.key][lv] = 0; });
      });
      return o;
    }
    function ensureRunesInitialized() {
      window.state = window.state || {};
      const s = window.state;
      if (!s.runes || typeof s.runes !== 'object') s.runes = _emptyRunes_();

      // 누락된 키/레벨 채우기(구버전/프리셋 호환)
      RUNE_CATS.forEach(c => {
        if (!s.runes[c.key] || typeof s.runes[c.key] !== 'object') s.runes[c.key] = {};
        RUNE_LEVELS.forEach(lv => {
          const v = Number(s.runes[c.key][lv] ?? 0);
          s.runes[c.key][lv] = Number.isFinite(v) ? v : 0;
        });
      });
    }
    function ensureSpecialRunesInitialized() {
      window.state = window.state || {};
      const s = window.state;
      if (!s.specialRunes || typeof s.specialRunes !== 'object') s.specialRunes = { gaho: 0, jihe: 0, waegok: 0 };
      s.specialRunes.gaho = Number(s.specialRunes.gaho ?? 0) || 0;
      s.specialRunes.jihe = Number(s.specialRunes.jihe ?? 0) || 0;
      s.specialRunes.waegok = Number(s.specialRunes.waegok ?? 0) || 0;
    }

    function countSelectedRunes() {
      const s = window.state || {};
      let n = 0;
      const runes = s.runes || {};
      RUNE_CATS.forEach(c => {
        const row = runes[c.key] || {};
        RUNE_LEVELS.forEach(lv => { n += Number(row[lv] || 0); });
      });
      const sp = s.specialRunes || {};
      n += Number(sp.gaho || 0) + Number(sp.jihe || 0) + Number(sp.waegok || 0);
      return n;
    }

    function updateRuneCountSummary() {
      const n = countSelectedRunes();
      const main = document.getElementById('runeCountM');
      const lbl = document.getElementById('runeCountLabelM');
      if (main) main.textContent = String(n);
      if (lbl) lbl.textContent = String(n);
    }

    function _capTo20OrRevert_(applyFn, revertFn) {
      const n = countSelectedRunes();
      if (n <= 20) {
        updateRuneCountSummary();
        return true;
      }
      // 초과면 revert
      revertFn?.();
      updateRuneCountSummary();
      toast('스킬룬은 최대 20개까지 선택할 수 있어요.');
      return false;
    }



    // ✅ 스킬룬(모바일 행 UI) 전역 유틸: 행 정규화(중복 합치기/유효성 보정/최소 1행/최대 5행)
    const MAX_RUNE_ROWS_M = 5;

    function _getRuneDefaultsM_() {
      const cats = (typeof RUNE_CATS !== 'undefined' && Array.isArray(RUNE_CATS)) ? RUNE_CATS : [];
      const levels = (typeof RUNE_LEVELS !== 'undefined' && Array.isArray(RUNE_LEVELS)) ? RUNE_LEVELS : [];
      const defCat = (cats[0] != null) ? (cats[0].key ?? cats[0]) : 'awakening';
      const defTier = (levels[0] != null ? Number(levels[0]) : 15) || 15;
      return { cats, levels, defCat, defTier };
    }

    function _isValidRuneCatM_(cat) {
      const { cats } = _getRuneDefaultsM_();
      return (cats || []).some(c => (c.key ?? c) === cat);
    }
    function _isValidRuneTierM_(tier) {
      const { levels } = _getRuneDefaultsM_();
      return (levels || []).map(Number).includes(Number(tier));
    }

    function normalizeRuneRowsM() {
      window.state = window.state || {};
      const s = window.state;

      // 없으면 생성
      const src = Array.isArray(s.runeRowsM) ? s.runeRowsM : [];
      const { levels, defCat, defTier } = _getRuneDefaultsM_();

      const out = [];
      const idxMap = new Map();
      let merged = false, trimmed = false;

      for (const r of src) {
        const catRaw = String(r?.cat ?? '').trim();
        const cat = _isValidRuneCatM_(catRaw) ? catRaw : defCat;

        const tierN = Number(r?.tier ?? defTier) || defTier;
        const tier = _isValidRuneTierM_(tierN) ? Number(tierN) : Number(defTier);

        const cnt = Math.max(0, Math.min(20, Math.floor(Number(r?.cnt ?? 0) || 0)));

        const key = cat + '|' + String(tier);
        if (idxMap.has(key)) {
          const i = idxMap.get(key);
          out[i].cnt = Math.min(20, Number(out[i].cnt || 0) + cnt);
          merged = true;
        } else {
          idxMap.set(key, out.length);
          out.push({ cat, tier, cnt });
        }
      }

      if (out.length === 0) {
        out.push({ cat: defCat, tier: Number(defTier), cnt: 0 });
      }

      if (out.length > MAX_RUNE_ROWS_M) {
        out.length = MAX_RUNE_ROWS_M;
        trimmed = true;
      }

      s.runeRowsM = out;
      return { merged, trimmed };
    }
    function bindRunePickerMobile() {
      const wrap = document.getElementById('runePickRowsM');
      const addBtn = document.getElementById('btnRuneRowAddM');
      if (!wrap || !addBtn) return;

      ensureRunesInitialized();
      ensureSpecialRunesInitialized();

      window.state = window.state || {};
      const s = window.state;

      // ✅ 행 모델: [{cat, tier, cnt}] (모달 UI 전용)
      if (!Array.isArray(s.runeRowsM)) {
        s.runeRowsM = [];

        // 기존 state.runes(그리드 방식) → 행으로 변환
        try {
          (RUNE_CATS || []).forEach(c => {
            (RUNE_LEVELS || []).forEach(lv => {
              const n = Number(((s.runes || {})[c.key] || {})[lv] ?? 0) || 0;
              if (n > 0) s.runeRowsM.push({ cat: c.key, tier: Number(lv), cnt: n });
            });
          });
        } catch (_) { }

        // 아무것도 없으면 기본 1행
        if (s.runeRowsM.length === 0) {
          s.runeRowsM.push({
            cat: (RUNE_CATS && RUNE_CATS[0] ? RUNE_CATS[0].key : 'awakening'),
            tier: (RUNE_LEVELS && RUNE_LEVELS[0] ? Number(RUNE_LEVELS[0]) : 15),
            cnt: 0
          });
        }
      }

      // 초기 정규화(최대 5행 제한)
      const _initNorm_ = normalizeRuneRowsM();
      if (_initNorm_.trimmed) {
        toast('저장된 스킬룬 조합이 5개를 초과하여 일부가 표시/저장 제한으로 제외될 수 있어요.');
      }

      // ✅ 행 → state.runes(집계) 반영
      const buildAggregateRunes = () => {
        const agg = _emptyRunes_();
        (s.runeRowsM || []).forEach(r => {
          const catKey = String(r?.cat || '').trim();
          const tier = Number(r?.tier || 0) || 0;
          const cnt = Number(r?.cnt || 0) || 0;
          if (!catKey || !Number.isFinite(tier) || !Number.isFinite(cnt)) return;
          if (agg[catKey] && Object.prototype.hasOwnProperty.call(agg[catKey], tier)) {
            agg[catKey][tier] = Number(agg[catKey][tier] || 0) + Math.max(0, cnt);
          }
        });
        return agg;
      };

      const applyRowsToStateOrRevert = (revertFn) => {
        const beforeRunes = s.runes;
        const nextRunes = buildAggregateRunes();
        s.runes = nextRunes;

        const ok = _capTo20OrRevert_(
          () => { },
          () => {
            s.runes = beforeRunes;
            revertFn?.();
          }
        );
        return ok;
      };

      const makeSelect = (cls, aria) => {
        const el = document.createElement('select');
        el.className = cls || 'select rune-select';
        if (aria) el.setAttribute('aria-label', aria);
        return el;
      };

      const fillCatOptions = (sel) => {
        sel.innerHTML = '';
        (RUNE_CATS || []).forEach(c => {
          const opt = document.createElement('option');
          opt.value = c.key;
          opt.textContent = c.label;
          sel.appendChild(opt);
        });
      };

      const fillTierOptions = (sel) => {
        sel.innerHTML = '';
        (RUNE_LEVELS || []).forEach(lv => {
          const opt = document.createElement('option');
          opt.value = String(lv);
          opt.textContent = String(lv);
          sel.appendChild(opt);
        });
      };

      const fillCntOptions = (sel) => {
        sel.innerHTML = '';
        for (let i = 0; i <= 20; i++) {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = String(i);
          sel.appendChild(opt);
        }
      };

      const pickNextUnusedRunePairM = () => {
        const used = new Set((s.runeRowsM || []).map(r => `${r.cat}|${r.tier}`));

        const cats = (RUNE_CATS || []).map(c => c.key);
        const tiers = (RUNE_LEVELS || []).map(Number);

        const defCat = (cats[0] || 'awakening');
        const defTier = (tiers[0] || 15);

        // 1) 같은 cat에서 tier만 다음으로 돌리기(체감상 가장 자연스러움)
        const sameCatTiers = tiers.slice();
        // 기본 tier 다음부터 우선 시도
        const startIdx = Math.max(0, sameCatTiers.indexOf(defTier));
        const rotated = sameCatTiers.slice(startIdx).concat(sameCatTiers.slice(0, startIdx));

        for (const t of rotated) {
          const key = `${defCat}|${t}`;
          if (!used.has(key)) return { cat: defCat, tier: t };
        }

        // 2) 그래도 없으면 전체 cats×tiers에서 첫 미사용 조합 찾기
        for (const c of cats) {
          for (const t of tiers) {
            const key = `${c}|${t}`;
            if (!used.has(key)) return { cat: c, tier: t };
          }
        }

        // 전부 사용중(= 더 추가해봤자 중복합치기로 티도 안 남)
        return null;
      };

      const render = () => {
        // 중복/유효성 보정
        normalizeRuneRowsM();

        wrap.innerHTML = '';

        (s.runeRowsM || []).forEach((row, idx) => {
          const rowEl = document.createElement('div');
          rowEl.className = 'rune-picker-row';
          rowEl.style.cssText = 'display:flex;gap:8px;align-items:center;';

          const selCat = makeSelect('select rune-select', '룬 종류');
          const selTier = makeSelect('select rune-select', '레벨');
          const selCnt = makeSelect('select rune-select', '개수');

          fillCatOptions(selCat);
          fillTierOptions(selTier);
          fillCntOptions(selCnt);

          // 값 복원(유효성 보정)
          const defCat = (RUNE_CATS && RUNE_CATS[0] ? RUNE_CATS[0].key : 'awakening');
          const defTier = (RUNE_LEVELS && RUNE_LEVELS[0] ? Number(RUNE_LEVELS[0]) : 15);

          const catKey = String(row?.cat || defCat);
          const tier = Number(row?.tier ?? defTier) || defTier;
          const cnt = Math.max(0, Number(row?.cnt ?? 0) || 0);

          selCat.value = (RUNE_CATS || []).some(c => c.key === catKey) ? catKey : defCat;
          selTier.value = (RUNE_LEVELS || []).map(Number).includes(Number(tier)) ? String(tier) : String(defTier);
          selCnt.value = String(Math.min(20, cnt));

          // state에 정규화
          row.cat = selCat.value;
          row.tier = Number(selTier.value || defTier) || defTier;
          row.cnt = Number(selCnt.value || 0) || 0;

          const onChange = () => {
            // 변경 전 스냅샷(행/집계 revert 용)
            const prevRows = (s.runeRowsM || []).map(x => ({ cat: x.cat, tier: x.tier, cnt: x.cnt }));

            row.cat = String(selCat.value || defCat);
            row.tier = Number(selTier.value || defTier) || defTier;
            row.cnt = Number(selCnt.value || 0) || 0;

            // ✅ 중복 선택은 자동 합치기 + 행 최대 5개 제한
            const norm = normalizeRuneRowsM();

            const ok = applyRowsToStateOrRevert(() => {
              // revert rows
              s.runeRowsM = prevRows;
            });

            // 정규화/합치기 반영 위해 항상 재렌더
            render();

            if (ok) {
              if (norm.merged) toast('중복 선택은 자동으로 합쳐졌어요.');
              if (norm.trimmed) toast('스킬룬 행은 최대 5개까지 추가할 수 있어요.');
            } else {
              try { selCnt.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], { duration: 180 }); } catch (_) { }
            }
          };

          selCat.addEventListener('change', onChange);
          selTier.addEventListener('change', onChange);
          selCnt.addEventListener('change', onChange);

          // 🗑 행 삭제 버튼(× 아이콘형)
          const btnDel = document.createElement('button');
          btnDel.type = 'button';
          btnDel.className = 'btn rune-row-del rune-icon-btn';
          btnDel.innerHTML = '&times;';          // ×
          btnDel.title = '행 삭제';
          btnDel.setAttribute('aria-label', '행 삭제');

          btnDel.addEventListener('click', (e) => {
            e.preventDefault(); e.stopPropagation();
            if ((s.runeRowsM || []).length <= 1) {
              toast('최소 1행은 남겨야 해요.');
              return;
            }
            const prevRows = (s.runeRowsM || []).map(x => ({ cat: x.cat, tier: x.tier, cnt: x.cnt }));
            s.runeRowsM.splice(idx, 1);
            const ok = applyRowsToStateOrRevert(() => {
              s.runeRowsM = prevRows;
            });
            render();
            if (ok) toast('스킬룬 행이 삭제되었습니다.');
          });

          rowEl.appendChild(selCat);
          rowEl.appendChild(selTier);
          rowEl.appendChild(selCnt);
          rowEl.appendChild(btnDel);
          wrap.appendChild(rowEl);
        });

        updateRuneCountSummary();
      };

      // ✅ + 버튼(1회 바인딩)
      if (!addBtn.dataset.bound) {
        addBtn.addEventListener('click', () => {
          if ((s.runeRowsM || []).length >= MAX_RUNE_ROWS_M) {
            toast('스킬룬 행은 최대 5개까지 추가할 수 있어요.');
            return;
          }

          const nextPair = pickNextUnusedRunePairM();
          if (!nextPair) {
            toast('추가할 수 있는 조합이 없어요. (중복 선택은 자동으로 합쳐집니다)');
            return;
          }

          s.runeRowsM.push({ cat: nextPair.cat, tier: Number(nextPair.tier), cnt: 0 });

          applyRowsToStateOrRevert(() => { });
          render();
          toast('스킬룬 행이 추가되었습니다.');
        });
        addBtn.dataset.bound = '1';
      }

      // 최초: rows → runes 반영 + 렌더
      applyRowsToStateOrRevert(() => { });
      render();
    }



    function bindSpecialRuneSelectsMobile() {
      const gaho = document.getElementById('specialRune_gahoM');
      const jihe = document.getElementById('specialRune_jiheM');
      const waegok = document.getElementById('specialRune_waegokM');
      if (!gaho || !jihe || !waegok) return;

      ensureSpecialRunesInitialized();

      // 초기값 반영
      gaho.value = String(window.state.specialRunes.gaho || 0);
      jihe.value = String(window.state.specialRunes.jihe || 0);
      waegok.value = String(window.state.specialRunes.waegok || 0);

      const onChange = (key, el) => {
        const s = window.state || {};
        const before = Number(s.specialRunes?.[key] ?? 0) || 0;
        const after = Number(el.value || 0) || 0;

        s.specialRunes[key] = after;

        const ok = _capTo20OrRevert_(
          () => { },
          () => {
            s.specialRunes[key] = before;
            el.value = String(before);
          }
        );

        if (!ok) {
          try { el.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], { duration: 180 }); } catch (_) { }
        }
      };

      gaho.addEventListener('change', () => onChange('gaho', gaho));
      jihe.addEventListener('change', () => onChange('jihe', jihe));
      waegok.addEventListener('change', () => onChange('waegok', waegok));

      updateRuneCountSummary();
    }

    function openRuneModalMobile() {
      const modal = document.getElementById('runeModalM');
      if (!modal) return;

      ensureRunesInitialized();
      ensureSpecialRunesInitialized();

      // 렌더 + 바인딩
      bindRunePickerMobile();
      bindSpecialRuneSelectsMobile();

      modal.classList.add('show');
      modal.setAttribute('aria-hidden', 'false');
      updateRuneCountSummary();
    }

    function closeRuneModalMobile() {
      const modal = document.getElementById('runeModalM');
      if (!modal) return;
      modal.classList.remove('show');
      modal.setAttribute('aria-hidden', 'true');
      updateRuneCountSummary();
    }

        // ✅ 와일드베인 스킬트리 요약 갱신
    function updateWildbaneTreeSummaryMobile() {
      const s = window.state || {};
      const preset = String(s.wildbaneTreePreset || '파파초').trim() || '파파초';
      const cycle = Number.isFinite(+s.wildbaneCycleCount) ? Math.max(0, Math.floor(+s.wildbaneCycleCount)) : 0;

      const pEl = document.getElementById('wildbaneTreePickM');
      const cEl = document.getElementById('wildbaneCyclePickM');

      if (pEl) pEl.textContent = preset;
      if (cEl) cEl.textContent = (cycle > 0 ? `${cycle}회` : '자동');
    }

    // ✅ 와일드베인 모달 열기
    function openWildbaneTreeModalMobile() {
      const modal = document.getElementById('wildbaneTreeModalM');
      if (!modal) return;

      const s = (window.state || (window.state = {}));

      // 기본값 보정
      s.wildbaneTreePreset = String(s.wildbaneTreePreset || '파파초').trim() || '파파초';
      s.wildbaneCycleCount = Number.isFinite(+s.wildbaneCycleCount) ? Math.max(0, Math.floor(+s.wildbaneCycleCount)) : 0;

      // 임시값(모달에서 선택 중)
      s._wbTreeTemp = s.wildbaneTreePreset;
      s._wbCycleCountTemp = s.wildbaneCycleCount;

      // 버튼 active 반영
      modal.querySelectorAll('[data-wb-tree]').forEach(btn => {
        btn.classList.toggle('wb-active', btn.dataset.wbTree === s._wbTreeTemp);
      });

      // 입력값 반영
      const inp = modal.querySelector('#wbCycleCountM');
      if (inp) inp.value = String(s._wbCycleCountTemp ?? 0);

      modal.classList.add('show');
      modal.setAttribute('aria-hidden', 'false');
    }

    // ✅ 와일드베인 모달 바인딩(1회)
    function bindWildbaneTreeModalMobile() {
      const modal = document.getElementById('wildbaneTreeModalM');
      if (!modal || modal.dataset.bound) return;
      modal.dataset.bound = '1';

      const close = () => {
        modal.classList.remove('show');
        modal.setAttribute('aria-hidden', 'true');
      };

      // 닫기(배경/닫기 버튼)
      modal.querySelectorAll('[data-wb-close]').forEach(el => {
        el.addEventListener('click', close);
      });

      // 트리 버튼 선택
      modal.querySelectorAll('[data-wb-tree]').forEach(btn => {
        btn.addEventListener('click', () => {
          const s = (window.state || (window.state = {}));
          s._wbTreeTemp = btn.dataset.wbTree;

          modal.querySelectorAll('[data-wb-tree]').forEach(b => {
            b.classList.toggle('wb-active', b.dataset.wbTree === s._wbTreeTemp);
          });
        });
      });

      // 사이클 입력
      const inp = modal.querySelector('#wbCycleCountM');
      if (inp) {
        inp.addEventListener('input', () => {
          const s = (window.state || (window.state = {}));
          const v = Math.floor(Number(inp.value || 0));
          s._wbCycleCountTemp = Math.max(0, isFinite(v) ? v : 0);
        });
      }

      // 선택 확정
      document.getElementById('btnWildbaneTreeApplyM')?.addEventListener('click', () => {
        const s = (window.state || (window.state = {}));

        s.wildbaneTreePreset = String(s._wbTreeTemp || s.wildbaneTreePreset || '파파초').trim() || '파파초';
        s.wildbaneCycleCount = Math.max(0, Math.floor(Number(s._wbCycleCountTemp || 0)));

        updateWildbaneTreeSummaryMobile();
        close();
        toast('스킬트리가 적용되었습니다.');
      });
    }

    function bindRuneButtonMobile() {
      const btn = document.getElementById('btnRuneM');
      if (!btn) return;

      // 버튼 클릭 → 모달 오픈
      if (!btn.dataset.bound) {
        btn.addEventListener('click', () => {
          openRuneModalMobile();
        });
        btn.dataset.bound = '1';
      }

      // 모달 close / commit 바인딩은 1회만
      const modal = document.getElementById('runeModalM');
      if (modal && !modal.dataset.bound) {
        modal.addEventListener('click', (e) => {
          if (e.target?.dataset?.runeClose !== undefined) closeRuneModalMobile();
          if (e.target?.classList?.contains('backdrop')) closeRuneModalMobile();
        });
        modal.querySelectorAll('[data-rune-close]').forEach(el => {
          el.addEventListener('click', closeRuneModalMobile);
        });

        const commit = document.getElementById('runeCommitM');
        commit?.addEventListener('click', () => {
          // state에 이미 반영되어 있으므로 닫기만
          closeRuneModalMobile();
          toast('스킬룬 설정이 적용되었습니다.');
        });

        modal.dataset.bound = '1';
      }

      // 초기 카운트 반영
      ensureRunesInitialized();
      ensureSpecialRunesInitialized();
      updateRuneCountSummary();
    }

// ✅ 윈드시어 스킬트리 요약 갱신
function updateWindshearTreeSummaryMobile() {
  const s = window.state || {};
  const preset = String(s.windshearTreePreset || 'A').trim() || 'A';
  const cycle = Number.isFinite(+s.windshearCycleCount) ? Math.max(0, Math.floor(+s.windshearCycleCount)) : 0;

  const labelMap = { A: 'A (파파파파빨)', B: 'B (파파파빨)', C: 'C (파파빨)' };
  const pEl = document.getElementById('windshearTreePickM');
  const cEl = document.getElementById('windshearCyclePickM');

  if (pEl) pEl.textContent = (labelMap[preset] || preset);
  if (cEl) cEl.textContent = (cycle > 0 ? `${cycle}회` : '자동');
}

// ✅ 윈드시어 모달 열기
function openWindshearTreeModalMobile() {
  const modal = document.getElementById('windshearTreeModalM');
  if (!modal) return;

  const s = (window.state || (window.state = {}));

  // 기본값 보정
  s.windshearTreePreset = String(s.windshearTreePreset || 'A').trim() || 'A';
  s.windshearCycleCount = Number.isFinite(+s.windshearCycleCount) ? Math.max(0, Math.floor(+s.windshearCycleCount)) : 0;

  // 임시값(모달에서 선택 중)
  s._wsTreeTemp = s.windshearTreePreset;
  s._wsCycleCountTemp = s.windshearCycleCount;

  // 버튼 active 반영
  modal.querySelectorAll('[data-ws-tree]').forEach(btn => {
    btn.classList.toggle('wb-active', btn.dataset.wsTree === s._wsTreeTemp);
  });

  // 입력값 반영
  const inp = modal.querySelector('#wsCycleCountM');
  if (inp) inp.value = String(s._wsCycleCountTemp ?? 0);

  modal.classList.add('show');
  modal.setAttribute('aria-hidden', 'false');
}

// ✅ 윈드시어 모달 바인딩(1회)
function bindWindshearTreeModalMobile() {
  const modal = document.getElementById('windshearTreeModalM');
  if (!modal || modal.dataset.bound) return;
  modal.dataset.bound = '1';

  const close = () => {
    modal.classList.remove('show');
    modal.setAttribute('aria-hidden', 'true');
  };

  // 닫기(배경/닫기 버튼)
  modal.querySelectorAll('[data-ws-close]').forEach(el => {
    el.addEventListener('click', close);
  });

  // 트리 버튼 선택
  modal.querySelectorAll('[data-ws-tree]').forEach(btn => {
    btn.addEventListener('click', () => {
      const s = (window.state || (window.state = {}));
      s._wsTreeTemp = btn.dataset.wsTree;

      modal.querySelectorAll('[data-ws-tree]').forEach(b => {
        b.classList.toggle('wb-active', b.dataset.wsTree === s._wsTreeTemp);
      });
    });
  });

  // 사이클 입력
  const inp = modal.querySelector('#wsCycleCountM');
  if (inp) {
    inp.addEventListener('input', () => {
      const s = (window.state || (window.state = {}));
      const v = Math.floor(Number(inp.value || 0));
      s._wsCycleCountTemp = Math.max(0, isFinite(v) ? v : 0);
    });
  }

  // 설정 하기
  modal.querySelector('#btnWindshearTreeApplyM')?.addEventListener('click', () => {
    const s = (window.state || (window.state = {}));
    const preset = String(s._wsTreeTemp || 'A').trim() || 'A';
    const cycle = Number.isFinite(+s._wsCycleCountTemp) ? Math.max(0, Math.floor(+s._wsCycleCountTemp)) : 0;

    s.windshearTreePreset = preset;
    s.windshearCycleCount = cycle;

    updateWindshearTreeSummaryMobile();
    close();

    // 토스트 함수가 있으면 사용(없어도 안전)
    if (typeof toast === 'function') toast('윈드시어 스킬트리 설정이 적용되었습니다.');
  });
}

    async function bindCastleSealMobile() {
      // 0) 데이터 준비
      await initMobileAllLightListsOnce();
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const btn = document.getElementById('btnCastleSealM');
      const sum = document.getElementById('castleSealSummaryM');
      const modal = document.getElementById('castleSealModalM');

      if (!btn || !sum) return;

      window.state = window.state || {};
      const s = window.state;
      s.castleSeal = s.castleSeal || { mainName: '', subName: '' };

            const refresh = () => {
        // ✅ 혹시 summary DOM이 깨져있으면(누가 textContent로 덮어쓴 경우) 즉시 복구
        const sumEl = document.getElementById('castleSealSummaryM');
        if (sumEl && (!sumEl.querySelector('#castleSealMainPickM') || !sumEl.querySelector('#castleSealSubPickM'))) {
          sumEl.innerHTML = `
            <div>주요 옵션 : <span id="castleSealMainPickM">-</span></div>
            <div>추가 옵션 : <span id="castleSealSubPickM">-</span></div>
          `.trim();
        }

        const main = s.castleSeal.mainName ? s.castleSeal.mainName : '-';
        const sub = s.castleSeal.subName ? s.castleSeal.subName : '-';

        const mainEl = document.getElementById('castleSealMainPickM');
        const subEl = document.getElementById('castleSealSubPickM');

        if (mainEl) mainEl.textContent = main;
        if (subEl) subEl.textContent = sub;
      };

      refresh();

      // 1) 옵션 목록(매번 최신 DBEnh 기준)
      const getLists = () => {
        const mains = (DBEnh?.byType?.['주요 옵션'] || [])
          .map(r => String(r?.name ?? r?.['이름'] ?? '').trim())
          .filter(Boolean);

        const subs = (DBEnh?.byType?.['추가 옵션'] || [])
          .map(r => String(r?.name ?? r?.['이름'] ?? '').trim())
          .filter(Boolean);

        return { mains, subs };
      };

      // ✅ [추가] 기본값 자동 세팅: 비어있으면 항상 “맨 위(0번)”로
      const ensureCastleSealDefaults = () => {
        const { mains, subs } = getLists();

        if (!s.castleSeal.mainName && mains.length) {
          s.castleSeal.mainName = mains[0];
        }
        if (!s.castleSeal.subName && subs.length) {
          s.castleSeal.subName = subs[0];
        }
      };

      // ✅ [추가] 바인딩 시점에 1번 기본값 확정 + 요약 갱신
      ensureCastleSealDefaults();
      refresh();

      const openModal = () => {
        if (!modal) {
          console.error('[CastleSeal] modal not found: #castleSealModalM');
          toast('성안의 봉인 모달이 없습니다. HTML을 확인하세요.');
          return;
        }

        const selMain = document.getElementById('castleSealMainSelM');
        const selSub = document.getElementById('castleSealSubSelM');
        if (!selMain || !selSub) {
          console.error('[CastleSeal] selects not found', { selMain: !!selMain, selSub: !!selSub });
          toast('성안의 봉인 셀렉트가 없습니다. HTML을 확인하세요.');
          return;
        }

        // ✅ [추가] 모달 열 때도 안전하게 기본값 보정
        ensureCastleSealDefaults();

        const { mains, subs } = getLists();

        const fill = (sel, arr, current) => {
          // DOM 방식으로 안전하게 채우기
          sel.innerHTML = '';
          const opt0 = document.createElement('option');
          opt0.value = '';
          opt0.textContent = '- 선택 안함 -';
          sel.appendChild(opt0);

          for (const name of arr) {
            const op = document.createElement('option');
            op.value = name;
            op.textContent = name;
            sel.appendChild(op);
          }
          sel.value = current || '';
        };

        fill(selMain, mains, s.castleSeal.mainName);
        fill(selSub, subs, s.castleSeal.subName);

        // ✅ 모달 오픈 시점에 draft(임시 선택값) 초기화
        modal.dataset.draftMain = String(s.castleSeal.mainName || '').trim();
        modal.dataset.draftSub  = String(s.castleSeal.subName  || '').trim();

        modal.classList.add('show');        // ✅ CSS가 .modal.show로 열리는 구조
        modal.setAttribute('aria-hidden', 'false');

      };

      const closeModal = () => {
        if (!modal) return;
        modal.classList.remove('show');
        modal.setAttribute('aria-hidden', 'true');
      };

      // 2) 모달 이벤트 바인딩(1회만)
            if (modal && !modal.dataset.bound) {
        // backdrop/닫기 버튼
        modal.addEventListener('click', (e) => {
          const t = e.target;
          if (t?.dataset?.sealClose !== undefined) closeModal();
          if (t?.classList?.contains('backdrop')) closeModal();
        });

        // ✅ 셀렉트는 "임시 선택값"만 들고 있고, summary/state는 건드리지 않는다.
        const selMain = document.getElementById('castleSealMainSelM');
        const selSub = document.getElementById('castleSealSubSelM');

        // 모달 열릴 때 openModal()에서 현재값으로 채우지만,
        // change 시점에는 적용하지 않고 modal.dataset에만 저장(임시값)
        selMain?.addEventListener('change', () => {
          if (!modal) return;
          modal.dataset.draftMain = String(selMain.value || '').trim();
        });

        selSub?.addEventListener('change', () => {
          if (!modal) return;
          modal.dataset.draftSub = String(selSub.value || '').trim();
        });

        // ✅ "설정 하기"를 눌렀을 때만 state 반영 + summary 갱신
        const commit = document.getElementById('castleSealCommitM');
        commit?.addEventListener('click', () => {
          const mainV = String(selMain?.value || modal?.dataset?.draftMain || '').trim();
          const subV  = String(selSub?.value  || modal?.dataset?.draftSub  || '').trim();

          s.castleSeal.mainName = mainV;
          s.castleSeal.subName  = subV;

          refresh();      // ✅ 여기서만 요약 텍스트 갱신
          closeModal();
          toast('성안의 봉인이 적용되었습니다.');
        });

        modal.dataset.bound = '1';
      }

      // 3) 버튼 클릭 바인딩(1회만)
      if (!btn.dataset.bound) {
        btn.addEventListener('click', () => {
          console.log('[CastleSeal] btn click'); // ✅ 디버깅용
          openModal();
        });
        btn.dataset.bound = '1';
      }
    }

    // ✅ Page 3 init을 '딱 1번만' 보장
    let __page3InitDone = false;

    async function ensurePage3Init() {
      if (__page3InitDone) return;
      __page3InitDone = true;
      try {
        await initPage3Mobile();
        console.log('[PAGE3] init ok');
      } catch (e) {
        __page3InitDone = false;
        console.error('[PAGE3] init fail', e);
      }
    }

    // ✅ 한 번에 묶어서 호출
    async function initPage3Mobile() {
      bindTimeMobile();
      await populateMonsterMobile();
      await populateAvatarImprintMobile();
      await populateRuneEngraveMobile();
      bindRuneButtonMobile();
      await bindCastleSealMobile();
    }
    // ================================
    // ✅ Page4: Skill (SP/TP) UI
    // ================================
    let __page4InitDone = false;

    function ensurePage4Init() {
      if (__page4InitDone) return;
      __page4InitDone = true;

      try {
        bindSkillPageMobile();
        renderSkillPageMobile();
      } catch (e) {
        __page4InitDone = false;
        console.error(e);
      }
    }

    function _num(x, def = 0) {
      const n = Number(x);
      return Number.isFinite(n) ? n : def;
    }

    function _clamp(v, a, b) {
      v = _num(v, a);
      if (v < a) return a;
      if (v > b) return b;
      return v;
    }

    function _pickAny(obj, keys) {
      for (const k of keys) {
        if (obj && obj[k] != null && String(obj[k]).trim() !== '') return obj[k];
      }
      return '';
    }

    function _getSkillListRaw() {
      // 서버/버전별 키 차이를 느슨하게 커버
      return (
        window.CORE?.lists?.['skill:list'] ||
        window.CORE?.lists?.['skills:list'] ||
        window.CORE?.lists?.['skillList'] ||
        window.CORE?.lists?.['skills'] ||
        []
      );
    }

    function _getSkillName(r) {
      return String(_pickAny(r, ['name', '이름', 'skillName', '스킬명']) || '').trim();
    }
    function _getSkillChar(r) {
      return String(_pickAny(r, ['charName', '캐릭터명', '캐릭터', 'char', 'job']) || '').trim();
    }
    function _getSkillReq(r) {
      return _num(_pickAny(r, ['reqLevel', '요구레벨', '레벨', 'Lv']), 0);
    }
    function _getSkillMin(r) {
      return _num(_pickAny(r, ['minLevel', '최소레벨', 'min', 'minLv']), 0);
    }
    function _getSkillMax(r) {
      // lvCap를 max로 쓰는 데이터도 있어서 느슨하게
      const a = _pickAny(r, ['maxLevel', '최대레벨', 'max', 'maxLv']);
      const b = _pickAny(r, ['lvCap', '레벨상한', 'cap']);
      const n = _num(a, NaN);
      return Number.isFinite(n) ? n : _num(b, 0);
    }
    function _getSkillTPCap(r) {
      // ✅ tpMax 컬럼이 없으므로: tp설정이 있으면 유저 수동 TP는 최대 5
      const set = _num(_pickAny(r, ['tp', 'tp설정', 'tp 설정', 'TP설정', 'TP 설정', 'tpSetting', 'tp_setting']), 0);
      return (set === 1 || set === 2) ? 5 : 0;
    }
    function _getSkillShow(r) {
      // 시트가 한글키로 들어오면 '노출여부', 가공된 리스트면 'show'를 쓰는 경우가 많음
      const v = _pickAny(r, ['노출여부', 'show', 'visible', '노출', '노출 여부']);
      const s = String(v ?? '').trim();
      return s === '1' || s.toLowerCase() === 'true';
    }
    function _getSkillImg(r) {
      return String(r?.['image'] ?? '').trim();
    }
    function _getSkillSpCost(r) {
      // 스킬 시트의 '소모 sp' 컬럼(PC에서는 skill.sp 로 들어감)
      return _num(_pickAny(r, ['costSP', '소모 sp', '소모sp', 'SP소모', 'sp', 'spCost', 'sp_cost', 'sp소모']), 0);
    }
    function _getSkillTpCost(r) {
      // ✅ TP 1레벨당 소모량:
      // 사용자가 말한 규칙: 시트의 'tp설정' 값이 1이면 1, 2이면 2를 소모
      const set = _num(_pickAny(r, ['tp', 'tp 설정', 'TP설정', 'TP 설정', 'tpSetting', 'tp_setting']), NaN);
      if (set === 1 || set === 2) return set;
    }

    // ===== Page4 Skill: 남은 SP/TP 표시 =====
    function _getCharTotalSpTp() {
      const s = window.state || {};
      const c = s.currentCharacter || {};

      // ✅ 모바일 char:list에서 총 SP/TP가 sp / tp 로 들어오는 경우가 많아서 포함
      const totalSP_1 = _num(_pickAny(c, [
        'TotalSP', 'totalSP', 'spTotal', '총SP', 'SP총합', 'spAll',
        'sp', 'SP', 'sp_total', 'totalSp'
      ]), NaN);

      const totalTP_1 = _num(_pickAny(c, [
        'TotalTP', 'totalTP', 'tpTotal', '총TP', 'TP총합', 'tpAll',
        'tp', 'TP', 'tp_total', 'totalTp'
      ]), NaN);

      // ✅ 폴백: state.sp.total / state.tp.total (PC쪽 구조를 따라온 경우)
      const totalSP = Number.isFinite(totalSP_1) ? totalSP_1 : _num(s?.sp?.total, NaN);
      const totalTP = Number.isFinite(totalTP_1) ? totalTP_1 : _num(s?.tp?.total, NaN);

      return { totalSP, totalTP };
    }


    function _calcUsedSpTp() {
      const charKey = _getCurrentCharKey() || '__nochar__';
      const store = window.state?.skillTrees?.[charKey] || {};
      const isStriker = String(charKey || '').replace(/\s+/g, '') === '격투가스트라이커';
      let usedSP = 0;
      let usedTP = 0;

      for (const k in store) {
        const it = store[k];
        if (!it) continue;

        // ✅ 본 크러셔는 로킥 연동(무료) → 남은 SP 계산에서 제외
        if (isStriker && String(k || '').replace(/\s+/g, '') === '본크러셔') continue;

        const spLv = _num(it.spLv, 0);
        const spMin = _num(it.spMin, 0);
        const tpLv = _num(it.tpLv, 0);

        const spCost = _num(it.spCost ?? it.sp ?? 0, 0);
        const tpCost = _num(it.tpCost ?? 1, 1);

        usedSP += Math.max(0, spLv - spMin) * (spCost > 0 ? spCost : 0);
        usedTP += Math.max(0, tpLv) * (tpCost > 0 ? tpCost : 0);
      }
      return { usedSP, usedTP };
    }

    function updateSkillRemainBar() {
  const bar = document.getElementById('skillRemainBarM');
  const elSp = document.getElementById('skillRemainSpM');
  const elTp = document.getElementById('skillRemainTpM');
  if (!bar || !elSp || !elTp) return;

  // ✅ 와일드베인(스킬트리 선택형)에서는 남은 SP/TP 표시를 사용하지 않음
  const s0 = window.state || {};
  const ok0 = String(s0.ownerKey || s0.CurrentSumStats?.ownerKey || '').trim()
    || (String(s0.currentCharacter?.jobGroupLabel || s0.currentCharacter?.jobGroup || '').trim()
      + String(s0.currentCharacter?.name || s0.currentCharacter?.charName || '').trim()
    ).replace(/\s+/g, '');

  if (ok0 === '워리어와일드베인') {
    bar.classList.add('is-hidden');
    elSp.textContent = '-';
    elTp.textContent = '-';
    return;
  }

  const { totalSP, totalTP } = _getCharTotalSpTp();
  const hasAny = Number.isFinite(totalSP) || Number.isFinite(totalTP);

  if (!hasAny) {
    bar.classList.add('is-hidden');
    elSp.textContent = '-';
    elTp.textContent = '-';
    return;
  }

  bar.classList.remove('is-hidden');

  // ✅ 핵심: 현재 찍은 스킬로 사용한 SP/TP를 빼서 "남은 값" 표시
  const { usedSP, usedTP } = _calcUsedSpTp();

  elSp.textContent = Number.isFinite(totalSP)
    ? String(Math.max(0, Math.round(totalSP - usedSP)))
    : '-';

  elTp.textContent = Number.isFinite(totalTP)
    ? String(Math.max(0, Math.round(totalTP - usedTP)))
    : '-';
}


    function _getCurrentCharKey() {
      const c = window.state?.currentCharacter || {};
      const k = String(c.ownerKey || c.charKey || '').trim();
      if (k) return k.replace(/\s+/g, '');

      // fallback: jobGroup + name 조합
      const job = String(c.jobGroupLabel || c.jobGroup || c.job || '').trim();
      const nm = String(c.name || c.charName || '').trim();
      return (job + nm).replace(/\s+/g, '');
    }

    function _syncStrikerBoneCrusherFromLowKick_mobile() {
  const s = (window.state || (window.state = {}));
  const charKey = _getCurrentCharKey() || '__nochar__';
  const ownerKeyNow = String(charKey || '').replace(/\s+/g, '');
  if (ownerKeyNow !== '격투가스트라이커') return null;

  s.skillTrees = s.skillTrees || {};
  s.skillTrees[charKey] = s.skillTrees[charKey] || {};
  const store = s.skillTrees[charKey];

  const norm = (v) => String(v || '').replace(/\s+/g, '');
  const findKey = (wantNorm) => {
    for (const k in store) {
      if (norm(k) === wantNorm) return k;
    }
    return '';
  };

  const lowKey = findKey('로킥') || '로킥';
  const boneKey = findKey('본크러셔') || '본 크러셔';

  const low = store[lowKey] || { spLv: 0 };
  const bone = store[boneKey] || { spLv: 0, tpLv: 0, spMin: 0, spMax: 0, tpMax: 0, spCost: 0, tpCost: 1 };

  // ✅ 본 크러셔 = max(0, 로킥 - 10)
  const target = Math.max(0, _num(low.spLv, 0) - 10);

  const spMin = _num(bone.spMin, 0);
  const spMax = _num(bone.spMax, target); // spMax가 없으면 target로
  const next = Math.max(spMin, Math.min(spMax, target));

  const prev = _num(bone.spLv, 0);
  const changed = (prev !== next) || (_num(bone.spCost ?? 0, 0) !== 0);

  // ✅ 본 크러셔는 “연동 무료”로 취급: SP 소모 0 고정
  store[boneKey] = { ...bone, spLv: next, spCost: 0 };

  return { boneKey, boneLv: next, changed };
}

function _refreshStrikerBoneCrusherRowUiMobile(info) {
  if (!info) return;
  const listEl = document.getElementById('skillListM');
  if (!listEl) return;

  const norm = (v) => String(v || '').replace(/\s+/g, '');

  let row = null;
  for (const r of listEl.querySelectorAll('.skill-row')) {
  const nm = norm(r.dataset.skill || r.dataset.skillName || '');
  if (nm === '본크러셔') { row = r; break; }
}
  if (!row) return;

  const val = row.querySelector('.skill-val[data-val="sp"]');
  if (val) val.textContent = String(info.boneLv);

  // 혹시 렌더에서 disabled 처리 누락된 경우 대비
  row.querySelectorAll('button[data-act^="sp-"]').forEach((b) => {
    b.disabled = true;
  });
}

function _syncFMechGMagneticFromSyncroCorona_mobile() {
  const s = (window.state || (window.state = {}));
  const charKey = _getCurrentCharKey() || '__nochar__';
  const ownerKeyNow = String(charKey || '').replace(/\s+/g, '');
  if (ownerKeyNow !== '여거너메카닉') return null;

  s.skillTrees = s.skillTrees || {};
  s.skillTrees[charKey] = s.skillTrees[charKey] || {};
  const store = s.skillTrees[charKey];

  const norm = (v) => String(v || '').replace(/\s+/g, '');
  const findKey = (wantNorm) => {
    for (const k in store) {
      if (norm(k) === wantNorm) return k;
    }
    return '';
  };

  const coronaKey = findKey('싱크로:코로나');
  const magKey    = findKey('G마그네틱');
  if (!coronaKey || !magKey) return null;

  const corona = store[coronaKey] || {};
  const mag = store[magKey] || {};

  // ✅ "레벨 차이 없이 동일" 이므로 그대로 복사
  const target = _num(corona.spLv, 0);

  const spMin = _num(mag.spMin, 0);
  const spMax = _num(mag.spMax, target); // spMax 없으면 target
  const next = Math.max(spMin, Math.min(spMax, target));

  const prev = _num(mag.spLv, 0);
  const changed = (prev !== next) || (_num(mag.spCost ?? 0, 0) !== 0);

  // ✅ G마그네틱은 항상 무료(=spCost 0) + 레벨 동기화
  store[magKey] = { ...mag, spLv: next, spCost: 0 };

  return { magKey, magLv: next, changed };
}

function _refreshFMechGMagneticRowUiMobile(info) {
  if (!info) return;
  const listEl = document.getElementById('skillListM');
  if (!listEl) return;

  const norm = (v) => String(v || '').replace(/\s+/g, '');

  let row = null;
  for (const r of listEl.querySelectorAll('.skill-row')) {
    const nm = norm(r.dataset.skill || r.dataset.skillName || '');
    if (nm === 'G마그네틱') { row = r; break; }
  }
  if (!row) return;

  const val = row.querySelector('.skill-val[data-val="sp"]');
  if (val) val.textContent = String(info.magLv);

  // 혹시 렌더에서 disabled 처리 누락된 경우 대비(안전장치)
  row.querySelectorAll('button[data-act^="sp-"]').forEach((b) => {
    b.disabled = true;
  });
}

    function bindSkillPageMobile() {
  const listEl = document.getElementById('skillListM');
  const resetBtn = document.getElementById('btnSkillResetM');
  if (!listEl) return;

  // (1) 버튼 이벤트(위임)
  if (!listEl.dataset.bound) {
    listEl.dataset.bound = '1';

    listEl.addEventListener('click', (e) => {
      const btn = e.target?.closest?.('button[data-act]');
      if (!btn) return;

      const row = btn.closest('.skill-row');
      if (!row) return;

      const act = btn.dataset.act || '';

      // ✅ row.dataset.col에 의존하지 말고, act 접두사로 SP/TP 판별
      const isSp = act.startsWith('sp-');
      const isTp = act.startsWith('tp-');
      if (!isSp && !isTp) return;

      // ✅ 렌더쪽이 data-skill을 쓰는 경우가 많으니 우선 사용
      const skillName = row.dataset.skill || row.dataset.skillName || '';
      if (!skillName) return;

      const s = (window.state || (window.state = {}));
      const charKey = _getCurrentCharKey() || '__nochar__';

      const isFMech = String(charKey || '').replace(/\s+/g, '') === '여거너메카닉';
      const isStriker = String(charKey || '').replace(/\s+/g, '') === '격투가스트라이커';
const normSkill = String(skillName || '').replace(/\s+/g, '');

// ✅ 격투가 스트라이커: '본 크러셔' SP는 수동 조작 불가(안전장치)
if (isStriker && isSp && normSkill === '본크러셔') {
  return;
}

// ✅ 여거너메카닉: 'G 마그네틱' SP는 수동 조작 불가(싱크로:코로나와 자동 동일화)
if (isFMech && isSp && normSkill === 'G마그네틱') {
  return;
}

/* ================================
 * ✅ 여거너메카닉: G-2 롤링썬더 ↔ G-3 랩터 동시 SP 불가
 * - 한쪽이 1 이상이면, 다른쪽을 1 이상으로 올리려는 시도를 차단
 * - SP 내리는 건(0으로 만드는 것) 허용
 * ================================ */

// 공백 제거 비교용
const _norm = (v) => String(v || '').replace(/\s+/g, '');

// store 안에서 "정규화된 스킬명"으로 실제 key 찾기
const _findSkillKeyByNorm = (storeObj, normTarget) => {
  if (!storeObj) return null;
  for (const k of Object.keys(storeObj)) {
    if (_norm(k) === normTarget) return k;
  }
  return null;
};

// 상대 스킬 SP 레벨 얻기(없으면 0)
const _getOtherSpLv = (storeObj, normTarget) => {
  const k = _findSkillKeyByNorm(storeObj, normTarget);
  if (!k) return 0;
  const o = storeObj[k] || {};
  return _num(o.spLv, 0);
};

// 두 스킬 정규화명(공백 제거)
const RT = _norm('G-2 롤링썬더');
const RP = _norm('G-3 랩터');

// 현재 클릭한 스킬이 둘 중 하나면, 상대 스킬의 norm 지정
let _otherNorm = null;
if (isFMech) {
  if (normSkill === RT) _otherNorm = RP;
  else if (normSkill === RP) _otherNorm = RT;
}

// “이 스킬을 nextSp(>0)로 만들려는 순간” 상대가 이미 >0이면 차단
const _blockIfExclusive = (nextSp, storeObj) => {
  if (!isFMech) return false;
  if (!_otherNorm) return false;
  if (_num(nextSp, 0) <= 0) return false; // 0 이하는 허용(내리기)
  const otherLv = _getOtherSpLv(storeObj, _otherNorm);
  if (otherLv > 0) {
    const warn = `'G-2 롤링썬더'와 'G-3 랩터'중 하나만 찍어주세요.`;
    (typeof toast === 'function' ? toast : alert)(warn);
    return true;
  }
  return false;
};
/* ================================
 * ✅ 여거너메카닉: 팔콘 4종 중 1개만 SP 가능
 * - 인서트 : 팔콘
 * - G-SP 팔콘(코로나 폼)
 * - G-SP 팔콘(롤링 썬더 폼)
 * - G-SP 팔콘(랩터 폼)
 * ================================ */
const FAL1 = _norm('인서트 : 팔콘');
const FAL2 = _norm('G-SP 팔콘(코로나 폼)');
const FAL3 = _norm('G-SP 팔콘(롤링 썬더 폼)');
const FAL4 = _norm('G-SP 팔콘(랩터 폼)');

let _falconOthers = null;
if (isFMech) {
  const all = [FAL1, FAL2, FAL3, FAL4];
  const idx = all.findIndex(x => x === normSkill);
  if (idx >= 0) _falconOthers = all.filter((_, i) => i !== idx);
}

// nextSp(>0)로 올리려는 순간, 나머지 3개 중 하나라도 이미 >0이면 차단
const _blockIfExclusiveFalcon = (nextSp, storeObj) => {
  if (!isFMech) return false;
  if (!_falconOthers) return false;
  if (_num(nextSp, 0) <= 0) return false; // 0 이하는 허용(내리기)

  for (const otherNorm of _falconOthers) {
    const otherLv = _getOtherSpLv(storeObj, otherNorm);
    if (otherLv > 0) {
      toast(
        `팔콘류 스킬은 한가지 종류만 찍어주세요.`
      );
      return true;
    }
  }
  return false;
};


      s.skillTrees = s.skillTrees || {};
      s.skillTrees[charKey] = s.skillTrees[charKey] || {};
      const store = s.skillTrees[charKey];

      const cur = store[skillName] || { spLv: 0, tpLv: 0, spMin: 0, spMax: 0, tpMax: 0 };

      const spMin = _num(cur.spMin, 0);
      const spMax = _num(cur.spMax, 0);
      const tpMax = _num(cur.tpMax, 0);

      let spLv = _num(cur.spLv, 0);
      let tpLv = _num(cur.tpLv, 0);

      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

      // ✅ 핵심: 남은 SP/TP로 “이 스킬이 찍을 수 있는 최대치”를 매번 계산
      const { totalSP, totalTP } = _getCharTotalSpTp();
      const { usedSP, usedTP } = _calcUsedSpTp();

      const spCost = _num(cur.spCost ?? cur.sp ?? 0, 0);
      const tpCost = _num(cur.tpCost ?? 1, 1);

      const curSpentSP = Math.max(0, spLv - spMin) * (spCost > 0 ? spCost : 0);
      const curSpentTP = Math.max(0, tpLv) * (tpCost > 0 ? tpCost : 0);

      const remainSPForThis = Math.max(0, totalSP - (usedSP - curSpentSP));
      const remainTPForThis = Math.max(0, totalTP - (usedTP - curSpentTP));

      const spCap = (spCost > 0)
        ? Math.min(spMax, spMin + Math.floor(remainSPForThis / spCost))
        : spMax;

      const tpCap = (tpCost > 0)
        ? Math.min(tpMax, Math.floor(remainTPForThis / tpCost))
        : tpMax;

      const applySp = (next) => {
        // ✅ spMax가 아니라 spCap(남은 SP 기준 상한)으로 clamp
        spLv = clamp(next, spMin, spCap);
        store[skillName] = { ...cur, spLv, tpLv };
      };
      const applyTp = (next) => {
        // ✅ tpMax가 아니라 tpCap(남은 TP 기준 상한)으로 clamp
        tpLv = clamp(next, 0, tpCap);
        store[skillName] = { ...cur, spLv, tpLv };
      };

      if (isSp) {
  if (act === 'sp-min') {
    const next = spMin;
    if (_blockIfExclusive(next, store)) return;
    if (_blockIfExclusiveFalcon(next, store)) return;
    applySp(next);
  }
  if (act === 'sp-dec') {
    applySp(spLv - 1); // 내리기는 항상 허용
  }
  if (act === 'sp-inc') {
    const next = spLv + 1;
    if (_blockIfExclusive(next, store)) return;
    if (_blockIfExclusiveFalcon(next, store)) return;
    applySp(next);
  }
  if (act === 'sp-max') {
    const next = spCap;
    if (_blockIfExclusive(next, store)) return;
    if (_blockIfExclusiveFalcon(next, store)) return;
    applySp(next);
  }
} else if (isTp) {
  if (act === 'tp-min') applyTp(0);
  if (act === 'tp-dec') applyTp(tpLv - 1);
  if (act === 'tp-inc') applyTp(tpLv + 1);
  if (act === 'tp-max') applyTp(tpCap);
}

      // 화면 반영
      const valSpan = row.querySelector(`.skill-val[data-val="${isSp ? 'sp' : 'tp'}"]`);
      if (valSpan) valSpan.textContent = String(isSp ? spLv : tpLv);

            // ✅ 격투가 스트라이커: 로킥 ↔ 본 크러셔 자동 연동(실시간)
      if (isStriker) {
        const info = _syncStrikerBoneCrusherFromLowKick_mobile();
        if (info && info.changed) {
          _refreshStrikerBoneCrusherRowUiMobile(info);
        }
      }

      // ✅ 여거너메카닉: 싱크로:코로나 ↔ G마그네틱 자동 연동(실시간)
      if (isFMech) {
        const info2 = _syncFMechGMagneticFromSyncroCorona_mobile();
        if (info2 && info2.changed) {
          _refreshFMechGMagneticRowUiMobile(info2);
        }
      }

      updateSkillRemainBar();
    });
  }

  // (2) 초기화 버튼
  if (resetBtn && !resetBtn.dataset.bound) {
    resetBtn.dataset.bound = '1';
    resetBtn.addEventListener('click', () => {
      const s = (window.state || (window.state = {}));
      const charKey = _getCurrentCharKey() || '__nochar__';
      if (s.skillTrees && s.skillTrees[charKey]) {
        delete s.skillTrees[charKey];
      }
      renderSkillPageMobile();
      updateSkillRemainBar();
      toast('스킬이 초기화되었습니다.');
    });
  }

  // (3) 워리어 와일드베인: 스킬트리 선택 버튼/모달
  const wbBtn = document.getElementById('btnWildbaneTreeM');
  if (wbBtn && !wbBtn.dataset.bound) {
    wbBtn.dataset.bound = '1';
    wbBtn.addEventListener('click', () => {
      openWildbaneTreeModalMobile();
    });
  }
  bindWildbaneTreeModalMobile();
}

    // ✅ 공백 제거 정규화(스킬명/캐릭키 비교용)
function _normNoSpace(v) {
  return String(v ?? '').trim().replace(/\s+/g, '');
}

// ✅ PC프리셋 키: SK_번호_스킬명 -> 스킬명만 추출
function _stripPcSkillKeyToName(k) {
  const s = String(k ?? '').trim();
  return s.replace(/^SK_\d+_/, '').trim(); // 핵심
}

// ✅ owner 매칭 느슨하게: 완전일치 아니어도 포함/끝매칭 허용
function _looseOwnerMatch(rowOwner, charKey) {
  const a = _normNoSpace(rowOwner);
  const b = _normNoSpace(charKey);
  if (!a || !b) return false;
  if (a === b) return true;
  return a.includes(b) || b.includes(a) || a.endsWith(b) || b.endsWith(a);
}

// ✅ Object/Map 모두를 "entries"로 받기
function _entriesOf(maybe) {
  if (!maybe) return [];
  if (maybe instanceof Map) return Array.from(maybe.entries());
  if (typeof maybe === 'object') return Object.entries(maybe);
  return [];
}

// ✅ PC skillLv/skillTpLv -> 모바일 skillTrees[charKey][skillName].spLv/tpLv 로 변환
// ✅ (교체) PC 프리셋(skillLv/skillTpLv) → 모바일 스킬 저장소(skillTrees[charKey])로 변환
function syncSkillTreesFromLvMaps_mobile(charObj) {
  try {
    const s = window.state || {};
    const c = charObj || s.currentCharacter || {};

    // charKey는 Page4에서 쓰는 규칙과 동일하게(공백 제거)
    const charKey =
      String(c.ownerKey || '').trim().replace(/\s+/g, '') ||
      (String((c.jobGroupLabel || c.jobGroup || '') + (c.name || c.charName || '')).trim().replace(/\s+/g, ''));

    if (!charKey) return;

    const lvMap = (s.skillLv && typeof s.skillLv === 'object') ? s.skillLv : {};
    const tpMap = (s.skillTpLv && typeof s.skillTpLv === 'object') ? s.skillTpLv : {};

    const hasLv = Object.keys(lvMap).length > 0;
    const hasTp = Object.keys(tpMap).length > 0;
    if (!hasLv && !hasTp) return;

    s.skillTrees = s.skillTrees || {};
    s.skillTrees[charKey] = s.skillTrees[charKey] || {};
    const store = s.skillTrees[charKey];

    // rows 가져오기 (스킬 리스트)
    const raw = (typeof _getSkillListRaw === 'function')
      ? _getSkillListRaw()
      : (CORE?.skillsLite || CORE?.lists?.skillsLite);

    const rows = Array.isArray(raw) ? raw : [];
    if (!rows.length) return;

    // --- helpers ---
    const normName = (v) => String(v ?? '')
      .trim()
      .replace(/\s+/g, '')            // 공백 제거
      .replace(/[\u00A0]/g, '')       // NBSP 제거
      .replace(/[’‘]/g, "'");         // 따옴표 정규화(혹시 모를 케이스)

    // PC key: "SK_0_귀참" → "귀참"
    const stripSkPrefix = (k) => String(k ?? '').trim().replace(/^SK_\d+_/, '');

    // owner 느슨 매칭(공백 제거 후 포함/접미 허용)
    const isOwnerMatchLoose = (rowOwnerKey, targetCharKey) => {
      const a = normName(rowOwnerKey);
      const b = normName(targetCharKey);
      if (!a) return false;                // row에 owner가 없으면 통과시키지 않음(빈행/공용행 차단)
      if (a === b) return true;
      if (a.includes(b) || b.includes(a)) return true;
      if (a.endsWith(b) || b.endsWith(a)) return true;
      return false;
    };

    // 1) lvMap/tpMap을 “스킬명 기반”으로 변환해 lookup 테이블 생성
    const lvBySkill = Object.create(null);
    const tpBySkill = Object.create(null);

    for (const [k, v] of Object.entries(lvMap)) {
      const sk = normName(stripSkPrefix(k));
      if (!sk) continue;
      lvBySkill[sk] = Number(v ?? 0) || 0;
    }
    for (const [k, v] of Object.entries(tpMap)) {
      const sk = normName(stripSkPrefix(k));
      if (!sk) continue;
      tpBySkill[sk] = Number(v ?? 0) || 0;
    }

    // 2) rows의 “스킬명”으로 store에 채움
    for (const r of rows) {
      const rowOwner =
        _pickAny?.(r, ['ownerKey', '캐릭터명', 'character', 'charKey', 'charName']) ??
        r?.charName ?? r?.['캐릭터명'] ?? r?.ownerKey ?? '';

      if (!isOwnerMatchLoose(rowOwner, charKey)) continue;

       // ✅ show=1만 동기화 (UI와 동일 정책)
  const isShow =
    (typeof _getSkillShow === 'function')
      ? _getSkillShow(r)
      : (String(r?.show ?? r?.['노출여부'] ?? '').trim() === '1');
  if (!isShow) continue;

      const name = (typeof _getSkillName === 'function')
        ? _getSkillName(r)
        : String(_pickAny?.(r, ['name', '스킬명']) || r?.name || r?.['스킬명'] || '').trim();

      if (!name) continue;

      const key = normName(name);
      const lv = Number(lvBySkill[key] ?? 0) || 0;
      const tp = Number(tpBySkill[key] ?? 0) || 0;

      if (lv > 0 || tp > 0) {
        const cur = store[name] || {};
        store[name] = { ...cur, spLv: lv, tpLv: tp };
      }
    }
  } catch (e) {
    console.warn('[preset] sync skillTrees from lv maps fail', e);
  }
}

    function renderSkillPageMobile(cObj) {
  const listEl = document.getElementById('skillListM');
  if (!listEl) return;

  const s = (window.state || (window.state = {}));
  const c = cObj || window.state?.currentCharacter || {};
  const charKey = String(c.ownerKey || '').trim().replace(/\s+/g, '') || _getCurrentCharKey();

  if (!charKey) {
    listEl.innerHTML = `<div style="padding:14px 10px; color:#c7b589;">캐릭터를 먼저 선택하세요.</div>`;
    updateSkillRemainBar();
    return;
  }

  // ✅ 워리어 와일드베인/윈드시어 UI 처리(402 유지)
  const wbBox = document.getElementById('wildbaneTreeBoxM');
  const wsBox = document.getElementById('windshearTreeBoxM');
  const remainBar = document.getElementById('skillRemainBarM');
  const footnote = document.querySelector('#pageSkill .skill-footnote');

  const ownerKeyNow = String(charKey || '').trim().replace(/\s+/g, '');
  const isStriker = (ownerKeyNow === '격투가스트라이커');
  const isFMech   = (ownerKeyNow === '여거너메카닉');   // ✅ 추가
  const isWildbane = (ownerKeyNow === '워리어와일드베인');
  const isWindshear = (ownerKeyNow === '워리어윈드시어');

  if (isWildbane) {
    wsBox?.classList.add('is-hidden');
    wbBox?.classList.remove('is-hidden');
    remainBar?.classList.add('is-hidden');
    footnote?.classList.add('is-hidden');
    listEl.innerHTML = '';
    updateWildbaneTreeSummaryMobile?.();
    return;
  }

  if (isWindshear) {
    wbBox?.classList.add('is-hidden');
    wsBox?.classList.remove('is-hidden');
    remainBar?.classList.add('is-hidden');
    footnote?.classList.add('is-hidden');
    listEl.innerHTML = '';
    updateWindshearTreeSummaryMobile?.();
    return;
  }

  // 그 외 캐릭터: 트리 UI 숨기고 일반 스킬 UI 표시
  wbBox?.classList.add('is-hidden');
  wsBox?.classList.add('is-hidden');
  remainBar?.classList.remove('is-hidden');
  footnote?.classList.remove('is-hidden');

  // ✅ 402 방식: 스킬 원본은 _getSkillListRaw()에서 가져오고,
  // 캐릭 매칭은 느슨 매칭 + 노출여부(show=1)만 통과
  const raw = _getSkillListRaw();
  const rows = Array.isArray(raw) ? raw : [];

  const mine = rows.filter(r =>
    _looseOwnerMatch(_getSkillChar(r), charKey) &&
    (typeof _getSkillShow === 'function'
      ? _getSkillShow(r)
      : (String(r?.show ?? r?.['노출여부'] ?? '').trim() === '1'))
  );

  if (!mine.length) {
    listEl.innerHTML = `<div style="padding:14px 10px; color:#c7b589;">표시할 스킬이 없습니다. (skill:list / 캐릭터명 매칭 확인)</div>`;
    updateSkillRemainBar();
    return;
  }

  // ✅ 저장소(캐릭별)
  s.skillTrees = s.skillTrees || {};
  s.skillTrees[charKey] = s.skillTrees[charKey] || {};
  const store = s.skillTrees[charKey];

  // ✅ 정렬: 요구레벨 → 이름 (402 유지)
  mine.sort((a, b) => {
    const da = _getSkillReq(a) - _getSkillReq(b);
    if (da !== 0) return da;
    return _getSkillName(a).localeCompare(_getSkillName(b), 'ko');
  });

  // 렌더 (402 DOM 구조 유지)
  listEl.innerHTML = '';
  const frag = document.createDocumentFragment();
  let lastReq = null;

  for (const r of mine) {
    const skillName = _getSkillName(r);
    if (!skillName) continue;

        const normSkillName = String(skillName || '').replace(/\s+/g, '');

    // ✅ 스트라이커: 본 크러셔는 SP 직접 조작 불가 + SP 소모 0
    const isBoneCrusher = (isStriker && normSkillName === '본크러셔');

    // ✅ 여거너메카닉: G 마그네틱은 SP 직접 조작 불가 + SP 소모 0 (싱크로:코로나와 동일화)
    const isGMagnetic   = (isFMech && normSkillName === 'G마그네틱');

    const spMin = _getSkillMin(r);
    const spMax = _getSkillMax(r);
    const tpMax = _getSkillTPCap(r);

    const spCost = _getSkillSpCost(r);
    const effSpCost = (isBoneCrusher || isGMagnetic) ? 0 : spCost;

    const tpCost = _getSkillTpCost(r);
    const reqLv = _getSkillReq(r);

    // ✅ 렙제 구분선(402 유지)
    if (lastReq !== reqLv) {
      lastReq = reqLv;

      const div = document.createElement('div');
      div.className = 'skill-divider';

      const t = document.createElement('div');
      t.className = 'txt';
      t.textContent = `Lv ${reqLv}`;

      const line = document.createElement('div');
      line.className = 'line';

      div.appendChild(t);
      div.appendChild(line);
      frag.appendChild(div);
    }

    const cur = store[skillName] || {};
    const spLv = _clamp(cur.spLv ?? spMin, spMin, spMax);
    const tpLv = _clamp(cur.tpLv ?? 0, 0, tpMax);

    // ✅ cap/cost 포함 저장(403에서 필요로 하던 구조 포함)
    store[skillName] = { ...cur, spLv, tpLv, spMin, spMax, tpMax, spCost: effSpCost, tpCost };

    const row = document.createElement('div');
    row.className = 'skill-row';
    row.dataset.skill = skillName;
    row.dataset.spcost = String(effSpCost ?? 0);
    row.dataset.tpcost = String(tpCost ?? 1);

    // ✅ LEFT (402: 이미지 + 스킬명)
    const left = document.createElement('div');
    left.className = 'skill-left';

    const imgSrc = _getSkillImg(r);
    if (imgSrc) {
      const icon = document.createElement('div');
      icon.className = 'skill-icon';

      const img = document.createElement('img');
      img.alt = skillName;
      img.loading = 'lazy';
      img.decoding = 'async';
      img.src = imgSrc;

      icon.appendChild(img);
      left.appendChild(icon);
    }

    const nm = document.createElement('div');
    nm.className = 'skill-name';
    nm.textContent = skillName;
    left.appendChild(nm);

    // ✅ RIGHT (402: skill-ctrl / skill-mini)
    const right = document.createElement('div');
    right.className = 'skill-right';

    const mkCtrl = (label, valKey, acts, disabledAll = false) => {
      const line = document.createElement('div');
      line.className = 'skill-ctrl';

      const lbl = document.createElement('span');
      lbl.className = 'lbl' + (valKey === 'sp' ? ' c-sp' : (valKey === 'tp' ? ' c-tp' : ''));
      lbl.textContent = label;

      const makeBtn = (text, act, wide = false, disabled = false) => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'skill-mini' + (wide ? ' is-wide' : '');
        b.textContent = text;
        b.dataset.act = act;
        if (disabledAll || disabled) b.disabled = true;
        return b;
      };

      const v = document.createElement('span');
      v.className = 'skill-val';
      v.dataset.val = valKey;
      v.textContent = String(valKey === 'sp' ? spLv : tpLv);

      line.appendChild(lbl);

      // 좌측: MAX, +
      line.appendChild(makeBtn('MAX', acts.max, true));
      line.appendChild(makeBtn('+', acts.inc));

      line.appendChild(v);

      // 우측: -, MIN
      line.appendChild(makeBtn('-', acts.dec));
      line.appendChild(makeBtn('MIN', acts.min, true));

      return line;
    };

        // ✅ 본 크러셔 / G마그네틱은 SP 컨트롤 버튼 비활성화(“찍을 수 없음” UI 반영)
    right.appendChild(mkCtrl('SP', 'sp', {
      min: 'sp-min', dec: 'sp-dec', inc: 'sp-inc', max: 'sp-max'
    }, (isBoneCrusher || isGMagnetic)));

    right.appendChild(mkCtrl('TP', 'tp', {
      min: 'tp-min', dec: 'tp-dec', inc: 'tp-inc', max: 'tp-max'
    }, tpMax <= 0)); // tpCap=0이면 비활성

    row.appendChild(left);
    row.appendChild(right);
    frag.appendChild(row);
  }

  listEl.appendChild(frag);
  updateSkillRemainBar();

    // ✅ 격투가 스트라이커: 로킥→본크러셔 동기화 + UI 즉시 반영(403 기능 유지)
  if (isStriker) {
    const info = _syncStrikerBoneCrusherFromLowKick_mobile?.();
    if (info) _refreshStrikerBoneCrusherRowUiMobile?.(info);
  }

  // ✅ 여거너메카닉: 싱크로:코로나 → G마그네틱 동기화 + UI 즉시 반영
  if (isFMech) {
    const info2 = _syncFMechGMagneticFromSyncroCorona_mobile?.();
    if (info2) _refreshFMechGMagneticRowUiMobile?.(info2);
  }
}

    // ===== Header actions =====
function _modalRememberOpener_(m) {
  // 모달 열기 직전 포커스(트리거 버튼)를 기억해두었다가 닫을 때 돌려준다.
  const ae = document.activeElement;
  if (ae && ae !== document.body && !m.contains(ae)) m.__opener = ae;
}
function _modalSetInert_(m, on) {
  // aria-hidden만으로는 '포커스'를 막지 못하므로 inert도 같이 써서 접근성 경고를 예방한다.
  try {
    if (on) m.setAttribute('inert', '');
    else m.removeAttribute('inert');
  } catch (e) {}
  try {
    if ('inert' in m) m.inert = !!on;
  } catch (e) {}
}
function _modalBlurIfFocusInside_(m) {
  const ae = document.activeElement;
  if (ae && m.contains(ae)) {
    try { ae.blur(); } catch (e) {}
  }
}
function _modalRestoreFocus_(m) {
  const opener = m.__opener;
  m.__opener = null;
  if (opener && document.contains(opener)) {
    try { opener.focus({ preventScroll: true }); }
    catch (e) { try { opener.focus(); } catch (e2) {} }
  }
}

// ===== Header actions =====
function openModal(id) {
  const m = document.getElementById(id);
  if (!m) return;
  _modalRememberOpener_(m);
  _modalSetInert_(m, false);
  m.classList.add('show');
  m.setAttribute('aria-hidden', 'false');
}
function closeModal(id) {
  const m = document.getElementById(id);
  if (!m) return;
  _modalBlurIfFocusInside_(m);
  m.classList.remove('show');
  m.setAttribute('aria-hidden', 'true');
  _modalSetInert_(m, true);
  _modalRestoreFocus_(m);
}


    // ===== Confirm Modal (window.confirm 대체) =====
    function _findCharThumbByName(name) {
  const n = String(name || '').trim();
  if (!n) return '';

  const items = window.CORE?.lists?.['char:list'];
  if (!Array.isArray(items)) return '';

  // _getCharName/_getCharMainImage 는 이미 위에서 쓰고 있는 함수들이라 그대로 활용
  const c = items.find(x => String(_getCharName?.(x) || '').trim() === n);
  const src = c ? String(_getCharMainImage?.(c) || '').trim() : '';
  return src;
}

function makePreviewFromSlotInfo(info) {
  const meta = info?.meta || {};

  const charNameRaw = String(meta.charName || meta.char || info?.label || '').trim();
  const userNameRaw = String(meta.userName || meta.user || meta.nick || '').trim();

  let thumb = String(meta.thumb || meta.thumbnail || '').trim();

  // ✅ (NEW) 슬롯 썸네일이 비어있으면 → 캐릭 아이콘(캐릭 이미지) → 없으면 placeholder
  if (!thumb) {
    thumb = _findCharThumbByName(charNameRaw) || PLACEHOLDER_IMG;
  }

  return {
    thumb,
    charName: charNameRaw || '빈 슬롯',
    userName: userNameRaw,
  };
}

function makePreviewFromCurrentState() {
  const c = window.state?.currentCharacter || null;

  // 캐릭명
  let charName = String(c?.name || '').trim();
  if (!charName) charName = '캐릭터 미선택';

  // 썸네일: pickedCharImg → currentCharacter 이미지 → char:list 검색 → placeholder
  const imgEl = document.getElementById('pickedCharImg');
  let thumb = String(imgEl?.getAttribute('src') || imgEl?.src || '').trim();

  if (!thumb) {
    thumb = String(_getCharMainImage?.(c) || '').trim()
      || _findCharThumbByName(charName)
      || PLACEHOLDER_IMG;
  }

  // ✅ 이메일/유저명은 미리보기에서 완전히 제거
  return { thumb, charName };
}

    let _confirmBusy = false;

    function openConfirmModal(opts = {}) {
  const {
    title = '확인',
    message = '',
    okText = '확인',
    cancelText = '취소',
    preview = null, // ✅ { thumb, charName }
    // ✅ (NEW) 저장 시 프리셋 이름 입력
    presetNameInput = false,
    presetNameDefault = '',
    presetNamePlaceholder = '프리셋 이름을 입력하세요',
    presetNameMaxLen = 30,
  } = opts;

  const m = document.getElementById('confirmModal');
  if (!m) return Promise.resolve(window.confirm(message || title)); // 안전장치

  // 중복 호출 방지(연타 방어)
  if (_confirmBusy) return Promise.resolve(false);
  _confirmBusy = true;

  const titleEl = m.querySelector('#confirmTitle');
  const msgEl = m.querySelector('#confirmMsg');

  // "취소 버튼 텍스트"는 confirm-cancel-btn에만 넣는다
  const okBtn = m.querySelector('.confirm-ok-btn') || m.querySelector('[data-confirm-ok]');
  const cancelBtn = m.querySelector('.confirm-cancel-btn');

  // preview elements
  const pvWrap = m.querySelector('#confirmPreview');
  const pvImg = m.querySelector('#confirmThumb');
  const pvChar = m.querySelector('#confirmCharName');

  // ✅ (NEW) preset name input elements
  const nameRow = m.querySelector('#confirmPresetNameRow');
  const nameInput = m.querySelector('#confirmPresetName');

  if (titleEl) titleEl.textContent = title;
  if (msgEl) msgEl.textContent = message;
  if (okBtn) okBtn.textContent = okText;
  if (cancelBtn) cancelBtn.textContent = cancelText;

  // ✅ 프리셋 이름 입력칸 제어
  if (nameRow && nameInput) {
    if (presetNameInput) {
      nameRow.style.display = 'block';
      nameInput.maxLength = Number(presetNameMaxLen) || 30;
      nameInput.placeholder = presetNamePlaceholder || '프리셋 이름을 입력하세요';
      nameInput.value = String(presetNameDefault || '');
      setTimeout(() => {
        try { nameInput.focus(); nameInput.select(); } catch (e) {}
      }, 0);
    } else {
      nameRow.style.display = 'none';
      nameInput.value = '';
    }
  }

  // preview 채우기/숨기기
  const hasPreview = !!(preview && (preview.thumb || preview.charName));
  if (pvWrap) pvWrap.style.display = hasPreview ? 'flex' : 'none';

  if (hasPreview) {
    const thumb = String(preview.thumb || '').trim();
    const charName = String(preview.charName || '').trim();

    if (pvImg) {
      if (thumb) pvImg.src = thumb;
      else pvImg.removeAttribute('src');
    }
    if (pvChar) pvChar.textContent = charName;
  } else {
    if (pvImg) pvImg.removeAttribute('src');
    if (pvChar) pvChar.textContent = '';
  }

  openModal('confirmModal');

  return new Promise((resolve) => {
    const cancelEls = Array.from(m.querySelectorAll('[data-confirm-cancel]'));

    const onEnter = (e) => {
      if (!presetNameInput) return;
      if (e.key === 'Enter') {
        e.preventDefault();
        okBtn?.click();
      }
    };

    const cleanup = (val) => {
      _confirmBusy = false;
      closeModal('confirmModal');

      okBtn?.removeEventListener('click', onOk);
      cancelEls.forEach(el => el.removeEventListener('click', onCancel));
      document.removeEventListener('keydown', onKey);
      nameInput?.removeEventListener('keydown', onEnter);

      resolve(val);
    };

    const onOk = () => cleanup(true);
    const onCancel = () => cleanup(false);
    const onKey = (e) => {
      if (e.key === 'Escape') cleanup(false);
    };

    okBtn?.addEventListener('click', onOk);
    cancelEls.forEach(el => el.addEventListener('click', onCancel));
    document.addEventListener('keydown', onKey);
    nameInput?.addEventListener('keydown', onEnter);
  });
}

        // ===== 문의하기 / Q&A =====
    function openContactModal() {
      openModal('contactModal');
      const ta = document.getElementById('contactTalk');
      if (ta) {
        setTimeout(() => ta.focus(), 0);
      }
    }
    function closeContactModal() {
      closeModal('contactModal');
    }

    function getFaqItems() {
      const list = (window.CORE && CORE.lists && CORE.lists['faq:list']) || [];
      return Array.isArray(list) ? list : [];
    }

    function openFaqModal() {
      const listEl = document.getElementById('faqList');
      const items = getFaqItems();

      if (listEl) {
        listEl.innerHTML = '';

        if (!items.length) {
          const empty = document.createElement('div');
          empty.style.opacity = '0.8';
          empty.textContent = '등록된 Q&A가 없습니다.';
          listEl.appendChild(empty);
        } else {
          items.forEach((it) => {
            const q = String(it?.q || it?.question || '').trim();
            const a = String(it?.a || it?.answer || '').trim();
            if (!q) return;

            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'faq-q-btn';
            btn.textContent = q;
            btn.addEventListener('click', () => openFaqAnswerModal(q, a));
            listEl.appendChild(btn);
          });
        }
      }

      openModal('faqModal');
    }

    function openFaqAnswerModal(q, a) {
      const qEl = document.getElementById('faqAnswerTitle');
      const aEl = document.getElementById('faqAnswerText');
      if (qEl) qEl.textContent = q || '';

      function renderFaqAnswer(container, answerText) {
        if (!container) return;
        container.innerHTML = '';

        const lines = String(answerText || '').split(/\r?\n/);

        const isImgToken = (s) => {
          const t = String(s || '').trim();
          return (
            /^https?:\/\/\S+\.(png|jpg|jpeg|gif|webp)(\?\S*)?$/i.test(t) ||
            /^\S+\.(png|jpg|jpeg|gif|webp)(\?\S*)?$/i.test(t)
          );
        };

        const makeImg = (src) => {
          const img = document.createElement('img');
          img.className = 'faq-img';
          img.src = src;
          img.alt = 'FAQ image';
          img.loading = 'lazy';
          return img;
        };

        for (const lineRaw of lines) {
          const line = lineRaw.trim();

          if (!line) {
            container.appendChild(document.createElement('br'));
            continue;
          }

          // ✅ 한 줄에 | 로 여러 이미지면 "자동 그리드"로 렌더
          const parts = line.split('|').map(s => s.trim()).filter(Boolean);
          const allImgs = (parts.length >= 2) && parts.every(isImgToken);

          if (allImgs) {
            const grid = document.createElement('div');
            grid.className = 'faq-img-grid';
            for (const p of parts) grid.appendChild(makeImg(p));
            container.appendChild(grid);
            continue;
          }

          // ✅ 한 줄이 이미지 1개면 1열(기존 방식)
          if (isImgToken(line)) {
            container.appendChild(makeImg(line));
            continue;
          }

          // 텍스트
          const div = document.createElement('div');
          div.textContent = lineRaw;
          container.appendChild(div);
        }
      }

      if (aEl) renderFaqAnswer(aEl, a || '');
      openModal('faqAnswerModal');
    }

    document.getElementById('btnContactAdmin')?.addEventListener('click', openContactModal);
    document.getElementById('btnFaq')?.addEventListener('click', async () => {
      try {
        await initMobileAllLightListsOnce();
      } catch (e) {
        // 목록 불러오기에 실패해도 모달은 열어줌(빈 목록 표시)
      }
      openFaqModal();
    });

    document.querySelectorAll('[data-contact-close]').forEach(el => {
      el.addEventListener('click', () => closeModal('contactModal'));
    });
    document.getElementById('contactModal')?.addEventListener('click', (e) => {
      if (e.target?.classList?.contains('backdrop')) closeModal('contactModal');
    });

    document.querySelectorAll('[data-faq-close]').forEach(el => {
      el.addEventListener('click', () => closeModal('faqModal'));
    });
    document.getElementById('faqModal')?.addEventListener('click', (e) => {
      if (e.target?.classList?.contains('backdrop')) closeModal('faqModal');
    });

    document.querySelectorAll('[data-faqans-close]').forEach(el => {
      el.addEventListener('click', () => closeModal('faqAnswerModal'));
    });
    document.getElementById('faqAnswerModal')?.addEventListener('click', (e) => {
      if (e.target?.classList?.contains('backdrop')) closeModal('faqAnswerModal');
    });


    // ===== Equip Picker =====
    const EQUIP_SLOT_LABELS = {
      headshoulder: '머리어깨',
      top: '상의',
      bottom: '하의',
      belt: '허리',
      shoes: '신발',
      bracelet: '팔찌',
      necklace: '목걸이',
      ring: '반지',
      sub: '보조장비',
      magestone: '마법석',
      earring: '귀걸이',
      weapon: '무기',
        // ✅ 오칭크아
  title: '칭호',
  aura: '오라',
  creature: '크리쳐',
  artifact: '아티팩트',
    };

    function _equipListKey(slot) {
      return `${slot}:list`;
    }
    function _baseJG_mobile(s) {
      s = String(s || '').trim();
      // 괄호 안 옵션 제거(예: 거너(남) -> 거너)
      return s.replace(/\(.*?\)/g, '').trim();
    }

    function _jgMatches_mobile(a, b) {
      a = String(a || '').trim();
      b = String(b || '').trim();
      if (!a || !b) return true;

      const aa = _baseJG_mobile(a);
      const bb = _baseJG_mobile(b);

      return (
        a === b ||
        aa === bb ||
        a.includes(b) || b.includes(a) ||
        aa.includes(bb) || bb.includes(aa)
      );
    }

    function _getEquipJobGroup_mobile(it) {
      // 데이터 키가 뭐든 최대한 잡아내기
      return String(_pick(it, ['jobGroup', '직업군', 'group', 'job_group', '직업군(필터)']) || '').trim();
    }

    function _getWeaponType_mobile(it) {
      // 무기 "종류" 컬럼(예: 소검/대검/권총 등) 최대한 잡아내기
      return String(_pick(it, ['type', '종류', 'weaponType', '무기종류', 'kind']) || '').trim();
    }

    function _ensureWeaponTypeBar_mobile() {
      let bar = document.getElementById('weaponTypeBar');
      if (bar) return bar;

      const dialog = document.querySelector('#equipModal .dialog');
      const catalog = document.getElementById('equipCatalog');
      if (!dialog || !catalog) return null;

      bar = document.createElement('div');
      bar.id = 'weaponTypeBar';
      bar.className = 'weapon-typebar';

      // equipCatalog 바로 위(=모달 안, 목록 위)에 끼워넣기
      dialog.insertBefore(bar, catalog);
      return bar;
    }

    function _hideWeaponTypeBar_mobile() {
      const bar = document.getElementById('weaponTypeBar');
      if (!bar) return;
      bar.style.display = 'none';
      bar.innerHTML = '';
    }

    function renderWeaponTypeBar_mobile(types, activeType, onPick) {
      const bar = _ensureWeaponTypeBar_mobile();
      if (!bar) return;

      if (!Array.isArray(types) || types.length === 0) {
        _hideWeaponTypeBar_mobile();
        return;
      }

      bar.style.display = 'flex';
      bar.innerHTML = '';

      // ✅ '전체' 없음: types만 렌더
      types.forEach(t => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'weapon-typebtn';
        b.textContent = t;
        if (t === activeType) b.classList.add('active');
        b.addEventListener('click', () => onPick(t));
        bar.appendChild(b);
      });
    }

    function closeEquipModal() {
      _hideWeaponTypeBar_mobile();

      closeEquipEnhModal();
      closeEquipSealUModal();
      closeEquipSealNModal();
      closeEquipEnchantModal();
      closeEquipEmblemModal();

      const m = document.getElementById('equipModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }

    function openEquipModal() {
      const m = document.getElementById('equipModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }

    // 닫기(backdrop + 닫기 버튼)
    document.querySelectorAll('[data-equip-close]').forEach(el => {
      el.addEventListener('click', closeEquipModal);
    });
    document.getElementById('equipModal')?.addEventListener('click', (e) => {
      if (e.target?.classList?.contains('backdrop')) closeEquipModal();
    });

    function renderMobileEquipList(slot, items) {
      const titleEl = document.getElementById('equipModalTitle');
      if (titleEl) titleEl.textContent = `${EQUIP_SLOT_LABELS[slot] || slot} 선택`;

      const catalog = document.getElementById('equipCatalog');
      if (!catalog) return;
      catalog.innerHTML = '';

      const wrap = document.createElement('div');
      wrap.className = 'meq-wrap';

      for (const it of items) {
        const name = String(it?.name || '').trim();
        if (!name) continue;

        const img = _normImg(it?.image || '');

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'meq-row';
        btn.innerHTML = `
      <img class="meq-thumb" src="${img}" alt="">
      <div class="meq-name">${name}</div>
    `;

        btn.addEventListener('click', () => {
  window.state = window.state || {};
  window.state.equips = window.state.equips || {};
  window.state.selections = window.state.selections || {};

  // ✅ 1) CORE DB로 가능한 "풀 아이템"으로 업그레이드
  const fullIt = _upgradeEquipByCore_(slot, it) || it;

  // ✅ 2) equips는 풀 객체로 저장
  window.state.equips[slot] = fullIt;

  // ✅ 3) selections도 PC처럼 "풀 메타"로 저장
  window.state.selections[slot] = _buildSelectionFromEquip_(fullIt);

  // ✅ UI 반영도 풀 객체 기준으로
  applyPickedEquipUI(slot, fullIt);
  closeEquipModal();
});

        wrap.appendChild(btn);
      }

      catalog.appendChild(wrap);
    }

    /* =========================
   ✅ 프리셋 저장 호환: selections에 "풀 메타" 저장
========================= */

// code 키가 파일/버전마다 달라서 최대한 넓게 흡수
function _getEquipCodeAny_(it) {
  return String(
    it?.code ??
    it?.Code ??
    it?.itemCode ??
    it?.key ??
    it?.id ??
    it?.['코드'] ??
    ''
  ).trim();
}

// name에서 괄호(세트명 보조표기 등) 제거
function _stripParenName_(name) {
  return String(name ?? '').replace(/\s*\([^)]*\)\s*$/, '').trim();
}

// PC 쪽 state.selections 형태(확장 필드 포함)로 맞춰 저장
function _buildSelectionFromEquip_(it) {
  const rawName = String(it?.name ?? it?.['이름'] ?? '').trim();
  const name = _stripParenName_(rawName);

  const code = _getEquipCodeAny_(it);
  const img = _normImg(it?.img || it?.image || it?.thumb || it?.icon || it?.['이미지'] || '');

  const desc = String(it?.desc ?? it?.['설명'] ?? it?.description ?? '').trim();
  const rarity = String(it?.rarity ?? it?.['레어리티'] ?? it?.['희귀도'] ?? it?.['등급'] ?? '').trim();
  const type = String(it?.type ?? it?.['타입'] ?? it?.['종류'] ?? '').trim();

  let level = it?.level ?? it?.['레벨'] ?? it?.['요구레벨'];
  level = (level === '' || level == null) ? null : (Number.isFinite(+level) ? +level : null);

  // "레거시: XXX" 같은 경우 prefixLabel만 따로 들고 있으면 PC와 콘솔 출력이 더 유사해짐
  let prefixLabel = String(it?.prefixLabel ?? it?.prefix ?? '').trim();
  if (!prefixLabel && name.includes(':')) {
    prefixLabel = name.split(':')[0].trim();
  }

  // code는 PC쪽이 null을 더 선호(빈문자열이면 매칭 실패 잦음)
  return {
    name,
    code: code ? code : null,
    img: img || null,
    desc: desc || undefined,
    rarity: rarity || undefined,
    type: type || undefined,
    level: level,
    prefixLabel: prefixLabel || undefined,
  };
}

// code로 CORE DB에서 "진짜 아이템 객체" 찾아 업그레이드
function _upgradeEquipByCore_(slot, it) {
  try {
    const code = _getEquipCodeAny_(it);
    if (!code) return it;

    if (typeof _equipListKey !== 'function') return it;
    const listKey = _equipListKey(slot);
    const list = CORE?.lists?.[listKey];
    if (!Array.isArray(list)) return it;

    const found = list.find(x => String(x?.code ?? x?.Code ?? x?.itemCode ?? x?.key ?? x?.id ?? x?.['코드'] ?? '') === code);
    return found || it;
  } catch (e) {
    return it;
  }
}

    function applyPickedEquipUI(slot, it) {
      // ✅ 보험: 불러온 it에 이미지가 없으면 code로 DB에서 다시 찾아오기
  try {
    const code = it?.code ?? it?.Code ?? it?.itemCode ?? it?.key;
    const hasImg = !!(it?.image || it?.img || it?.thumb || it?.icon || it?.['이미지']);
    if (code && !hasImg && typeof _equipListKey === 'function') {
      const listKey = _equipListKey(slot);
      const list = CORE?.lists?.[listKey];
      if (Array.isArray(list)) {
        const found = list.find(x => String(x?.code ?? x?.Code ?? x?.itemCode ?? x?.key) === String(code));
        if (found) {
  it = found; // 👈 “진짜 아이템 객체”로 교체

  // ✅ 여기서 끝내면 UI만 바뀌고 저장데이터는 안 바뀜 → state에도 반영
  try {
    window.state = window.state || {};
    window.state.equips = window.state.equips || {};
    window.state.selections = window.state.selections || {};
    window.state.equips[slot] = found;
    window.state.selections[slot] = _buildSelectionFromEquip_(found);
  } catch (e) {}
}

      }
    }
  } catch (e) {}
  const row = document.querySelector(
    `#pageEquip .equip-row[data-slot="${slot}"], #pageEquip .oca-item[data-slot="${slot}"]`
  );
  if (!row) return;

  // 왼쪽 이미지
  const imgBox = row.querySelector('.equip-img');
  if (imgBox) {
    const src = _normImg(it?.image || '');
    imgBox.style.backgroundImage = src ? `url("${src}")` : '';
    imgBox.style.backgroundSize = 'cover';
    imgBox.style.backgroundPosition = 'center';
    imgBox.style.backgroundRepeat = 'no-repeat';
  }

  // 이미지 아래 “장비이름”
  const nameEl = row.querySelector('.equip-name');
  if (nameEl) {
    nameEl.textContent = String(it?.name || EQUIP_SLOT_LABELS[slot] || '').trim();
  }

  // (oca-item에는 아래 요소가 없으니 null이면 그냥 스킵됨)
  const uniqueEl = row.querySelector('.equip-unique');
  if (uniqueEl) uniqueEl.textContent = String(it?.prefix || '').trim() || '—';

  const normalEl = row.querySelector('.equip-normal');
  if (normalEl) normalEl.textContent = String(it?.desc || '').trim() || '—';

  _syncEnhLabelFromState_mobile(slot);
  _syncSealLabelFromState_mobile(slot);
  _syncGrindLabelFromState_mobile(slot);
}

    // ===== Enhancement Picker (Mobile) =====
    function _enhTypeForSlot_mobile(slot) {
      if (slot === 'weapon') return '무기강화';
      if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slot)) return '방어구강화';
      if (['bracelet', 'necklace', 'ring'].includes(slot)) return '악세강화';
      if (['sub', 'support', 'earring', 'magestone'].includes(slot)) return '보장강화';
      return null;
    }

    function _getLightEnhList_mobile() {
      const lists = window.CORE?.lists || {};
      const list = lists['enh:list'] || lists['enhList']; // 백엔드 키가 enh:list면 이걸로 잡힘
      return Array.isArray(list) ? list : [];
    }

    function _parseEnhLevel_mobile(name) {
      const s = String(name || '');
      let m = s.match(/\+(\d{1,2})/); if (m) return parseInt(m[1], 10);
      m = s.match(/(\d{1,2})\s*강/); if (m) return parseInt(m[1], 10);
      m = s.match(/(\d{1,2})/); if (m) return parseInt(m[1], 10);
      return 0;
    }

    function _normEnhItem_mobile(row) {
      const raw = row?._raw || row || {};

      // ✅ 빈 문자열('')도 fallback 되도록 || 체인 사용
      const name =
        String(row?.name || '').trim() ||
        String(raw['이름'] || raw.name || raw.title || '').trim();

      const type =
        String(row?.type || '').trim() ||
        String(raw['종류'] || raw.type || raw.category || '').trim();

      const lv =
        Number.isFinite(Number(row?.level)) ? Number(row.level) :
          Number.isFinite(Number(raw['강화'])) ? Number(raw['강화']) :
            _parseEnhLevel_mobile(name);

      return { name, type, level: lv, _raw: raw };
    }


    function _syncEnhLabelFromState_mobile(slot) {
      const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slot}"]`);
      if (!row) return;
      const el = row.querySelector('.equip-enh-val'); // 모바일 UI에 존재 
      if (!el) return;

      const info = window.state?.enh?.[slot];
      if (info?.name) el.textContent = String(info.name).trim();
    }

    function openEquipEnhModal() {
      const m = document.getElementById('equipEnhModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }

    function closeEquipEnhModal() {
      const m = document.getElementById('equipEnhModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }
    function openEquipEmblemModal() {
      const m = document.getElementById('equipEmblemModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function closeEquipEmblemModal() {
      const m = document.getElementById('equipEmblemModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }

    (function bindEquipEmblemModalCloseOnce() {
      const m = document.getElementById('equipEmblemModal');
      if (!m || m.__bound) return;
      m.__bound = 1;

      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipEmblemModal();
        if (e.target?.closest?.('[data-equip-emblem-close]')) return closeEquipEmblemModal();
      });
    })();

    // 닫기(backdrop + X)
    (function bindEquipEnhModalCloseOnce() {
      const m = document.getElementById('equipEnhModal');
      if (!m || m.__bound) return;
      m.__bound = 1;

      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipEnhModal();
        if (e.target?.closest?.('[data-equip-enh-close]')) return closeEquipEnhModal();
      });
    })();
    function _grindTypeForSlot_mobile(slot) {
      return (slot === 'weapon') ? '무기연마' : '보조장비연마';
    }

    function _getGrindLevelFromName(name) {
      const m = String(name || '').match(/^(\d+)연마$/);
      return m ? Number(m[1]) : 0;
    }

    function _syncGrindLabelFromState_mobile(slot) {
      const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slot}"]`);
      if (!row) return;

      const el = row.querySelector('.equip-grind');
      if (!el) return;

      const slotKey = (slot === 'weapon') ? 'weapon' : (slot === 'sub') ? 'sub' : '';
      const name = slotKey && window.state?.refines?.[slotKey]?.name ? String(window.state.refines[slotKey].name) : '';
      const lv = _getGrindLevelFromName(name);

      el.textContent = (lv > 0) ? `연마 ${lv}` : '연마 -';
    }

    function syncGrindTopbarLabel_mobile(slot) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;

      const btn = bar.querySelector('.equip-topbtn[data-eqtab="grind"]');
      if (!btn) return;

      const slotKey = (slot === 'weapon') ? 'weapon' : (slot === 'sub') ? 'sub' : '';
      const name = slotKey && window.state?.refines?.[slotKey]?.name ? String(window.state.refines[slotKey].name) : '';
      const lv = _getGrindLevelFromName(name);

      btn.textContent = (lv > 0) ? `연마 ${lv}` : '연마';
    }

    function renderMobileGrindList(slot) {
      bindEquipGrindModalCloseOnce();

      const title = document.getElementById('equipGrindModalTitle');
      if (title) {
        const slotName = (slot === 'weapon') ? '무기' : '보조장비';
        title.textContent = `${slotName} 연마 선택`;
      }

      const listEl = document.getElementById('equipGrindList');
      if (!listEl) return;

      const labels = ['연마없음', '1연마', '2연마', '3연마', '4연마', '5연마', '6연마', '7연마', '8연마', '9연마'];
      const slotKey = (slot === 'weapon') ? 'weapon' : 'sub';

      const curName = window.state?.refines?.[slotKey]?.name ? String(window.state.refines[slotKey].name) : '연마없음';

      listEl.innerHTML = '';
      labels.forEach(name => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'enh-option';
        b.textContent = (name === '연마없음') ? '없음' : name;

        if (String(name) === curName) b.classList.add('active');

        b.addEventListener('click', () => {
          window.state = window.state || {};
          window.state.refines = window.state.refines || {};

          const refineType = _grindTypeForSlot_mobile(slot);
          const level = _getGrindLevelFromName(name);

          window.state.refines[slotKey] = { name, refineType, level };

          _syncGrindLabelFromState_mobile(slot);
          syncGrindTopbarLabel_mobile(slot);

          showEquipGrindModal(false);
          toast(level > 0 ? `연마 ${level} 적용` : '연마 해제');
        });

        listEl.appendChild(b);
      });

      showEquipGrindModal(true);
    }

    function openMobileGrindPicker() {
      const slot = window.state?.ui?.equipPickerSlot;
      if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

      if (!(slot === 'weapon' || slot === 'sub')) {
        toast('이 슬롯은 연마를 지원하지 않습니다.');
        return;
      }

      renderMobileGrindList(slot);
    }


    function showEquipGrindModal(on) {
      const m = document.getElementById('equipGrindModal');
      if (!m) return;
      if (on) {
        m.classList.add('show');
        m.setAttribute('aria-hidden', 'false');
      } else {
        m.classList.remove('show');
        m.setAttribute('aria-hidden', 'true');
      }
    }

    function bindEquipGrindModalCloseOnce() {
      const m = document.getElementById('equipGrindModal');
      if (!m || m.dataset.bound) return;
      m.dataset.bound = '1';

      m.addEventListener('click', (e) => {
        if (e.target?.dataset?.equipGrindClose != null) {
          showEquipGrindModal(false);
        }
      });
    }

    // =========================
    // ✅ 마법봉인(고유/일반) 2중모달
    // =========================

    function openEquipSealUModal() {
      const m = document.getElementById('equipSealUModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function closeEquipSealUModal() {
      const m = document.getElementById('equipSealUModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }
    (function bindEquipSealUModalCloseOnce() {
      const m = document.getElementById('equipSealUModal');
      if (!m || m.__bound) return;
      m.__bound = 1;
      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipSealUModal();
        if (e.target?.closest?.('[data-equip-seal-u-close]')) return closeEquipSealUModal();
      });
    })();

    function openEquipSealNModal() {
      const m = document.getElementById('equipSealNModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function closeEquipSealNModal() {
      const m = document.getElementById('equipSealNModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }
    function openEquipEnchantModal() {
      const m = document.getElementById('equipEnchantModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function closeEquipEnchantModal() {
      const m = document.getElementById('equipEnchantModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }

    (function bindEquipSealNModalCloseOnce() {
      const m = document.getElementById('equipSealNModal');
      if (!m || m.__bound) return;
      m.__bound = 1;
      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipSealNModal();
        if (e.target?.closest?.('[data-equip-seal-n-close]')) return closeEquipSealNModal();
      });
    })();
    (function bindEquipEnchantModalCloseOnce() {
      const m = document.getElementById('equipEnchantModal');
      if (!m || m.__bound) return;
      m.__bound = 1;

      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipEnchantModal();
        if (e.target?.closest?.('[data-equip-enchant-close]')) return closeEquipEnchantModal();
      });
    })();
    function _sealTypeKeysForSlot_mobile(slot) {
      if (slot === 'weapon') return { u: '무기고유', g: '무기일반' };

      // ✅ 모바일 방어구 슬롯키: headshoulder / top / bottom / belt / shoes
      if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slot)) return { u: '방어고유', g: '방어일반' };

      // ✅ 모바일 악세 슬롯키: bracelet / necklace / ring
      if (['bracelet', 'necklace', 'ring'].includes(slot)) return { u: '악세고유', g: '악세일반' };

      // ✅ 모바일 특수(보조/마법석/귀걸이) = PC 표준: 보장고유/보장일반
      if (['sub', 'magestone', 'earring'].includes(slot)) return { u: '보장고유', g: '보장일반' };

      return null;
    }

    function normalizeSealType_mobile(s) {
      const raw = String(s ?? '');
      const t = raw.replace(/\s+|-/g, '').replace(/[()]/g, '').trim();

      const has = (w) => t.includes(w);
      const isDef = /방어구|방어/.test(t);
      const isAks = /악세|악세서리|액세/.test(t);
      const isBoj = /보장|보조장비|보조/.test(t);

      const isUni = /고유/.test(t) || /고유옵션/.test(t);
      const isGen = /일반/.test(t) || /일반옵션/.test(t);

      if (has('무기') && isUni) return '무기고유';
      if (has('무기') && isGen) return '무기일반';
      if (isDef && isUni) return '방어고유';
      if (isDef && isGen) return '방어일반';
      if (isAks && isUni) return '악세고유';
      if (isAks && isGen) return '악세일반';
      if (isBoj && isUni) return '보장고유';
      if (isBoj && isGen) return '보장일반';
      return raw.trim();
    }


    function _syncSealLabelFromState_mobile(slot) {
      const row = document.querySelector(`.equip-row[data-slot="${slot}"]`);
      if (!row) return;

      const uEl = row.querySelector('.equip-unique');
      const nEl = row.querySelector('.equip-normal');

      const uName = window.state?.seals?.[slot]?.unique?.name
        ? String(window.state.seals[slot].unique.name).trim()
        : '';
      const nName = window.state?.seals?.[slot]?.general1?.name
        ? String(window.state.seals[slot].general1.name).trim()
        : '';

      // ✅ 라벨 대신 "선택값" 자체를 표시
      if (uEl) uEl.textContent = uName ? uName : '고유옵션';
      if (nEl) nEl.textContent = nName ? nName : '일반옵션';
    }

    function _syncEnchantLabelFromState_mobile(slot) {
      const row = document.querySelector(`.equip-row[data-slot="${slot}"]`);
      if (!row) return;

      const body = row.querySelector('.equip-enchant .equip-col-body');
      if (!body) return;

      const name = window.state?.enchants?.[slot]?.name
        ? String(window.state.enchants[slot].name).trim()
        : '';

      body.textContent = name ? name : '-';
    }


    function renderMobileSealUniqueList(slot) {
      const keys = _sealTypeKeysForSlot_mobile(slot);
      const type = keys?.u;
      if (!type) { toast('이 슬롯은 고유옵션 타입이 없습니다.'); return; }

      const list = _getLightEnhList_mobile()
        .map(_normEnhItem_mobile)
        .filter(x => x.name && normalizeSealType_mobile(x.type) === type);

      if (!list.length) {
        toast(`고유옵션 목록을 불러오지 못했습니다. (${type})`);
        return;
      }


      const titleEl = document.getElementById('equipSealUModalTitle');
      if (titleEl) titleEl.textContent = `${EQUIP_SLOT_LABELS[slot] || slot} 고유옵션 선택`;

      const listEl = document.getElementById('equipSealUList');
      if (!listEl) return;
      listEl.innerHTML = '';

      const curName = window.state?.seals?.[slot]?.unique?.name ? String(window.state.seals[slot].unique.name).trim() : '';

      for (const it of list) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'enh-option' + (curName && curName === it.name ? ' active' : '');
        b.textContent = it.name;

        b.onclick = () => {
          window.state = window.state || {};
          window.state.seals = window.state.seals || {};
          window.state.seals[slot] = window.state.seals[slot] || {};
          window.state.seals[slot].unique = { name: it.name, type: it.type };

          _syncSealLabelFromState_mobile(slot);
          syncSealTopbarLabel_mobile(slot);
          closeEquipSealUModal(); // ✅ 장비 모달은 유지
        };

        listEl.appendChild(b);
      }

      window.state.ui = window.state.ui || {};
      window.state.ui.sealTargetSlot = slot;

      openEquipSealUModal();
    }

    function renderMobileSealNormalList(slot) {
      const keys = _sealTypeKeysForSlot_mobile(slot);
      const type = keys?.g;
      if (!type) { toast('이 슬롯은 일반옵션 타입이 없습니다.'); return; }

      const list = _getLightEnhList_mobile()
        .map(_normEnhItem_mobile)
        .filter(x => x.name && x.type === type);

      if (!list.length) {
        toast(`일반옵션 목록을 불러오지 못했습니다. (${type})`);
        return;
      }

      const titleEl = document.getElementById('equipSealNModalTitle');
      if (titleEl) titleEl.textContent = `${EQUIP_SLOT_LABELS[slot] || slot} 일반옵션 선택`;

      const listEl = document.getElementById('equipSealNList');
      if (!listEl) return;
      listEl.innerHTML = '';

      const curName = window.state?.seals?.[slot]?.general1?.name ? String(window.state.seals[slot].general1.name).trim() : '';

      for (const it of list) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'enh-option' + (curName && curName === it.name ? ' active' : '');
        b.textContent = it.name;

        b.onclick = () => {
          window.state = window.state || {};
          window.state.seals = window.state.seals || {};
          window.state.seals[slot] = window.state.seals[slot] || {};
          window.state.seals[slot].general1 = { name: it.name, type: it.type };

          _syncSealLabelFromState_mobile(slot);
          syncSealTopbarLabel_mobile(slot);
          closeEquipSealNModal(); // ✅ 장비 모달은 유지
        };

        listEl.appendChild(b);
      }

      window.state.ui = window.state.ui || {};
      window.state.ui.sealTargetSlot = slot;

      openEquipSealNModal();
    }


    function renderMobileEnhList(slot) {
      const type = _enhTypeForSlot_mobile(slot);
      if (!type) {
        toast('이 슬롯은 강화 타입이 없습니다.');
        return;
      }

      const list = _getLightEnhList_mobile()
        .map(_normEnhItem_mobile)
        .filter(x => x.name && x.type === type);

      if (!list.length) {
        toast(`강화 목록을 불러오지 못했습니다. (${type})`);
        return;
      }

      // 레벨 오름차순 정렬(보기 편하게)
      list.sort((a, b) => (a.level || 0) - (b.level || 0) || a.name.localeCompare(b.name, 'ko'));

      // ✅ (방법B) 강화 모달에 렌더
      const titleEl = document.getElementById('equipEnhModalTitle');
      if (titleEl) titleEl.textContent = `${EQUIP_SLOT_LABELS[slot] || slot} 강화 선택`;

      const listEl = document.getElementById('equipEnhList');
      if (!listEl) return;
      listEl.innerHTML = '';

      const curName = window.state?.enh?.[slot]?.name ? String(window.state.enh[slot].name).trim() : '';

      for (const it of list) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'enh-option' + (curName && curName === it.name ? ' active' : '');
        b.textContent = it.name;

        b.onclick = () => {
          window.state = window.state || {};
          window.state.enh = window.state.enh || {};
          // ✅ PC버전/백코드가 기대하는 형태로 저장(name/type/level)
          const lv = Number.isFinite(Number(it.level)) ? Number(it.level) : _parseEnhLevel_mobile(it.name);
          window.state.enh[slot] = { name: it.name, type: it.type, level: lv };

          _syncEnhLabelFromState_mobile(slot);
          // ✅ 추가: 상단 '강화' 버튼 텍스트도 즉시 +수치로 변경
          syncEnhTopbarLabel_mobile(slot);
          closeEquipEnhModal(); // ✅ 장비 모달은 유지하고, 강화 모달만 닫기
        };

        listEl.appendChild(b);
      }

      // UI 상태 기록(선택적)
      window.state.ui = window.state.ui || {};
      window.state.ui.enhTargetSlot = slot;

      openEquipEnhModal();
    }

    function _enchantTypeForSlot_mobile(slot) {
      switch (slot) {
        case 'weapon': return '무기마부';
        case 'headshoulder': return '머리어깨마부';
        case 'top': return '상의마부';
        case 'bottom': return '하의마부';
        case 'belt': return '허리마부';
        case 'shoes': return '신발마부';

        case 'bracelet': return '팔찌마부';
        case 'necklace': return '목걸이마부';
        case 'ring': return '반지마부';

        case 'sub': return '보장마부';
        case 'magestone': return '마법석마부';
        case 'earring': return '귀걸이마부';

    case 'title': return '칭호마부';
        default: return '';
      }
    }

    function normalizeEnchantType_mobile(t) {
      const raw = String(t ?? '');
      // 공백/하이픈/괄호 제거로 최대한 표준화
      const s = raw.replace(/\s+|-/g, '').replace(/[()]/g, '').trim();
      if (!s) return '';

      // ✅ 핵심: "마부/마법부여" 계열만 마부로 인정 (무기강화/무기마봉/연마 등은 여기서 컷)
      if (!/(마부|마법부여)/.test(s)) return '';

      // 이미 표준키(…마부)면 그대로 + 일부 동의어만 정리
      if (s.endsWith('마부')) {
        const alias = {
          '머리/어깨마부': '머리어깨마부',
          '보조장비마부': '보장마부',
        };
        return alias[s] || s;
      }

      // "무기마법부여" 같은 형태면 표준키로 변환
      if (/칭호/.test(s)) return '칭호마부';
      if (/무기/.test(s)) return '무기마부';
      if (/머리어깨|머리\/어깨|어깨/.test(s)) return '머리어깨마부';
      if (/상의/.test(s)) return '상의마부';
      if (/하의/.test(s)) return '하의마부';
      if (/허리|벨트/.test(s)) return '허리마부';
      if (/신발/.test(s)) return '신발마부';
      if (/팔찌/.test(s)) return '팔찌마부';
      if (/목걸이/.test(s)) return '목걸이마부';
      if (/반지/.test(s)) return '반지마부';
      if (/보장|보조/.test(s)) return '보장마부';
      if (/마법석/.test(s)) return '마법석마부';
      if (/귀걸이/.test(s)) return '귀걸이마부';

      // 변환 실패면 마부로 취급하지 않음(섞여 들어오는 것 방지)
      return '';
    }

    function renderMobileEnchantList(slot) {
      const typeKey = _enchantTypeForSlot_mobile(slot);
      if (!typeKey) {
        toast('이 슬롯은 마법부여를 지원하지 않습니다.');
        return;
      }

      const listEl = document.getElementById('equipEnchantList');
      if (!listEl) return;

      const map = window.EQUIP_SLOT_LABELS || {};
      const slotLabel =
        map[slot]
        || (slot === 'headshoulder' ? (map.headshoulder || map.shoulder || '머리어깨') : '')
        || slot;

      const titleEl = document.getElementById('equipEnchantModalTitle');
      if (titleEl) titleEl.textContent = `${slotLabel} 마법부여 선택`;

      // ✅ 목록은 "강화마봉마부 시트"에서 가져오는 라이트 리스트를 재사용
      const raw = _getLightEnhList_mobile().map(_normEnhItem_mobile);

      const items = raw.filter(x => {
        if (!x || !x.name) return false;
        return normalizeEnchantType_mobile(x.type) === typeKey;
      });

      // ✅ 렌더
      const picked = window.state?.enchants?.[slot]?.name ? String(window.state.enchants[slot].name) : '';

      let html = '';
      // 없음
      html += `
    <button type="button" class="enh-btn ${picked ? '' : 'active'}" data-none="1">
      없음
    </button>
  `;

      // 실제 옵션들 (정렬 X: 시트 순서 유지)
      for (const it of items) {
        const name = String(it.name || '').trim();
        const active = (picked && picked === name) ? 'active' : '';
        html += `
      <button type="button" class="enh-btn ${active}"
        data-name="${name.replace(/"/g, '&quot;')}"
        data-typekey="${typeKey.replace(/"/g, '&quot;')}">
        ${name}
      </button>
    `;
      }

      listEl.innerHTML = html;

      // 클릭 핸들러(중복 바인딩 방지)
      if (!listEl.dataset.bound) {
        listEl.dataset.bound = '1';
        listEl.addEventListener('click', (e) => {
          const btn = e.target.closest('.enh-btn');
          if (!btn) return;

          const slot = window.state?.ui?.equipPickerSlot;
          if (!slot) return;

          (window.state = window.state || {}).enchants = (window.state.enchants || {});

          // 없음
          if (btn.dataset.none === '1') {
            delete window.state.enchants[slot];
            _syncEnchantLabelFromState_mobile(slot);
            syncEnchantTopbarLabel_mobile(slot);
            closeEquipEnchantModal();
            return;
          }

          // 선택
          const name = (btn.dataset.name || '').trim();
          const typeKey = (btn.dataset.typekey || '').trim();

          window.state.enchants[slot] = { name, typeKey };
          _syncEnchantLabelFromState_mobile(slot);
          syncEnchantTopbarLabel_mobile(slot);
          closeEquipEnchantModal();
        });
      }

      openEquipEnchantModal();
    }


    function _isSpecialSlot(slot) {
      return slot === 'sub' || slot === 'magestone' || slot === 'earring' || slot === 'title';
    }

    function _getEnhLevelFromState_mobile(slot) {
      const info = window.state?.enh?.[slot];
      if (!info) return 0;

      const lv = Number(info.level);
      if (Number.isFinite(lv) && lv > 0) return lv;

      // ✅ level이 없거나 0이면 name에서 숫자 파싱(12강 / +12 / 12)
      const name = String(info.name || '');
      return _parseEnhLevel_mobile(name);
    }

    function syncEnhTopbarLabel_mobile(slot) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;

      const enhBtn = bar.querySelector('.equip-topbtn[data-eqtab="enh"]');
      if (!enhBtn) return;

      // 기본 라벨 기억(처음 1회만)
      if (!enhBtn.dataset.baseLabel) {
        enhBtn.dataset.baseLabel = (enhBtn.textContent || '강화').trim();
      }

      const lv = _getEnhLevelFromState_mobile(slot);

      // ✅ 원하는 표기: +12 처럼 "수치"로 바꾸기
      enhBtn.textContent = (lv > 0) ? `+${lv}` : enhBtn.dataset.baseLabel;

      // 만약 "강화 +12"로 표기하고 싶으면 위 줄 대신:
      // enhBtn.textContent = (lv > 0) ? `강화 +${lv}` : enhBtn.dataset.baseLabel;
    }
    /* =========================
     * ✅ 모바일 엠블렘 시스템
     * ========================= */

    // (PC와 동일) 플래티넘 7라인
    const PLAT_LINES = [
      { label: '화', key: '화' },
      { label: '수', key: '수' },
      { label: '명', key: '명' },
      { label: '암', key: '암' },
      { label: '모속', key: '모속' },
      { label: '힘', key: '힘' },
      { label: '지능', key: '지능' },
    ];

    // (PC와 동일) 슬롯별 허용 엠블렘 타입
    const SOCKET_RULES = {
      headshoulder: ['노란빛엠블렘'],
      belt: ['노란빛엠블렘'],
      top: ['붉은빛엠블렘'],
      bottom: ['붉은빛엠블렘'],
      shoes: ['푸른빛엠블렘'],
      bracelet: ['푸른빛엠블렘'],
      necklace: ['녹색빛엠블렘'],
      ring: ['녹색빛엠블렘'],
      weapon: ['붉은빛엠블렘', '노란빛엠블렘', '녹색빛엠블렘', '푸른빛엠블렘'],
      sub: ['플래티넘엠블렘'],
      title: ['플래티넘엠블렘'], // 모바일에 칭호 슬롯 붙일 때 사용
      earring: ['플래티넘엠블렘'],
      magestone: ['플래티넘엠블렘'],
    };
    const SOCKET_COUNT = (slotKey) => _isSpecialSlot(slotKey) ? 1 : 2;

    // DBEnh.byType 준비(모바일은 init에서 CORE.lists만 있으니 여기서 그룹핑)
    const PLACEHOLDER_IMG = 'img/gametestlab.png';
    function _ensureDBEnhByType_mobile() {
      window.DBEnh = window.DBEnh || {};
      if (DBEnh.byType && DBEnh.__byTypeReady && Object.keys(DBEnh.byType).length > 0) return;

      DBEnh.byType = {};
      const list = (window.CORE?.lists && (CORE.lists['enh:list'] || CORE.lists.enh || CORE.lists.enhList)) || [];
      for (const row of list) {
        const it = _normEnhItem_mobile(row);
        const raw = it._raw || {};
        const type = String(it.type || '').trim();
        const name = String(it.name || '').trim();
        if (!type || !name) continue;

        // 이미지
        const img = _normImg(row?.image ?? raw['이미지'] ?? raw.image ?? '');
        // 플래티넘 라인 분류용(PC는 levelVal/tag를 쓰므로 여기서 하나 만들어 둠)
        const levelVal = String(
          row?.levelVal ??
          row?.level ??          // ✅ CORE 경량리스트에서 '렙제'가 level로 들어오는 케이스 대응
          raw['렙제'] ??
          raw['태그'] ??
          raw['tag'] ??
          raw.level ??
          ''
        ).trim();


        // 숫자 뱃지(이름에서 1~2자리 숫자)
        let level_num = '';
        const m = name.match(/(\d{1,2})/);
        if (m) level_num = m[1];

        const out = { name, type, img: img || PLACEHOLDER_IMG, levelVal, level_num, _raw: raw };
        (DBEnh.byType[type] = DBEnh.byType[type] || []).push(out);
      }
      DBEnh.__byTypeReady = true;
    }

    // state.emblems[slot] 배열 보장
    function _ensureEmblemArray_mobile(slotKey) {
      window.state = window.state || {};
      state.emblems = state.emblems || {};
      const cnt = SOCKET_COUNT(slotKey);
      if (!Array.isArray(state.emblems[slotKey])) state.emblems[slotKey] = new Array(cnt).fill(null);

      // 길이 보정
      if (state.emblems[slotKey].length !== cnt) {
        const arr = state.emblems[slotKey].slice(0, cnt);
        while (arr.length < cnt) arr.push(null);
        state.emblems[slotKey] = arr;
      }
      return state.emblems[slotKey];
    }

    // 상단바(엠블렘 구멍) 이미지 동기화
    function syncEmblemTopbarDots_mobile(slotKey) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;
      const emblemBtn = bar.querySelector('.equip-topbtn[data-eqtab="emblem"]');
      if (!emblemBtn) return;

      const dots = emblemBtn.querySelectorAll('.top-embs .emb');
      const arr = _ensureEmblemArray_mobile(slotKey);
      dots.forEach((d, i) => {
        const picked = arr[i] || null;

        const badge = picked?.level_num
          ? String(picked.level_num).replace(/[^\d]/g, '')
          : (picked?.name ? String(picked.name).replace(/[^\d]/g, '') : '');

        d.classList.toggle('has-img', !!picked);
        d.textContent = picked ? (badge || '') : '';

        if (picked?.img) d.style.backgroundImage = `url("${String(picked.img).replace(/"/g, '\\"')}")`;
        else d.style.backgroundImage = '';
      });
    }

    // 장비 리스트(메인 페이지) 엠블렘 아이콘 동기화
    function syncEquipRowEmblemIcons_mobile(slotKey) {
      const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slotKey}"]`);
      if (!row) return;
      const box = row.querySelector('.equip-emblem-icons');
      if (!box) return;

      const arr = _ensureEmblemArray_mobile(slotKey);
      const dots = box.querySelectorAll('.emb');
      dots.forEach((d, i) => {
        const picked = arr[i] || null;

        // ✅ 숫자(레벨) 표시: level_num 우선, 없으면 name에서 숫자 추출
        const badge = picked?.level_num
          ? String(picked.level_num).replace(/[^\d]/g, '')
          : (picked?.name ? String(picked.name).replace(/[^\d]/g, '') : '');

        d.classList.toggle('has-img', !!picked);
        d.textContent = picked ? (badge || '') : '';   // ✅ 숫자 표시

        if (picked?.img) d.style.backgroundImage = `url("${String(picked.img).replace(/"/g, '\\"')}")`;
        else d.style.backgroundImage = '';
      });
      // ✅ 특수장비(플래티넘) 속성 텍스트 미리보기(보조/마법석/귀걸이)
      // CSS는 이미 존재하며(:empty면 숨김) DOM이 없으면 여기서 생성해서 붙임 :contentReference[oaicite:4]{index=4}
      if (typeof _isSpecialSlot === 'function' && _isSpecialSlot(slotKey)) {
        let desc = row.querySelector('.equip-emblem-desc');
        if (!desc) {
          const emWrap = row.querySelector('.equip-emblems');
          if (emWrap) {
            desc = document.createElement('div');
            desc.className = 'equip-emblem-desc';
            emWrap.appendChild(desc);
          }
        }

        if (desc) {
          const p0 = arr[0] || null; // 특수장비는 소켓 1개
          const txt = (p0 && p0.type === '플래티넘엠블렘' && p0.tag) ? String(p0.tag).trim() : '';
          desc.textContent = txt;
        }
      } else {
        // 다른 부위는 혹시 남아있으면 비움
        const desc = row.querySelector('.equip-emblem-desc');
        if (desc) desc.textContent = '';
      }
    }

    // 장비 리스트(메인 페이지) 마법부여 텍스트 동기화
function syncEquipRowEnchant_mobile(slotKey) {
  const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slotKey}"]`);
  if (!row) return;

  // (HTML 구조상) 마법부여 영역 텍스트 컨테이너
  const body =
    row.querySelector('.equip-enchant .equip-col-body') ||
    row.querySelector('.equip-enchant-val') ||
    row.querySelector('[data-role="equip-enchant"]');

  if (!body) return;

  const ench = (window.state && state.enchants) ? (state.enchants[slotKey] || null) : null;
  body.textContent = ench?.name ? ench.name : '마법부여';
}

// 2페이지 장비 슬롯들(메인 UI) 마부/엠블렘 미리보기 일괄 동기화
function syncEquipSubOptionsFromState_mobile() {
  // pageEquip 내부의 모든 슬롯을 훑는다 (slotKey는 data-slot 기준)
  document.querySelectorAll('#pageEquip .equip-row[data-slot]').forEach(row => {
    const slotKey = row.getAttribute('data-slot');
    if (!slotKey) return;

    // 마법부여 텍스트
    syncEquipRowEnchant_mobile(slotKey);

    // 엠블렘 점/아이콘
    if (typeof syncEquipRowEmblemIcons_mobile === 'function') {
      syncEquipRowEmblemIcons_mobile(slotKey);
    }
  });
}

    // 모달 상단 타겟(소켓 선택 UI) 렌더
    function renderEmblemTarget_mobile(slotKey) {
      const wrap = document.getElementById('equipEmblemTarget');
      if (!wrap) return;

      const cnt = SOCKET_COUNT(slotKey);
      const slotKo =
        (window.EQUIP_SLOT_LABELS && EQUIP_SLOT_LABELS[slotKey]) ||
        (document.querySelector(`#pageEquip .equip-row[data-slot="${slotKey}"] .equip-name`)?.textContent || slotKey);

      state.ui = state.ui || {};
      state.ui.emblemTarget = state.ui.emblemTarget || { slotKey, sockIndex: 0 };
      state.ui.emblemTarget.slotKey = slotKey;

      const arr = _ensureEmblemArray_mobile(slotKey);
      const cur = Math.max(0, Math.min(cnt - 1, Number(state.ui.emblemTarget.sockIndex) || 0));
      state.ui.emblemTarget.sockIndex = cur;

      wrap.innerHTML = `
    <div class="em-target-top">
      <div class="em-slot-title">${String(slotKo).trim()} · 엠블렘</div>
      <div class="em-sockets">
        ${Array.from({ length: cnt }).map((_, i) => {
        const p = arr[i];
        const bg = p?.img ? `style="background-image:url('${String(p.img).replace(/'/g, "\\'")}')"` : '';
        const active = (i === cur) ? 'active' : '';
        const has = p?.img ? 'has-img' : '';
        const num = p?.level_num ? `<span class="num">${p.level_num}</span>` : '';
        const line = (p?.type === '플래티넘엠블렘' && p?.tag)
          ? `<span class="em-line-badge">${String(p.tag).trim()}</span>`
          : '';

        return `
  <span class="em-sock-wrap" data-sock="${i}">
    ${line}
    <button type="button" class="em-sock ${active} ${has}" data-sock="${i}" ${bg}>${num}</button>
  </span>
`;

      }).join('')}
      </div>
    </div>
    <div style="font-size:12px;color:rgba(240,230,210,0.75);">
      소켓을 눌러 대상을 바꾸고, 아래에서 엠블렘을 선택하세요.
    </div>
  `;

      // 소켓 클릭 바인딩(한 번만)
if (!wrap.dataset.bound) {
  wrap.dataset.bound = '1';
  wrap.addEventListener('click', (e) => {
    const b = e.target.closest('.em-sock, .em-sock-wrap');
    if (!b) return;

    const i = Number(b.dataset.sock);
    if (!Number.isFinite(i)) return;

    state.ui = state.ui || {};
    state.ui.emblemTarget = state.ui.emblemTarget || { slotKey: slotKey, sockIndex: 0 };

    state.ui.emblemTarget.sockIndex = i;

    // ✅ 핵심: 클로저 slotKey 말고 "현재 slotKey" 사용
    const curSlotKey = state.ui.emblemTarget.slotKey || slotKey;
    renderEmblemTarget_mobile(curSlotKey);
  });
}
    }

    // 모달 리스트(가로 행) 렌더
    function renderEmblemList_mobile(slotKey) {
      function _emNum(x) {
        const n = parseInt(String(x?.level_num ?? '').replace(/[^\d]/g, ''), 10);
        return Number.isFinite(n) ? n : -1;
      }
      // ✅ 내림차순: level_num 큰 것 먼저 → 이름(내림차순)
      function _sortEmblemsDesc(a, b) {
        const na = _emNum(a), nb = _emNum(b);
        if (nb !== na) return nb - na;
        const an = String(a?.name || '');
        const bn = String(b?.name || '');
        return bn.localeCompare(an, 'ko'); // name desc
      }

      const listEl = document.getElementById('equipEmblemList');
      if (!listEl) return;

      // ✅ 추가: enh:list → DBEnh.byType 준비(엠블렘 포함)
      _ensureDBEnhByType_mobile();

      const allowRaw = SOCKET_RULES[slotKey] || [];
      const allow = allowRaw
        .map(s => String(s || '').trim().replace(/^"+|"+$/g, ''))  // 앞/뒤 따옴표 제거
        .filter(Boolean);

      // ✅ DEBUG: 렌더 시점(진짜로 목록 채우기 직전)
      if (slotKey === 'weapon') {
        const by = window.DBEnh?.byType || {};
        console.log('[DBG weapon render] allow=', allow);
        allow.forEach(t => {
          console.log('  - type', t, 'len=', (by[t] || []).length);
        });
      }

      listEl.innerHTML = '';

      if (!allow.length) {
        listEl.innerHTML = `<div style="color:rgba(240,230,210,0.75);padding:8px;">선택 가능한 엠블렘이 없습니다.</div>`;
        return;
      }

      const isPlatinumOnly = (allow.length === 1 && allow[0] === '플래티넘엠블렘');

      const makeItemBtn = (item, isNone = false) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'em-item' + (isNone ? ' none' : '');
        const img = isNone ? '' : (item?.img || PLACEHOLDER_IMG);
        const name = isNone ? '없음' : (item?.name || '');
        const sub = isNone ? '선택한 소켓을 비웁니다' : (item?.type || '');
        const badge = (!isNone && item?.level_num) ? String(item.level_num) : '';

        btn.innerHTML = `
    <div class="thumb" style="${isNone ? '' : `background-image:url('${String(img).replace(/'/g, "\\'")}')`}">
      ${isNone ? '없음' : ''}
    </div>
    <div class="meta">
      <div class="name">${name}</div>
      <div class="sub">${sub}</div>
    </div>
    <div class="badge">${badge}</div>
  `;
        return btn;
      };

      const pick = (pickedItemOrNull) => {
        const t = state.ui?.emblemTarget || { slotKey, sockIndex: 0 };
        const sKey = t.slotKey;
        const idx = Number(t.sockIndex) || 0;

        _ensureEmblemArray_mobile(sKey);
        state.emblems[sKey][idx] = pickedItemOrNull ? {
          name: pickedItemOrNull.name,
          type: pickedItemOrNull.type,
          img: pickedItemOrNull.img,
          level_num: pickedItemOrNull.level_num,
          tag: pickedItemOrNull.levelVal,
        } : null;

        // UI 동기화
        syncEquipRowEmblemIcons_mobile(sKey);
        syncEmblemTopbarDots_mobile(sKey);
        renderEmblemTarget_mobile(sKey);

        // ✅ 자동 다음 소켓으로 이동(마지막이면 닫기)
        const cnt = SOCKET_COUNT(sKey);
        if (idx < cnt - 1) {
          state.ui.emblemTarget.sockIndex = idx + 1;
          renderEmblemTarget_mobile(sKey);
        } else {
          closeEquipEmblemModal();
        }
      };

      if (isPlatinumOnly) {
        let base = (DBEnh.byType['플래티넘엠블렘'] || []);
        const isSpecial = _isSpecialSlot(slotKey); // sub / magestone / earring

        // ✅ 특수장비: "속성 선택" → 선택한 속성의 단계(이름)만 아래에 표시
        if (isSpecial) {
          const ui = (state.ui || (state.ui = {}));
          const mem = (ui.emblemPlatLine || (ui.emblemPlatLine = {})); // 슬롯별 선택 기억
          const cur = (mem[slotKey] || '').trim();

          const group = document.createElement('div');
          group.className = 'em-group';

          const title = document.createElement('div');
          title.className = 'em-group-title plat';
          title.innerHTML = `
      <span>플래티넘 · <b class="em-plat-cur">${cur || '선택'}</b></span>
      <button type="button" class="em-line-btn">속성 선택</button>
    `;
          group.appendChild(title);

          const vlist = document.createElement('div');
          vlist.className = 'em-vlist';
          group.appendChild(vlist);

          // 속성 선택 패널(기본 숨김, 버튼 누르면 펼침)
          const chooser = document.createElement('div');
          chooser.className = 'em-line-choices';
          chooser.innerHTML = (PLAT_LINES || []).map(line => {
            const k = String(line.key || '').trim();
            const lb = String(line.label || k);
            return `<button type="button" class="em-line-opt" data-key="${k}">${lb}</button>`;
          }).join('');
          vlist.appendChild(chooser);

          const setActiveChooser = () => {
            const now = (mem[slotKey] || '').trim();
            chooser.querySelectorAll('.em-line-opt').forEach(b => {
              b.classList.toggle('active', (b.dataset.key || '') === now);
            });
            const curEl = title.querySelector('.em-plat-cur');
            if (curEl) curEl.textContent = now || '선택';
          };

          const renderStageList = () => {
            // 기존 단계 버튼/힌트 제거(chooser는 유지)
            vlist.querySelectorAll('.em-item, .em-plat-hint').forEach(el => el.remove());

            setActiveChooser();

            const now = (mem[slotKey] || '').trim();
            if (!now) {
              const hint = document.createElement('div');
              hint.className = 'em-plat-hint';
              hint.textContent = '속성(화/수/명/암/모속/힘/지능)을 먼저 선택해주세요.';
              vlist.appendChild(hint);
              return;
            }

            // 해제(없음)
            const noneBtn = document.createElement('button');
            noneBtn.type = 'button';
            noneBtn.className = 'em-item none';
            noneBtn.innerHTML = `
        <span class="thumb">없음</span>
        <span class="meta">
          <div class="name">없음</div>
          <div class="sub">플래티넘엠블렘</div>
        </span>
        <span class="badge">해제</span>
      `;
            noneBtn.addEventListener('click', () => {
              applyEmblem_mobile(slotKey, sockIdx, null);
              closeEquipEmblemModal();
            });
            vlist.appendChild(noneBtn);

            // ✅ 선택 속성과 일치하는 것만 "이름" 목록으로
            const items = base
              .filter(it => String((it.levelVal || '')).trim() === now)
              .sort(_sortEmblemsDesc);

            items.forEach(it => {
              const btn = makeItemBtn(it, false);
              btn.addEventListener('click', () => pick(it)); // ✅ 선택 적용
              vlist.appendChild(btn);
            });
          };

          // 버튼 눌러 chooser 토글
          const btnToggle = title.querySelector('.em-line-btn');
          if (btnToggle) {
            btnToggle.addEventListener('click', () => {
              chooser.classList.toggle('show');
            });
          }

          // chooser에서 속성 선택
          chooser.addEventListener('click', (e) => {
            const b = e.target.closest('.em-line-opt');
            if (!b) return;
            mem[slotKey] = (b.dataset.key || '').trim();
            chooser.classList.remove('show');
            renderStageList();
          });

          renderStageList();
          listEl.appendChild(group);
          return;
        }

        // (기존) 방어구/악세 등: 화/수/명/암 그룹 표시 유지
        const lines = PLAT_LINES.slice(0, 4);
        const SYNS = {
          '화': ['화', '화속', '화속성', '불'],
          '수': ['수', '수속', '수속성', '물'],
          '명': ['명', '명속', '명속성', '빛'],
          '암': ['암', '암속', '암속성', '어둠'],
          '모속': ['모속', '모든속성', '전속성'],
          '힘': ['힘'],
          '지능': ['지능'],
        };

        lines.forEach(line => {
          const keys = SYNS[line.key] || [line.key];
          const group = document.createElement('div');
          group.className = 'em-group';
          group.innerHTML = `<div class="em-group-title">플래티넘 · ${line.label}</div>`;
          const vlist = document.createElement('div');
          vlist.className = 'em-vlist';

          const noneBtn = document.createElement('button');
          noneBtn.type = 'button';
          noneBtn.className = 'em-item none';
          noneBtn.innerHTML = `
      <span class="thumb">없음</span>
      <span class="meta">
        <div class="name">없음</div>
        <div class="sub">플래티넘엠블렘</div>
      </span>
      <span class="badge">해제</span>
    `;
          noneBtn.addEventListener('click', () => pick(null));
          vlist.appendChild(noneBtn);

          const filtered = base
            .filter(x => {
              const lv = String(x.levelVal || '').trim();
              return keys.some(k => lv === k);
            })
            .sort(_sortEmblemsDesc);

          filtered.forEach(item => {
            vlist.appendChild(makeItemBtn(item));
          });

          group.appendChild(vlist);
          listEl.appendChild(group);
        });

      } else {
        const orderMap = { '붉은빛엠블렘': 0, '노란빛엠블렘': 1, '녹색빛엠블렘': 2, '푸른빛엠블렘': 3 };

        allow.slice().sort((a, b) => (orderMap[a] ?? 9) - (orderMap[b] ?? 9)).forEach(type => {
          const group = document.createElement('div');
          group.className = 'em-group';

          const title = document.createElement('div');
          title.className = 'em-group-title';
          const key = String(type || '').trim().replace(/^"+|"+$/g, '');
          title.textContent = key.replace('엠블렘', '');
          group.appendChild(title);

          const vlist = document.createElement('div');
          vlist.className = 'em-vlist';

          // ✅ 없음은 항상 맨 위
          const noneBtn = makeItemBtn(null, true);
          noneBtn.addEventListener('click', () => pick(null));
          vlist.appendChild(noneBtn);

          // ✅ 내림차순 정렬
          const items = (DBEnh.byType[key] || []).slice().sort(_sortEmblemsDesc);
          items.forEach(item => {
            const b = makeItemBtn(item, false);
            b.addEventListener('click', () => pick(item));
            vlist.appendChild(b);
          });

          group.appendChild(vlist);
          listEl.appendChild(group);
        });
      }
    }

    // 외부 진입점: 슬롯/소켓으로 엠블렘 모달 열기
    function openMobileEmblemPicker(slotKey, sockIndex = 0) {
      _ensureDBEnhByType_mobile();

      // ✅ DEBUG: 무기 엠블렘 모달 진입 시점 점검
      try {
        const allow = SOCKET_RULES[slotKey] || [];
        const allowRaw = SOCKET_RULES[slotKey] || [];
        const allowNorm = allowRaw.map(s => String(s || '').trim().replace(/^"+|"+$/g, '')).filter(Boolean);

        console.log('[DBG emblem open]', { slotKey, allowRaw, allowNorm });

        const by = window.DBEnh?.byType || {};
        console.log('[DBG byType counts]', {
          red: (by['붉은빛엠블렘'] || []).length,
          yel: (by['노란빛엠블렘'] || []).length,
          grn: (by['녹색빛엠블렘'] || []).length,
          blu: (by['푸른빛엠블렘'] || []).length,
          keysEmblem: Object.keys(by).filter(k => k.includes('엠블렘')).slice(0, 30)
        });

        // 무기일 때만 샘플도 몇 개 찍기
        if (slotKey === 'weapon') {
          console.log('[DBG weapon sample red]', (by['붉은빛엠블렘'] || []).slice(0, 5).map(x => x.name));
          console.log('[DBG weapon sample yel]', (by['노란빛엠블렘'] || []).slice(0, 5).map(x => x.name));
          console.log('[DBG weapon sample grn]', (by['녹색빛엠블렘'] || []).slice(0, 5).map(x => x.name));
          console.log('[DBG weapon sample blu]', (by['푸른빛엠블렘'] || []).slice(0, 5).map(x => x.name));
        }
      } catch (e) { console.warn('[DBG emblem open] err', e); }


      window.state = window.state || {};
      state.ui = state.ui || {};
      state.ui.emblemTarget = { slotKey, sockIndex };

      // 제목
      const titleEl = document.getElementById('equipEmblemModalTitle');
      if (titleEl) {
        const slotKo =
          (window.EQUIP_SLOT_LABELS && EQUIP_SLOT_LABELS[slotKey]) ||
          (document.querySelector(`#pageEquip .equip-row[data-slot="${slotKey}"] .equip-name`)?.textContent || slotKey);
        titleEl.textContent = `${String(slotKo).trim()} 엠블렘 선택`;
      }

      _ensureEmblemArray_mobile(slotKey);
      renderEmblemTarget_mobile(slotKey);
      renderEmblemList_mobile(slotKey);

      openEquipEmblemModal();
    }

    function _shortTopbarText_mobile(s, maxLen = 7) {
      s = String(s || '').trim();
      if (!s) return '';
      return (s.length > maxLen) ? (s.slice(0, maxLen - 1) + '…') : s;
    }

    function syncSealTopbarLabel_mobile(slot) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;

      const uBtn = bar.querySelector('.equip-topbtn[data-eqtab="seal_u"]');
      const nBtn = bar.querySelector('.equip-topbtn[data-eqtab="seal_n"]');

      if (uBtn && !uBtn.dataset.baseLabel) {
        uBtn.dataset.baseLabel = (uBtn.textContent || '고유옵션').trim();
      }
      if (nBtn && !nBtn.dataset.baseLabel) {
        nBtn.dataset.baseLabel = (nBtn.textContent || '일반옵션').trim();
      }

      const uName = window.state?.seals?.[slot]?.unique?.name
        ? String(window.state.seals[slot].unique.name).trim()
        : '';
      const nName = window.state?.seals?.[slot]?.general1?.name
        ? String(window.state.seals[slot].general1.name).trim()
        : '';

      if (uBtn) uBtn.textContent = uName ? _shortTopbarText_mobile(uName) : uBtn.dataset.baseLabel;
      if (nBtn) nBtn.textContent = nName ? _shortTopbarText_mobile(nName) : nBtn.dataset.baseLabel;
    }

    function syncEnchantTopbarLabel_mobile(slot) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;

      const btn = bar.querySelector('.equip-topbtn[data-eqtab="enchant"]');
      if (!btn) return;

      if (!btn.dataset.baseLabel) {
        btn.dataset.baseLabel = (btn.textContent || '마법부여').trim();
      }

      const name = window.state?.enchants?.[slot]?.name
        ? String(window.state.enchants[slot].name).trim()
        : '';

      btn.textContent = name ? _shortTopbarText_mobile(name) : btn.dataset.baseLabel;
    }

function setEquipTopbarSlot(slot) {
  const bar = document.getElementById('equipTopbar');
  if (!bar) return;

  const enhBtn     = bar.querySelector('.equip-topbtn[data-eqtab="enh"]');
  const grindBtn   = bar.querySelector('.equip-topbtn[data-eqtab="grind"]');
  const sealUBtn   = bar.querySelector('.equip-topbtn[data-eqtab="seal_u"]');
  const sealNBtn   = bar.querySelector('.equip-topbtn[data-eqtab="seal_n"]');
  const enchantBtn = bar.querySelector('.equip-topbtn[data-eqtab="enchant"]');
  const emblemBtn  = bar.querySelector('.equip-topbtn[data-eqtab="emblem"]');

  const hide = (b) => { if (b) b.style.display = 'none'; };
  const show = (b) => { if (b) b.style.display = ''; };

  const isOchingSubSlot = (slot === 'aura' || slot === 'creature' || slot === 'artifact');
  const isTitleSlot = (slot === 'title');

  // ✅ 오라/크리쳐/아티팩트: 강화/봉인/마부/엠블렘 자체가 없으니 topbar 통째로 숨김
  if (isOchingSubSlot) {
    bar.style.display = 'none';

    (window.state = window.state || {}).ui = (window.state.ui || {});
    window.state.ui.equipPickerSlot = slot;
    return;
  }

  // 나머지는 topbar 표시
  bar.style.display = '';

  // ✅ 칭호: “강화/연마/고유/일반” 숨기고 “마법부여/엠블렘”만 노출
  if (isTitleSlot) {
    hide(enhBtn);
    hide(grindBtn);
    hide(sealUBtn);
    hide(sealNBtn);
    show(enchantBtn);
    show(emblemBtn);

    // active 기본은 마법부여
    bar.querySelectorAll('.equip-topbtn').forEach(b => b.classList.remove('active'));
    if (enchantBtn) enchantBtn.classList.add('active');

    // 라벨 동기화(칭호 마부명)
    syncEnchantTopbarLabel_mobile(slot);

    // 엠블렘 구멍: title은 1개(플래티넘)
    if (emblemBtn) {
      const cnt = _isSpecialSlot(slot) ? 1 : 2;
      emblemBtn.innerHTML = `
        <span class="top-embs">
          ${Array.from({ length: cnt }).map(() => `<span class="emb"></span>`).join('')}
        </span>
      `;
      syncEmblemTopbarDots_mobile(slot);
    }

    (window.state = window.state || {}).ui = (window.state.ui || {});
    window.state.ui.equipPickerSlot = slot;
    return;
  }

  // ✅ 기존 슬롯들(무기/방어구/악세/특장): 원래 로직 유지
  show(enhBtn);
  show(sealUBtn);
  show(sealNBtn);
  show(enchantBtn);
  show(emblemBtn);

  // ✅ 연마 탭: data-grind="1" 인 슬롯에서만 노출 (무기/보조장비)
  if (grindBtn) {
    const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slot}"]`);
    const canGrind = !!(row && row.dataset.grind === '1');
    grindBtn.style.display = canGrind ? '' : 'none';
    if (canGrind) syncGrindTopbarLabel_mobile(slot);
  }

  bar.querySelectorAll('.equip-topbtn').forEach(b => {
    b.classList.toggle('active', b.dataset.eqtab === 'enh');
  });

  syncEnhTopbarLabel_mobile(slot);
  syncSealTopbarLabel_mobile(slot);
  syncEnchantTopbarLabel_mobile(slot);

  if (emblemBtn) {
    const cnt = _isSpecialSlot(slot) ? 1 : 2;
    emblemBtn.innerHTML = `
      <span class="top-embs">
        ${Array.from({ length: cnt }).map(() => `<span class="emb"></span>`).join('')}
      </span>
    `;
    syncEmblemTopbarDots_mobile(slot);
  }

  (window.state = window.state || {}).ui = (window.state.ui || {});
  window.state.ui.equipPickerSlot = slot;
}

    // ✅ 상단바 클릭(구멍 포함) → 탭 활성화
    (function bindEquipTopbarOnce() {
      const bar = document.getElementById('equipTopbar');
      if (!bar || bar.dataset.bound) return;
      bar.dataset.bound = '1';

      bar.addEventListener('click', async (e) => { // ✅ async로 변경
        const btn = e.target.closest('.equip-topbtn');
        if (!btn) return;

        bar.querySelectorAll('.equip-topbtn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const tab = btn.dataset.eqtab;

        // ✅ 강화 탭: enhList 버튼 목록 보여주기
        if (tab === 'enh') {
          const slot = window.state?.ui?.equipPickerSlot; // setEquipTopbarSlot에서 저장
          if (!slot) {
            toast('슬롯 정보가 없습니다.');
            return;
          }
          await initMobileAllLightListsOnce();  // 경량리스트 보장
          renderMobileEnhList(slot);
          return;
        }

        // 나머지는 일단 기존대로 토스트
        if (tab === 'grind') {
          openMobileGrindPicker();
          return;
        }
        else if (tab === 'seal_u') {
          const slot = window.state?.ui?.equipPickerSlot; // ✅ setEquipTopbarSlot에서 저장한 슬롯
          if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

          await initMobileAllLightListsOnce(); // ✅ 경량리스트 보장
          renderMobileSealUniqueList(slot);    // ✅ 고유옵션 모달 오픈 + 목록 렌더
          return;

        } else if (tab === 'seal_n') {
          const slot = window.state?.ui?.equipPickerSlot; // ✅ setEquipTopbarSlot에서 저장한 슬롯
          if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

          await initMobileAllLightListsOnce(); // ✅ 경량리스트 보장
          renderMobileSealNormalList(slot);    // ✅ 일반옵션 모달 오픈 + 목록 렌더
          return;
        } else if (tab === 'enchant') {
          const slot = window.state?.ui?.equipPickerSlot;
          if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

          initMobileAllLightListsOnce().then(() => {
            renderMobileEnchantList(slot);
          });
          return;
        } else if (tab === 'emblem') {
          const slot = window.state?.ui?.equipPickerSlot;
          if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

          await initMobileAllLightListsOnce(); // 경량리스트 보장
          openMobileEmblemPicker(slot, 0);     // ✅ 엠블렘 모달 오픈
          return;
        }
      });
    })();



    async function openEquipPicker(slot) {
      // ✅ 무기 선택(캐릭터 직업군 + 무기종류 필터 반영)
      if (slot === 'weapon') {
        _hideWeaponTypeBar_mobile();
        await initMobileAllLightListsOnce(); // 경량리스트 보장

        // 1) 현재 선택 캐릭터 직업군 확보 (프로젝트 내 상태키가 다를 수 있어 방어적으로)
        const ch = window.state?.currentCharacter || window.state?.char || window.state?.pickedChar || null;
        const jobGroup = _getCharJobGroup(ch) || '';
        if (!jobGroup) {
          toast('캐릭터를 먼저 선택해주세요.');
          return;
        }

        // 2) 무기 리스트 가져오기
        //    - 직업군별로 따로 내려주는 키가 있으면 그걸 우선
        //    - 없으면 weapon:list 전체에서 jobGroup으로 필터
        const keyByJob = `weapon:${jobGroup}:list`;
        const byJob = window.CORE?.lists?.[keyByJob];
        let items = Array.isArray(byJob) ? byJob.slice() : (window.CORE?.lists?.['weapon:list'] || []).slice();

        // 직업군별 키가 없어서 전체 weapon:list를 쓰는 경우만 jobGroup 필터
        if (!Array.isArray(byJob)) {
          const base = _baseJG_mobile(jobGroup);
          items = items.filter(it => _jgMatches_mobile(_getEquipJobGroup_mobile(it), jobGroup));
        }

        // 3) 무기종류 탭(버튼) 구성 + 선택 시 목록 갱신
        const baseItems = items.slice();

        // 직업군에 해당하는 무기들에서 "종류" 목록 뽑기
        let types = Array.from(new Set(
          baseItems.map(it => _getWeaponType_mobile(it)).filter(Boolean)
        ));

        // 보기 좋게 정렬(원하면 제거 가능)
        types.sort((a, b) => String(a).localeCompare(String(b), 'ko-KR'));

        // state.ui 준비
        window.state = window.state || {};
        window.state.ui = window.state.ui || {};

        let activeType = String(window.state.ui.weaponType || '전체').trim() || '전체';
        if (activeType !== '전체' && !types.includes(activeType)) activeType = '전체';
        window.state.ui.weaponType = activeType;

        // ✅ 탭 클릭 시: active 갱신 + 목록 재렌더
        const onPickType = (t) => {
          t = String(t || '전체').trim() || '전체';
          window.state.ui.weaponType = t;

          // 탭 active 다시 그리기
          renderWeaponTypeBar_mobile(types, t, onPickType);

          // 목록 필터링 후 다시 렌더
          let filtered = baseItems;
          if (t !== '전체') filtered = baseItems.filter(it => _getWeaponType_mobile(it) === t);

          const catalog = document.getElementById('equipCatalog');
          if (!filtered.length) {
            toast('표시할 무기 목록이 없습니다.');
            if (catalog) {
              catalog.innerHTML = `<div style="padding:14px 16px; color:#c7b589;">표시할 무기 목록이 없습니다.</div>`;
            }
            return;
          }
          renderMobileEquipList('weapon', filtered);
        };

        // 최초 1회 탭 렌더
        renderWeaponTypeBar_mobile(types, activeType, onPickType);

        // 최초 진입 시 현재 선택 타입으로 필터 적용
        items = baseItems;
        if (activeType !== '전체') {
          items = baseItems.filter(it => _getWeaponType_mobile(it) === activeType);
        }


        if (!items.length) {
          toast('표시할 무기 목록이 없습니다.');
          return;
        }

        setEquipTopbarSlot(slot);
        renderMobileEquipList(slot, items);
        openEquipModal();
        return;
      }


      // init에서 경량리스트 전부 받기
      await initMobileAllLightListsOnce();

      const key = _equipListKey(slot);
      const items = window.CORE?.lists?.[key];

      if (!Array.isArray(items) || !items.length) {
        console.error('equip list missing:', key, items);
        toast(`장비 목록을 불러오지 못했습니다. (${key})`);
        return;
      }

      setEquipTopbarSlot(slot);
      renderMobileEquipList(slot, items);
      openEquipModal();
    }

    /* =========================
   ✅ (NEW) Set Equip (Mobile)
========================= */

    function _openModalById_(id) {
  // openModal()을 재사용해서 포커스/접근성 처리를 공통화
  openModal(id);
}
function _closeModalById_(id) {
  // closeModal()을 재사용해서 포커스/접근성 처리를 공통화
  closeModal(id);
}

    /* ✅ 공통 닫기 바인딩: backdrop 클릭 또는 [data-mset-close] */
    (function bindMSetCloseOnce() {
      const ids = ['mArmorSetModal', 'mAccSetModal', 'mSpecSetModal', 'mUniqueBulkModal', 'mUniquePickModal'];
      ids.forEach(id => {
        const m = document.getElementById(id);
        if (!m || m.__bound) return;
        m.__bound = 1;
        m.addEventListener('click', (e) => {
          if (e.target?.classList?.contains('backdrop')) return _closeModalById_(id);
          if (e.target?.closest?.('[data-mset-close]')) return _closeModalById_(id);
        });
      });
    })();

    /* ✅ 세트 적용: selections + equips + UI 동기화 (세트 적용이 실제 계산에 반영되도록) */
    function applySetPieces_mobile(setCard) {
      if (!setCard?.pieces) return;

      window.state = window.state || {};
      state.equips = state.equips || {};
      state.selections = state.selections || {}; // ✅ payload에서 쓰는 핵심

      const stripParen = (name) => String(name ?? '').replace(/\s*\([^)]*\)\s*$/, '').trim();

      for (const p of setCard.pieces) {
        if (!p?.slot || !p?.item) continue;

        const raw = p.item;

        // ✅ applyPickedEquipUI는 it.image만 보므로 img → image로 맞춰준다
        const it = { ...raw };
        it.name = (raw.name || raw['이름'] || p.name || '').trim();
        it.image = (raw.image || raw.img || raw['이미지'] || it.image || '').trim();

        const cleanName = stripParen(it.name);
        const code = String(raw.code ?? '');

        // 1) UI용/모달 재오픈용
        // ✅ 1) 세트 조각도 CORE DB로 가능한 "풀 아이템"으로 업그레이드
const fullIt = _upgradeEquipByCore_(p.slot, it) || it;

// ✅ 2) equips는 풀 객체
state.equips[p.slot] = fullIt;

// ✅ 3) selections는 PC처럼 풀 메타
state.selections[p.slot] = _buildSelectionFromEquip_(fullIt);

        // 3) UI 반영
        if (typeof applyPickedEquipUI === 'function') {
          applyPickedEquipUI(p.slot, it);
        } else if (typeof syncEquipUI_mobile === 'function') {
          syncEquipUI_mobile(p.slot);
        }
      }
    }


    /* =========================
       ✅ PC의 세트 카드 생성 로직 이식
       - 아래 3개 함수는 PC(새로운프론트249)에서 가져오는 것을 권장
       - buildAccSetCardsFromSheets / buildSpecSetCardsFromSheets / buildArmorSetCardsFromSheets
    ========================= */
    function buildArmorSetCardsFromSheets() {
      // 현재 토글 상태 (기본값은 익시드)
      const mode = (typeof armorSetMode === 'string') ? armorSetMode : 'exceed';
      // --- CORE.lists 접근 ---
      const lists = (function _coreRoot() {
        const core =
          (window.CORE && (window.CORE.data || window.CORE)) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)) ||
          null;
        return core ? (core.lists || {}) : null;
      })();
      if (!lists) return [];

      // 1) 세트 시트 로우들
      let setRows = lists['set:list'];
      if (setRows && typeof setRows === 'object' && Array.isArray(setRows.rows)) {
        setRows = setRows.rows;
      }
      if (!Array.isArray(setRows)) setRows = [];

      const norm = (v) => String(v ?? '').trim();
      const toNum = (v) => {
        const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
        return Number.isFinite(n) ? n : 0;
      };

      // 2) 방어구 세트만 type 기준으로 대표 1개씩 뽑기 (보통 5세트 행)
      const armorSetByType = new Map(); // type -> { type, name, num }

      for (const r of setRows) {
        const category = norm(r.category || r['분류'] || '');
        const armp = toNum(r.armpoint);

        // 방어구 세트만 대상으로
        if (!category && !armp) continue;
        if (category && category !== '방어구') continue;

        const type = norm(r.type);
        if (!type) continue;

        const rarity = norm(r.rarity || r['레어리티'] || '');
        const num = toNum(r.num);
        const name = norm(r.name || r['이름'] || type);

        const prev = armorSetByType.get(type);
        if (!prev || num > prev.num) {
          armorSetByType.set(type, { type, name, num, rarity });
        }
      }


      if (!armorSetByType.size) return [];

      // 3) 각 부위 시트에서, 해당 세트 type 과 같은 '종류' 를 가진 장비 찾기
      const slotKeys = ['top', 'bottom', 'headshoulder', 'belt', 'shoes'];

      // itemModal 쪽에서 쓰는 헬퍼 재사용
      function _getListArray(slotKey) {
        const lists2 =
          (window.CORE && (window.CORE.data || window.CORE)?.lists) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)?.lists) ||
          null;
        if (!lists2) return [];
        const key1 = `${slotKey}:list`;
        const key2 = `${slotKey}:lists`;
        const key3 = slotKey;
        let arr = lists2[key1] ?? lists2[key2] ?? lists2[key3] ?? [];
        if (arr && typeof arr === 'object' && Array.isArray(arr.rows)) arr = arr.rows;
        return Array.isArray(arr) ? arr : [];
      }

      function _mapEquipRow(row) {
        const S = (v) => (v == null ? '' : String(v));
        const N = (v) => {
          const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
          return Number.isFinite(n) ? n : 0;
        };
        const 이름 = row['이름'] ?? row.name ?? row.title ?? '';
        const 종류 = row['종류'] ?? row.type ?? row.category ?? '';
        const 렙제 = row['레벨제한'] ?? row['렙제'] ?? row.level ?? row.reqLevel ?? 0;
        const 이미지 = row['이미지'] ?? row.image ?? row.img ?? '';
        const 레어리티 = row['레어리티'] ?? row.rarity ?? '';
        return {
          name: S(이름),
          type: S(종류),
          level: N(렙제),
          img: S(이미지),
          rarity: S(레어리티),
          _raw: row,
        };
      }

      const equipBySlot = {};
      for (const slotKey of slotKeys) {
        equipBySlot[slotKey] = _getListArray(slotKey).map(_mapEquipRow);
      }

      // 4) 세트별 카드 데이터 구성
      const cards = [];

      armorSetByType.forEach((info, typeKey) => {
        const pieces = [];

        for (const slotKey of slotKeys) {
          const rows = equipBySlot[slotKey] || [];

          let row;

          if (mode === 'epic') {
            // ✅ 에픽 모드: 종류가 세트 type 이고, 레어리티가 '에픽' 인 장비 우선 선택
            row = rows.find(
              (r) =>
                norm(r.type) === norm(typeKey) &&
                norm(r.rarity || r['레어리티']) === '에픽'
            );

            // 혹시 에픽 장비가 없으면(데이터 누락 등) 그냥 종류만 맞는 첫 장비로 fallback
            if (!row) {
              row = rows.find((r) => norm(r.type) === norm(typeKey));
            }
          } else {
            // ✅ 익시드 모드: 기존과 동일 (종류만 맞으면 사용)
            row = rows.find((r) => norm(r.type) === norm(typeKey));
          }

          if (row) {
            pieces.push({
              slot: slotKey,
              name: row.name,
              level: row.level,
              img: row.img || PLACEHOLDER_IMG,
              rarity: row.rarity,
              item: row,              // ★ 실제 장비 객체 저장
            });
          } else {
            pieces.push({
              slot: slotKey,
              name: '',
              level: null,
              img: PLACEHOLDER_IMG,
              rarity: '',
              item: null,             // 없으면 null
            });
          }
        }

        cards.push({
          id: typeKey,
          type: typeKey,
          name: info.name,
          num: info.num,
          pieces,
        });
      });

      // 보기 좋게 세트 이름 순 정렬
      //cards.sort((a, b) => a.name.localeCompare(b.name, 'ko'));

      // 디버그용으로 한 번 볼 수 있게
      window._debugArmorSets = cards;

      return cards;
    }

    function buildAccSetCardsFromSheets() {
      const mode = (typeof armorSetMode === 'string') ? armorSetMode : 'exceed';

      const lists = (function _coreRoot() {
        const core =
          (window.CORE && (window.CORE.data || window.CORE)) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)) ||
          null;
        return core ? (core.lists || {}) : null;
      })();
      if (!lists) return [];

      // 1) 세트 시트
      let setRows = lists['set:list'];
      if (setRows && typeof setRows === 'object' && Array.isArray(setRows.rows)) {
        setRows = setRows.rows;
      }
      if (!Array.isArray(setRows)) setRows = [];

      const norm = (v) => String(v ?? '').trim();
      const toNum = (v) => {
        const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
        return Number.isFinite(n) ? n : 0;
      };

      // 2) 악세사리 세트만 type 기준으로 대표 1개씩 뽑기
      const accSetByType = new Map(); // type -> { type, name, num }

      for (const r of setRows) {
        const category = norm(r.category || r['분류'] || '');
        const acp = toNum(r.accpoint); // 악세 포인트

        // 분류가 '악세사리' 이거나, accpoint 가 있는 행만 악세 세트 취급
        if (!category && !acp) continue;
        if (category && category !== '악세') continue;

        const type = norm(r.type);
        if (!type) continue;

        const rarity = norm(r.rarity || r['레어리티'] || '');
        const num = toNum(r.num);
        const name = norm(r.name || r['이름'] || type);

        const prev = accSetByType.get(type);
        if (!prev || num > prev.num) {
          accSetByType.set(type, { type, name, num, rarity });
        }
      }

      if (!accSetByType.size) return [];

      // 3) 장비 시트에서 팔찌/목걸이/반지 찾기
      const slotKeys = ['bracelet', 'necklace', 'ring'];

      function _getListArray(slotKey) {
        const lists2 =
          (window.CORE && (window.CORE.data || window.CORE)?.lists) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)?.lists) ||
          null;
        if (!lists2) return [];
        const key1 = `${slotKey}:list`;
        const key2 = `${slotKey}:lists`;
        const key3 = slotKey;
        let arr = lists2[key1] ?? lists2[key2] ?? lists2[key3] ?? [];
        if (arr && typeof arr === 'object' && Array.isArray(arr.rows)) arr = arr.rows;
        return Array.isArray(arr) ? arr : [];
      }

      function _mapEquipRow(row) {
        const S = (v) => (v == null ? '' : String(v));
        const N = (v) => {
          const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
          return Number.isFinite(n) ? n : 0;
        };
        const 이름 = row['이름'] ?? row.name ?? row.title ?? '';
        const 종류 = row['종류'] ?? row.type ?? row.category ?? '';
        const 렙제 = row['레벨제한'] ?? row['렙제'] ?? row.level ?? row.reqLevel ?? 0;
        const 이미지 = row['이미지'] ?? row.image ?? row.img ?? '';
        const 레어리티 = row['레어리티'] ?? row.rarity ?? '';
        return {
          name: S(이름),
          type: S(종류),
          level: N(렙제),
          img: S(이미지),
          rarity: S(레어리티),
          _raw: row,
        };
      }

      const equipBySlot = {};
      for (const slotKey of slotKeys) {
        equipBySlot[slotKey] = _getListArray(slotKey).map(_mapEquipRow);
      }

      const cards = [];

      accSetByType.forEach((info, typeKey) => {
        const pieces = [];

        for (const slotKey of slotKeys) {
          const rows = equipBySlot[slotKey] || [];
          let row;

          if (mode === 'epic') {
            // 에픽 모드: 종류 + 레어리티 '에픽' 우선
            row = rows.find(
              (r) =>
                norm(r.type) === norm(typeKey) &&
                norm(r.rarity || r['레어리티']) === '에픽'
            );
            if (!row) {
              row = rows.find((r) => norm(r.type) === norm(typeKey));
            }
          } else {
            // 익시드 모드: 종류만 맞으면 OK
            row = rows.find((r) => norm(r.type) === norm(typeKey));
          }

          if (row) {
            pieces.push({
              slot: slotKey,
              name: row.name,
              level: row.level,
              img: row.img || PLACEHOLDER_IMG,
              rarity: row.rarity,
              item: row,
            });
          } else {
            pieces.push({
              slot: slotKey,
              name: '',
              level: null,
              img: PLACEHOLDER_IMG,
              rarity: '',
              item: null,
            });
          }
        }

        cards.push({
          id: typeKey,
          type: typeKey,
          name: info.name,
          num: info.num,
          pieces,
        });
      });

      // 시트 순서 유지 (정렬 안 함)
      window._debugAccSets = cards;
      return cards;
    }

    function buildSpecSetCardsFromSheets() {
      const mode = (typeof armorSetMode === 'string') ? armorSetMode : 'exceed';

      const lists = (function _coreRoot() {
        const core =
          (window.CORE && (window.CORE.data || window.CORE)) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)) ||
          null;
        return core ? (core.lists || {}) : null;
      })();
      if (!lists) return [];

      let setRows = lists['set:list'];
      if (setRows && typeof setRows === 'object' && Array.isArray(setRows.rows)) {
        setRows = setRows.rows;
      }
      if (!Array.isArray(setRows)) setRows = [];

      const norm = (v) => String(v ?? '').trim();
      const toNum = (v) => {
        const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
        return Number.isFinite(n) ? n : 0;
      };

      const specSetByType = new Map();

      for (const r of setRows) {
        const categoryRaw = r.category ?? r['분류'] ?? '';
        const category = norm(categoryRaw);
        const categoryNoSpace = category.replace(/\s+/g, '');

        const subp = toNum(r.subpoint || r['subpoint'] || r['특수장비포인트'] || 0);

        // ✅ 분류에 '특수', '보조', '마법석', '귀걸이' 포함 또는 특수장비포인트가 있으면 특수세트로 취급
        const isSpecCategory =
          categoryNoSpace.includes('특수') ||
          categoryNoSpace.includes('보조') ||
          categoryNoSpace.includes('마법석') ||
          categoryNoSpace.includes('귀걸이');

        if (!isSpecCategory && !subp) continue;

        const type = norm(r.type);
        if (!type) continue;

        const rarity = norm(r.rarity || r['레어리티'] || '');
        const num = toNum(r.num);
        const name = norm(r.name || r['이름'] || type);

        const prev = specSetByType.get(type);
        if (!prev || num > prev.num) {
          specSetByType.set(type, { type, name, num, rarity });
        }
      }

      if (!specSetByType.size) return [];

      // ✅ 특수장비 슬롯 키: 보조 / 마법석 / 귀걸이
      const slotKeys = ['sub', 'magestone', 'earring'];

      function _getListArray(slotKey) {
        const core =
          (window.CORE && (window.CORE.data || window.CORE)) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)) ||
          null;
        const lists2 = core ? (core.lists || {}) : {};
        let arr =
          lists2[`${slotKey}:list`] ??
          lists2[`${slotKey}:lists`] ??
          lists2[slotKey] ??
          [];
        if (arr && typeof arr === 'object' && Array.isArray(arr.rows)) arr = arr.rows;
        return Array.isArray(arr) ? arr : [];
      }

      function _mapEquipRow(row) {
        const S = (v) => (v == null ? '' : String(v));
        const N = (v) => {
          const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
          return Number.isFinite(n) ? n : 0;
        };
        const 이름 = row['이름'] ?? row.name ?? row.title ?? '';
        const 종류 = row['종류'] ?? row.type ?? row.category ?? '';
        const 렙제 = row['레벨제한'] ?? row['렙제'] ?? row.level ?? row.reqLevel ?? 0;
        const 이미지 = row['이미지'] ?? row.image ?? row.img ?? '';
        const 레어리티 = row['레어리티'] ?? row.rarity ?? '';
        return {
          name: S(이름),
          type: S(종류),
          level: N(렙제),
          img: S(이미지),
          rarity: S(레어리티),
          _raw: row,
        };
      }

      const equipBySlot = {};
      for (const slotKey of slotKeys) {
        equipBySlot[slotKey] = _getListArray(slotKey).map(_mapEquipRow);
      }

      const cards = [];

      specSetByType.forEach((info, typeKey) => {
        const pieces = [];

        for (const slotKey of slotKeys) {
          const rows = equipBySlot[slotKey] || [];
          let row;

          if (mode === 'epic') {
            // 에픽 모드: 종류 + 레어리티 '에픽' 우선
            row = rows.find(
              (r) =>
                norm(r.type) === norm(typeKey) &&
                norm(r.rarity || r['레어리티']) === '에픽'
            );
            if (!row) {
              row = rows.find((r) => norm(r.type) === norm(typeKey));
            }
          } else {
            // 익시드 모드: 종류만 맞으면 OK
            row = rows.find((r) => norm(r.type) === norm(typeKey));
          }

          if (row) {
            pieces.push({
              slot: slotKey,
              name: row.name,
              level: row.level,
              img: row.img || PLACEHOLDER_IMG,
              rarity: row.rarity,
              item: row,
            });
          } else {
            pieces.push({
              slot: slotKey,
              name: '',
              level: null,
              img: PLACEHOLDER_IMG,
              rarity: '',
              item: null,
            });
          }
        }

        cards.push({
          id: typeKey,
          type: typeKey,
          name: info.name,
          num: info.num,
          pieces,
        });
      });

      window._debugSpecSets = cards;
      return cards;
    }


    /* ⚠️ 여기부터는 “PC의 함수 본문을 그대로 복사”해서 넣어야 함
       - PC 파일에 이미 구현되어 있고(set:list + 슬롯별 list에서 아이템 찾아 pieces 구성),
       - 그 구조가 가장 안전함
    */
    function ensureCustomSkillsMobile() {
      window.state = window.state || {};
      state.customSkills = state.customSkills || {};
      if (typeof state.customSkills.weaponType !== "string") state.customSkills.weaponType = "";
      if (typeof state.customSkills.armorType !== "string") state.customSkills.armorType = "";
      if (typeof state.customSkills.braceletType !== "string") state.customSkills.braceletType = "";
      if (typeof state.customSkills.earringType !== "string") state.customSkills.earringType = "";
    }

    function syncUniqueMiniLabels() {
      ensureCustomSkillsMobile();

      const map = {
        weaponType: state.customSkills.weaponType,
        armorType: state.customSkills.armorType,
        braceletType: state.customSkills.braceletType,
        earringType: state.customSkills.earringType
      };

      // ✅ 색상 매핑
      // - 무기: 강타/광채/분쇄/선명 그대로
      // - 나머지: 선봉=분쇄색, 의지=광채색, 이상=선명색
      const mapColor = (key, rawVal) => {
        const v = String(rawVal || '').trim();
        if (!v || v === '-' || v === '없음') return 'none';

        if (key === 'weaponType') {
          // 강타/광채/분쇄/선명
          return v;
        }
        if (v === '선봉') return '분쇄';
        if (v === '의지') return '광채';
        if (v === '이상') return '선명';
        return 'none';
      };

      document.querySelectorAll("[data-uval]").forEach(el => {
        const k = el.getAttribute("data-uval");

        const v = (map[k] && String(map[k]).trim()) ? String(map[k]).trim() : "";
        el.textContent = v ? v : "-";

        // ✅ [data-uval] span의 부모 미니버튼(.equip-u-mini)에 색상 주입
        const mini = el.closest('.equip-u-mini');
        if (mini) {
          mini.dataset.ucolor = mapColor(k, v);
        }
      });
    }


    // ✅ 전역 escapeHTML 보장 (없을 때만 생성)
    if (typeof window.escapeHTML !== 'function') {
      window.escapeHTML = (s) => String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    // ✅ PC의 unique-desc 설명 매핑을 모바일에서도 재사용
    function updateUniqueEffectDescriptionsMobile(rootEl) {
      const root = rootEl || document;

      // PC처럼 custom:list를 소스로 사용
      const customList = window.CORE?.lists?.['custom:list'] || [];
      if (!Array.isArray(customList) || !customList.length) {
        // 데이터가 없으면 설명은 비워둠
        root.querySelectorAll('.unique-desc').forEach(el => el.innerHTML = '');
        return;
      }

      // (모바일 state 구조) 현재 캐릭터의 직업군 라벨
      const jobGroupLabel =
        (window.state?.currentCharacter?.jobGroupLabel)
        || (window.state?.currentCharacter?.jobGroup)
        || '';

      // 간단 escape (PC도 innerHTML 넣기 전에 처리)
      const escapeHTML = window.escapeHTML;

      // ✅ customName(강타/광채/...) → custom:list에서 설명 가져오기 (PC 매칭 방식)
      const pickDescByCustomName = (customName) => {
        const name = (customName || '').trim();
        if (!name || name === '없음') return '';

        const norm = (v) => String(v ?? '').trim();

        const jobGroup = norm(window.state?.currentCharacter?.jobGroupLabel
          ?? window.state?.currentCharacter?.jobGroup
          ?? '');
        const charName = norm(window.state?.currentCharacter?.name ?? '');

        // 1차: type(종류)로 매칭 (PC와 동일)
        let rowsBase = customList.filter(r =>
          norm(r?.type ?? r?.['종류']) === name
        );
        if (!rowsBase.length) return '';

        // 2차: 직업군 + 캐릭명(있으면)까지 맞는 row 우선
        let candidates = rowsBase.filter(r =>
          (!jobGroup || norm(r?.jobGroupLabel ?? r?.jobGroup ?? r?.['직업군']) === jobGroup || !norm(r?.jobGroupLabel ?? r?.jobGroup ?? r?.['직업군'])) &&
          (!charName || norm(r?.name ?? r?.['이름']) === charName || !norm(r?.name ?? r?.['이름']))
        );
        if (!candidates.length) candidates = rowsBase;

        // 3차: num(갯수) 기준 — 모달 설명은 기본 1개 효과를 보여주기 위해 num=1 우선
        const scored = candidates.map(r => {
          const rawNum = norm(r?.num ?? r?.['갯수']);
          const rowNum = rawNum ? (parseInt(rawNum, 10) || 0) : 1;
          return { r, rowNum };
        }).filter(x => x.rowNum > 0);

        let best = scored.find(x => x.rowNum === 1) || scored[0];
        if (!best) return '';

        const r = best.r;
        const parts = [
          r?.desc1, r?.desc2, r?.desc3, r?.desc4, r?.desc5,
          r?.['설명1'], r?.['설명2'], r?.['설명3'], r?.['설명4'], r?.['설명5'],
        ].map(v => norm(v)).filter(Boolean);

        if (!parts.length) return '';

        const raw = parts.join('\n');
        // PC처럼 <br> 처리 + escape
        return raw.includes('<')
          ? raw.replace(/\n/g, '<br>')
          : window.escapeHTML(raw).replace(/\n/g, '<br>');
      };


      // ✅ root 안의 unique-desc 모두 채우기
      root.querySelectorAll('.unique-desc').forEach(descEl => {
        const v = (descEl.dataset.value || '').trim();
        const raw = pickDescByCustomName(v);

        if (!raw) { descEl.innerHTML = ''; return; }

        // PC처럼 "<"가 들어간 경우는 HTML로 취급, 아니면 escape 후 줄바꿈 처리
        descEl.innerHTML = raw.includes('<')
          ? raw
          : escapeHTML(raw).replace(/\n/g, '<br>');
      });
    }

    function openUniquePickModalMobile(targetKey) {
      ensureCustomSkillsMobile();

      const isWeapon = (targetKey === "weaponType");
      const opts = isWeapon
        ? ["강타", "광채", "분쇄", "선명", "없음"]
        : ["선봉", "의지", "이상", "없음"];

      const titleMap = {
        weaponType: "고유효과 (무기)",
        armorType: "고유효과 (상의)",
        braceletType: "고유효과 (팔찌)",
        earringType: "고유효과 (귀걸이)"
      };

      const cur = (state.customSkills[targetKey] || "").trim();
      const $title = document.getElementById("mUniquePickTitle");
      const $list = document.getElementById("mUniquePickList");
      if ($title) $title.textContent = titleMap[targetKey] || "고유효과";

      if ($list) {
        const kind = isWeapon ? "weapon" : "other"; // (설명 매칭용)

        // ✅ (1) 컨테이너에 weapon/other 클래스를 붙여서 CSS 스코프가 매칭되게
        $list.classList.remove("unique-options-weapon", "unique-options-other");
        $list.classList.add(isWeapon ? "unique-options-weapon" : "unique-options-other");

        // ✅ (2) 버튼에 data-value도 같이 넣어서 CSS 셀렉터([data-value="..."])가 먹게
        $list.innerHTML = opts.map(v => {
          const on = (cur === v);
          return `
    <div class="unique-row ${on ? "is-selected" : ""}">
      <button type="button"
              class="unique-btn ${on ? "active" : ""}"
              data-uvalpick="${v}" data-value="${v}">
        ${v}
      </button>
      <div class="unique-desc" data-kind="${kind}" data-value="${v}"></div>
    </div>
  `;
        }).join("");
      }

      const modal = document.getElementById("mUniquePickModal");
      if (modal) {
        modal.dataset.utarget = targetKey;

        // ✅ 추가: PC처럼 unique-desc 실제 텍스트 채우기
        updateUniqueEffectDescriptionsMobile(modal);
      }

      _openModalById_("mUniquePickModal");
    }

    function bindUniquePickModalOnce() {
      const modal = document.getElementById("mUniquePickModal");
      if (!modal || modal.dataset.bound === "1") return;
      modal.dataset.bound = "1";

      modal.addEventListener("click", (e) => {
        // 1) 버튼 클릭이면 그대로
        let btn = e.target.closest("[data-uvalpick]");

        // 2) 버튼이 아니면(= 설명칸 클릭 등) 같은 row의 버튼을 찾아서 대신 선택 처리
        if (!btn) {
          const desc = e.target.closest(".unique-desc");
          if (desc) {
            const row = desc.closest(".unique-row");
            btn = row ? row.querySelector("[data-uvalpick]") : null;
          }
        }

        if (!btn) return;

        ensureCustomSkillsMobile();
        const v = btn.getAttribute("data-uvalpick") || "";
        const targetKey = modal.dataset.utarget;

        if (targetKey) {
          state.customSkills[targetKey] = v;
          syncUniqueMiniLabels();

          // ✅ PC처럼 "선택됨"을 버튼 자체(active)에 부여
          modal.querySelectorAll(".unique-btn.active").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");

          // (선택 강조가 row 기반인 CSS도 같이 쓰는 중이라면 row도 동기화)
          modal.querySelectorAll(".unique-row.is-selected").forEach(r => r.classList.remove("is-selected"));
          const row = btn.closest(".unique-row");
          if (row) row.classList.add("is-selected");
        }

        _closeModalById_("mUniquePickModal");
      });
      // 닫기
      modal.querySelectorAll("[data-mset-close]").forEach(el => {
        el.addEventListener("click", () => _closeModalById_("mUniquePickModal"));
      });
    }

    // ✅ 고유효과 "일괄 적용" 모달: 선택(무기/기타) 바인딩 + 현재 state 반영
    function bindUniqueBulkModalOnce() {
      const modal = document.getElementById('mUniqueBulkModal');
      if (!modal || modal.dataset.bound === "1") return;
      modal.dataset.bound = "1";

      // 버튼/설명 어디를 눌러도 "row" 기준으로 선택되게 + hover 강조를 is-selected로 고정
      modal.addEventListener('click', (e) => {
        const row = e.target.closest('.unique-row');
        if (!row || !modal.contains(row)) return;

        const btn = row.querySelector('.unique-btn');
        const desc = row.querySelector('.unique-desc');
        const kind = desc?.dataset?.kind; // "weapon" | "other"
        if (!btn || !kind) return;

        const val = btn.getAttribute('data-value') || btn.textContent.trim();

        // 같은 kind 내에서 active + is-selected를 "현재 row"로만 고정
        modal.querySelectorAll(`.unique-desc[data-kind="${kind}"]`).forEach(d => {
          const r = d.closest('.unique-row');
          const b = r?.querySelector('.unique-btn');
          const on = (r === row);
          if (b) b.classList.toggle('active', on);
          if (r) r.classList.toggle('is-selected', on);
        });

        // 선택값 저장
        modal.dataset[`sel_${kind}`] = val;
      });

      // 닫기 버튼들
      modal.querySelectorAll('[data-mset-close]').forEach(el => {
        el.addEventListener('click', () => _closeModalById_('mUniqueBulkModal'));
      });
    }

    function syncUniqueBulkModalSelectionFromState() {
      const modal = document.getElementById('mUniqueBulkModal');
      if (!modal) return;

      ensureCustomSkillsMobile();

      // 현재 state를 모달 선택값으로 주입
      const weaponPick = (state.customSkills.weaponType ?? '');
      const otherPick =
        (state.customSkills.armorType || state.customSkills.braceletType || state.customSkills.earringType || '');

      if (weaponPick) modal.dataset.sel_weapon = weaponPick;
      if (otherPick) modal.dataset.sel_other = otherPick;

      // UI active + is-selected 표시(weapon/other만)
      ["weapon", "other"].forEach(kind => {
        const v = modal.dataset[`sel_${kind}`] ?? '';
        modal.querySelectorAll(`.unique-desc[data-kind="${kind}"]`).forEach(desc => {
          const row = desc.closest('.unique-row');
          const btn = row?.querySelector('.unique-btn');
          const val = btn?.getAttribute('data-value') || btn?.textContent?.trim() || '';
          const on = (v !== '' && v === val);

          if (btn) btn.classList.toggle('active', on);
          if (row) row.classList.toggle('is-selected', on);
        });
      });
    }

    /* =========================
       ✅ 익시드/에픽 토글 상태 (Mobile)
    ========================= */
    let armorSetMode = 'exceed'; // 'exceed' | 'epic'

    function updateArmorSetToggleUI_mobile() {
      const ids = ['mArmorSetToggle', 'mAccSetToggle', 'mSpecSetToggle'];
      ids.forEach((id) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.classList.toggle('mode-exceed', armorSetMode === 'exceed');
        el.classList.toggle('mode-epic', armorSetMode === 'epic');
      });
    }

    function setArmorSetMode_mobile(nextMode) {
      armorSetMode = (nextMode === 'epic') ? 'epic' : 'exceed';
      updateArmorSetToggleUI_mobile();

      // ✅ 열려있는 세트 모달이면 즉시 재렌더(익시드/에픽 반영)
      const armorOpen = document.getElementById('mArmorSetModal')?.getAttribute('aria-hidden') === 'false';
      const accOpen = document.getElementById('mAccSetModal')?.getAttribute('aria-hidden') === 'false';
      const specOpen = document.getElementById('mSpecSetModal')?.getAttribute('aria-hidden') === 'false';

      if (armorOpen) renderSetModal_mobile('armor');
      else if (accOpen) renderSetModal_mobile('acc');
      else if (specOpen) renderSetModal_mobile('spec');
    }

    function bindArmorSetTogglesOnce_mobile() {
      const ids = ['mArmorSetToggle', 'mAccSetToggle', 'mSpecSetToggle'];

      ids.forEach((id) => {
        const el = document.getElementById(id);
        if (!el || el.__bound) return;
        el.__bound = 1;

        const toggle = () => {
          setArmorSetMode_mobile(armorSetMode === 'exceed' ? 'epic' : 'exceed');
        };

        el.addEventListener('click', toggle);
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggle();
          }
        });
      });

      updateArmorSetToggleUI_mobile();
    }

    function _getSetGroupTitle_mobile(name) {
      const raw = (name || '').trim();
      if (!raw) return '(기타 세트)';
      // "신속: 그란데 전투기갑 파츠 세트" -> "그란데 전투기갑 파츠 세트"
      if (raw.includes(':')) return raw.split(':').slice(1).join(':').trim() || raw;
      return raw;
    }

    function renderSetModal_mobile(kind) {
      if (typeof updateArmorSetToggleUI_mobile === 'function') updateArmorSetToggleUI_mobile();

      let sets = [];
      let modalId = '';
      let listId = '';

      if (kind === 'armor') {
        modalId = 'mArmorSetModal';
        listId = 'mArmorSetList';
        sets = (typeof buildArmorSetCardsFromSheets === 'function') ? buildArmorSetCardsFromSheets() : [];
      } else if (kind === 'acc') {
        modalId = 'mAccSetModal';
        listId = 'mAccSetList';
        sets = (typeof buildAccSetCardsFromSheets === 'function') ? buildAccSetCardsFromSheets() : [];
      } else if (kind === 'spec') {
        modalId = 'mSpecSetModal';
        listId = 'mSpecSetList';
        sets = (typeof buildSpecSetCardsFromSheets === 'function') ? buildSpecSetCardsFromSheets() : [];
      }

      const box = document.getElementById(listId);
      if (!box) return;

      box.innerHTML = '';

      if (!Array.isArray(sets) || !sets.length) {
        box.innerHTML =
          '<div class="empty-hint" style="padding:16px;font-size:13px;color:#ddd;">세트 데이터를 찾을 수 없습니다.</div>';
        _openModalById_(modalId);
        return;
      }

      const applyAndClose = (s) => {
        applySetPieces_mobile(s);
        _closeModalById_(modalId);
        if (typeof toast === 'function') toast('세트가 적용되었습니다.');
      };

      // ✅ "신속: XXX" / "전격: XXX" 같은 접두를 제거해서 그룹키로 사용
      const _getSetGroupKey_mobile = (setName) => {
        const n = String(setName || '').trim();
        const m = n.match(/^[^:]{1,12}\s*:\s*(.+)$/); // "무언가: 본문" 형태면 본문을 그룹키로
        return (m ? m[1] : n).trim();
      };

      let prevGroupKey = null;

      sets.forEach((s) => {
        const curKey = _getSetGroupTitle_mobile(s?.name);

        if (prevGroupKey !== curKey) {
          const divider = document.createElement('div');
          divider.className = 'armor-set-divider';

          const txt = document.createElement('span');
          txt.className = 'txt';
          txt.textContent = curKey;          // ✅ 예: "그란데 전투기갑 파츠 세트"
          divider.appendChild(txt);

          box.appendChild(divider);
        }
        prevGroupKey = curKey;

        const card = document.createElement('div');
        card.className = 'armor-set-card';

        // header
        const header = document.createElement('div');
        header.className = 'armor-set-header';

        const titleSpan = document.createElement('span');
        titleSpan.textContent = s?.name || '(세트)';
        header.appendChild(titleSpan);

        const applyBtn = document.createElement('button');
        applyBtn.type = 'button';
        applyBtn.className = 'set-auto-toggle';
        applyBtn.textContent = '세트 적용';
        applyBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          applyAndClose(s);
        });
        header.appendChild(applyBtn);

        card.appendChild(header);

        // items
        const items = document.createElement('div');
        items.className = 'armor-set-items';

        (s.pieces || []).forEach((p) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'armor-set-item';
          btn.title = p?.item?.name || p?.name || '';

          // ✅ 아이콘/레벨을 눌러도 "세트 적용"되도록
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            applyAndClose(s);
          });

          const box2 = document.createElement('div');
          box2.className = 'iconbox';

          const img = document.createElement('img');
          img.className = 'icon';
          img.src = p?.img || p?.item?.img || (typeof PLACEHOLDER_I !== 'undefined' ? PLACEHOLDER_I : '');
          img.alt = '';
          box2.appendChild(img);

          const lv = p?.level ?? p?.item?.level ?? null;
          if (lv) {
            const badge = document.createElement('div');
            badge.className = 'badge-lv';
            badge.textContent = String(lv);
            box2.appendChild(badge);
          }

          btn.appendChild(box2);
          items.appendChild(btn);
        });

        card.appendChild(items);
        box.appendChild(card);
      });

      _openModalById_(modalId);
    }


    function wireSetButtons_mobile() {
      const a = document.getElementById('btnMSetArmor');
      const b = document.getElementById('btnMSetAcc');
      const c = document.getElementById('btnMSetSpec');
      const o = document.getElementById('btnMOchingkra');   // ✅ (NEW)
      const d = document.getElementById('btnMUniqueBulk');

      if (a && !a.__bound) { a.__bound = 1; a.addEventListener('click', () => renderSetModal_mobile('armor')); }
      if (b && !b.__bound) { b.__bound = 1; b.addEventListener('click', () => renderSetModal_mobile('acc')); }
      if (c && !c.__bound) { c.__bound = 1; c.addEventListener('click', () => renderSetModal_mobile('spec')); }
      if (o && !o.__bound) { o.__bound = 1; o.addEventListener('click', () => openOchingkraModal_mobile()); }

      if (d && !d.__bound) {
        d.__bound = 1;
        d.addEventListener('click', () => {
          const modal = document.getElementById('mUniqueBulkModal');

          // ✅ 1) 바인딩 보장
          bindUniqueBulkModalOnce();

          // ✅ 2) PC처럼 설명 텍스트 채우기
          if (modal) updateUniqueEffectDescriptionsMobile(modal);

          // ✅ 3) 현재 state 선택값을 모달 active 표시로 동기화
          syncUniqueBulkModalSelectionFromState();

          _openModalById_('mUniqueBulkModal');
        });
      }



      // ✅ 고유효과 일괄 적용 실행(버튼/바깥터치 공용)
      function applyUniqueBulkSelectionFromModal(modal) {
        if (!modal) return;

        ensureCustomSkillsMobile();

        // 모달에서 고른 값(없으면 기존 state 유지)
        const pickWeapon = (modal.dataset.sel_weapon ?? state.customSkills.weaponType ?? '');
        const pickOther =
          (modal.dataset.sel_other ??
            state.customSkills.armorType ??
            state.customSkills.braceletType ??
            state.customSkills.earringType ??
            '');

                // ✅ 실제 적용 (모바일 state 구조)
        state.customSkills.weaponType = pickWeapon;

        // ✅ PC 호환 필드도 같이 채움 (PC는 customSkills.type/weaponName 을 보는 경우가 있음)
        try {
          const _wPick = (String(pickWeapon || '').trim() === '없음') ? '' : String(pickWeapon || '').trim();
          state.customSkills.type = _wPick;
          if (!state.customSkills.weaponName) {
            const _wName = state?.selections?.weapon?.name;
            if (_wName) state.customSkills.weaponName = String(_wName).trim();
          }
        } catch (e) { /* ignore */ }

        state.customSkills.armorType = pickOther;
        state.customSkills.braceletType = pickOther;
        state.customSkills.earringType = pickOther;

        // 소제목 옆 mini 라벨 갱신
        syncUniqueMiniLabels();

        toast?.('고유효과가 적용되었습니다.');
        _closeModalById_('mUniqueBulkModal');
      }

      const applyBtn = document.getElementById('mUniqueBulkApplyBtn');
      if (applyBtn && !applyBtn.__bound) {
        applyBtn.__bound = 1;
        applyBtn.addEventListener('click', () => {
          const modal = document.getElementById('mUniqueBulkModal');
          applyUniqueBulkSelectionFromModal(modal);
        });
      }

      // ✅ 바깥쪽(백드롭) 터치 = '선택 적용'
      const bulkModal = document.getElementById('mUniqueBulkModal');
      const bulkBackdrop = bulkModal?.querySelector('.backdrop[data-unique-bulk-apply]');
      if (bulkBackdrop && !bulkBackdrop.__boundApply) {
        bulkBackdrop.__boundApply = 1;
        bulkBackdrop.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const modal = document.getElementById('mUniqueBulkModal');
          applyUniqueBulkSelectionFromModal(modal);
        }, true);
      }

      // ✅ 여기 1줄 추가
      bindArmorSetTogglesOnce_mobile();
    }

    /* ✅ page init / DOMContentLoaded / resetAll() 이후 한 번 호출 */
    wireSetButtons_mobile();
    syncUniqueMiniLabels();



    /* ✅ 개별 고유효과(소제목 옆) 버튼 클릭 */
    document.getElementById('pageEquip')?.addEventListener('click', (e) => {
      const u = e.target?.closest?.('.equip-u-mini');
      if (!u) return;

      e.preventDefault();
      e.stopPropagation();

      const targetKey = u.getAttribute('data-utarget');
      if (!targetKey) return;

      bindUniquePickModalOnce();       // 모달 내부 클릭/닫기 바인딩 보장
      openUniquePickModalMobile(targetKey);
    }, true);


    // ✅ 장비 슬롯 클릭 → 장비 선택 (equip-row + oca-item 모두 지원)
document.getElementById('pageEquip')?.addEventListener('click', async (e) => {
  const btn = e.target?.closest?.('.oca-item, .equip-row');
  if (!btn) return;

  const slot = btn.getAttribute('data-slot');
  if (!slot) return;

  try {
    await openEquipPicker(slot);
  } catch (err) {
    console.error(err);
    toast('장비 목록을 불러오지 못했습니다.');
  }
});

    // ✅ 무기 상단 자동 입력 버튼(PC버전 동일 기능 연결)
    document.getElementById('btnWeaponAutoEnh')?.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openAutoEnhModal_mobile();
    });
    document.getElementById('btnWeaponAutoSeal')?.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openAutoSealModal_mobile();
    });
    document.getElementById('btnWeaponAutoEnchant')?.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openAutoEnchantModal_mobile();
    });
    document.getElementById('btnWeaponAutoEmblem')?.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openAutoEmblemModal_mobile();
    });

    // ===== Main actions (placeholders) =====
    document.getElementById('btnPickChar')?.addEventListener('click', async () => {
      try {
        await openMobileCharacterPicker();
      } catch (e) {
        console.error(e);
        toast('캐릭터 목록을 불러오지 못했습니다.');
      }
    });

    document.getElementById('btnContactSend')?.addEventListener('click', async () => {
  const ta = document.getElementById('contactTalk');
  const talk = String(ta?.value || '').trim();

  if (!talk) {
    toast('문의 내용을 입력해주세요.');
    ta?.focus();
    return;
  }
  if (talk.length < 5) {
    toast('문의 내용은 5자 이상 입력해주세요.');
    ta?.focus();
    return;
  }

  try {
    const res = await apiJSON('contact_admin', { talk });
    if (!res?.ok) throw new Error(res?.error || 'contact_fail');

    toast('문의가 전송되었습니다. 최대한 빠르게 답변 드리도록 하겠습니다 !');
    if (ta) ta.value = '';
    closeModal('contactModal');
  } catch (e) {
    console.error(e);
    toast('문의 전송에 실패했습니다. 잠시 후 다시 시도해주세요.');
  }
});


    // ============================================================
    // ✅ PC판과 동일한 calc_all payload 구성 (모바일 스냅샷 → 백코드 세션 반영)
    // - 장비: state.selections
    // - 강화: state.enh
    // - 고유옵션/일반옵션: state.seals.unique / state.seals.general1  (PC의 seals 구조 유지)
    // - 마법부여: state.enchants
    // - 엠블렘: state.emblems
    // ============================================================
    async function saveSkillSelectionsMobile() {
      const s = window.state || {};

      // 1) ownerKey 계산 (PC와 동일 로직)
      let ownerKey = '';
      if (s.currentCharacter) {
        const jg = String(s.currentCharacter.jobGroupLabel || s.currentCharacter.jobGroup || '').trim();
        const nm = String(s.currentCharacter.name || s.currentCharacter.charName || '').trim();
        if (jg || nm) ownerKey = (jg + nm).replace(/\s+/g, '');
      }
      if (!ownerKey) ownerKey = String(s.CurrentSumStats?.ownerKey || s.ownerKey || '').trim();
      if (!ownerKey) throw new Error('missing_owner');

      // state에도 캐시(다음 호출들에서 재사용)
      s.ownerKey = ownerKey;

      // 2) 모바일 skillTrees -> skills 배열로 변환 (PC가 보내는 형태)
      // Page4와 동일하게 "ownerKey(=charKey)"로 읽어야 한다
      const charKey = String(s.currentCharacter?.ownerKey || ownerKey || '').trim().replace(/\s+/g, '');
      const tree = (s.skillTrees && charKey && s.skillTrees[charKey]) ? s.skillTrees[charKey] : {};

      const skills = [];
      for (const [name, v] of Object.entries(tree)) {
        const lv = Number(v?.spLv ?? 0);
        const tp = Number(v?.tpLv ?? 0);
        // lv/tp 둘 중 하나라도 있으면 보내기 (tp만 찍는 케이스 방어)
        if (lv > 0 || tp > 0) skills.push({ name, lv, tp });
      }

      // ✅ 핵심: byName이 아니라 skills 배열로 보낸다 (PC 동일)
      const res = await apiJSON('skill_state_set', { ownerKey, skills });
      if (!res?.ok) throw new Error(res?.message || res?.error || 'skill_state_set_failed');
      return res;
    }


    async function simulateSkillUsageMobile() {
      const s = window.state || {};

      // ownerKey 확보 (saveSkillSelectionsMobile에서 캐시된 값 우선)
      let ownerKey = String(s.ownerKey || s.CurrentSumStats?.ownerKey || '').trim();
      if (!ownerKey && s.currentCharacter) {
        const jg = String(s.currentCharacter.jobGroupLabel || s.currentCharacter.jobGroup || '').trim();
        const nm = String(s.currentCharacter.name || s.currentCharacter.charName || '').trim();
        ownerKey = (jg + nm).replace(/\s+/g, '');
      }
      if (!ownerKey) throw new Error('missing_owner');

      const timeKey = String(s.timeKey || '180');

      // ✅ 와일드베인 / 윈드시어 스킬트리 선택값도 함께 전송(백엔드 uses 계산에 반영)
      const isWB = (ownerKey === '워리어와일드베인');
      const isWS = (ownerKey === '워리어윈드시어');

      const extra = {};
      if (isWB) {
        const preset = String(s.wildbaneTreePreset || '파파초').trim() || '파파초';
        const cycle = Number.isFinite(+s.wildbaneCycleCount) ? Math.max(0, Math.floor(+s.wildbaneCycleCount)) : 0;

        extra.wildbaneTreePreset = preset;
        extra.wbTree = preset; // 호환용
        extra.wildbaneCycleCount = cycle;
        extra.wbCycleCount = cycle; // 호환용
      }
      if (isWS) {
        const preset = String(s.windshearTreePreset || '파파초').trim() || '파파초';
        const cycle = Number.isFinite(+s.windshearCycleCount) ? Math.max(0, Math.floor(+s.windshearCycleCount)) : 0;

        extra.windshearTreePreset = preset;
        extra.wsTree = preset; // 호환용
        extra.windshearCycleCount = cycle;
        extra.wsCycleCount = cycle; // 호환용
      }

      const res = await apiJSON('skill_uses', {
        ownerKey,
        window: timeKey,
        wantDbg: false,
        ...extra,
      });

      if (!res?.ok) throw new Error(res?.message || res?.error || 'skill_uses_failed');
      return res;
    }

    function buildCalcAllPayloadMobile() {
      const s = window.state || {};
      const c = s.currentCharacter || {};

      const charPayload = {
        name: String(c.name || c.charName || '').trim(),
        jobGroup: String(c.jobGroup || c.jobGroupLabel || '').trim(),
        sp: Number(c.sp ?? 0) || 0,
        tp: Number(c.tp ?? 0) || 0,
        power: String(c.power ?? '').trim(),
      };

      // 최소 유효성(백엔드 calc_all 에서 missing_char 체크)
      if (!charPayload.name || !charPayload.jobGroup) {
        throw new Error('missing_char');
      }

      // 1) equip
      const equipPayload = {};
      const sel = s.selections || {};
      for (const [slotKey, info] of Object.entries(sel)) {
        const name = String(info?.name || '').trim();
        if (!name) continue;
        equipPayload[slotKey] = {
          name,
          code: info?.code || '',
        };
      }

      // 2) enh
      const enhPayload = {};
      const enh = s.enh || {};
      for (const [slotKey, up] of Object.entries(enh)) {
        const name = String(up?.name || '').trim();
        if (!name) continue;
        enhPayload[slotKey] = {
          name,
          type: up?.type || '',
          level: up?.level ?? null,
        };
      }

      // 3) seals (모바일: 고유옵션/일반옵션 → PC: unique/general1)
      const sealPayload = {};
      const seals = s.seals || {};
      for (const [slotKey, sv] of Object.entries(seals)) {
        if (!sv) continue;
        const uniqueName = String(sv.unique?.name || sv.unique || '').trim();
        const general1Name = String(sv.general1?.name || sv.general1 || '').trim();
        if (!uniqueName && !general1Name) continue;
        sealPayload[slotKey] = {
          unique: uniqueName || null,
          general1: general1Name || null,
        };
      }

      // 4) enchants
      const enchantPayload = {};
      const enchants = s.enchants || {};
      for (const [slotKey, eInfo] of Object.entries(enchants)) {
        const name = String(eInfo?.name || '').trim();
        if (!name) continue;
        enchantPayload[slotKey] = {
          name,
          enchType: eInfo?.typeKey || eInfo?.enchType || '',
        };
      }

      // 5) emblems
      const emblemPayload = {};
      const emState = s.emblems || {};
      for (const [slotKey, arr] of Object.entries(emState)) {
        if (!Array.isArray(arr)) continue;
        const mapped = arr.map(e => {
          const name = String(e?.name || '').trim();
          if (!name) return null;

          // ✅ 모바일 state는 케이스에 따라 levelVal 대신 tag/level에 들어있을 수 있음(특히 플래티넘)
          const type = String(e?.type || e?.typeKey || '').trim();
          const levelVal = String(
            (e?.levelVal ?? e?.tag ?? e?.level ?? '')
          ).trim();

          return {
            name,
            levelVal,   // ✅ 서버가 찾는 키는 levelVal이므로 여기로 강제
            type,
          };
        });
        if (mapped.some(x => x)) emblemPayload[slotKey] = mapped;
      }

      // 6) refines(연마) - 모바일이 이미 쓰고 있으면 그대로 전송
      const refinePayload = {};
      const refState = s.refines || {};
      for (const [slotKey, info] of Object.entries(refState)) {
        const name = String(info?.name || '').trim();
        if (!name) continue;
        refinePayload[slotKey] = {
          name,
          refineType: info?.refineType || '',
        };
      }

      // 최종 payload (PC 방식 그대로)
      const payload = { char: charPayload };
      if (Object.keys(equipPayload).length) payload.equip = equipPayload;
      if (Object.keys(enhPayload).length) payload.enh = enhPayload;
      if (Object.keys(sealPayload).length) payload.seals = sealPayload;
      if (Object.keys(enchantPayload).length) payload.enchants = enchantPayload;
      if (Object.keys(emblemPayload).length) payload.emblems = emblemPayload;
      if (Object.keys(refinePayload).length) payload.refines = refinePayload;

      // ✅ 7) Page3 옵션들(아바타/무기압, 시간/몬스터, 룬각인, 성안의 봉인, 스킬룬)
      const s3 = window.state || {};

      // 아바타 / 무기압
      if (s3.avatarSel && (s3.avatarSel.avatarName || s3.avatarSel.imprintName)) {
        payload.avatar = {
          avatarName: String(s3.avatarSel.avatarName || '').trim(),
          imprintName: String(s3.avatarSel.imprintName || '').trim(),
        };
      }

      // 시간 기준 / 몬스터
      if (s3.timeKey) payload.window = String(s3.timeKey || '').trim();      // 예: '1m'
      if (s3.monsterName) payload.monsterName = String(s3.monsterName || '').trim();

      // 룬 각인
      if (s3.runeEngrave && typeof s3.runeEngrave === 'object') {
        // 너 state 구조가 {type:'룬각인', name:'', level:''}라면 그대로 전달
        if (s3.runeEngrave.name && s3.runeEngrave.level) {
          payload.runeEngrave = {
            type: '룬각인',
            name: String(s3.runeEngrave.name || '').trim(),
            level: String(s3.runeEngrave.level || '').trim(),
          };
        }
      }

      // 성안의 봉인
      if (s3.castleSeal && typeof s3.castleSeal === 'object') {
        if (s3.castleSeal.mainName || s3.castleSeal.subName) {
          payload.castleSeal = {
            mainName: String(s3.castleSeal.mainName || '').trim(),
            subName: String(s3.castleSeal.subName || '').trim(),
          };
        }
      }

      // ✅ 고유효과(커스텀옵) - PC처럼 calc_all payload에 실어 보내야 서버 세션에 반영됨
      // (state.customSkills 구조는 너가 모달에서 이미 채우고 있는 그대로 전달)
      if (s.customSkills && typeof s.customSkills === 'object') {
        // structuredClone이 없을 수 있으니 안전하게 처리
        const cs = (typeof structuredClone === 'function')
          ? structuredClone(s.customSkills)
          : JSON.parse(JSON.stringify(s.customSkills));

        // ✅ 핵심: 모바일은 weaponType에 저장하지만,
        // 백엔드는 (customType/type/kind) 중 하나로 무기 고유효과를 읽는다.
        const hasBackendWeaponKey =
          (typeof cs.customType === 'string' && cs.customType.trim()) ||
          (typeof cs.type === 'string' && cs.type.trim()) ||
          (typeof cs.kind === 'string' && cs.kind.trim());

        if (!hasBackendWeaponKey && typeof cs.weaponType === 'string') {
          cs.type = cs.weaponType;   // ← 이 1줄이 무기 고유효과 적용의 핵심
        }

        payload.customSkills = cs;
      }


      // 스킬룬 (나중에 모달 붙이면 state에 채워질 구조 그대로 전달)
      if (s3.runes && typeof s3.runes === 'object') {
        payload.runes = s3.runes;
      }
      if (s3.specialRunes && typeof s3.specialRunes === 'object') {
        payload.specialRunes = {
          gaho: Number(s3.specialRunes.gaho || 0),
          jihe: Number(s3.specialRunes.jihe || 0),
          waegok: Number(s3.specialRunes.waegok || 0),
        };
      }

            // ✅ 워리어 와일드베인/윈드시어: 스킬트리 선택값 포함(백엔드 세션/uses 계산에 반영)
      const ownerKeyNow = String(s.ownerKey || s.CurrentSumStats?.ownerKey || '').trim()
        || (String(charPayload.jobGroup || '').trim() + String(charPayload.name || '').trim()).replace(/\s+/g, '');

      if (ownerKeyNow === '워리어와일드베인') {
        const preset = String(s.wildbaneTreePreset || '파파초').trim() || '파파초';
        const cycle = Number.isFinite(+s.wildbaneCycleCount) ? Math.max(0, Math.floor(+s.wildbaneCycleCount)) : 0;

        payload.wildbaneTreePreset = preset;
        payload.wbTree = preset; // 호환용
        payload.wildbaneCycleCount = cycle;
        payload.wbCycleCount = cycle; // 호환용
      } else if (ownerKeyNow === '워리어윈드시어') {
  const preset = String(s.windshearTreePreset || 'A').trim() || 'A';
  const cycle = Number.isFinite(+s.windshearCycleCount) ? Math.max(0, Math.floor(+s.windshearCycleCount)) : 0;

  payload.windshearTreePreset = preset;
  payload.wsTree = preset; // 호환용
  payload.windshearCycleCount = cycle;
  payload.wsCycleCount = cycle; // 호환용
}
      return payload;
    }

    // (디버그) 현재 스냅샷을 콘솔에서 바로 확인하고 싶을 때
    window.__buildCalcAllPayloadMobile = buildCalcAllPayloadMobile;

    let __mobileComputing = false;

    document.getElementById('btnMobileCompute')?.addEventListener('click', async () => {
      if (__mobileComputing) return;
      __mobileComputing = true;

      const btn = document.getElementById('btnMobileCompute');
      const out = document.getElementById('mobileFinalDamage');

      const prevBtnText = btn?.textContent || '계산하기';

      // ✅ 1) 즉시 UI 반영 (PC처럼)
      if (btn) btn.disabled = true;
      if (btn) btn.textContent = '계산중…';
      if (out) out.textContent = '계산중입니다…';

      try {
        // 0) payload 구성
        const payload = buildCalcAllPayloadMobile();
        window.state = window.state || {};
        window.state.lastCalcAllPayload = payload;

        // 1) 장비/옵션/아바타/룬각인/시간기준/몬스터 등 세션 반영
        const resCalc = await apiJSON('calc_all', { payload, p: null });
        if (!resCalc?.ok) throw new Error(resCalc?.message || resCalc?.error || 'calc_all_failed');

        // 2) (선택) sum_stats로 세션 정리/확인
        const sum = await apiJSON('sum_stats', { wantDbg: false });

        if (!sum?.ok) {
          console.warn('[MOBILE sum_stats fail]', sum);
          // ❗sum_stats가 실패해도 다음 단계 진행은 하되, CurrentSumStats는 최소 객체로 보장
          window.state.CurrentSumStats = window.state.CurrentSumStats || {};
        } else {
          // ✅ 플래티넘 엠블렘 등 특정 케이스에서 sum.sum이 비어오는 경우 방어
          if (sum.sum && typeof sum.sum === 'object') {
            window.state.CurrentSumStats = sum.sum; // 정상
          } else {
            console.warn('[MOBILE sum_stats ok but missing sum.sum]', sum);
            window.state.CurrentSumStats = window.state.CurrentSumStats || {};
          }
        }

        // 3) ✅ 스킬 상태 저장 (skill_state_set)
        await saveSkillSelectionsMobile();

        // 4) ✅ 스킬 사용횟수 시뮬레이션 (skill_uses)
        const uses = await simulateSkillUsageMobile();
        window.state.lastSkillUses = uses;

        // 5) ✅ 최종 compute
        const s = window.state || {};
        const timeKey = String(s.timeKey || '180');
        // ✅ 몬스터는 "현재 드롭다운 선택(monsterName)"을 항상 최우선으로 사용
//    (PC프리셋에서 넘어온 s.monster 객체가 남아 있으면 변경이 무시되는 문제 방지)
const monster = (s.monsterName ? { name: String(s.monsterName).trim() } : (s.monster || null));

        const resCompute = await apiJSON('compute', {
          p: null,
          window: timeKey,
          monster,
        });

        if (!resCompute?.ok) throw new Error(resCompute?.message || resCompute?.error || 'compute_failed');

        const total = Number(resCompute.total || 0);
        document.getElementById('mobileFinalDamage').textContent = Math.floor(total).toLocaleString();

        toast('계산 완료!');
        console.log('[MOBILE calc_all payload]', payload);
        console.log('[MOBILE skill_uses]', uses);
        console.log('[MOBILE compute]', resCompute);

      } catch (e) {
        console.error(e);
        document.getElementById('mobileFinalDamage').textContent = '-';
        toast('계산 실패: ' + String(e?.message || e || ''));
      }
      finally {
        // ✅ 3) 반드시 원복
        if (btn) {
          btn.disabled = false;
          btn.textContent = prevBtnText;
        }
        __mobileComputing = false;
      }
    });


    /* ===== Auto Input (PC 동일 기능) ===== */

    function _showModal_mobile(id) {
  openModal(id);
}
function _hideModal_mobile(id) {
  closeModal(id);
}

    function _wireModalClose_mobile(id) {
      const m = document.getElementById(id);
      if (!m || m.__wiredClose) return;
      m.__wiredClose = true;
      m.addEventListener('click', (e) => {
        const t = e.target;
        if (t && (t.matches('[data-close]') || t.closest?.('[data-close]'))) {
          e.preventDefault();
          _hideModal_mobile(id);
        }
      });
    }
function openOchingkraModal_mobile() {
  _wireModalClose_mobile('ochingkraModal');
  _wireOchingkraClicks_mobile();
  _showModal_mobile('ochingkraModal');
}
function scrollToOchingkraSection_mobile() {
  // 오칭크아 실제 영역: 칭호 row + 오라/크리쳐/아티팩트 묶음 row
  const target =
    document.querySelector('#pageEquip .equip-row[data-slot="title"]') ||
    document.querySelector('#pageEquip .equip-oca-row') ||
    document.getElementById('btnMOchingkra');

  if (!target) return;

  // ✅ target에서 가장 가까운 "진짜 스크롤 부모" 찾기
  let scroller = target.parentElement;
  while (scroller && scroller !== document.body) {
    const st = getComputedStyle(scroller);
    const oy = st.overflowY;
    if ((oy === 'auto' || oy === 'scroll') && scroller.scrollHeight > scroller.clientHeight + 1) {
      break;
    }
    scroller = scroller.parentElement;
  }
  if (!scroller || scroller === document.body) scroller = document.scrollingElement || document.documentElement;

  // ✅ scroller 기준으로 offsetTop 계산
  const top = target.offsetTop - 12;

  if (typeof scroller.scrollTo === 'function') {
    scroller.scrollTo({ top: Math.max(0, top), behavior: 'smooth' });
  } else {
    scroller.scrollTop = Math.max(0, top);
  }

  // (선택) 스크롤 후 오칭크아 첫 버튼에 포커스
  const focusEl = document.querySelector('#pageEquip .equip-oca-row .oca-item') || target;
  if (focusEl && typeof focusEl.focus === 'function') {
    setTimeout(() => { try { focusEl.focus(); } catch(e) {} }, 150);
  }
}

function _wireOchingkraClicks_mobile() {
  const modal = document.getElementById('ochingkraModal');
  if (!modal) return;

  // 중복 바인딩 방지
  if (modal.__ochingkraBound) return;
  modal.__ochingkraBound = true;

  modal.addEventListener('click', async (e) => {
    const btn = e.target.closest('[data-och-tier]');
    if (!btn) return;

    const tier = btn.getAttribute('data-och-tier') || '';
    _hideModal_mobile('ochingkraModal');

    // 직접입력: 모달 닫고 ✅ 오칭크아 위치로 이동
if (tier === '__manual__') {
  // 모달 닫힘/레이아웃 반영 후 스크롤 (2프레임 기다리면 안정적)
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      scrollToOchingkraSection_mobile();
    });
  });
  return;
}


    try {
      await applyOchingkraAuto_mobile(tier);
    } catch (err) {
      console.error(err);
      toast?.('오칭크아 자동 입력 중 오류가 발생했습니다.');
    }
  });
}

async function applyOchingkraAuto_mobile(tierText) {
  // ✅ 리스트가 아직 안 들어온 상태일 수 있으니 경량리스트 보장
  if (typeof initMobileAllLightListsOnce === 'function') {
    await initMobileAllLightListsOnce();
  }

  const slots = ['title', 'aura', 'creature', 'artifact'];
  const miss = [];

  for (const slot of slots) {
    const key =
      (typeof _equipListKey === 'function') ? _equipListKey(slot) : `${slot}:list`;

    const list =
      (window.CORE?.lists?.[key]) ||
      (window.CORE?.lists?.[`${slot}:list`]) ||
      [];

    if (!Array.isArray(list) || !list.length) {
      miss.push(slot);
      continue;
    }

    const found = list.find(it => {
      const r = String(it?.rarity ?? it?.Rarity ?? it?.['레어리티'] ?? '').trim();
      // ✅ “선택지 텍스트” ↔ “rarity 컬럼” 비교
      return r === String(tierText ?? '').trim();

    });

    if (!found) {
      miss.push(slot);
      continue;
    }

    // ✅ UI/상태 반영 (image/name 방어적으로 보정)
    const it = { ...found };
    it.name = String(it.name || it['이름'] || '').trim();
    it.image = String(it.image || it.img || it['이미지'] || '').trim();

    window.state = window.state || {};
    window.state.equips = window.state.equips || {};
    window.state.selections = window.state.selections || {};

    window.state.equips[slot] = it;
    const _img = _normImg(it?.image || it?.img || it?.['이미지'] || '');
window.state.selections[slot] = {
  name: it.name,
  code: (it.code || it['코드'] || ''),
  img: _img,
};
    applyPickedEquipUI(slot, it);
  }

  // ✅ 결과 안내(선택)
  if (miss.length === slots.length) {
    toast?.(`'${tierText}' 레어리티 장비를 찾지 못했습니다.`);
  } else if (miss.length) {
    const label = (s) => (window.EQUIP_SLOT_LABELS?.[s] || s);
    toast?.(`'${tierText}' 일부 적용됨 (미적용: ${miss.map(label).join(', ')})`);
  } else {
    toast?.(`'${tierText}' 오칭크아 자동 적용 완료`);
  }
}


    function openAutoEnhModal_mobile() {
      _wireModalClose_mobile('autoEnhModal');
      _buildAutoEnhButtons_mobile();
      _showModal_mobile('autoEnhModal');
    }
    function openAutoSealModal_mobile() {
      _wireModalClose_mobile('autoSealModal');
      _wireAutoSealClicks_mobile();
      _showModal_mobile('autoSealModal');
    }
    function openAutoEnchantModal_mobile() {
      _wireModalClose_mobile('autoEnchantModal');
      renderAutoEnchantChoices_mobile();
      _showModal_mobile('autoEnchantModal');
    }
    function openAutoEmblemModal_mobile() {
      _wireModalClose_mobile('autoEmblemModal');
      renderAutoEmblemChoices_mobile();
      _showModal_mobile('autoEmblemModal');
    }

    /* --- Auto Enhance --- */
    function _buildAutoEnhButtons_mobile() {
      const wrap = document.getElementById('autoEnhList');
      if (!wrap || wrap.__built) return;
      wrap.__built = true;
      wrap.innerHTML = '';
      for (let lv = 12; lv <= 20; lv++) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'opt-btn';
        b.textContent = `${lv}강`;
        b.addEventListener('click', async () => {
          b.disabled = true;
          try {
            await autoEnhanceApply_mobile(lv);
          } finally {
            b.disabled = false;
          }
          _hideModal_mobile('autoEnhModal');
        });
        wrap.appendChild(b);
      }
    }
    function _findEnhOptByLevel_mobile(typeKey, lv) {
      const list = (window.DBEnh?.byType?.[String(typeKey).trim()] || []);
      if (!list.length) return null;
      const target = Number(lv) || 0;

      // 1) level_num/level 추출
      let hit = list.find(o => Number(o?.level_num ?? o?.level) === target);
      if (hit) return hit;

      // 2) name에 숫자 포함
      const re = new RegExp(`(^|\\D)${target}(\\D|$)`);
      hit = list.find(o => re.test(String(o?.name || '')));
      if (hit) return hit;

      // 3) 마지막 폴백
      return list[list.length - 1] || null;
    }
    async function autoEnhanceApply_mobile(level) {
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      window.state = window.state || {};
      state.enh = state.enh || {};

      const slots = ['weapon', 'headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring', 'sub', 'magestone', 'earring'];

      for (const slot of slots) {
        const typeKey = (typeof _enhTypeForSlot_mobile === 'function') ? _enhTypeForSlot_mobile(slot) : null;
        if (!typeKey) continue;

        const opt = _findEnhOptByLevel_mobile(typeKey, level);
        if (!opt) continue;

        state.enh[slot] = { name: String(opt.name || '').trim(), type: String(opt.type || typeKey).trim(), level: Number(level) || 0 };

        // UI sync
        if (typeof _syncEnhLabelFromState_mobile === 'function') _syncEnhLabelFromState_mobile(slot);
        if (typeof syncEnhTopbarLabel_mobile === 'function') syncEnhTopbarLabel_mobile(slot);
      }
    }

    /* --- Auto Seal (추천 마법봉인) --- */
    const _AUTO_ELEM_KOR = { fire: '화', water: '수', light: '명', dark: '암' };

    function _jobGroupKeyFromState_mobile() {
      const s = window.state || {};
      const p = String(s?.currentCharacter?.power ?? '').trim();

      // PC판과 동일하게 power를 '물리'/'마법'으로 정규화
      if (p === 'mag' || p === '마법' || p === 'magic') return '마법';
      if (p === 'phys' || p === '물리' || p === 'physical') return '물리';

      // 안전장치: base['물마공']도 확인
      const basePM = String(s?.currentCharacter?.base?.['물마공'] ?? '').trim();
      if (basePM === '마법') return '마법';
      if (basePM === '물리') return '물리';

      // 마지막 기본값
      return '물리';
    }
    function _parseJobFlags_mobile(s) {
      const t = String(s ?? '').toLowerCase().replace(/\s+/g, '');
      const phys = /(물리|물공)/.test(t);
      const magic = /(마법|마공)/.test(t);
      const both = phys && magic;
      const common = /공용|모두|all/.test(t);
      return { phys, magic, both, common };
    }
    function _getJobGroupText_mobile(it) {
      return String(
        it?._raw?.jobGroup ??
        it?._raw?.['직업군'] ??
        it?.raw?.jobGroup ??
        it?.raw?.['직업군'] ??
        it?.jobGroup ?? ''
      ).trim();
    }

    function findSealOption_mobile(typeKey, { jobKey, elemKor }) {
      const key = String(typeKey || '').trim();
      if (!key) return null;

      let list = (window.DBEnh?.byType?.[key] || []).slice();
      if (!list.length && Array.isArray(window.DBEnh?.list)) {
        list = window.DBEnh.list.filter(o => String(o?.type || '').trim() === key);
      }
      if (!list.length) return null;

      const isAcc = key.startsWith('악세');
      if (isAcc) {
        // ✅ 악세는 속성(화/수/명/암) "정확히 일치"로 찾는 게 맞음
        for (const it of list) {
          const v = _getJobGroupText_mobile(it);
          if (v === String(elemKor || '').trim()) return it;
        }
        return null;
      }

      // ✅ 비악세(무기/방어/보장): PC판과 동일하게 "물리/마법/공용" 포함 규칙
      const wantPhys = jobKey === '물리';
      const wantMagic = jobKey === '마법';

      // 1) 우선: 물리/마법(또는 물리마법) 포함
      for (const it of list) {
        const v = _getJobGroupText_mobile(it);
        const f = _parseJobFlags_mobile(v);
        if (wantPhys && (f.phys || f.both)) return it;
        if (wantMagic && (f.magic || f.both)) return it;
      }

      // 2) 다음: 공용
      for (const it of list) {
        const v = _getJobGroupText_mobile(it);
        if (_parseJobFlags_mobile(v).common) return it;
      }

      // 3) 마지막: 직업군 미표기(빈칸)
      for (const it of list) {
        const v = _getJobGroupText_mobile(it);
        if (!v) return it;
      }

      return null;
    }

    async function applyAutoSeal_mobile(elementKey) {
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const elemKor = _AUTO_ELEM_KOR[elementKey] || '';
      const jobKey = _jobGroupKeyFromState_mobile();

      window.state = window.state || {};
      state.seals = state.seals || {};

      const slots = ['weapon', 'headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring', 'sub', 'magestone', 'earring'];

      for (const slot of slots) {
        const types = (typeof _sealTypeKeysForSlot_mobile === 'function') ? _sealTypeKeysForSlot_mobile(slot) : null;
        if (!types) continue;

        const pickU = findSealOption_mobile(types.u, { jobKey, elemKor });
        const pickG = findSealOption_mobile(types.g, { jobKey, elemKor });
        if (!pickU || !pickG) continue;

        state.seals[slot] = {
          unique: { name: String(pickU.name || '').trim(), typeKey: String(pickU.type || types.u).trim() },
          general1: { name: String(pickG.name || '').trim(), typeKey: String(pickG.type || types.g).trim() },
        };

        if (typeof _syncSealLabelFromState_mobile === 'function') _syncSealLabelFromState_mobile(slot);
        if (typeof syncSealTopbarLabel_mobile === 'function') syncSealTopbarLabel_mobile(slot);
      }

      _hideModal_mobile('autoSealModal');
    }

    function _wireAutoSealClicks_mobile() {
      const m = document.getElementById('autoSealModal');
      if (!m || m.__wiredSeal) return;
      m.__wiredSeal = true;
      m.querySelectorAll('[data-ele]').forEach(btn => {
        btn.addEventListener('click', () => {
          const k = String(btn.dataset.ele || '').trim();
          if (!k) return;
          applyAutoSeal_mobile(k);
        });
      });
    }

    /* --- Auto Enchant --- */
    const autoEnchantState_mobile = { attr: null, tier: null };

    function _updateAutoEnchantConfirmBtn_mobile() {
      const btn = document.getElementById('autoEnchantConfirmBtn');
      if (!btn) return;
      const ready = !!(autoEnchantState_mobile.attr && autoEnchantState_mobile.tier);
      btn.disabled = !ready;
    }

    function _bindAutoEnchantConfirmBtn_mobile() {
      const btn = document.getElementById('autoEnchantConfirmBtn');
      if (!btn || btn.__bound) return;
      btn.__bound = true;

      btn.addEventListener('click', async () => {
        if (!(autoEnchantState_mobile.attr && autoEnchantState_mobile.tier)) return;

        btn.disabled = true;
        try {
          await applyAutoEnchant_mobile(autoEnchantState_mobile.attr, autoEnchantState_mobile.tier);
          _hideModal_mobile('autoEnchantModal'); // ✅ 확인 누를 때만 닫힘
        } catch (e) {
          console.error(e);
          toast('추천 마법부여 자동 입력 실패');
        } finally {
          _updateAutoEnchantConfirmBtn_mobile();
        }
      });
    }

    function _updateAutoEmblemConfirmBtn_mobile() {
      const btn = document.getElementById('autoEmblemConfirmBtn');
      if (!btn) return;
      const ready = !!(autoEmblemState_mobile.attr && autoEmblemState_mobile.stage);
      btn.disabled = !ready;
    }

    function _bindAutoEmblemConfirmBtn_mobile() {
      const btn = document.getElementById('autoEmblemConfirmBtn');
      if (!btn || btn.__bound) return;
      btn.__bound = true;

      btn.addEventListener('click', async () => {
        if (!(autoEmblemState_mobile.attr && autoEmblemState_mobile.stage)) return;

        btn.disabled = true;
        try {
          await autoEmblemApply_mobile(autoEmblemState_mobile.attr, autoEmblemState_mobile.stage);
          _hideModal_mobile('autoEmblemModal'); // ✅ 확인 누를 때만 닫힘
        } catch (e) {
          console.error(e);
          toast('엠블렘 자동 입력 실패');
        } finally {
          _updateAutoEmblemConfirmBtn_mobile();
        }
      });
    }

    function _normTier_mobile(t) {
      const s = String(t || '').replace(/\s+/g, '').trim();
      if (!s) return '종결';
      if (s.includes('준')) return '준결';
      if (s.includes('종결')) return '종결';
      if (s.includes('보통')) return '보통';
      if (s.includes('가성비')) return '가성비';
      return s;
    }
    function _findEnchant_mobile(typeKey, keyword) {
      const list = (window.DBEnh?.byType?.[String(typeKey).trim()] || []);
      const kw = String(keyword || '').trim();
      if (!list.length || !kw) return null;
      const N = (v) => String(v ?? '').replace(/\s+|-/g, '').replace(/[()]/g, '').trim();
      const kwN = N(kw);

      const getJobGroupText = (o) => {
        return String(o?._raw?.jobGroup ?? o?._raw?.['직업군'] ?? o?._raw?.['조건'] ?? o?.raw?.jobGroup ?? o?.jobGroup ?? '').trim();
      };

      let hit = list.find(o => N(getJobGroupText(o)).includes(kwN));
      if (hit) return hit;

      hit = list.find(o => N(String(o?.name || '')).includes(kwN));
      return hit || null;
    }

    async function applyAutoEnchant_mobile(attrPicked, tierPicked) {
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const attr = String(attrPicked || '').trim(); // '화속성'
      const tier = _normTier_mobile(tierPicked);

      window.state = window.state || {};
      state.enchants = state.enchants || {};

      const targets = [
        { slot: 'weapon', needAttr: true },
        { slot: 'title', needAttr: false },
        { slot: 'bracelet', needAttr: true },
        { slot: 'necklace', needAttr: true },
        { slot: 'ring', needAttr: true },
        { slot: 'headshoulder', needAttr: false },
        { slot: 'top', needAttr: false },
        { slot: 'bottom', needAttr: false },
        { slot: 'belt', needAttr: false },
        { slot: 'shoes', needAttr: false },
        { slot: 'sub', needAttr: false },
        { slot: 'magestone', needAttr: false },
        { slot: 'earring', needAttr: false },
      ];

      for (const t of targets) {
        const slot = t.slot;
        const typeKey = (typeof _enchantTypeForSlot_mobile === 'function') ? _enchantTypeForSlot_mobile(slot) : '';
        if (!typeKey) continue;

        let pick = null;
        if (t.needAttr) {
          const attrFull = attr;                         // '화속성'
          const attrShort = attrFull.replace('속성', ''); // '화'

          const keywords = [
            attrFull + tier,
            attrShort + tier,
            attrFull + (tier === '준종결' ? '준결' : tier),
            attrShort + (tier === '준종결' ? '준결' : tier),
          ];
          for (const kw of keywords) {
            if (!kw) continue;
            pick = _findEnchant_mobile(typeKey, kw);
            if (pick) break;
          }
        } else {
          pick = _findEnchant_mobile(typeKey, tier);
        }
        if (!pick) continue;

        state.enchants[slot] = { name: String(pick.name || '').trim(), typeKey: String(typeKey).trim(), raw: pick._raw || null };

        if (typeof _syncEnchantLabelFromState_mobile === 'function') _syncEnchantLabelFromState_mobile(slot);
        if (typeof syncEnchantTopbarLabel_mobile === 'function') syncEnchantTopbarLabel_mobile(slot);
      }

      _hideModal_mobile('autoEnchantModal');
    }

    function renderAutoEnchantChoices_mobile() {
      const m = document.getElementById('autoEnchantModal');
      if (!m) return;
      const wrapAttrs = m.querySelector('.lists.attrs');
      const wrapTiers = m.querySelector('.lists.tiers');
      if (!wrapAttrs || !wrapTiers) return;

      wrapAttrs.innerHTML = '';
      wrapTiers.innerHTML = '';

      const makeBtn = (txt, group) => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'opt-btn';
        b.textContent = txt;

        // '준종결' 버튼은 내부값 '준결'로 들고다님(PC 동일)
        let internalVal = txt;
        if (group === 'tier') {
          internalVal = (txt.includes('준')) ? '준결' : txt;
          b.dataset.value = internalVal;
        }

        b.addEventListener('click', () => {
          if (group === 'attr') autoEnchantState_mobile.attr = txt;
          else autoEnchantState_mobile.tier = internalVal;

          renderAutoEnchantChoices_mobile();
          _updateAutoEnchantConfirmBtn_mobile(); // ✅ 선택만 반영, 적용은 확인 버튼에서

        });

        // active
        if (group === 'attr' && autoEnchantState_mobile.attr === txt) b.classList.add('active');
        if (group === 'tier' && autoEnchantState_mobile.tier === internalVal) b.classList.add('active');
        return b;
      };

      ['화속성', '수속성', '명속성', '암속성'].forEach(a => wrapAttrs.appendChild(makeBtn(a, 'attr')));
      ['종결', '준종결', '보통', '가성비'].forEach(t => wrapTiers.appendChild(makeBtn(t, 'tier')));
      _updateAutoEnchantConfirmBtn_mobile();
      _bindAutoEnchantConfirmBtn_mobile();
    }

    /* --- Auto Emblem --- */
    const autoEmblemState_mobile = { attr: null, stage: null };

    function pickEmblemByTypeAndStage_mobile(typeKey, stageNum) {
      const list = (window.DBEnh?.byType?.[String(typeKey).trim()] || []);
      if (!list.length) return null;
      const st = Number(stageNum) || 0;
      // stage는 이름(예: '15단계')로 들어오므로 level_num이 있으면 우선, 없으면 name에서 파싱
      const parseStage = (o) => {
        const n = Number(o?.level_num);
        if (Number.isFinite(n) && n > 0) return n;
        const m = String(o?.name || '').match(/(\d+)\s*단/);
        return m ? Number(m[1]) : 0;
      };
      let hit = list.find(o => parseStage(o) === st);
      if (hit) return hit;
      // 폴백: stage 이하 중 가장 큰 것
      const sorted = list.slice().sort((a, b) => parseStage(a) - parseStage(b));
      for (let i = sorted.length - 1; i >= 0; i--) {
        if (parseStage(sorted[i]) <= st) return sorted[i];
      }
      return sorted[sorted.length - 1] || null;
    }

    function pickPlatForAttr_mobile(attrKey, stageNum) {
      const arr = (window.DBEnh?.byType?.['플래티넘엠블렘'] || []);
      if (!arr.length) return null;

      const normMap = {
        fire: '화',
        water: '수',
        light: '명',
        dark: '암',
        all: '모속',
        str: '힘',
        int: '지능',
      };

      const normAttr = normMap[String(attrKey || '').trim()] || String(attrKey || '').trim();
      const st = Number(stageNum) || 0;

      // ✅ PC와 동일: levelVal + level_num “정확히 일치” 매칭
      const hit = arr.find(r =>
        String(r?.levelVal ?? '').trim() === normAttr &&
        Number(r?.level_num ?? 0) === st
      );

      // ✅ fallback 제거: 매칭 실패면 null (랜덤/고정값 방지)
      return hit || null;
    }


    async function autoEmblemApply_mobile(attrKey, stage) {
      // ✅ 1) CORE.lists(=enh:list 등) 로딩 보장 (미로딩 상태에서 byType이 빈 채로 캐시되는 버그 방지)
      if (typeof initMobileAllLightListsOnce === 'function') {
        await initMobileAllLightListsOnce();
      }

      // ✅ 2) byType 재구성 보장
      if (window.DBEnh) DBEnh.__byTypeReady = false;  // (안전장치) 빈 캐시로 굳는 것 방지
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const stageNum = Number(stage) || 0;

      const slots = ['headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring', 'weapon', 'sub', 'earring', 'magestone', 'title'];

      window.state = window.state || {};
      state.emblems = state.emblems || {};

      for (const sk of slots) {
        const RULES =
          (typeof SOCKET_RULES !== 'undefined' && SOCKET_RULES) ? SOCKET_RULES :
            (window.SOCKET_RULES || null);

        const allow = (RULES && RULES[sk]) ? RULES[sk].slice() : [];

        if (!allow.length) continue;

        // PC 동일: 무기는 붉은빛만 자동입력
        const useTypes = (sk === 'weapon') ? ['붉은빛엠블렘'] : allow;

        const cnt = (typeof SOCKET_COUNT === 'function') ? SOCKET_COUNT(sk) : 2;

        for (let i = 0; i < cnt; i++) {
          const typeKey = useTypes[i % useTypes.length];
          let pick = null;

          if (typeKey === '플래티넘엠블렘') {
            pick = pickPlatForAttr_mobile(attrKey, stageNum);
          } else {
            pick = pickEmblemByTypeAndStage_mobile(typeKey, stageNum);
          }
          _ensureEmblemArray_mobile(sk);
          state.emblems[sk][i] = pick ? {
            name: String(pick.name || '').trim(),
            type: String(pick.type || typeKey).trim(),
            img: pick.img,
            level_num: pick.level_num,
            tag: pick.levelVal || pick.tag || '',
          } : null;
        }

        // UI sync (특수장비 텍스트 포함)
        if (typeof syncEquipRowEmblemIcons_mobile === 'function') syncEquipRowEmblemIcons_mobile(sk);
        if (typeof syncEmblemTopbarDots_mobile === 'function') syncEmblemTopbarDots_mobile(sk);
      }
    }

    function renderAutoEmblemChoices_mobile() {
      const m = document.getElementById('autoEmblemModal');
      if (!m) return;
      const wrapAttrs = m.querySelector('.lists.attrs');
      const wrapTiers = m.querySelector('.lists.tiers');
      if (!wrapAttrs || !wrapTiers) return;

      wrapAttrs.innerHTML = '';
      wrapTiers.innerHTML = '';

      const makeBtn = (txt, group) => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'opt-btn';
        b.textContent = txt;

        b.addEventListener('click', () => {
          if (group === 'attr') {
            autoEmblemState_mobile.attr = txt; // fire/water/light/dark
          } else {
            autoEmblemState_mobile.stage = Number(txt) || 0;
          }
          renderAutoEmblemChoices_mobile();

          _updateAutoEmblemConfirmBtn_mobile();
        });

        // active
        if (group === 'attr' && autoEmblemState_mobile.attr === txt) b.classList.add('active');
        if (group === 'stage' && autoEmblemState_mobile.stage === Number(txt)) b.classList.add('active');
        return b;
      };

      // attrs (PC 동일 키)
      const attrs = [
        { key: 'fire', label: '화속성' },
        { key: 'water', label: '수속성' },
        { key: 'light', label: '명속성' },
        { key: 'dark', label: '암속성' },
      ];
      attrs.forEach(a => wrapAttrs.appendChild(makeBtn(a.key, 'attr')).textContent = a.label);

      // stages 5~15
      const makeRow = (from, to) => {
        const row = document.createElement('div');
        row.className = 'grid';
        row.style.gridTemplateColumns = 'repeat(4, 1fr)';
        for (let lv = from; lv <= to; lv++) {
          const b = document.createElement('button');
          b.type = 'button';
          b.className = 'opt-btn';
          b.textContent = `${lv}단계`;
          if (autoEmblemState_mobile.stage === lv) b.classList.add('active');
          b.addEventListener('click', () => {
            autoEmblemState_mobile.stage = lv;
            renderAutoEmblemChoices_mobile();
            _updateAutoEmblemConfirmBtn_mobile();

          });
          row.appendChild(b);
        }
        return row;
      };
      // tiers wrapper uses grid; just append rows
      wrapTiers.appendChild(makeRow(5, 8));
      wrapTiers.appendChild(makeRow(9, 12));
      wrapTiers.appendChild(makeRow(13, 15));
      _updateAutoEmblemConfirmBtn_mobile();
      _bindAutoEmblemConfirmBtn_mobile();

      // active attr highlight: rebuild attr buttons with active class
      // (attrs button rebuild above is a quick build; to keep minimal, we re-render by calling itself once more when state changes)
    }

    /* ===== end auto input ===== */

    // ✅ 저장슬롯(푸터 위 고정) 높이를 실제 DOM 기준으로 측정해서 본문 padding-bottom에 반영
    function _syncPresetbarHeight_mobile() {
      const el = document.getElementById('mobilePresetBar');
      const h = el ? Math.ceil(el.getBoundingClientRect().height) : 0;
      document.documentElement.style.setProperty('--presetbar-h', `${h}px`);
    }

    // 최초 1회 + 리사이즈/회전 대응
    requestAnimationFrame(_syncPresetbarHeight_mobile);
    window.addEventListener('resize', _syncPresetbarHeight_mobile);

    // ✅ 저장슬롯 페이징 + 서버 fpreset_list 연동 (PC 기능 그대로)
    // - 총 20슬롯(1~20), 페이지당 5개 => 4페이지
    const presetSlots = {
      currentSlot: null,
      // slot 번호별 메타: { slot, label, meta, savedAt }
      data: {}
    };

    const PRESET_UI_TOTAL = 20;
    const PRESET_UI_PER_PAGE = 5;
    let presetPage = 0;

    // PC처럼 "직책별 허용 슬롯 수"가 있으면 그걸 우선 사용
    function _getMobilePresetMaxSlot() {
      try {
        const lim = (typeof getUserPresetLimit === 'function') ? Number(getUserPresetLimit() || 0) : 0;
        if (lim > 0) return Math.min(PRESET_UI_TOTAL, lim);
      } catch (e) { }
      return PRESET_UI_TOTAL;
    }

    function getPresetMaxPage(maxSlot) {
      const n = Math.max(0, Number(maxSlot || 0));
      return Math.max(0, Math.ceil(n / PRESET_UI_PER_PAGE) - 1);
    }

    // ✅ 현재 페이지에 맞춰 DOM(5개 슬롯)의 data-slot을 1~20으로 재매핑
    function applyPresetPageToDom() {
      const base = presetPage * PRESET_UI_PER_PAGE;

      // 모바일은 #mobilePresetBar 안쪽만 대상으로 잡는 게 안전
      const wraps = document.querySelectorAll('#mobilePresetBar .save-box .preset-slot');
      wraps.forEach((wrap, i) => {
        const slotNo = base + i + 1;

        const btn = wrap.querySelector('.preset-btn');
        const trash = wrap.querySelector('.preset-trash');

        if (btn) btn.dataset.slot = String(slotNo);

        if (trash) {
          trash.dataset.slot = String(slotNo);
          trash.setAttribute('aria-label', `슬롯 ${slotNo} 초기화`);
        }
      });
    }

    function updatePresetPagerUI(maxSlot) {
      const prev = document.getElementById('presetPagePrev');
      const next = document.getElementById('presetPageNext');
      const ind = document.getElementById('presetPageInd');

      const maxPage = getPresetMaxPage(maxSlot);

      if (prev) prev.disabled = (presetPage <= 0);
      if (next) next.disabled = (presetPage >= maxPage);

      if (ind) {
        if (maxPage <= 0) {
          ind.style.display = 'none';
          ind.textContent = '';
        } else {
          ind.style.display = 'inline-flex';
          ind.textContent = `${presetPage + 1}/${maxPage + 1}`;
        }
      }
    }

    // ✅ 버튼 UI(썸네일/has-data/disabled/휴지통 표시) 갱신
    function updatePresetButtonsUI() {
      const maxSlot = _getMobilePresetMaxSlot();

      // 페이지 보정
      const maxPage = getPresetMaxPage(maxSlot);
      if (presetPage > maxPage) presetPage = maxPage;

      // 현재 페이지에 맞춰 data-slot 재매핑
      applyPresetPageToDom();

      // 버튼들
      const btns = document.querySelectorAll('#mobilePresetBar .save-box .preset-btn[data-slot]');
      btns.forEach((btn) => {
        const slotStr = btn.dataset.slot;
        const slotNum = Number(slotStr || '0');
        const info = presetSlots.data[slotStr];
        const meta = info && info.meta ? info.meta : null;

        const isAllowed = slotNum > 0 && slotNum <= maxSlot;
        btn.disabled = !isAllowed;

        // 같은 슬롯의 휴지통도 함께 제어
        const wrap = btn.closest('.preset-slot');
        const trash = wrap ? wrap.querySelector('.preset-trash') : null;

        if (info) {
          btn.classList.add('has-data');

          const label = info.label || '';
          const charName = meta?.charName || '';
          btn.title = label || charName || `슬롯 ${slotNum}`;

          const thumb = meta && meta.thumb ? String(meta.thumb) : '';
          if (thumb) {
            btn.style.backgroundImage = `url("${thumb}")`;
            btn.textContent = '';
          } else {
            btn.style.backgroundImage = '';
            btn.textContent = '+';
          }

          if (trash) trash.style.display = 'flex';
        } else {
          btn.classList.remove('has-data');
          btn.style.backgroundImage = '';
          btn.textContent = '+';
          btn.title = isAllowed ? `슬롯 ${slotNum}` : `멤버십 업그레이드가 필요합니다!`;

          if (trash) trash.style.display = 'none';
        }
      });

      updatePresetPagerUI(maxSlot);
      if (typeof _syncPresetbarHeight_mobile === 'function') {
        _syncPresetbarHeight_mobile();
      }
    }

    // ====== 서버 연동 (fpreset_*) ======
    async function refreshFpresetList_mobile() {
      try {
        const res = await apiJSON('fpreset_list', {});
        if (!res || !res.ok) throw new Error(res?.error || 'fpreset_list_fail');

        presetSlots.data = {};
        const items = Array.isArray(res.items) ? res.items : [];
        items.forEach(it => {
          const n = Number(it?.slot);
          if (!Number.isFinite(n) || n < 1 || n > PRESET_UI_TOTAL) return;
          presetSlots.data[String(n)] = {
            slot: n,
            label: String(it?.label || `프리셋 ${n}`),
            savedAt: Number(it?.savedAt || 0) || null,
            meta: it?.meta || null,
          };
        });

        updatePresetButtonsUI();
      } catch (e) {
        console.warn('[fpreset_list] fail:', e);
        // 목록 실패는 UI를 "비어있음"으로라도 유지
        updatePresetButtonsUI();
      }
    }

    function _clonePlain(obj) {
      try {
        if (typeof structuredClone === 'function') return structuredClone(obj);
      } catch (e) { }
      return JSON.parse(JSON.stringify(obj || {}));
    }

    // 현재 프론트 state 전체를 스냅샷으로 만들어서 서버에 보낼 객체로 반환
    function buildFrontPresetState_mobile() {
      // 모바일도 결국 window.state가 “PC와 동일한 구조”로 유지되는 걸 전제로 함
      return _clonePlain(window.state || {});
    }

    // 저장된 state를 window.state에 반영하고, 화면을 state 기준으로 갱신
    function applyFrontPresetState_mobile(presetState) {
  const next = _clonePlain(presetState || {});

  // ✅ window.state 객체를 교체하지 말고, 같은 참조를 유지한 채 내용만 갱신
  window.state = window.state || {};
  const s = window.state;
  for (const k of Object.keys(s)) delete s[k];
  Object.assign(s, next);

      // 1) 캐릭터 UI
      if (s.currentCharacter) {
        applyPickedCharacterUI(s.currentCharacter);
        ensurePage4Init();
        renderSkillPageMobile(s.currentCharacter);
      }

      // 2) 장비 UI
try {
  const equips = s.equips || {};
  const sels = s.selections || {};

  // 2-1) equips(실제 아이템 객체) 우선 반영
  let applied = 0;
  for (const [slotKey, it] of Object.entries(equips)) {
    if (!it) continue;
    applyPickedEquipUI(slotKey, it);
    applied++;
  }

  // 2-2) equips가 비어있거나 일부만 있을 때 selections로 보완
  // (예: 아주 옛날 저장본 / equips가 누락된 경우)
  if (applied === 0) {
    for (const [slotKey, info] of Object.entries(sels)) {
      if (!info) continue;
      applyPickedEquipUI(slotKey, info);
    }
  }
} catch (e) {
  console.warn('[preset] apply equip ui fail', e);
}

      // 3) Page3 요약 텍스트들(시간/몬스터/룬각인/성안의 봉인) 즉시 반영
      try {
        // 시간 기준
        const tSel = document.getElementById('timeSelectM');
        if (tSel && s.timeKey) tSel.value = String(s.timeKey);

        // 몬스터
        const mSel = document.getElementById('monsterSelectM');
        if (mSel && s.monsterName) mSel.value = String(s.monsterName);

        // 룬각인
        const reName = s.runeEngrave?.name ? String(s.runeEngrave.name) : '';
        const reLv = s.runeEngrave?.level ? String(s.runeEngrave.level) : '';
        const reSum = document.getElementById('runeEngraveSummaryM');
        if (reSum) reSum.textContent = (reName && reLv) ? `${reName} (${reLv})` : '선택 없음';

                // 성안의 봉인(요약 + 아래 표시)
        const main = s.castleSeal?.mainName ? String(s.castleSeal.mainName) : '';
        const sub = s.castleSeal?.subName ? String(s.castleSeal.subName) : '';

        // ✅ 중요: #castleSealSummaryM 은 내부에 2줄(div) + span 구조가 유지되어야 함
        // (textContent로 덮어쓰면 span이 사라져 이후 변경 시 갱신이 안 됨)
        const csSum = document.getElementById('castleSealSummaryM');
        if (csSum && (!csSum.querySelector('#castleSealMainPickM') || !csSum.querySelector('#castleSealSubPickM'))) {
          csSum.innerHTML = `
            <div>주요 옵션 : <span id="castleSealMainPickM">-</span></div>
            <div>추가 옵션 : <span id="castleSealSubPickM">-</span></div>
          `.trim();
        }

        const mainEl = document.getElementById('castleSealMainPickM');
        const subEl = document.getElementById('castleSealSubPickM');
        if (mainEl) mainEl.textContent = main || '-';
        if (subEl) subEl.textContent = sub || '-';
                  } catch (e) {
        console.warn('[preset] page3 sync fail', e);
      }

      // ✅ (추가) 스킬룬/룬각인 UI 재동기화 (PC 프리셋 호환 포함)
      try {
        const st = window.state || {};

        // 혹시 normalize를 거치지 않고 apply만 호출하는 경로도 방어
        if ((!st.runes || typeof st.runes !== 'object') && st.skillrune && typeof st.skillrune === 'object') st.runes = st.skillrune;
        if ((!st.runes || typeof st.runes !== 'object') && st.skillRune && typeof st.skillRune === 'object') st.runes = st.skillRune;

        if ((!st.specialRunes || typeof st.specialRunes !== 'object')) {
          const src =
            (st.specialRune && typeof st.specialRune === 'object') ? st.specialRune :
            (st.specialrunes && typeof st.specialrunes === 'object') ? st.specialrunes :
            null;
          if (src) st.specialRunes = src;
        }
        if (st.specialRunes && typeof st.specialRunes === 'object') {
          if (st.specialRunes['가호'] != null && st.specialRunes.gaho == null) st.specialRunes.gaho = st.specialRunes['가호'];
          if (st.specialRunes['지혜'] != null && st.specialRunes.jihe == null) st.specialRunes.jihe = st.specialRunes['지혜'];
          if (st.specialRunes['왜곡'] != null && st.specialRunes.waegok == null) st.specialRunes.waegok = st.specialRunes['왜곡'];
        }

        if (st.runeEngrave && typeof st.runeEngrave === 'object') {
          const re = st.runeEngrave;
          if (!re.type) re.type = '룬각인';
          if (!String(re.level || '').trim()) {
            const lv = (re.levelVal ?? re.tag ?? re['렙제'] ?? re.level ?? '');
            if (String(lv || '').trim()) re.level = String(lv).trim();
          }
        }

        // 🔥 중요: 룬 모달 행 모델은 runes 기반으로 다시 만들게 초기화
        // (기존 runeRowsM이 남아 있으면 새 프리셋 runes가 UI에 안 보일 수 있음)
        if (st.runeRowsM) delete st.runeRowsM;

        if (typeof ensureRunesInitialized === 'function') ensureRunesInitialized();
        if (typeof ensureSpecialRunesInitialized === 'function') ensureSpecialRunesInitialized();
        if (typeof updateRuneCountSummary === 'function') updateRuneCountSummary();

        // 룬각인 드롭다운/세부설정 실제 UI 복원
        if (typeof populateRuneEngraveMobile === 'function') {
          populateRuneEngraveMobile(); // 내부에서 state.runeEngrave 기반으로 복원
        }
      } catch (e) {
         console.warn('[preset] rune sync fail', e);
      }

      // ✅ (추가) 고유효과 UI 동기화 (PC프리셋: type -> weaponType 보정 + 미니라벨 갱신)
      try {
        if (state?.customSkills && typeof state.customSkills === 'object') {
          const cs = state.customSkills;
          const pcWeapon = String(cs.type || cs.customType || cs.kind || '').trim();
          if (!String(cs.weaponType || '').trim() && pcWeapon) {
            cs.weaponType = pcWeapon;
          }
        }
        if (typeof syncUniqueMiniLabels === 'function') {
          syncUniqueMiniLabels();
        }
      } catch (e) {
        console.warn('[preset] unique sync fail', e);
      }

            // ✅ (추가) 아바타/무기압 드롭다운 UI 재동기화
      try {
        if (typeof populateAvatarImprintMobile === 'function') {
          // async지만 여기서는 fire-and-forget으로 OK (내부에서 state.avatarSel로 복원함)
          populateAvatarImprintMobile();
        }
      } catch (e) {
        console.warn('[preset] avatar dropdown sync fail', e);
      }

      // 4) 최종적으로 저장슬롯 UI도 재갱신
      updatePresetButtonsUI();
    }

    function _getPickedCharImgSrcForPreset() {
  const imgEl = document.getElementById('pickedCharImg');
  if (!imgEl) return '';
  // getAttribute 우선(상대경로 보존), 없으면 .src
  const raw = (imgEl.getAttribute('src') || imgEl.src || '').trim();
  return _normImg ? _normImg(raw) : raw;
}

function _getPickedCharThumbSrcForPreset(st) {
  try {
    const c = st?.currentCharacter || null;
    // 1) state/currentCharacter 안에 이미 썸네일이 있으면 그걸 우선
    let t = (typeof _getCharThumb === 'function') ? _getCharThumb(c) : '';

    // 2) 없으면 CORE.lists에서 '썸네일' 컬럼 재탐색(캐릭 선택 시 full만 저장되는 경우 대비)
    if (!t) {
      const name = String(c?.name || '').trim();
      const group = String(c?.jobGroupLabel || c?.jobGroup || '').trim();

      // 프로젝트에 이미 있는 방식대로 캐릭 row 찾기
      // (파일에 _findCharRowFromCore/_pick/_normImg가 이미 있어서 그걸 활용)
      let row = null;
      if (typeof _findCharRowFromCore === 'function') {
        row = _findCharRowFromCore(name, group, c);
      } else if (typeof CORE !== 'undefined' && CORE?.lists?.characters) {
        const rows = CORE.lists.characters;
        row = rows.find(r =>
          String(r?.name || r?.캐릭터명 || '').trim() === name &&
          String(r?.jobGroupLabel || r?.jobGroup || r?.직업군 || '').trim() === group
        ) || rows.find(r => String(r?.name || r?.캐릭터명 || '').trim() === name) || null;
      }

      if (row) {
        const raw = (typeof _pick === 'function')
          ? _pick(row, ['thumbnail', '썸네일', 'thumb', 'thumbSrc'])
          : (row.thumbnail || row['썸네일'] || row.thumb || row.thumbSrc || '');
        t = (typeof _normImg === 'function') ? _normImg(String(raw || '').trim()) : String(raw || '').trim();
      }
    }

    // 3) 그래도 없으면 마지막 fallback(빈 슬롯 방지): 초상화라도 사용
    if (!t) {
      const face = _getPickedCharImgSrcForPreset()
        || (typeof _getCharMainImage === 'function' ? _getCharMainImage(c) : '')
        || '';
      t = (typeof _normImg === 'function') ? _normImg(String(face || '').trim()) : String(face || '').trim();
    }

    return String(t || '').trim();
  } catch (e) {
    console.warn('[preset] pick thumb fail', e);
    return '';
  }
}

async function saveToFpresetSlot_mobile(slotNum, label) {
  const st = buildFrontPresetState_mobile();

  // ✅ 슬롯 리스트 썸네일(meta.thumb) = "썸네일"로 저장
  //    (백엔드가 meta.thumb 생성 시 char.saveFace를 최우선으로 쓰기 때문)
  try {
    const face = _getPickedCharImgSrcForPreset()
      || (typeof _getCharMainImage === 'function' ? _getCharMainImage(st.currentCharacter) : '')
      || '';

    const thumb = (typeof _getPickedCharThumbSrcForPreset === 'function')
      ? _getPickedCharThumbSrcForPreset(st)
      : '';

    if (st.currentCharacter && typeof st.currentCharacter === 'object') {
      // 1) 초상화(메인)는 full로 유지
      if (face) {
        if (!st.currentCharacter.full) st.currentCharacter.full = face;
        if (!st.currentCharacter.imgSrc) st.currentCharacter.imgSrc = face;
        if (!st.currentCharacter.image)  st.currentCharacter.image  = face;
        if (!st.currentCharacter['이미지']) st.currentCharacter['이미지'] = face;
      }

      // 2) 썸네일은 saveFace(+thumb 계열)로 강제 저장
      const finalThumb = String(thumb || '').trim() || String(face || '').trim();
      if (finalThumb) {
        st.currentCharacter.saveFace = finalThumb;
        st.currentCharacter.thumb = finalThumb;
        st.currentCharacter.thumbnail = finalThumb;
        st.currentCharacter['썸네일'] = finalThumb;
      }
    }
  } catch (e) {
    console.warn('[preset] thumb/face inject fail', e);
  }

  // ✅ (NEW) label 같이 전송 (빈 값이면 서버가 '프리셋 n' 처리)
  const payload = { slot: slotNum, state: st };
  const labelStr = String(label || '').trim();
  if (labelStr) payload.label = labelStr;

  const res = await apiJSON('fpreset_save', payload);
  if (!res || !res.ok) throw new Error(res?.error || 'fpreset_save_fail');

  await refreshFpresetList_mobile();
}


async function loadFromFpresetSlot_mobile(slotNum) {
  const res = await apiJSON('fpreset_load', { slot: slotNum });
  if (!res || !res.ok) throw new Error(res?.error || 'fpreset_load_fail');

  const rawState = res.state || {};
  const fixedState = normalizePresetStateForMobile(rawState);

  applyFrontPresetState_mobile(fixedState);

  // ✅ (추가) PC 저장본 스킬 반영: skillLv/skillTpLv → skillTrees 동기화
  try {
    if (typeof syncSkillTreesFromLvMaps_mobile === 'function') {
      // applyFrontPresetState_mobile 내부에서 window.state = ... 로 세팅되므로
      // 여기서는 window.state 기준으로 한 번 더 안전하게 동기화
      syncSkillTreesFromLvMaps_mobile(window.state?.currentCharacter);

      // 동기화 직후 4페이지 UI가 바로 갱신되게 재렌더(이미 내부에서 렌더해도 재렌더 1번은 안전)
      if (typeof ensurePage4Init === 'function') ensurePage4Init();
      if (typeof renderSkillPageMobile === 'function') renderSkillPageMobile(window.state?.currentCharacter);
    }
  } catch (e) {
    console.warn('[preset] skill sync in loadFrom fail', e);
  }

  // ✅ 로드 직후: 2페이지 슬롯 미리보기(마부/엠블렘) 강제 동기화
  if (typeof syncEquipSubOptionsFromState_mobile === 'function') {
    syncEquipSubOptionsFromState_mobile();
  }

  // ✅ (추가) 고유효과 미니라벨도 즉시 갱신
  if (typeof syncUniqueMiniLabels === 'function') {
    syncUniqueMiniLabels();
  }

  await refreshFpresetList_mobile();
}

    async function clearFpresetSlot_mobile(slotNum) {
      const res = await apiJSON('fpreset_clear', { slot: slotNum });
      if (!res || !res.ok) throw new Error(res?.error || 'fpreset_clear_fail');

      await refreshFpresetList_mobile();
    }
// ====== PC 스타일 저장/불러오기 모달 (모바일용) ======
let _presetModalOpen = false;
let _lastPresetFocusEl = null;
let _currentPresetSlot = 0;

function _setModalOpen(modalEl, open, focusEl) {
  if (!modalEl) return;
  _presetModalOpen = !!open;

  if (open) {
    // ✅ 기존 모바일 모달 방식: show 붙여서 표시
    modalEl.classList.add('show');
    modalEl.setAttribute('aria-hidden', 'false');

    // ✅ inert 해제
    if ('inert' in modalEl) modalEl.inert = false;

    // ✅ 포커스 이동
    requestAnimationFrame(() => {
      (focusEl || modalEl.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'))?.focus?.();
    });
  } else {
    // ✅ aria-hidden 경고 방지: 모달 안에 포커스가 남아있으면 먼저 blur
    const ae = document.activeElement;
    if (ae && modalEl.contains(ae)) {
      try { ae.blur(); } catch (e) {}
    }

    // ✅ 숨김 처리
    modalEl.classList.remove('show');
    modalEl.setAttribute('aria-hidden', 'true');

    // ✅ inert 적용(가능한 브라우저에서)
    if ('inert' in modalEl) modalEl.inert = true;
  }
}

function closePresetModal_mobile() {
  const modal = document.getElementById('presetModal');
  _setModalOpen(modal, false);
  const el = _lastPresetFocusEl;
  _lastPresetFocusEl = null;
  if (el && el.focus) requestAnimationFrame(() => el.focus());
}

function openPresetModal_mobile(slotNum) {
  const modal = document.getElementById('presetModal');
  const thumb = document.getElementById('presetThumb');
  const charNameEl = document.getElementById('presetCharName');
  const userNameEl = document.getElementById('presetUserName');

  _currentPresetSlot = Number(slotNum || 0) || 0;
  _lastPresetFocusEl = document.activeElement;

  // data 구조: presetSlots.data[slot] = { slot, label, savedAt, meta }
  const info = presetSlots.data[String(_currentPresetSlot)] || null;
  const meta = info && info.meta ? info.meta : null;

  // 1) 캐릭터 썸네일: "저장된 캐릭터" 기준 (PC와 동일)
  let thumbSrc = '';
  // ✅ 빈 슬롯(info 없음)일 때는 현재 캐릭터로 fallback 하지 않는다.
  if (info) {
    if (meta && (meta.thumb || meta.thumbSrc || meta.thumbnail || meta.image || meta.img)) {
      thumbSrc =
        meta.thumb ||
        meta.thumbSrc ||
        meta.thumbnail ||
        meta.image ||
        meta.img ||
        '';
    } else {
      // meta 없는 예전 프리셋 → 현재 캐릭터 fallback
      const char = (window.state && window.state.currentCharacter) || null;
      if (char) {
        thumbSrc = char.full || char.thumb || char.imgSrc || '';
      }
      if (!thumbSrc) {
        const imgEl = document.getElementById('characterImg');
        if (imgEl && imgEl.src) thumbSrc = imgEl.src;
      }
    }
  }

  if (thumb) {
    thumb.src = thumbSrc || PLACEHOLDER_IMG; // ✅ 빈 슬롯도 기본 이미지 표시
    thumb.style.display = '';
  }

  // 2) 상단 텍스트: 저장된 슬롯이면 "직업군 / 이름", 아니면 안내문구
  if (charNameEl) {
    if (!info) {
      // ✅ 빈 슬롯은 항상 안내 문구
      charNameEl.textContent = '저장된 캐릭터가 없습니다.';
    } else if (meta && (meta.charName || meta.jobGroup || meta.jobName)) {
      const job = meta.jobGroup || meta.jobName || '';
      const name = meta.charName || '';
      if (job && name) charNameEl.textContent = `${job} / ${name}`;
      else if (name || job) charNameEl.textContent = name || job;
      else charNameEl.textContent = '저장된 캐릭터가 없습니다.';
    } else {
      // meta 없는 예전 프리셋 → 현재 캐릭터로 fallback
      const char = (window.state && window.state.currentCharacter) || null;
      if (char && char.name) {
        const job =
          char.jobGroupLabel ||
          char.jobGroup ||
          char.jobName ||
          '';
        charNameEl.textContent = job ? `${job} / ${char.name}` : char.name;
      } else {
        charNameEl.textContent = '저장된 캐릭터가 없습니다.';
      }
    }
  }

  // 3) 하단 텍스트: 프리셋 이름(label) (빈 슬롯이면 "저장된 이름 없음")
  if (userNameEl) {
    userNameEl.textContent = info?.label || '저장된 이름 없음';
    userNameEl.style.display = '';
  }

  // 4) 버튼 라벨/상태
  const btnSave = document.getElementById('btnPresetSaveM');
  const btnLoad = document.getElementById('btnPresetLoadM');
  const btnClear = document.getElementById('btnPresetClearM');

  if (btnSave) btnSave.textContent = info ? '덮어쓰기' : '저장하기';
  if (btnLoad) btnLoad.disabled = !info;
  if (btnClear) btnClear.disabled = !info;

  _setModalOpen(modal, true, btnSave || btnLoad || btnClear);
}

function initPresetModalUI_mobile() {
  const modal = document.getElementById('presetModal');
  if (!modal || modal._bound) return;
  modal._bound = true;

  modal.addEventListener('click', (e) => {
    // 닫기(배경/닫기버튼)
    if (e.target.closest('[data-preset-close]')) {
      closePresetModal_mobile();
      return;
    }
    // 저장/불러오기/초기화
    if (e.target.closest('#btnPresetSaveM')) {
      handlePresetSave_mobile();
      return;
    }
    if (e.target.closest('#btnPresetLoadM')) {
      handlePresetLoad_mobile();
      return;
    }
    if (e.target.closest('#btnPresetClearM')) {
      handlePresetClear_mobile();
      return;
    }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && _presetModalOpen) closePresetModal_mobile();
  });
}

async function handlePresetSave_mobile() {
  const slotNum = _currentPresetSlot;
  if (!slotNum) return;

  const info = presetSlots.data[String(slotNum)];
  const preview = makePreviewFromCurrentState();

  const currentCharName = String(window.state?.currentCharacter?.name || '').trim();
  const existingLabel = String(info?.label || '').trim();

  // ✅ 입력칸 기본값(우선순위: 기존 라벨 → 현재 캐릭명 → 프리셋 n)
  const defaultLabel = existingLabel || currentCharName || `프리셋 ${slotNum}`;

  const isOverwrite = !!info;

  const ok = await openConfirmModal({
    title: isOverwrite ? '덮어쓰기' : '저장하기',
    message: isOverwrite
      ? `"${defaultLabel}" 슬롯에 현재 설정을 덮어쓸까요?`
      : `현재 설정을 슬롯 ${slotNum}에 저장할까요?`,
    okText: isOverwrite ? '덮어쓰기' : '저장',
    cancelText: '취소',
    preview,

    // ✅ (NEW) 프리셋 이름 입력 활성화
    presetNameInput: true,
    presetNameDefault: defaultLabel,
    presetNamePlaceholder: '프리셋 이름(예: 출혈/수면/광룡)',
    presetNameMaxLen: 30,
  });

  if (!ok) return;

  // ✅ 사용자가 입력한 프리셋 이름
  const label = String(document.getElementById('confirmPresetName')?.value || '').trim();

  // ✅ (FIX) 체감 속도 개선: 슬롯 관리 모달을 먼저 닫고 저장을 진행
  closePresetModal_mobile();

  try {
    await saveToFpresetSlot_mobile(slotNum, label);
  } catch (err) {
    console.error(err);
    (window.toast || alert)('저장에 실패했습니다.');

    // 실패 시 다시 열어주기(사용자가 재시도 가능)
    try { openPresetModal_mobile(slotNum); } catch (e) {}
  }
}

async function handlePresetLoad_mobile() {
  const slotNum = _currentPresetSlot;
  if (!slotNum) return;

  const info = presetSlots.data[String(slotNum)];
  if (!info) return;

  const title = info?.label || info?.meta?.charName || `슬롯 ${slotNum}`;
  const preview = makePreviewFromSlotInfo(info);

  if (!await openConfirmModal({
    title: '불러오기',
    message: `"${title}" 불러올까요?`,
    okText: '불러오기',
    cancelText: '취소',
    preview,
  })) return;

  // ✅ (FIX) 체감 속도 개선: 슬롯 관리 모달을 먼저 닫고 불러오기를 진행
  closePresetModal_mobile();

  try {
    await loadFromFpresetSlot_mobile(slotNum);
  } catch (err) {
    console.error(err);
    (window.toast || alert)('불러오기에 실패했습니다.');

    try { openPresetModal_mobile(slotNum); } catch (e) {}
  }
}

async function handlePresetClear_mobile() {
  const slotNum = _currentPresetSlot;
  if (!slotNum) return;

  const info = presetSlots.data[String(slotNum)];
  if (!info) return;

  const preview = makePreviewFromSlotInfo(info);

  if (!await openConfirmModal({
    title: '슬롯 초기화',
    message: `슬롯 ${slotNum}을(를) 초기화할까요?`,
    okText: '초기화',
    cancelText: '취소',
    preview,
  })) return;

  // ✅ (FIX) 체감 속도 개선: 슬롯 관리 모달을 먼저 닫고 초기화를 진행
  closePresetModal_mobile();

  try {
    await clearFpresetSlot_mobile(slotNum);
  } catch (err) {
    console.error(err);
    (window.toast || alert)('초기화에 실패했습니다.');

    try { openPresetModal_mobile(slotNum); } catch (e) {}
  }
}

    // ✅ 슬롯 클릭/휴지통 클릭 바인딩(한 번만)
function bindPresetBarOnce_mobile() {
  const bar = document.getElementById('mobilePresetBar');
  if (!bar || bar._bound) return;
  bar._bound = true;

  bar.addEventListener('click', async (e) => {
    const trash = e.target?.closest?.('.preset-trash');
    const btn = e.target?.closest?.('.preset-btn');

    // 휴지통(즉시 확인 모달로 초기화)
    if (trash) {
      const slotNum = Number(trash.dataset.slot || '0');
      if (!slotNum) return;

      const info = presetSlots.data[String(slotNum)];
      const preview = makePreviewFromSlotInfo(info);

      if (!await openConfirmModal({
        title: '슬롯 초기화',
        message: `슬롯 ${slotNum}을(를) 초기화할까요?`,
        okText: '초기화',
        cancelText: '취소',
        preview,
      })) return;

      try {
        await clearFpresetSlot_mobile(slotNum);
      } catch (err) {
        console.error(err);
        (window.toast || alert)('초기화에 실패했습니다.');
      }
      return;
    }

    // 슬롯 버튼 → 슬롯 관리 모달 오픈
    if (btn) {
      if (btn.disabled) return;

      const slotNum = Number(btn.dataset.slot || '0');
      if (!slotNum) return;

      openPresetModal_mobile(slotNum);
    }
  }, true);
}

    function setPresetPage(p) {
      const maxSlot = _getMobilePresetMaxSlot();
      const maxPage = getPresetMaxPage(maxSlot);

      presetPage = Math.max(0, Math.min(maxPage, (p | 0)));

      // 1) data-slot 재매핑
      applyPresetPageToDom();

      // 2) 버튼 UI 즉시 갱신
      updatePresetButtonsUI();
    }

    // ✅ 이벤트 바인딩 + 초기 세팅
    function initPresetPager() {
  // ✅ 356에서 쓰는 ID 우선, 혹시 예전 ID가 남아있어도 동작하게 fallback
  const prev = document.getElementById('btnPresetPrevM') || document.getElementById('presetPagePrev');
  const next = document.getElementById('btnPresetNextM') || document.getElementById('presetPageNext');

  if (prev && !prev._bound) {
    prev._bound = true;
    prev.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      setPresetPage(presetPage - 1);
    });
  }

  if (next && !next._bound) {
    next._bound = true;
    next.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      setPresetPage(presetPage + 1);
    });
  }

  initPresetModalUI_mobile();
  bindPresetBarOnce_mobile();

  // 최초 0페이지로 맞추고 UI 갱신
  setPresetPage(0);

  // ✅ 서버 슬롯 목록 불러오기
  refreshFpresetList_mobile();
}


// ✅ DOM이 다 만들어진 뒤에 실행되도록 변경
if (!window.__presetPagerBound) {
  window.__presetPagerBound = true;
  window.addEventListener('DOMContentLoaded', () => { initPresetPager(); initOneLinerMobile(); });
}

  </script>

  <!-- ★ 저장/불러오기 슬롯 모달 (PC 동일 UI) -->
<div id="presetModal" class="modal" aria-hidden="true">
  <div class="backdrop" data-preset-close></div>

  <div class="dialog preset-dialog" role="dialog" aria-modal="true" aria-labelledby="presetTitle">
    <header>
      <div style="width:32px;"></div>
      <h2 id="presetTitle">저장 슬롯 관리</h2>
      <button type="button" class="btn" data-preset-close style="font-size:12px;padding:4px 8px;border-radius:999px;">✕</button>
    </header>

    <div class="preset-body">
      <button id="btnPresetClearM" type="button" class="preset-clear-btn" title="초기화">🗑</button>

      <div class="preset-thumb">
        <img id="presetThumb" alt="" />
      </div>

      <div id="presetCharName" class="preset-char-name"></div>
      <div id="presetUserName" class="preset-user-name"></div>

      <div class="preset-actions">
        <button id="btnPresetSaveM" type="button" class="btn main">저장하기</button>
        <button id="btnPresetLoadM" type="button" class="btn ghost">불러오기</button>
      </div>
    </div>
  </div>
</div>

  <!-- ★ 저장/불러오기 확인 모달 (PC 저장 슬롯 관리 모달 스타일) -->
  <div id="confirmModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-confirm-cancel></div>

    <div class="dialog preset-dialog confirm-dialog" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
      <header>
        <div style="width:32px;"></div>
        <h2 id="confirmTitle">확인</h2>

        <!-- 닫기 버튼: PC presetModal과 동일한 톤 -->
        <button type="button" class="btn" data-confirm-cancel
          style="font-size:12px;padding:4px 8px;border-radius:999px;">
          ✕
        </button>
      </header>

      <div class="preset-body confirm-body">

        <!-- ✅ (NEW) 슬롯 미리보기: 원형 썸네일 + 캐릭명 + 유저명 -->
        <div id="confirmPreview" class="confirm-preview" style="display:none;">
  <div class="preset-thumb">
    <img id="confirmThumb" alt="" />
  </div>

  <div id="confirmCharName" class="preset-char-name"></div>

  <!-- ✅ 저장 시: 프리셋 이름을 직접 입력 -->
  <div id="confirmPresetNameRow" style="display:none; width:100%; margin-top:6px;">
    <input
      id="confirmPresetName"
      type="text"
      maxlength="30"
      placeholder="프리셋 이름을 입력하세요"
      style="
        width:100%;
        height:34px;
        border-radius:10px;
        border:1px solid rgba(255,255,255,0.14);
        background:rgba(0,0,0,0.25);
        color:var(--text);
        padding:0 10px;
        font-weight:800;
        font-size:12px;
        outline:none;
      "
    />
  </div>
</div>
        <div id="confirmMsg" class="confirm-msg"></div>

        <div class="preset-actions">
          <button type="button" class="btn ghost confirm-cancel-btn" data-confirm-cancel>취소</button>
          <button type="button" class="btn main  confirm-ok-btn" data-confirm-ok>확인</button>
        </div>
      </div>

    </div>
  </div>


  <!-- ===== Auto Input Modals (PC 동일 기능) ===== -->
  <div id="autoEnhModal" class="modal simple-auto" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEnhTitle">
      <header>
        <h3 id="autoEnhTitle">강화 자동 입력</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body">
        <div class="titles">강화 레벨 선택</div>
        <div id="autoEnhList" class="lists"></div>
      </div>
    </div>
  </div>

  <div id="autoSealModal" class="modal simple-auto" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoSealTitle">
      <header>
        <h3 id="autoSealTitle">추천 마법봉인 자동 입력</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body">
        <div class="titles">속성 선택</div>
        <div class="lists">
          <button type="button" class="opt-btn" data-ele="fire">화속성</button>
          <button type="button" class="opt-btn" data-ele="water">수속성</button>
          <button type="button" class="opt-btn" data-ele="light">명속성</button>
          <button type="button" class="opt-btn" data-ele="dark">암속성</button>
        </div>
      </div>
    </div>
  </div>

  <div id="autoEnchantModal" class="modal simple-auto" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEnchantTitle">
      <header>
        <h3 id="autoEnchantTitle">추천 마법부여 자동 입력</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body two-col">
        <div>
          <div class="titles">속성 선택</div>
          <div class="lists attrs"></div>
        </div>
        <div>
          <div class="titles">추천 티어</div>
          <div class="lists tiers"></div>
        </div>
      </div>
      <!-- ✅ 여기 추가 -->
      <div class="footer">
        <button type="button" class="confirm-btn" id="autoEnchantConfirmBtn" disabled>확인</button>
      </div>
    </div>
  </div>

  <div id="autoEmblemModal" class="modal simple-auto" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEmblemTitle">
      <header>
        <h3 id="autoEmblemTitle">엠블렘 자동 입력</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body two-col">
        <div>
          <div class="titles">속성 선택</div>
          <div class="lists attrs"></div>
        </div>
        <div>
          <div class="titles">단계 선택</div>
          <div class="lists tiers"></div>
        </div>
      </div>
      <!-- ✅ 여기 추가 -->
      <div class="footer">
        <button type="button" class="confirm-btn" id="autoEmblemConfirmBtn" disabled>확인</button>
      </div>
    </div>
  </div>
  <!-- ✅ (NEW) 오칭크아 선택 모달 -->
<div id="ochingkraModal" class="modal simple-auto" aria-hidden="true">
  <div class="backdrop" data-close></div>

  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="ochingkraTitle">
    <header>
      <h3 id="ochingkraTitle">오칭크아 선택</h3>
      <button class="close" data-close>✕</button>
    </header>

    <div class="body">
      <div class="titles">등급 선택</div>
      <div class="lists">
        <button type="button" class="opt-btn" data-och-tier="종결">종결</button>
        <button type="button" class="opt-btn" data-och-tier="준종결">준종결</button>
        <button type="button" class="opt-btn" data-och-tier="1티어">1티어</button>
        <button type="button" class="opt-btn" data-och-tier="2티어">2티어</button>
        <button type="button" class="opt-btn" data-och-tier="3티어">3티어</button>
        <button type="button" class="opt-btn" data-och-tier="__manual__">직접입력</button>
      </div>
    </div>
  </div>
</div>

</body>

</html>
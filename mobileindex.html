<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>게임실험연구소 계산기 (시즌5) - Mobile</title>

  <style>
    :root {
      --bg: #070a12;
      --card: rgba(255, 255, 255, 0.06);
      --card2: rgba(255, 255, 255, 0.10);
      --line: rgba(255, 255, 255, 0.10);
      --text: #e9eef7;
      --muted: rgba(233, 238, 247, 0.70);
      --btn: #2563eb;
      --btn2: #111827;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
      --footer-h: 92px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 700px at 50% -20%, rgba(37, 99, 235, 0.28), transparent 55%), var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", sans-serif;
      overflow: hidden;
      /* 스와이프 컨텐츠 내부 스크롤만 */
    }

    /* ====== Layout ====== */
    .m-shell {
      height: 100dvh;
      display: flex;
      flex-direction: column;
    }

    .m-header {
      position: sticky;
      top: 0;
      z-index: 50;
      padding: calc(10px + var(--safe-top)) 12px 10px 12px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.15));
      backdrop-filter: blur(10px);
    }

    .m-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .m-title {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .m-title .txt {
      font-weight: 800;
      letter-spacing: -0.2px;
      font-size: 15px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .m-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .m-action-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .m-action-btn:active {
      transform: translateY(1px);
    }

    .m-action-btn svg {
      width: 16px;
      height: 16px;
    }

    .m-action-btn svg path,
    .m-action-btn svg rect {
      fill: none;
      stroke: var(--text);
      stroke-width: 1.6;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    /* ====== Swipe Pages ====== */
    .m-main {
      flex: 1 1 auto;
      position: relative;
      padding-bottom: calc(var(--footer-h) + var(--safe-bottom));
      overflow: hidden;
    }

    .m-pages {
      height: 100%;
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;

      touch-action: pan-y;
      /* ✅ 추가: 가로는 우리가 제어, 세로 스크롤은 허용 */
      overscroll-behavior-x: contain;
      /* ✅ 추가: 가로 스와이프 튐 방지 */
    }

    .m-pages::-webkit-scrollbar {
      display: none;
    }

    .m-page {
      flex: 0 0 100%;
      height: 100%;
      scroll-snap-align: start;
      padding: 14px 12px 16px 12px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;

      /* ✅ 추가: 페이지 안에서 카드가 남은 높이를 채우도록 */
      display: flex;
      flex-direction: column;
      scroll-snap-stop: always;
      /* ✅ 추가: 스냅이 더 안정적으로 걸리게 */
    }

    .m-card {
      border: 1px solid var(--line);
      background: var(--card);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
    }

    /* ✅ 1페이지(캐릭터 선택) 카드가 남은 높이를 꽉 채우게 */
    #pageChar .m-card {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
    }

    /* ✅ big-pick 영역도 같이 늘어나서 버튼이 아래 고정 푸터 위까지 길어짐 */
    #pageChar .big-pick {
      flex: 1 1 auto;
      min-height: 0;
      /* flex에서 과도한 min-height 방지 */
    }

    #pageChar .hint {
      margin-top: 10px;
    }

    /* ===== 모바일 캐릭터 목록: 좌 썸네일 / 우 이름 ===== */
    /* ✅ 모달 내용: 손가락 드래그로 스크롤, 스크롤바는 숨김 */
    #charModal .dialog {
      overflow: hidden;
      /* dialog 자체는 숨기고 */
    }

    /* 실제 스크롤은 catalog에서 */
    #charModal #catalog {
      max-height: min(78vh, 720px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      /* iOS 관성 */
      scrollbar-width: none;
      /* Firefox */
    }

    #charModal #catalog::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    #charModal #catalog {
      touch-action: pan-y;
      /* 세로 스크롤 제스처 우선 */
    }

    #charModal .mchar-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #charModal .mchar-row {
      width: 100%;
      display: grid;
      grid-template-columns: 72px 1fr;
      gap: 12px;
      align-items: center;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.06);
      color: #fff;
      text-align: left;
      cursor: pointer;
    }

    #charModal .mchar-row:active {
      transform: translateY(1px);
    }

    #charModal .mchar-thumb {
      width: 72px;
      height: 44px;
      border-radius: 10px;
      object-fit: cover;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.10);
    }

    #charModal .mchar-name {
      font-weight: 900;
      font-size: 15px;
      letter-spacing: -0.2px;
    }

    /* ===== 직업군 그룹 구분(배지 + 직업군명) ===== */
    #charModal .mchar-group {
      padding: 10px 0 14px 0;
      border-top: 1px solid rgba(255, 255, 255, 0.10);
    }

    #charModal .mchar-group:first-child {
      border-top: 0;
      padding-top: 0;
    }

    #charModal .mchar-group-head {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 2px 2px 10px 2px;
    }

    #charModal .mchar-badge {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.06);
      flex: 0 0 auto;
    }

    #charModal .mchar-group-title {
      font-weight: 900;
      font-size: 14px;
      letter-spacing: -0.2px;
      color: rgba(233, 238, 247, 0.95);
    }

    #charModal .mchar-group-sub {
      margin-left: 6px;
      font-size: 11px;
      color: rgba(233, 238, 247, 0.60);
      font-weight: 800;
    }

    #charModal .mchar-group-body {
      display: flex;
      flex-direction: column;
      gap: 10px;
      /* 기존 row 간격 유지 */
    }



    .big-pick {
      margin-top: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 210px;
      border-radius: 18px;
      border: 1px dashed rgba(255, 255, 255, 0.22);
      background: rgba(255, 255, 255, 0.03);

      position: relative;
      /* ✅ 추가 */
      overflow: hidden;
      /* ✅ 추가 (넘치는 부분 잘라서 꽉 찬 느낌) */
    }

    .big-pick button {
      width: 100%;
      max-width: 520px;
      border: none;
      border-radius: 16px;
      padding: 18px 16px;
      font-size: 22px;
      font-weight: 900;
      letter-spacing: -0.4px;
      color: #ffffff;
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.95), rgba(29, 78, 216, 0.95));
      box-shadow: 0 10px 24px rgba(37, 99, 235, 0.25);
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .big-pick button:active {
      transform: translateY(1px);
    }

    /* ✅ 선택된 캐릭 이미지 표시 */
    #pickedCharImg.picked-char-img {
      display: none;
      /* 기본 숨김 (선택 후 block) */
      position: absolute;
      inset: 0;
      /* ✅ big-pick을 꽉 덮음 */
      width: 100%;
      height: 100%;
      max-width: none;
      max-height: none;

      object-fit: cover;
      /* ✅ 핵심: 잘려도 되니 꽉 채움 */
      object-position: center;

      border-radius: inherit;
      /* big-pick 라운드 그대로 */
      border: 0;
      background: rgba(0, 0, 0, 0.18);
    }

    .hint {
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .page-title {
      font-size: 13px;
      font-weight: 800;
      color: rgba(233, 238, 247, 0.9);
      margin-bottom: 10px;
    }

    .ghost {
      padding: 14px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0, 0, 0, 0.22);
      color: var(--muted);
      font-size: 13px;
      line-height: 1.6;
    }

    /* ====== Page 2: 장비 슬롯 ====== */
    #pageEquip .m-card {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
    }

    /* ====== Page 2: 장비(1열 상세 row) ====== */
    #pageEquip .equip-body {
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 2px 0;
    }

    #pageEquip .equip-group {
      padding-top: 14px;
      border-top: 1px solid rgba(255, 255, 255, 0.10);
    }

    #pageEquip .equip-group:first-child {
      padding-top: 0;
      border-top: 0;
    }

    #pageEquip .equip-group-head {
      font-weight: 900;
      font-size: 13px;
      letter-spacing: -0.2px;
      color: rgba(233, 238, 247, 0.92);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    #pageEquip .equip-group-head .equip-u-mini {
      margin: 0;
    }



    /* ✅ 무기 상단: 자동 입력 버튼 4개 */
    #pageEquip .equip-auto-bar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin: 0 0 10px 0;
    }

    #pageEquip .equip-auto-btn {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(233, 238, 247, 0.92);
      border-radius: 12px;
      padding: 10px 10px;
      font-size: 12px;
      font-weight: 900;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      text-align: center;
      line-height: 1.2;
    }

    #pageEquip .equip-auto-sep {
      height: 1px;
      background: rgba(255, 255, 255, 0.10);
      margin: 8px 0 12px 0;
    }

    #pageEquip .equip-auto-btn.primary {
      background: rgba(37, 99, 235, 0.85);
    }

    #pageEquip .equip-auto-btn:active {
      transform: translateY(1px);
    }

    #pageEquip .equip-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #pageEquip .equip-row {
      width: 100%;
      display: grid;
      grid-template-columns: 72px 1fr;
      gap: 10px;
      align-items: center;

      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      border-radius: 14px;
      padding: 8px;
      text-align: left;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    #pageEquip .equip-row:active {
      transform: translateY(1px);
    }

    /* 좌측: 이미지 + 이미지 아래 장비명 */
    #pageEquip .equip-left {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    /* 좌측 이미지: 둥근 정사각형(선택 전 빈 박스) */
    #pageEquip .equip-img {
      width: 56px;
      height: 56px;
      /* ✅ 정사각형 */
      border-radius: 14px;
      /* ✅ 끝이 둥근 정사각형 */
      background: rgba(0, 0, 0, 0.20);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    #pageEquip .equip-name {
      font-weight: 900;
      font-size: 12px;
      color: rgba(233, 238, 247, 0.95);
      text-align: center;
    }

    /* ✅ 고유효과(개별) 미니 버튼 */
    .equip-u-mini {
      margin-top: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, .04);
      font-size: 11px;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    .equip-u-mini:active {
      transform: translateY(1px);
    }

    .equip-u-mini .tag {
      font-weight: 700;
      color: var(--text);
    }

    /* ✅ (추가) 개별 고유효과 버튼 색상: data-ucolor로 제어 */
    .equip-u-mini[data-ucolor="강타"] {
      border-color: #facc15;
      color: #facc15;
      background: rgba(250, 204, 21, 0.08);
    }

    .equip-u-mini[data-ucolor="광채"] {
      border-color: #38bdf8;
      color: #38bdf8;
      background: rgba(56, 189, 248, 0.08);
    }

    .equip-u-mini[data-ucolor="분쇄"] {
      border-color: #f97373;
      color: #f97373;
      background: rgba(248, 113, 113, 0.08);
    }

    .equip-u-mini[data-ucolor="선명"] {
      border-color: #4ade80;
      color: #4ade80;
      background: rgba(74, 222, 128, 0.08);
    }

    .equip-u-mini[data-ucolor="none"] {
      border-color: var(--line);
      color: var(--muted);
      background: rgba(255, 255, 255, .04);
    }

    /* ✅ (추가) 색이 들어가면 tag도 같이 물들게 */
    .equip-u-mini[data-ucolor="강타"] .tag,
    .equip-u-mini[data-ucolor="광채"] .tag,
    .equip-u-mini[data-ucolor="분쇄"] .tag,
    .equip-u-mini[data-ucolor="선명"] .tag {
      color: inherit;
    }

    /* (선택) 모달의 '선봉/의지/이상' 버튼도 요청 매핑대로 색 적용 */
    .unique-options-other .unique-btn[data-value="선봉"] {
      border-color: #f97373;
      color: #f97373;
      background: rgba(248, 113, 113, 0.08);
      /* 분쇄색 */
    }

    .unique-options-other .unique-btn[data-value="의지"] {
      border-color: #38bdf8;
      color: #38bdf8;
      background: rgba(56, 189, 248, 0.08);
      /* 광채색 */
    }

    .unique-options-other .unique-btn[data-value="이상"] {
      border-color: #4ade80;
      color: #4ade80;
      background: rgba(74, 222, 128, 0.08);
      /* 선명색 */
    }

    .unique-options-other .unique-btn[data-value="없음"] {
      border-color: var(--line);
      color: var(--muted);
      background: rgba(15, 23, 42, 0.6);
    }



    /* 우측: 강화(연마) | 마법봉인 | 마법부여 | 엠블렘 */
    #pageEquip .equip-right {
      min-width: 0;
      display: grid;

      /* ✅ 고정폭 대신 비율로 분배 (마법봉인 과점 방지) */
      grid-template-columns:
        minmax(52px, 0.85fr)
        /* 강화/연마 */
        minmax(0, 1.45fr)
        /* 마법봉인(옵션) */
        minmax(52px, 0.90fr)
        /* 마법부여 */
        minmax(48px, 0.60fr);
      /* 엠블렘 */

      gap: 4px;
      /* ✅ 6px → 4px */
      align-items: start;
    }

    /* 강화/연마 */
    #pageEquip .equip-enh {
      font-weight: 900;
      font-size: 11px;
      color: rgba(233, 238, 247, 0.95);
      line-height: 1.2;
    }

    #pageEquip .equip-grind {
      margin-top: 6px;
      font-weight: 850;
      font-size: 11px;
      color: rgba(233, 238, 247, 0.70);
      display: none;
      /* 기본 숨김 */
    }

    #pageEquip .equip-row[data-grind="1"] .equip-grind {
      display: block;
    }

    /* 옵션(고유/일반) */
    #pageEquip .equip-opts {
      min-width: 0;
    }

    #pageEquip .equip-unique {
      font-weight: 900;
      font-size: 11px;
      color: rgba(233, 238, 247, 0.92);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #pageEquip .equip-normal {
      margin-top: 6px;
      font-weight: 850;
      font-size: 11px;
      color: rgba(233, 238, 247, 0.65);

      display: -webkit-box;
      -webkit-box-orient: vertical;
      overflow: hidden;

      -webkit-line-clamp: 2;
      /* WebKit */
      line-clamp: 2;
      /* ✅ 표준(린터 경고 제거용) */
    }

    /* 마법부여 / 엠블렘 공통 */
    #pageEquip .equip-col-title {
      font-weight: 900;
      font-size: 11px;
      color: rgba(233, 238, 247, 0.70);
      margin-bottom: 6px;
    }

    #pageEquip .equip-col-body {
      font-weight: 900;
      font-size: 12px;
      color: rgba(233, 238, 247, 0.92);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* 엠블렘 아이콘 자리 */
    #pageEquip .equip-emblem-icons {
      display: flex;
      flex-direction: column;
      /* ✅ 세로로 */
      gap: 6px;
      align-items: center;
    }

    #pageEquip .equip-emblem-icons .emb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(0, 0, 0, 0.20);
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      /* ✅ 이상한 타일/크롭 방지 */
    }

    #pageEquip .equip-emblem-icons .emb,
    #equipModal .equip-topbtn .top-embs .emb {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 900;
      color: rgba(255, 255, 255, 0.95);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.75);
    }

    /* ✅ 특수장비(플래티넘) 엠블렘 속성 텍스트(미리보기) */
    #pageEquip .equip-emblem-desc {
      margin-top: 4px;
      font-size: 10.5px;
      font-weight: 850;
      color: rgba(233, 238, 247, 0.70);
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #pageEquip .equip-emblem-desc:empty {
      display: none;
    }

    /* ✅ (NEW) Set Equipment Bar (Page2) */
    #pageEquip .equip-set-bar {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin: 2px 0 10px;
    }

    #pageEquip .equip-set-btn {
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, .14);
      background: rgba(255, 255, 255, .06);
      color: #fff;
      font-size: 13px;
      font-weight: 700;
      letter-spacing: -.2px;
    }

    #pageEquip .equip-set-btn:active {
      transform: translateY(1px);
    }


    /* ===== Equip list (Modal) ===== */
    .meq-wrap {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .meq-row {
      width: 100%;
      border: 0;
      background: var(--card2);
      color: var(--text);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      grid-template-columns: 54px 1fr;
      gap: 10px;
      align-items: center;
      text-align: left;
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.05) inset;
    }

    .meq-thumb {
      width: 54px;
      height: 54px;
      border-radius: 14px;
      background: #0b1220;
      border: 1px solid rgba(255, 255, 255, 0.08);
      object-fit: cover;
      display: block;
    }

    .meq-name {
      font-size: 14px;
      line-height: 1.25;
      font-weight: 700;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      overflow: hidden;

      /* ✅ 경고 방지용(표준 속성) */
      line-clamp: 2;
    }

    /* ✅ 2중 모달: 강화 모달은 장비 모달 위에 */
    #equipEnhModal {
      z-index: 1100;
    }

    #equipSealUModal {
      z-index: 1110;
    }

    #equipSealNModal {
      z-index: 1110;
    }

    #equipEnchantModal {
      z-index: 1120;
    }

    #equipEmblemModal {
      z-index: 1130;
    }

    #equipGrindModal {
      z-index: 1108;
    }


    /* ✅ (PC와 유사한 리스트 스타일) 강화 + 마법봉인(고유/일반) + 마법부여 공통 */
    #equipEnhModal .dialog,
    #equipSealUModal .dialog,
    #equipSealNModal .dialog,
    #equipEnchantModal .dialog,
    /* ✅ 추가 */
    #equipEmblemModal .dialog,
    #equipGrindModal .dialog {
      width: min(320px, 95vw);
      height: min(520px, 85vh);
    }


    /* 리스트(1열) */
    #equipEnhModal .enh-list,
    #equipSealUModal .enh-list,
    #equipSealNModal .enh-list,
    #equipEnchantModal .enh-list,
    #equipGrindModal .enh-list {
      overflow: auto;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr;
      /* ✅ 1열 고정 */
      gap: 8px;
    }

    /* 버튼 (마법부여는 .enh-btn 이라 같이 포함) */
    #equipEnhModal .enh-option,
    #equipSealUModal .enh-option,
    #equipSealNModal .enh-option,
    #equipEnchantModal .enh-btn,
    #equipGrindModal .enh-option {
      height: 36px;
      padding: 0 12px;
      text-align: left;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(0, 0, 0, 0.25);
      color: rgba(240, 230, 210, 0.95);
      cursor: pointer;
    }

    /* active (마법부여는 .enh-btn.active) */
    #equipEnhModal .enh-option.active,
    #equipSealUModal .enh-option.active,
    #equipSealNModal .enh-option.active,
    #equipEnchantModal .enh-btn.active,
    #equipGrindModal .enh-option.active {
      border-color: rgba(207, 162, 79, 0.9);
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.18) inset;
    }





    /* ====== Bottom Fixed ====== */
    .m-footer {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 60;
      padding: 10px 12px calc(10px + var(--safe-bottom)) 12px;
      border-top: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.10), rgba(0, 0, 0, 0.55));
      backdrop-filter: blur(10px);
    }

    .m-footer-row {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }

    .m-calc-btn {
      flex: 0 0 140px;
      border: none;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.95), rgba(29, 78, 216, 0.95));
      color: #fff;
      font-weight: 900;
      font-size: 18px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .m-calc-btn:active {
      transform: translateY(1px);
    }

    .m-result {
      flex: 1 1 auto;
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.06);
      padding: 12px 12px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-width: 0;
    }

    .m-result .label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .m-result .value {
      font-size: 18px;
      font-weight: 900;
      letter-spacing: -0.4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* ====== Toast ====== */
    .toast {
      position: fixed;
      left: 50%;
      bottom: calc(var(--footer-h) + 14px + var(--safe-bottom));
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.70);
      border: 1px solid rgba(255, 255, 255, 0.14);
      color: #fff;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 12px;
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(-2px);
    }

    /* (선택) 모달은 나중에 PC에서 그대로 복붙할 예정이면,
       여기선 최소한의 기본만 둠 */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 1000;
    }

    .modal.show {
      display: block;
    }

    /* ===== Auto Input Modals (PC 동일 기능) ===== */
    .simple-auto .dialog {
      max-width: 520px;
    }

    .simple-auto .body {
      padding: 12px;
    }

    .simple-auto .grid {
      display: grid;
      gap: 8px;
    }

    .simple-auto .two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .simple-auto .titles {
      font-size: 12px;
      font-weight: 900;
      opacity: .75;
      margin-bottom: 6px;
    }

    .simple-auto .lists {
      display: grid;
      gap: 8px;
    }

    .simple-auto .opt-btn {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(17, 24, 39, .50);
      color: rgba(240, 230, 210, .95);
      border-radius: 10px;
      padding: 10px 10px;
      font-size: 13px;
      font-weight: 850;
      text-align: center;
    }

    .simple-auto .opt-btn.active {
      outline: 2px solid rgba(37, 99, 235, .65);
      border-color: rgba(37, 99, 235, .35);
      background: rgba(37, 99, 235, .20);
    }

    .simple-auto .opt-btn:disabled {
      opacity: .6;
    }

    /* ✅ Auto Input Modal footer */
    .simple-auto .footer {
      padding: 10px 12px 14px;
      border-top: 1px solid rgba(0, 0, 0, 0.08);
      display: flex;
      justify-content: center;
    }

    .simple-auto .confirm-btn {
      width: min(240px, 70%);
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(37, 99, 235, 0.35);
      background: rgba(37, 99, 235, 0.92);
      color: #fff;
      font-weight: 900;
      letter-spacing: -0.2px;
      cursor: pointer;
    }

    .simple-auto .confirm-btn:disabled {
      opacity: .45;
      cursor: not-allowed;
    }


    .modal .backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.62);
    }

    .modal .dialog {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(720px, 92vw);
      max-height: min(80vh, 720px);
      overflow: auto;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(10, 14, 24, 0.96);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
    }

    .modal .dialog header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.10);
    }

    .modal .dialog header h2 {
      margin: 0;
      font-size: 14px;
      font-weight: 900;
      letter-spacing: -0.2px;
    }

    .modal .dialog header .close {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: #fff;
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
    }

    .modal .contact-body {
      padding: 14px;
    }

    .contact-notice {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.55;
      margin-bottom: 12px;
    }

    .contact-textarea {
      width: 100%;
      min-height: 130px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      padding: 10px 12px;
      resize: vertical;
      outline: none;
      font-size: 13px;
      line-height: 1.5;
    }

    .contact-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .ui-btnetc {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(37, 99, 235, 0.85);
      color: #fff;
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 800;
    }

    .faq-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
    }

    .faq-q-btn {
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.16);
      color: #e5e7eb;
      cursor: pointer;
    }

    /* ===== Emblem Modal UI ===== */
    #equipEmblemModal .items {
      overflow: auto;
      padding: 10px;
    }

    /* 상단: 현재 슬롯/소켓 선택 영역 */
    #equipEmblemTarget {
      position: sticky;
      top: 0;
      z-index: 2;
      padding: 8px;
      margin: 0 0 10px 0;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(6px);
    }

    .em-target-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .em-slot-title {
      font-size: 13px;
      font-weight: 800;
      color: rgba(240, 230, 210, 0.95);
    }

    .em-sockets {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* ✅ 상단 소켓 왼쪽에 플래티넘 속성 배지 */
    .em-sock-wrap {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .em-line-badge {
      font-size: 11px;
      font-weight: 900;
      line-height: 1;
      padding: 2px 6px;
      border-radius: 999px;

      color: rgba(240, 230, 210, 0.92);
      background: rgba(0, 0, 0, 0.40);
      border: 1px solid rgba(255, 255, 255, 0.16);

      /* 클릭 방해 방지 */
      pointer-events: none;
    }

    .em-sock {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(0, 0, 0, 0.25);
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }

    .em-sock.active {
      outline: 2px solid rgba(255, 220, 140, 0.55);
    }

    .em-sock.has-img {
      background-size: cover;
      background-position: center;
    }

    .em-sock {
      position: relative;
      /* 혹시 빠져있으면 보장 */
    }

    .em-sock .num {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);

      font-size: 13px;
      font-weight: 900;
      line-height: 1;

      padding: 3px 7px;
      border-radius: 999px;

      color: rgba(255, 255, 255, 0.95);
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.20);

      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.9);
      pointer-events: none;
      /* 클릭 방해 방지 */
    }

    /* ===== Emblem Modal (세로 리스트 버전) ===== */
    #equipEmblemList {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .em-group {
      border: 1px solid rgba(255, 255, 255, 0.10);
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.18);

      /* ✅ 잘림 방지 */
      overflow: visible;
      height: auto;
      max-height: none;
    }

    .em-group-title {
      padding: 10px 12px;
      font-size: 12px;
      font-weight: 900;
      color: rgba(240, 230, 210, 0.92);
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.18);
    }

    /* ✅ 특수장비 플래티넘: 속성 선택 UI */
    .em-group-title.plat {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .em-line-btn {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(240, 230, 210, 0.92);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 900;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .em-line-btn:active {
      transform: translateY(1px);
    }

    .em-line-choices {
      display: none;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(255, 255, 255, 0.03);
    }

    .em-line-choices.show {
      display: flex;
    }

    .em-line-opt {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(0, 0, 0, 0.25);
      color: rgba(240, 230, 210, 0.92);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 900;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .em-line-opt.active {
      border-color: rgba(207, 162, 79, 0.9);
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.18) inset;
    }

    .em-plat-hint {
      padding: 10px 12px;
      font-size: 12px;
      color: rgba(240, 230, 210, 0.65);
    }

    .em-vlist {
      display: flex;
      flex-direction: column;
    }

    .em-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: transparent;
      cursor: pointer;
      text-align: left;
    }

    .em-item:last-child {
      border-bottom: none;
    }

    .em-item:hover {
      background: rgba(255, 255, 255, 0.04);
    }

    .em-item .thumb {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(0, 0, 0, 0.25);
      background-size: cover;
      background-position: center;
      flex: 0 0 auto;
      position: relative;
      overflow: hidden;
    }

    .em-item.none .thumb {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 900;
      color: rgba(240, 230, 210, 0.75);
      background: rgba(0, 0, 0, 0.18);
    }

    .em-item .meta {
      flex: 1 1 auto;
      min-width: 0;
    }

    .em-item .name {
      font-size: 13px;
      font-weight: 900;
      color: rgba(240, 230, 210, 0.95);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .em-item .sub {
      margin-top: 2px;
      font-size: 12px;
      color: rgba(240, 230, 210, 0.65);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .em-item .badge {
      flex: 0 0 auto;
      font-size: 12px;
      font-weight: 900;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: rgba(250, 240, 220, 0.95);
      background: rgba(0, 0, 0, 0.25);
    }


    /* 장비 리스트의 엠블렘 표시(오른쪽 작은 원) */
    .equip-emblem-icons {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .equip-emblem-icons .emb {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(0, 0, 0, 0.18);
      background-size: cover;
      background-position: center;
    }

    .equip-emblem-icons .emb.has-img {
      box-shadow: 0 0 0 1px rgba(255, 220, 140, 0.25) inset;
    }

    /* 무기 종류 필터 바 (equipModal 안) */
    .weapon-typebar {
      display: none;
      /* 기본 숨김, 무기에서만 show */
      gap: 8px;

      /* ✅ 높이(세로) 키우기 */
      padding: 12px 12px 12px 12px;
      min-height: 56px;
      align-items: center;

      /* ✅ 종류가 많으면 2줄로 내려가게 (영역이 더 넓어 보임) */
      display: flex;
      flex-wrap: wrap;

      /* ✅ 너무 많아져도 모달을 침범하지 않게 제한 */
      max-height: 92px;
      overflow-y: auto;

      /* 스크롤바 숨김(스크롤은 유지) */
      scrollbar-width: none;
      /* firefox */
      -ms-overflow-style: none;
      /* ie/edge */
    }

    .weapon-typebar::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    .weapon-typebtn {
      flex: 0 0 auto;
      border: 1px solid rgba(255, 255, 255, .14);
      background: rgba(255, 255, 255, .06);
      color: rgba(233, 238, 247, .92);
      border-radius: 999px;
      padding: 9px 12px;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: -0.2px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .weapon-typebtn.active {
      background: rgba(37, 99, 235, .35);
      border-color: rgba(37, 99, 235, .55);
    }


    /* ✅ 장비 선택 모달만: 상단(헤더+버튼바) 고정, 목록만 스크롤 */
    #equipModal .dialog {
      overflow: hidden;
      /* dialog 전체 스크롤 금지 */
      display: flex;
      flex-direction: column;
    }

    /* 상단 버튼바 */
    #equipModal .equip-topbar {
      flex: 0 0 auto;
      display: flex;
      flex-wrap: wrap;
      /* ✅ 버튼들이 다음 줄로 내려감 */
      gap: 8px;
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(10, 14, 24, 0.96);

      overflow-x: hidden;
      /* ✅ 가로 스크롤 제거 */
      overflow-y: hidden;
    }

    /* 버튼 스타일(작고 촘촘하게) */
    #equipModal .equip-topbtn {
      flex: 0 0 auto;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(233, 238, 247, 0.92);
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 900;
      font-size: 12px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      white-space: nowrap;
    }

    #equipModal .equip-topbtn.active {
      background: rgba(37, 99, 235, 0.85);
      border-color: rgba(37, 99, 235, 0.65);
      color: #fff;
    }

    /* ✅ 상단바: 엠블렘 버튼은 구멍만 표시 */
    #equipModal .equip-topbtn.is-emblems {
      padding: 6px 10px;
      min-width: 48px;
    }

    #equipModal .equip-topbtn .top-embs {
      display: flex;
      flex-direction: column;
      /* 세로 배치 */
      gap: 6px;
      align-items: center;
      justify-content: center;
    }

    #equipModal .equip-topbtn .top-embs .emb {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(0, 0, 0, 0.22);
      display: block;
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      /* ✅ */
    }


    /* ✅ topbar 엠블렘: 버튼이 아니라 "구멍 2개" */
    #equipModal .equip-topemblem {
      flex: 0 0 auto;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.90);
      font-size: 12px;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
    }

    #equipModal .equip-topemblem .label {
      font-size: 11px;
      font-weight: 900;
      letter-spacing: -0.2px;
    }

    #equipModal .equip-topemblem .holes {
      display: inline-flex;
      flex-direction: column;
      /* ✅ 세로로 2개 */
      gap: 6px;
      align-items: center;
    }

    #equipModal .equip-topemblem .hole {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.10), rgba(0, 0, 0, 0.45) 72%);
      box-shadow:
        inset 0 2px 5px rgba(0, 0, 0, 0.55),
        0 1px 0 rgba(255, 255, 255, 0.06);
    }

    #equipModal .equip-topemblem.active {
      background: rgba(37, 99, 235, 0.85);
      border-color: rgba(37, 99, 235, 0.95);
      color: #fff;
    }

    #equipModal .equip-topemblem.active .hole {
      border-color: rgba(255, 255, 255, 0.32);
    }

    #equipModal .equip-topemblem:focus {
      outline: 2px solid rgba(37, 99, 235, 0.7);
      outline-offset: 2px;
    }


    /* ✅ 목록만 스크롤 */
    #equipModal #equipCatalog {
      flex: 1 1 auto;
      min-height: 0;
      /* flex에서 overflow 작동 필수 */
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }

    /* ✅ 모달 내부 리스트: 스크롤바(막대)만 숨기고, 터치 스와이프 스크롤은 유지 */
    #equipCatalog,
    #equipEnhList,
    #equipSealUList,
    #equipSealNList,
    #equipEnchantList,
    #equipGrindList {
      overflow: auto;
      /* 스크롤은 가능해야 손으로 밀림 */
      -webkit-overflow-scrolling: touch;
      /* iOS 관성 스크롤 */
      scrollbar-width: none;
      /* Firefox: 스크롤바 숨김 */
    }


    /* ✅ (선택모달) dialog 자체는 스크롤 금지: 스크롤은 리스트에서만 */
    dialog,
    #equipEnhModal .dialog,
    #equipSealUModal .dialog,
    #equipSealNModal .dialog,
    #equipEnchantModal .dialog,
    #equipEmblemModal .dialog,
    #equipGrindModal .dialog {
      overflow: hidden;
      display: flex;
      /* ✅ 추가 */
      flex-direction: column;
      /* ✅ 추가 */
    }

    /* ✅ 헤더 아래 남은 공간을 items가 먹고, 그 안의 리스트만 스크롤되게 */
    #equipEnhModal .items,
    #equipSealUModal .items,
    #equipSealNModal .items,
    #equipEnchantModal .items,
    #equipEmblemModal .items,
    #equipGrindModal .items {
      flex: 1 1 auto;
      /* ✅ 추가 */
      min-height: 0;
      /* ✅ 핵심: flex 환경에서 내부 overflow가 작동하려면 필요 */
      overflow: hidden;
      /* ✅ dialog은 숨기고, 실제 스크롤은 리스트에서만 */
    }

    /* ✅ 리스트: “스크롤바는 숨기되” 터치 스크롤은 허용 */
    #equipCatalog,
    #equipEnhList,
    #equipSealUList,
    #equipSealNList,
    #equipEnchantList,
    #equipEmblemList,
    #equipGrindList {
      height: 100%;
      /* ✅ 추가: items 높이를 꽉 채움 */
      overflow: auto;
      overflow-x: hidden;
      /* ✅ 가로 스크롤 방지 */
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      touch-action: pan-y;
      /* ✅ 모바일에서 위/아래 드래그를 스크롤로 확실히 */
      overscroll-behavior: contain;
      /* ✅ 바운스/배경 스크롤 간섭 줄이기 */
    }

    /* Chrome/Safari/Edge: 스크롤바 숨김 */
    #equipCatalog::-webkit-scrollbar,
    #equipEnhList::-webkit-scrollbar,
    #equipSealUList::-webkit-scrollbar,
    #equipSealNList::-webkit-scrollbar,
    #equipEnchantList::-webkit-scrollbar,
    #equipEmblemList::-webkit-scrollbar,
    #equipGrindList::-webkit-scrollbar {
      width: 0;
      height: 0;
      display: none;
    }

    /* ===== Page 3: Options ===== */
    #pageEtc .opt-box {
      border: 1px solid rgba(255, 255, 255, 0.10);
      background: rgba(0, 0, 0, 0.18);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 10px;
    }

    #pageEtc .opt-title {
      margin: 0 0 10px;
      font-size: 14px;
      font-weight: 900;
      letter-spacing: -0.2px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    #pageEtc .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin: 10px 0;
    }

    #pageEtc .label {
      font-size: 12px;
      opacity: .85;
    }

    #pageEtc {
      --dd-bg: #0D0E15;
      --dd-text: #ffffff;
      --dd-gold: #cfa24f;
    }

    #pageEtc .select {
      width: 100%;
      height: 40px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: var(--dd-bg);
      color: var(--dd-text);
      padding: 0 12px;
      outline: none;
    }

    /* ✅ 드롭다운 목록(option)도 셀렉트와 동일 톤으로 */
    #pageEtc .select option,
    #pageEtc .select optgroup {
      background: var(--dd-bg);
      color: var(--dd-text);
    }

    /* ✅ 드롭다운 펼쳐져 있는 동안(=focus 유지) 금색 테두리 */
    #pageEtc .select:focus {
      border-color: #cfa24f;
      /* gold */
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.22) inset;
    }

    /* 클릭 중에도 유지되는 느낌(브라우저별 보강) */
    #pageEtc .select:active {
      border-color: #cfa24f;
    }

    #pageEtc .row {
      display: flex;
      gap: 8px;
    }

    #pageEtc .row .field {
      margin: 0;
      flex: 1 1 0;
    }

    #pageEtc .btn {
      height: 40px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(0, 0, 0, 0.28);
      color: #fff;
      padding: 0 12px;
      font-weight: 800;
    }

    #pageEtc .btn:focus {
      outline: none;
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.22) inset;
    }

    #pageEtc .btn.primary {
      background: rgba(37, 99, 235, 0.92);
      border-color: rgba(37, 99, 235, 0.55);
    }

    /* ✅ 성안의 봉인 모달 드롭다운도 무기압(=pageEtc) 스타일과 동일하게 */
    #castleSealModalM {
      --dd-bg: #0D0E15;
      --dd-text: #ffffff;
      --dd-gold: #cfa24f;
    }

    #castleSealModalM .select {
      width: 100%;
      height: 40px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: var(--dd-bg);
      color: var(--dd-text);
      padding: 0 12px;
      outline: none;
    }

    #castleSealModalM .select option,
    #castleSealModalM .select optgroup {
      background: var(--dd-bg);
      color: var(--dd-text);
    }

    #castleSealModalM .select:focus {
      border-color: var(--dd-gold);
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.22) inset;
    }

    #castleSealModalM .select:active {
      border-color: var(--dd-gold);
    }



    /* =========================
   Skill Rune Modal (Mobile) - PC 톤 통일
   ========================= */

    /* 모달 자체 톤(갈색/금색) */
    #runeModalM .dialog {
      width: min(980px, 95vw);
      height: min(820px, 88vh);
      background: #0f0b08;
      color: #f0e6d2;
      border: 1px solid #3a2c21;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
    }

    #runeModalM header {
      border-bottom: 1px solid rgba(58, 44, 33, 0.9);
    }

    #runeModalM header h2 {
      color: #f0e6d2;
    }

    /* 공통: select(드롭다운) PC톤 */
    #runeModalM .rune-select {
      width: 100%;
      height: 38px;
      border-radius: 10px;
      padding: 0 10px;
      background: #1a130f;
      color: #f0e6d2;
      border: 1px solid #3a2c21;
      outline: none;
    }

    #runeModalM .rune-select:focus {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.25) inset;
    }

    /* ✅ 간편 스킬룬 선택(3 드롭다운) */
    #runeModalM .rune-picker-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }

    #runeModalM .rune-picker-row .rune-select {
      flex: 1 1 0;
      height: 40px;
      /* 간편 UI는 살짝 키움 */
      border-radius: 12px;
    }

    /* 그리드 */
    #runeModalM .rune-grid {
      display: grid;
      grid-auto-rows: minmax(46px, auto);
      gap: 8px;
      overflow: auto;
    }

    #runeModalM .rune-grid .row {
      display: grid;
      grid-template-columns: 96px repeat(8, minmax(54px, 1fr));
      gap: 6px;
      align-items: center;
    }

    #runeModalM .rune-grid .head {
      position: sticky;
      left: 0;
      z-index: 1;
      padding: 6px 8px;
      border: 1px solid #3a2c21;
      border-radius: 10px;
      background: rgba(207, 162, 79, 0.10);
      font-weight: 800;
      font-size: 12px;
      white-space: nowrap;
    }

    #runeModalM .rune-grid .cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* 카테고리 헤더(아이콘+라벨) */
    #runeModalM .rune-cat-head {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    #runeModalM .rune-cat-icon {
      width: 18px;
      height: 18px;
      object-fit: contain;
      flex: 0 0 auto;
    }

    #runeModalM .rune-cat-label {
      font-size: 12px;
      font-weight: 800;
    }

    /* 특수 스킬룬 */
    #runeModalM .special-runes {
      margin-top: 14px;
      padding-top: 12px;
      border-top: 1px solid rgba(58, 44, 33, 0.9);
    }

    #runeModalM .special-runes-title {
      font-weight: 800;
      font-size: 13px;
      margin-bottom: 10px;
      color: #c7b589;
    }

    #runeModalM .special-rune-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border: 1px solid #3a2c21;
      border-radius: 12px;
      background: rgba(207, 162, 79, 0.06);
      margin-bottom: 8px;
    }

    #runeModalM .special-rune-icon {
      width: 22px;
      height: 22px;
      object-fit: contain;
      flex: 0 0 auto;
    }

    #runeModalM .special-rune-row label {
      width: 42px;
      font-size: 12px;
      font-weight: 800;
      opacity: .95;
      color: #f0e6d2;
    }

    /* 버튼(모달 내부 전용) - PC opt-btnetc 느낌 */
    #runeModalM .btn,
    #castleSealModalM .btn {
      height: 38px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 700;
      background: #1a130f;
      color: #f0e6d2;
      border: 1px solid #3a2c21;
      cursor: pointer;
      transition: all .15s ease;
    }

    #runeModalM .btn:hover,
    #castleSealModalM .btn:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, 0.25) inset;
    }

    /* 적용 버튼 - PC ui-btnetc 느낌 */
    #runeModalM .btn.primary,
    #castleSealModalM .btn.primary {
      background: #ecc947;
      color: #111;
      border: none;
      font-size: 15px;
      font-weight: 800;
      padding: 12px 16px;
      height: auto;
      /* 버튼 텍스트에 맞춰 */
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25);
    }

    #runeModalM .btn.primary:hover {
      background: #ffe263;
    }

    /* (있다면) 행 삭제 버튼을 눈에 띄게 */
    #runeModalM .rune-row-del {
      border-color: rgba(255, 107, 107, 0.55);
      color: #ff6b6b;
    }

    #runeModalM .rune-row-del:hover {
      border-color: #ff6b6b;
      box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.18) inset;
    }

    /* × 아이콘 버튼을 컴팩트하게 */
    #runeModalM .rune-icon-btn {
      width: 30px;
      min-width: 30px;
      height: 30px;
      /* 기본 .btn 높이(38px) 덮어씀 */
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 900;
      line-height: 1;
    }

    #runeModalM .rune-icon-btn:active {
      transform: translateY(1px);
    }

    /* ✅ 3드롭다운 상단 라벨(헤더) */
    #runeModalM .rune-picker-head {
      display: flex;
      gap: 8px;
      align-items: flex-end;
      margin: 2px 0 6px;
      padding: 0 2px;
    }

    #runeModalM .rune-picker-head .col {
      flex: 1 1 0;
      font-size: 11px;
      font-weight: 800;
      color: #c7b589;
      opacity: .95;
      letter-spacing: -0.2px;
      white-space: nowrap;
    }

    /* 우측 삭제(×) 버튼 자리와 폭 맞추기 */
    #runeModalM .rune-picker-head .spacer {
      flex: 0 0 38px;
      /* 삭제 버튼이 38px 느낌이면 딱 맞음 */
    }

    /* ===== Page4 Skill ===== */
    .skill-topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .skill-topbar-title {
      font-size: 15px;
      font-weight: 700;
      color: #e9d7a6;
      letter-spacing: -0.2px;
    }

    .skill-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .skill-row {
      display: flex;
      align-items: stretch;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px;
      border: 1px solid rgba(231, 199, 125, .22);
      border-radius: 10px;
      background: rgba(12, 16, 24, .55);
    }

    .skill-left {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
      /* 아이콘-이름 간격 */
    }

    /* (추가) 스킬 아이콘 */
    .skill-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid rgba(231, 199, 125, .28);
      background: rgba(18, 22, 32, .60);
    }

    .skill-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .skill-name {
      font-size: 14px;
      font-weight: 700;
      color: #f3e6c1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .skill-right {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 172px;
    }

    .skill-ctrl {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
    }

    .skill-ctrl .lbl {
      font-size: 12px;
      color: rgba(233, 215, 166, .85);
      width: 22px;
      text-align: left;
    }

    .skill-val {
      min-width: 26px;
      text-align: center;
      font-size: 12px;
      font-weight: 800;
      color: #e9d7a6;
    }

    .skill-mini {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(231, 199, 125, .25);
      background: rgba(18, 22, 32, .65);
      color: #e9d7a6;
      font-size: 12px;
      font-weight: 800;
      line-height: 1;
    }

    .skill-mini:active {
      transform: translateY(1px);
    }

    .skill-mini.is-wide {
      padding: 6px 10px;
    }

    .skill-mini[disabled] {
      opacity: .35;
      cursor: not-allowed;
    }

    .skill-footnote {
      margin-top: 10px;
      font-size: 12px;
      color: rgba(233, 215, 166, .65);
    }

    /* 렙제 구분 헤더(구분선) */
    .skill-divider {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 2px 2px;

      margin-top: 14px;
      /* ✅ 구간 사이 간격 */
      margin-bottom: 4px;
      /* ✅ 헤더-첫 스킬 간격 */
    }

    .skill-divider .txt {
      font-size: 12px;
      font-weight: 900;
      color: rgba(233, 215, 166, .9);
      white-space: nowrap;
    }

    .skill-divider .line {
      height: 1px;
      flex: 1 1 auto;
      background: rgba(231, 199, 125, .22);
    }

    /* ✅ 상단 고정(스크롤 내려도 보이게) */
    .skill-sticky {
      position: sticky;
      top: 0;
      z-index: 6;
      margin: -16px -16px 10px;
      padding: 12px 16px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.10);
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.12));
      backdrop-filter: blur(10px);
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
    }

    .skill-remaining {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-top: 8px;
      margin-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.10);
    }

    .skill-remaining.is-hidden {
      display: none;
    }

    .skill-remaining .item {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-size: 12px;
      font-weight: 900;
      color: rgba(233, 238, 247, 0.78);
      letter-spacing: -0.2px;
    }

    .skill-remaining .num {
      font-size: 14px;
      font-weight: 900;
      color: rgba(233, 238, 247, 0.96);
    }

    /* =========================
   ✅ (Mobile) PC풍 세트 모달 스타일
========================= */

    .armor-set-dialog {
      width: min(980px, 96vw);
      height: min(720px, 90vh);
    }

    /* body scroll */
    .armor-set-body {
      overflow: auto;
      padding: 8px 6px 14px;
    }

    /* 카드 그리드: ✅ 모바일 전용 1열 */
    .armor-set-list {
      display: grid;
      grid-template-columns: 1fr;
      /* ✅ 1열로 고정 */
      gap: 10px;
    }

    /* ✅ 1열에서는 스페이서가 필요 없으니 항상 숨김 */
    .armor-set-spacer {
      display: none !important;
    }


    /* (PC처럼) 첫 줄 정렬 맞추기용 스페이서 */
    .armor-set-spacer {
      display: none;
    }

    @media (min-width: 720px) {
      .armor-set-spacer {
        display: block;
      }
    }

    /* 세트 카드 */
    .armor-set-card {
      background: #15100c;
      border: 1px solid #3b2b1e;
      border-radius: 14px;
      padding: 10px;
    }

    /* 카드 헤더: 세트명 + 적용버튼 */
    .armor-set-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 13px;
      font-weight: 900;
      color: #f6e7d2;
    }

    /* “세트 적용” 버튼(PC 토글 느낌) */
    .set-auto-toggle {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(250, 204, 107, .9);
      background: rgba(250, 204, 21, 0.10);
      color: #facc6b;
      font-weight: 900;
    }

    /* 카드 안 아이템들 */
    .armor-set-items {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    /* 아이템 버튼 */
    .armor-set-item {
      background: none;
      border: 0;
      padding: 0;
      cursor: pointer;
    }

    /* 아이콘 박스 */
    .iconbox {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(255, 255, 255, .10);
      background: rgba(255, 255, 255, .05);
    }

    .icon {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    /* 레벨 배지 */
    .badge-lv {
      position: absolute;
      left: 4px;
      bottom: 4px;
      font-size: 10px;
      font-weight: 900;
      padding: 2px 5px;
      border-radius: 999px;
      color: #fff;
      background: rgba(0, 0, 0, .55);
      border: 1px solid rgba(255, 255, 255, .14);
    }

    /* =========================
   ✅ PC 고유효과 모달 스타일 이식 (Mobile)
========================= */

    /* PC의 titlebar */
    .armor-set-titlebar {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 0 8px;
      border-bottom: 1px solid #2a211a;
    }

    .armor-set-titlebar h2 {
      margin: 0;
      font-size: 15px;
      color: #f0e6d2;
      font-weight: 700;
      text-align: center;
    }

    .armor-set-titlebar .close {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 26px;
      height: 26px;
      display: grid;
      place-items: center;
      line-height: 1;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.08);
      color: #fff;
      cursor: pointer;
      transition: all .2s ease;
    }

    .armor-set-titlebar .close:hover {
      background: rgba(255, 255, 255, 0.16);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .armor-set-titlebar .close:hover {
      background: rgba(255, 255, 255, 0.16);
      border-color: rgba(255, 255, 255, 0.3);
    }

    /* =========================
   ✅ 익시드/에픽 토글 (Mobile)
========================= */
    .armor-set-titlebar .armor-toggle {
      position: absolute;
      right: 46px;
      /* close(오른쪽 10px) 왼쪽에 붙임 */
      top: 50%;
      transform: translateY(-50%);
    }

    /* 토글 트랙 */
    .armor-toggle {
      position: relative;
      width: 120px;
      height: 26px;
      border-radius: 999px;
      padding: 2px;
      display: flex;
      align-items: stretch;
      overflow: hidden;
      user-select: none;
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.30),
        0 3px 8px rgba(0, 0, 0, 0.35);
    }

    /* 상태별 배경 */
    .armor-toggle.mode-exceed {
      background: linear-gradient(135deg, #22c55e, #10b981);
    }

    .armor-toggle.mode-epic {
      background: linear-gradient(135deg, #facc15, #f97316);
    }

    /* 라벨 */
    .armor-toggle-label {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      z-index: 2;
      transition: color .2s ease;
    }

    .armor-toggle.mode-exceed .armor-toggle-label-exceed {
      color: #0f172a;
      font-weight: 700;
    }

    .armor-toggle.mode-exceed .armor-toggle-label-epic {
      color: rgba(15, 23, 42, 0.45);
      font-weight: 600;
    }

    .armor-toggle.mode-epic .armor-toggle-label-exceed {
      color: rgba(15, 23, 42, 0.45);
      font-weight: 600;
    }

    .armor-toggle.mode-epic .armor-toggle-label-epic {
      color: #0f172a;
      font-weight: 700;
    }

    /* 손잡이 */
    .armor-toggle-thumb {
      position: absolute;
      top: 2px;
      bottom: 2px;
      width: 50%;
      border-radius: 999px;
      background: #fff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
      transition: transform .25s ease;
      z-index: 1;
    }

    .armor-toggle.mode-exceed .armor-toggle-thumb {
      transform: translateX(0%);
    }

    .armor-toggle.mode-epic .armor-toggle-thumb {
      transform: translateX(100%);
    }

    /* 키보드 포커스 */
    .armor-toggle:focus {
      outline: 2px solid rgba(250, 204, 21, 0.65);
      outline-offset: 2px;
    }

    /* ✅ PC 개별 고유효과 모달 닫기버튼 느낌(원형) */
    #mUniquePickModal .armor-set-titlebar .close {
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #f0e6d2;
      font-size: 14px;
      font-weight: 700;
    }

    #mUniquePickModal .armor-set-titlebar .close:hover {
      background: rgba(255, 255, 255, 0.16);
      border-color: rgba(255, 255, 255, 0.3);
    }

    /* ✅ 고유효과 모달 레이아웃 */
    .unique-dialog {
      width: min(600px, 95vw);
      max-height: 80vh;
    }

    .unique-body {
      padding: 12px 10px 14px;
      display: grid;
      gap: 12px;
    }

    .unique-section {
      border-radius: 10px;
      border: 1px solid #3a2c21;
      background: #15100c;
      padding: 8px 10px;
    }

    .unique-section-title {
      font-size: 14px;
      margin: 0 0 12px;
      color: #facc6b;
    }

    /* 고유효과 옵션 목록 */
    .unique-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* 한 줄: [버튼] [설명] */
    .unique-row {
      display: flex;
      align-items: flex-start;
      gap: 16px;
      padding: 4px 6px;
      border-radius: 8px;
      transition: background .12s ease, box-shadow .12s ease;
    }

    .unique-row:hover,
    .unique-row.is-selected {
      background: rgba(148, 163, 184, 0.12);
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.25);
    }

    .unique-row:hover .unique-btn,
    .unique-row.is-selected .unique-btn {
      transform: translateY(-1px);
      box-shadow: 0 0 0 1px rgba(248, 250, 252, 0.35);
    }

    .unique-row:hover .unique-desc,
    .unique-row.is-selected .unique-desc {
      color: #e5e7eb;
    }

    /* 버튼/설명 */
    .unique-btn {
      min-width: 60px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #3a2c21;
      background: rgba(15, 23, 42, 0.85);
      color: var(--muted);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      align-self: flex-start;
      transition: background .12s ease, color .12s ease, box-shadow .12s ease, border-color .12s ease;
    }

    .unique-btn:hover {
      background: rgba(15, 23, 42, 1);
    }

    .unique-btn.is-active {
      box-shadow: 0 0 0 1px rgba(250, 250, 250, 0.12);
    }

    .unique-desc {
      flex: 1;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      white-space: normal;
    }

    .unique-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 4px;
    }

    /* ───── 무기 고유효과 색상 ───── */
    .unique-options-weapon .unique-btn[data-value="강타"] {
      border-color: #facc15;
      color: #facc15;
      background: rgba(250, 204, 21, 0.08);
    }

    .unique-options-weapon .unique-btn[data-value="광채"] {
      border-color: #38bdf8;
      color: #38bdf8;
      background: rgba(56, 189, 248, 0.08);
    }

    .unique-options-weapon .unique-btn[data-value="분쇄"] {
      border-color: #f97373;
      color: #f97373;
      background: rgba(248, 113, 113, 0.08);
    }

    .unique-options-weapon .unique-btn[data-value="선명"] {
      border-color: #4ade80;
      color: #4ade80;
      background: rgba(74, 222, 128, 0.08);
    }

    .unique-options-weapon .unique-btn[data-value="없음"] {
      border-color: var(--line);
      color: var(--muted);
      background: rgba(15, 23, 42, 0.6);
    }
  </style>
</head>

<body>
  <div class="m-shell">

    <!-- ====== Header ====== -->
    <header class="m-header">
      <div class="m-header-row">
        <div class="m-title">
          <div class="txt">게임실험연구소 계산기 (시즌5)</div>
        </div>

        <div class="m-actions">
          <!-- 문의하기 (PC와 동일 id 유지) -->
          <button id="btnContactAdmin" class="m-action-btn" type="button" title="문의하기">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <rect x="3" y="6" width="18" height="13" rx="2"></rect>
              <path d="M3 8l9 6 9-6"></path>
            </svg>
            <span>문의하기</span>
          </button>

          <!-- Q&A (PC와 동일 id 유지) -->
          <button id="btnFaq" class="m-action-btn" type="button" title="문의 전 자주하는 Q&A">
            <span>Q&amp;A</span>
          </button>
        </div>
      </div>
    </header>

    <!-- ====== Main (Swipe) ====== -->
    <main class="m-main">
      <div id="mobilePages" class="m-pages">

        <!-- Page 1: 캐릭터 -->
        <section class="m-page" id="pageChar">
          <div class="m-card">
            <div class="page-title">1 / 4</div>
            <div class="big-pick">
              <button id="btnPickChar" type="button">캐릭터 선택하기</button>
              <!-- ✅ 선택 후 표시될 캐릭터 이미지 -->
              <img id="pickedCharImg" class="picked-char-img" alt="" />
            </div>
            <div class="hint">
              • 좌/우로 넘겨가며 설정합니다.<br />
              • 지금은 모바일 UI 뼈대만 만든 상태입니다.
            </div>
          </div>
        </section>
        <!-- 캐릭터 선택 모달 (PC와 동일 id) -->
        <div id="charModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-char-close></div>
          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="charModalTitle">
            <header>
              <h2 id="charModalTitle">캐릭터 선택</h2>
              <button type="button" class="close" data-char-close>닫기</button>
            </header>

            <!-- PC 스크립트가 여기에 카드들을 렌더링함 -->
            <div id="catalog" class="catalog"></div>
          </div>
        </div>


        <!-- Page 2: 장비 -->
        <!-- =========================
     ✅ (NEW) Set Modals (Mobile)
========================= -->

        <div id="mArmorSetModal" class="modal" aria-hidden="true">
          <div class="backdrop"></div>
          <div class="dialog armor-set-dialog" role="dialog" aria-modal="true" aria-labelledby="mArmorSetTitle">
            <header class="armor-set-titlebar">
              <h2 id="mArmorSetTitle">방어구 세트 선택</h2>

              <!-- ✅ 익시드/에픽 토글 -->
              <div id="mArmorSetToggle" class="armor-toggle mode-exceed" role="button" tabindex="0"
                aria-label="익시드/에픽 토글(방어구)">
                <span class="armor-toggle-label armor-toggle-label-exceed">익시드</span>
                <span class="armor-toggle-label armor-toggle-label-epic">에픽</span>
                <div class="armor-toggle-thumb"></div>
              </div>

              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="armor-set-body">
              <div id="mArmorSetList" class="armor-set-list"></div>
            </div>
          </div>
        </div>

        <div id="mAccSetModal" class="modal" aria-hidden="true">
          <div class="backdrop"></div>
          <div class="dialog armor-set-dialog" role="dialog" aria-modal="true" aria-labelledby="mAccSetTitle">
            <header class="armor-set-titlebar">
              <h2 id="mAccSetTitle">악세사리 세트 선택</h2>
              <!-- ✅ 익시드/에픽 토글 -->
              <div id="mAccSetToggle" class="armor-toggle mode-exceed" role="button" tabindex="0"
                aria-label="익시드/에픽 토글(악세)">
                <span class="armor-toggle-label armor-toggle-label-exceed">익시드</span>
                <span class="armor-toggle-label armor-toggle-label-epic">에픽</span>
                <div class="armor-toggle-thumb"></div>
              </div>
              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="armor-set-body">
              <div id="mAccSetList" class="armor-set-list"></div>
            </div>
          </div>
        </div>

        <div id="mSpecSetModal" class="modal" aria-hidden="true">
          <div class="backdrop"></div>
          <div class="dialog armor-set-dialog" role="dialog" aria-modal="true" aria-labelledby="mSpecSetTitle">
            <header class="armor-set-titlebar">
              <h2 id="mSpecSetTitle">특수장비 세트 선택</h2>
              <!-- ✅ 익시드/에픽 토글 -->
              <div id="mSpecSetToggle" class="armor-toggle mode-exceed" role="button" tabindex="0"
                aria-label="익시드/에픽 토글(특수)">
                <span class="armor-toggle-label armor-toggle-label-exceed">익시드</span>
                <span class="armor-toggle-label armor-toggle-label-epic">에픽</span>
                <div class="armor-toggle-thumb"></div>
              </div>
              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="armor-set-body">
              <div id="mSpecSetList" class="armor-set-list"></div>
            </div>
          </div>
        </div>


        <div id="mUniqueBulkModal" class="modal" aria-hidden="true">
          <div class="backdrop"></div>
          <div class="dialog unique-dialog" role="dialog" aria-modal="true" aria-labelledby="mUniqueBulkTitle">
            <header class="armor-set-titlebar">
              <h2 id="mUniqueBulkTitle">고유효과 일괄 적용</h2>
              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="unique-body">
              <!-- 무기 고유효과 -->
              <section class="unique-section">
                <h3 class="unique-section-title">무기 고유효과</h3>
                <div class="unique-options unique-options-weapon">
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="강타">강타</button>
                    <div class="unique-desc" data-kind="weapon" data-value="강타"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="광채">광채</button>
                    <div class="unique-desc" data-kind="weapon" data-value="광채"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="분쇄">분쇄</button>
                    <div class="unique-desc" data-kind="weapon" data-value="분쇄"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="선명">선명</button>
                    <div class="unique-desc" data-kind="weapon" data-value="선명"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="없음">없음</button>
                    <div class="unique-desc" data-kind="weapon" data-value="없음"></div>
                  </div>
                </div>
              </section>

              <!-- 기타 고유효과 -->
              <section class="unique-section">
                <h3 class="unique-section-title">기타 고유효과</h3>
                <div class="unique-options unique-options-other">
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="선봉">선봉</button>
                    <div class="unique-desc" data-kind="other" data-value="선봉"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="의지">의지</button>
                    <div class="unique-desc" data-kind="other" data-value="의지"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="이상">이상</button>
                    <div class="unique-desc" data-kind="other" data-value="이상"></div>
                  </div>
                  <div class="unique-row">
                    <button type="button" class="unique-btn" data-value="없음">없음</button>
                    <div class="unique-desc" data-kind="other" data-value="없음"></div>
                  </div>
                </div>
              </section>
              <div class="unique-actions">
                <button type="button" class="btn" data-mset-close>취소</button>
                <button type="button" class="btn" id="mUniqueBulkApplyBtn">선택 적용</button>
              </div>
            </div>
          </div>
        </div>
        <!-- ✅ 개별 고유효과 선택 모달 -->
        <div id="mUniquePickModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-mset-close></div>

          <div class="dialog unique-dialog" role="dialog" aria-modal="true" aria-labelledby="mUniquePickTitle">
            <header class="armor-set-titlebar">
              <h2 id="mUniquePickTitle">고유효과</h2>
              <button type="button" class="close" data-mset-close aria-label="닫기">✕</button>
            </header>

            <div class="unique-body">
              <section class="unique-section">
                <h3 class="unique-section-title">고유효과 선택</h3>

                <!-- ✅ 리스트를 unique-options로 감싸면 PC처럼 줄 간격/hover/선택 강조 전부 먹음 -->
                <div id="mUniquePickList" class="unique-options"></div>
              </section>

              <div class="unique-actions">
                <button type="button" class="btn" data-mset-close>닫기</button>
              </div>
            </div>
          </div>
        </div>



        <!-- ✅ 장비 선택 모달 -->
        <div id="equipModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-close></div>
          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipModalTitle">
            <header>
              <h2 id="equipModalTitle">장비 선택</h2>
              <button type="button" class="close" data-equip-close>닫기</button>
            </header>
            <div class="equip-topbar" id="equipTopbar">
              <button type="button" class="equip-topbtn active" data-eqtab="enh">강화</button>

              <!-- ✅ 추가: 보조장비(sub)에서만 보여줄 연마 버튼 -->
              <button type="button" class="equip-topbtn equip-topbtn-grind" data-eqtab="grind"
                style="display:none;">연마</button>

              <!-- ✅ 마법봉인 = 고유옵션/일반옵션 2개 -->
              <button type="button" class="equip-topbtn" data-eqtab="seal_u">고유옵션</button>
              <button type="button" class="equip-topbtn" data-eqtab="seal_n">일반옵션</button>

              <button type="button" class="equip-topbtn" data-eqtab="enchant">마법부여</button>

              <!-- ✅ 엠블렘: 글자 없이 “구멍”만 (구멍 자체가 버튼) -->
              <button type="button" class="equip-topbtn is-emblems" data-eqtab="emblem" aria-label="엠블렘 선택">
                <span class="top-embs">
                  <!-- JS에서 슬롯 종류에 따라 1개/2개로 다시 그려줌 -->
                  <span class="emb"></span>
                  <span class="emb"></span>
                </span>
              </button>
            </div>


            <div id="equipCatalog" class="catalog"></div>
          </div>
        </div>

        <!-- ✅ (방법B) 강화 선택 2중 모달 -->
        <div id="equipEnhModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-enh-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipEnhModalTitle">
            <header>
              <h2 id="equipEnhModalTitle">강화 선택</h2>
              <button type="button" class="close" data-equip-enh-close>✕</button>
            </header>

            <div class="items">
              <div id="equipEnhList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (방법B) 마법봉인: 고유옵션 2중 모달 -->
        <div id="equipSealUModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-seal-u-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipSealUModalTitle">
            <header>
              <h2 id="equipSealUModalTitle">고유옵션 선택</h2>
              <button type="button" class="close" data-equip-seal-u-close>✕</button>
            </header>

            <div class="items">
              <div id="equipSealUList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (방법B) 마법봉인: 일반옵션 2중 모달 -->
        <div id="equipSealNModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-seal-n-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipSealNModalTitle">
            <header>
              <h2 id="equipSealNModalTitle">일반옵션 선택</h2>
              <button type="button" class="close" data-equip-seal-n-close>✕</button>
            </header>

            <div class="items">
              <div id="equipSealNList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (방법B) 마법부여 선택 2중 모달 -->
        <div id="equipEnchantModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-enchant-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipEnchantModalTitle">
            <header>
              <h2 id="equipEnchantModalTitle">마법부여 선택</h2>
              <button type="button" class="close" data-equip-enchant-close>✕</button>
            </header>

            <div class="items">
              <div id="equipEnchantList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (추가) 엠블렘 선택 2중 모달 -->
        <div id="equipEmblemModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-emblem-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipEmblemModalTitle">
            <header>
              <h2 id="equipEmblemModalTitle">엠블렘 선택</h2>
              <button type="button" class="close" data-equip-emblem-close>✕</button>
            </header>

            <div class="items">
              <div id="equipEmblemTarget"></div>
              <div id="equipEmblemList"></div>
            </div>
          </div>
        </div>

        <!-- ✅ (방법B) 연마 선택 2중 모달 -->
        <div id="equipGrindModal" class="modal" aria-hidden="true">
          <div class="backdrop" data-equip-grind-close></div>

          <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="equipGrindModalTitle">
            <header>
              <h2 id="equipGrindModalTitle">연마 선택</h2>
              <button type="button" class="close" data-equip-grind-close>✕</button>
            </header>

            <div class="items">
              <div id="equipGrindList" class="enh-list"></div>
            </div>
          </div>
        </div>

        <section class="m-page" id="pageEquip">
          <div class="m-card">
            <div class="page-title">2 / 4</div>

            <div class="equip-body">

              <!-- 무기 -->
              <div class="equip-group">
                <!-- ✅ (NEW) Set Equipment Buttons -->
                <div class="equip-set-bar">
                  <button type="button" id="btnMSetArmor" class="equip-set-btn">방어구</button>
                  <button type="button" id="btnMSetAcc" class="equip-set-btn">악세사리</button>
                  <button type="button" id="btnMSetSpec" class="equip-set-btn">특수장비</button>
                  <button type="button" id="btnMUniqueBulk" class="equip-set-btn">고유효과</button>
                </div>

                <div class="equip-auto-bar" data-for="weapon">
                  <button type="button" class="equip-auto-btn primary" id="btnWeaponAutoEnh">강화 자동 입력</button>
                  <button type="button" class="equip-auto-btn" id="btnWeaponAutoSeal">추천 마법봉인 자동 입력</button>
                  <button type="button" class="equip-auto-btn" id="btnWeaponAutoEnchant">추천 마법부여 자동 입력</button>
                  <button type="button" class="equip-auto-btn" id="btnWeaponAutoEmblem">엠블렘 자동 입력</button>
                </div>
                <div class="equip-auto-sep"></div>
                <div class="equip-group-head">
                  <span>무기</span>

                  <div class="equip-u-mini" role="button" tabindex="0" data-utarget="weaponType" data-uslot="weapon">
                    <span class="tag">고유효과</span>
                    <span class="val" data-uval="weaponType">-</span>
                  </div>
                </div>
                <div class="equip-list">
                  <button type="button" class="equip-row" data-slot="weapon" data-grind="1" aria-label="무기 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">무기</div>
                    </div>

                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>

                      <div class="equip-opts">
                        <div class="equip-col-title">마법봉인</div>
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>

                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>

                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>
                </div>
              </div>

              <!-- 방어구 -->
              <div class="equip-group">
                <div class="equip-group-head">
                  <span>방어구</span>

                  <div class="equip-u-mini" role="button" tabindex="0" data-utarget="armorType" data-uslot="top">
                    <span class="tag">고유효과</span>
                    <span class="val" data-uval="armorType">-</span>
                  </div>
                </div>

                <div class="equip-list">

                  <button type="button" class="equip-row" data-slot="headshoulder" aria-label="머리어깨 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">머리어깨</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="top" aria-label="상의 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">상의</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="bottom" aria-label="하의 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">하의</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="belt" aria-label="허리 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">허리</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="shoes" aria-label="신발 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">신발</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                </div>
              </div>

              <!-- 악세사리 -->
              <div class="equip-group">
                <div class="equip-group-head">
                  <span>악세사리</span>

                  <div class="equip-u-mini" role="button" tabindex="0" data-utarget="braceletType"
                    data-uslot="bracelet">
                    <span class="tag">고유효과</span>
                    <span class="val" data-uval="braceletType">-</span>
                  </div>
                </div>
                <div class="equip-list">

                  <button type="button" class="equip-row" data-slot="bracelet" aria-label="팔찌 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">팔찌</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="necklace" aria-label="목걸이 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">목걸이</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="ring" aria-label="반지 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">반지</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span><span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                </div>
              </div>

              <!-- 특수장비 -->
              <div class="equip-group">
                <div class="equip-group-head">
                  <span>특수장비</span>

                  <div class="equip-u-mini" role="button" tabindex="0" data-utarget="earringType" data-uslot="earring">
                    <span class="tag">고유효과</span>
                    <span class="val" data-uval="earringType">-</span>
                  </div>
                </div>

                <div class="equip-list">

                  <button type="button" class="equip-row" data-slot="sub" data-grind="1" aria-label="보조장비 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">보조장비</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="magestone" aria-label="마법석 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">마법석</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                  <button type="button" class="equip-row" data-slot="earring" aria-label="귀걸이 선택">
                    <div class="equip-left">
                      <div class="equip-img" aria-hidden="true"></div>
                      <div class="equip-name">귀걸이</div>
                    </div>
                    <div class="equip-right">
                      <div class="equip-enh">
                        <div class="equip-enh-val">강화 +0</div>
                        <div class="equip-grind">연마 -</div>
                      </div>
                      <div class="equip-opts">
                        <div class="equip-unique">고유옵션 -</div>
                        <div class="equip-normal">일반옵션 -</div>
                      </div>
                      <div class="equip-enchant">
                        <div class="equip-col-title">마법부여</div>
                        <div class="equip-col-body">-</div>
                      </div>
                      <div class="equip-emblems">
                        <div class="equip-col-title">엠블렘</div>
                        <div class="equip-emblem-icons">
                          <span class="emb"></span>
                        </div>
                      </div>
                    </div>
                  </button>

                </div>
              </div>

            </div>
          </div>
        </section>

        <section class="m-page" id="pageEtc">
          <div class="m-card">
            <div class="page-title">3 / 4</div>

            <!-- 1) 아바타 / 무기압 -->
            <div class="opt-box">
              <h4 class="opt-title">아바타 세부 선택</h4>

              <label class="field">
                <span class="label">아바타</span>
                <select id="selAvatarM" class="select">
                  <option value="" selected>아바타 선택</option>
                </select>
              </label>

              <label class="field">
                <span class="label">무기압</span>
                <select id="selImprintM" class="select">
                  <option value="" selected>무기압 선택</option>
                </select>
              </label>
            </div>

            <!-- 2) 계산 세부 옵션 -->
            <div class="opt-box">
              <h4 class="opt-title">계산 세부 옵션 조절</h4>

              <label class="field">
                <span class="label">시간 기준</span>
                <select id="selTimeM" class="select">
                  <option value="30s">30초딜</option>
                  <option value="1m" selected>1분딜</option>
                  <option value="3m">3분딜</option>
                  <option value="5m">5분딜</option>
                  <option value="10m">10분딜</option>
                </select>
              </label>

              <label class="field">
                <span class="label">몬스터 설정</span>
                <select id="selMonsterM" class="select">
                  <option value="" selected>몬스터 선택</option>
                </select>
              </label>

              <label class="field">
                <span class="label">던전 난이도(미구현)</span>
                <select id="selDungeonM" class="select" disabled>
                  <option value="" selected>누골방 고정(미구현)</option>
                </select>
              </label>
            </div>

            <!-- 3) 스킬룬 / 룬각인 -->
            <div class="opt-box">
              <div class="opt-title">
                <span>스킬룬 / 룬 각인</span>
                <span style="font-size:12px;opacity:.8;">
                  선택 룬: <b id="runeCountM">0</b>
                </span>
              </div>

              <button id="btnRuneM" class="btn" type="button">스킬룬 설정</button>

              <div style="height:8px;"></div>

              <div class="row">
                <label class="field">
                  <span class="label">룬 각인 설정</span>
                  <select id="selRuneEngraveM" class="select">
                    <option value="" selected>룬 각인 선택</option>
                  </select>
                </label>

                <label class="field">
                  <span class="label">세부 설정</span>
                  <select id="selRuneDetailM" class="select" disabled>
                    <option value="" selected>세부 설정</option>
                  </select>
                </label>
              </div>
            </div>

            <!-- 4) 성안의 봉인 -->
            <div class="opt-box">
              <div class="opt-title">
                <span>성안의 봉인</span>
                <button id="btnCastleSealM" class="btn primary" type="button">옵션 선택</button>
              </div>
              <div id="castleSealSummaryM" style="font-size:12px;opacity:.85;">
                선택: -
              </div>
            </div>

          </div>
        </section>

        <!-- ✅ Page 4: Skill -->
        <section class="m-page" id="pageSkill">
          <div class="page-title">4 / 4</div>

          <div class="m-card">
            <div class="skill-sticky">
              <div class="skill-topbar">
                <div class="skill-topbar-title">스킬</div>
                <button id="btnSkillResetM" type="button" class="m-btn m-btn-ghost">초기화</button>
              </div>

              <div id="skillRemainBarM" class="skill-remaining is-hidden">
                <div class="item"><span class="k">남은 SP</span><span id="skillRemainSpM" class="num">-</span></div>
                <div class="item"><span class="k">남은 TP</span><span id="skillRemainTpM" class="num">-</span></div>
              </div>
            </div>

            <div id="skillListM" class="skill-list"></div>

            <div class="skill-footnote">
              * SP = 스킬 레벨, TP = TP 레벨 (각 행에서 MIN/MAX/±로 조절)
            </div>
          </div>
        </section>


      </div>
    </main>

    <!-- ====== Bottom Fixed ====== -->
    <footer class="m-footer" style="height: var(--footer-h);">
      <div class="m-footer-row">
        <button id="btnMobileCompute" class="m-calc-btn" type="button">계산하기</button>

        <div class="m-result">
          <div class="label">계산 결과</div>
          <div id="mobileFinalDamage" class="value">-</div>
        </div>
      </div>
    </footer>

  </div>

  <!-- ====== Modals (PC 것을 그대로 가져오기 쉬운 형태) ====== -->
  <!-- 관리자 문의 모달 -->
  <div id="contactModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-contact-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="contactTitle">
      <header>
        <h2 id="contactTitle">게임실험연구소에 문의하기</h2>
        <button type="button" class="close" data-contact-close>닫기</button>
      </header>

      <div class="contact-body">
        <div class="contact-notice">
          계산기 이용 중 정상적이지 않은 동작/오류/버그를 제보해주세요.<br />
          실시간 문의: 게임실험연구소 오픈채팅
        </div>

        <textarea id="contactTalk" class="contact-textarea" placeholder="문의 내용을 적어주세요."></textarea>
        <div class="contact-actions">
          <button id="btnContactSend" class="ui-btnetc" type="button">문의 보내기</button>
        </div>
      </div>
    </div>
  </div>

  <!-- FAQ 목록 모달 -->
  <div id="faqModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-faq-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="faqTitle">
      <header>
        <h2 id="faqTitle">문의하기 전 자주하는 Q&amp;A</h2>
        <button type="button" class="close" data-faq-close>닫기</button>
      </header>

      <div class="contact-body">
        <div class="contact-notice">
          가장 많이 하시는 질문들을 모아두었습니다.
        </div>
        <div id="faqList" class="faq-list"></div>
      </div>
    </div>
  </div>

  <!-- FAQ 답변 모달 (일단 placeholder) -->
  <div id="faqAnswerModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-faqans-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="faqAnswerTitle">
      <header>
        <h2 id="faqAnswerTitle">Q&amp;A</h2>
        <button type="button" class="close" data-faqans-close>닫기</button>
      </header>
      <div class="contact-body">
        <div id="faqAnswerText" class="contact-notice"></div>
      </div>
    </div>
  </div>


  <!-- ✅ 스킬룬 설정 모달 (모바일) -->
  <div id="runeModalM" class="modal" aria-hidden="true">
    <div class="backdrop" data-rune-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="runeDlgTitleM">
      <header style="display:flex;align-items:center;gap:10px;">
        <h2 id="runeDlgTitleM" style="flex:1;">
          스킬룬 설정
          <span style="font-size:12px;opacity:.75;font-weight:600;display:block;margin-top:2px;">
            선택한 스킬룬 개수: <b id="runeCountLabelM" style="color:#ef4444;">0</b> / 20
          </span>
        </h2>
        <button type="button" class="close" data-rune-close>닫기</button>
      </header>

      <div class="items" style="padding:10px;">
        <!-- ✅ 3드롭다운 헤더 라벨 -->
        <div class="rune-picker-head" aria-hidden="true">
          <div class="col">스킬룬 종류</div>
          <div class="col">스킬 레벨</div>
          <div class="col">스킬룬 갯수</div>
          <div class="spacer"></div> <!-- (우측 × 삭제 버튼 자리 정렬용) -->
        </div>
        <div id="runePickRowsM" class="rune-picker-rows"
          style="display:flex;flex-direction:column;gap:8px;margin-bottom:8px;"></div>
        <button id="btnRuneRowAddM" class="btn" type="button" style="width:100%;margin:0 0 10px;">+ 스킬룬 행 추가</button>

        <div class="special-runes">
          <div class="special-runes-title">특수 스킬룬</div>

          <div class="special-rune-row">
            <img src="./img/etc/skillrune/왜가지.png" alt="왜가지" class="special-rune-icon">
            <label for="specialRune_gahoM">가호</label>
            <select id="specialRune_gahoM" class="select rune-select" aria-label="가호 개수">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>

          <div class="special-rune-row">
            <img src="./img/etc/skillrune/왜가지.png" alt="왜가지" class="special-rune-icon">
            <label for="specialRune_jiheM">지혜</label>
            <select id="specialRune_jiheM" class="select rune-select" aria-label="지혜 개수">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>

          <div class="special-rune-row">
            <img src="./img/etc/skillrune/왜가지.png" alt="왜가지" class="special-rune-icon">
            <label for="specialRune_waegokM">왜곡</label>
            <select id="specialRune_waegokM" class="select rune-select" aria-label="왜곡 개수">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
            </select>
          </div>
        </div>

        <div style="height:10px;"></div>
        <button id="runeCommitM" class="btn primary" type="button" style="width:100%;">설정 하기</button>
      </div>
    </div>
  </div>
  <!-- ✅ 성안의 봉인 설정 모달 (모바일) -->
  <div id="castleSealModalM" class="modal" aria-hidden="true">
    <div class="backdrop" data-seal-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="castleSealDlgTitleM">
      <header style="display:flex;align-items:center;gap:10px;">
        <h2 id="castleSealDlgTitleM" style="flex:1;">성안의 봉인</h2>
        <button type="button" class="close" data-seal-close>닫기</button>
      </header>

      <div class="items" style="padding:10px;">
        <div style="display:flex;flex-direction:column;gap:10px;">
          <div>
            <div style="font-size:12px;font-weight:800;color:#c7b589;margin-bottom:6px;">주요 옵션</div>
            <select id="castleSealMainSelM" class="select" aria-label="주요 옵션"></select>
          </div>

          <div>
            <div style="font-size:12px;font-weight:800;color:#c7b589;margin-bottom:6px;">추가 옵션</div>
            <select id="castleSealSubSelM" class="select" aria-label="추가 옵션"></select>
          </div>

          <div style="height:6px;"></div>
          <button id="castleSealCommitM" class="btn primary" type="button" style="width:100%;">설정 하기</button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    window.idToken = sessionStorage.getItem('id_token') || null;
    window.WEBAPP_URL = window.WEBAPP_URL || 'https://dnf-backend.gogo456654.workers.dev';
    const WEBAPP_URL = window.WEBAPP_URL;   // 기존 코드들이 쓰는 식별자 보존
    // DB
    const DB = { itemsBySlot: {}, loaded: {}, chars: { loaded: false, groups: [] } };
    // ✅ 전역이 없으면 만들고
    window.DBEnh = window.DBEnh || { loaded: false, list: [], byType: {} };
    // ✅ 지역 별칭은 전역을 가리키게
    const DBEnh = window.DBEnh;
    // 1) 토큰만 보내는 API (시트/목록 로딩 계열)
    function getStoredToken() {
      return (
        window.idToken ||
        sessionStorage.getItem('id_token') ||
        localStorage.getItem('id_token') ||
        null
      );
    }

    async function waitForIdToken(timeoutMs = 1500) {
      // 1) 즉시 꺼내기
      const now = getStoredToken();
      if (now) {
        window.idToken = now;
        return now;
      }

      // 2) 짧게 폴링(PC에서 넘어오는 타이밍이 애매할 때 대비)
      const t0 = Date.now();
      while (Date.now() - t0 < timeoutMs) {
        const tok = getStoredToken();
        if (tok) {
          window.idToken = tok;
          return tok;
        }
        await new Promise(r => setTimeout(r, 60));
      }

      throw new Error('no_id_token');
    }

    async function apiText(type) {
      const token = await waitForIdToken();
      const res = await fetch(`${WEBAPP_URL}?type=${encodeURIComponent(type)}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'text/plain',
          'Authorization': `Bearer ${token}`,
        },
        body: token, // ✅ 하위호환 유지
      });

      if (!res.ok) {
        if (res.status === 401 || res.status === 403) {
          // 토큰이 만료/거부일 때 대비(선택)
          // sessionStorage.removeItem('id_token'); localStorage.removeItem('id_token');
        }
        throw new Error(`${type}_http_${res.status}`);
      }

      // 응답이 JSON이라고 가정하지만, 안전하게 처리
      const text = await res.text();
      try { return JSON.parse(text); }
      catch { throw new Error(`${type}_bad_json`); }
    }

    async function apiJSON(type, payload = {}) {
      const token = await waitForIdToken();

      // ✅ 네 기존 형식 유지: Authorization + body.id_token
      const body = { id_token: token, ...payload };

      const res = await fetch(`${WEBAPP_URL}?type=${encodeURIComponent(type)}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(body),
      });

      if (!res.ok) {
        if (res.status === 401 || res.status === 403) {
          // sessionStorage.removeItem('id_token'); localStorage.removeItem('id_token');
        }
        throw new Error(`${type}_http_${res.status}`);
      }

      const text = await res.text();
      try { return JSON.parse(text); }
      catch { throw new Error(`${type}_bad_json`); }
    }

    // ✅ 모바일: 최초 1회 init 호출로 경량리스트(=CORE.lists) 전부 확보
    let __mobileInitPromise = null;

    async function initMobileAllLightListsOnce() {
      if (__mobileInitPromise) return __mobileInitPromise;

      __mobileInitPromise = (async () => {
        const res = await apiJSON('init', {});
        if (!res?.ok) {
          __mobileInitPromise = null;
          throw new Error(res?.error || 'init_failed');
        }

        window.CORE = window.CORE || {};
        CORE.lists = res.lists || {};
        CORE.userEmail = res.email || null;

        return CORE.lists;
      })();

      return __mobileInitPromise;
    }

    // ===== 캐릭터 선택 (모바일 전용: 좌 썸네일 / 우 이름) =====
    window.state = window.state || {};

    function _normImg(src) {
      const s = String(src || '').trim();
      if (!s) return '';
      if (/^https?:\/\//i.test(s)) return s;
      // img/xxx 형태면 현재 경로 기준으로 로딩되게
      if (s.startsWith('img/')) return './' + s.replace(/^\.?\//, '');
      return s;
    }

    function _pick(obj, keys) {
      for (const k of keys) {
        if (obj && obj[k] != null && String(obj[k]).trim() !== '') return obj[k];
      }
      return '';
    }

    function _getCharName(c) {
      return String(_pick(c, ['name', '이름', 'charName', '캐릭터명']) || '').trim();
    }
    function _getCharThumb(c) {
      return _normImg(_pick(c, ['thumbnail', '썸네일', 'thumb', 'thumbSrc']));
    }
    // ✅ 메인 표시용: 반드시 '이미지' 컬럼만 사용(썸네일 fallback 금지)
    function _getCharMainImage(c) {
      // 혹시 컬럼명이 공백 포함(예: "이미지 " )으로 들어오는 경우까지 커버
      const direct = _pick(c, ['fullSrc', '이미지', 'image', 'img', 'imgSrc']);
      if (direct) return _normImg(direct);

      // 느슨한 매칭(키의 공백 제거 후 비교)
      const target = new Set(['이미지', 'image', 'img', 'imgsrc'].map(s => s.toLowerCase()));
      for (const k in (c || {})) {
        const nk = String(k).replace(/\s+/g, '').toLowerCase();
        if (target.has(nk) && String(c[k] || '').trim() !== '') return _normImg(c[k]);
      }
      return '';
    }
    function applyPickedCharacterUI(c) {
      const pickBtn = document.getElementById('btnPickChar');
      const imgEl = document.getElementById('pickedCharImg');

      if (!pickBtn || !imgEl) return;

      const name = _getCharName(c) || '';
      const imgSrc = _getCharMainImage(c);  // ✅ 메인은 '이미지'만

      // 이미지가 없으면(예외) 기존 버튼 유지
      if (!imgSrc) {
        pickBtn.style.display = '';
        pickBtn.textContent = name || '캐릭터 선택하기';
        imgEl.style.display = 'none';
        imgEl.removeAttribute('src');
        imgEl.alt = '';
        return;
      }

      // ✅ 요구사항: 선택버튼은 사라지고 이미지가 들어감
      pickBtn.style.display = 'none';
      imgEl.src = imgSrc;
      imgEl.alt = name ? `${name} 이미지` : '';
      imgEl.style.display = 'block';

      if (!imgEl.dataset.boundPick) {
        imgEl.dataset.boundPick = '1';
        imgEl.addEventListener('click', () => openMobileCharacterPicker());
      }
    }

    function _getCharJobGroup(c) {
      return String(_pick(c, ['jobGroup', '직업군', 'group', 'job_group']) || '').trim();
    }
    function _getCharBadge(c) {
      // ‘종류’ 컬럼(배지 이미지)
      return _normImg(_pick(c, ['type', '종류', 'badge', 'badgeSrc', 'kind']) || '');
    }

    function renderMobileCharList(items) {
      const catalog = document.getElementById('catalog');
      if (!catalog) return;

      catalog.innerHTML = '';

      if (!Array.isArray(items) || items.length === 0) {
        catalog.innerHTML = `<div style="opacity:.8;padding:12px;">캐릭터 목록이 비어있습니다.</div>`;
        return;
      }

      // 1) 직업군별로 그룹 만들기(등장 순서 유지)
      const order = [];
      const groups = new Map(); // jobGroup -> { title, badge, list: [] }

      for (const c of items) {
        const name = _getCharName(c);
        if (!name) continue;

        const job = _getCharJobGroup(c) || '기타';
        const badge = _getCharBadge(c);

        if (!groups.has(job)) {
          groups.set(job, { title: job, badge: badge || '', list: [] });
          order.push(job);
        }
        const g = groups.get(job);
        if (!g.badge && badge) g.badge = badge; // 비어있으면 채워두기

        g.list.push(c);
      }

      // 2) 렌더
      const frag = document.createDocumentFragment();

      for (const job of order) {
        const g = groups.get(job);

        const groupEl = document.createElement('div');
        groupEl.className = 'mchar-group';

        // 헤더(배지 + 직업군명)
        const head = document.createElement('div');
        head.className = 'mchar-group-head';

        const img = document.createElement('img');
        img.className = 'mchar-badge';
        img.loading = 'lazy';
        img.alt = job;
        // 배지 없을 때 깨짐 방지(투명 1x1)
        img.src = g.badge || 'data:image/gif;base64,R0lGODlhAQABAAAAACw=';

        const titleWrap = document.createElement('div');
        titleWrap.innerHTML = `
      <span class="mchar-group-title">${job}</span>
      <span class="mchar-group-sub">(${g.list.length})</span>
    `;

        head.appendChild(img);
        head.appendChild(titleWrap);

        // 바디(기존 row를 그대로 사용)
        const body = document.createElement('div');
        body.className = 'mchar-group-body';

        for (const c of g.list) {
          const name = _getCharName(c);
          const thumb = _getCharThumb(c);

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'mchar-row';
          btn.innerHTML = `
        <img class="mchar-thumb" src="${thumb}" alt="">
        <div class="mchar-name">${name}</div>
      `;



          btn.addEventListener('click', () => {
            const job = String(c.jobGroupLabel || c.jobGroup || c.job || '').trim();
            const nm = String(name || c.name || '').trim();
            const ownerKey = (job + nm).replace(/\s+/g, '');
            // 선택 저장
            window.state.currentCharacter = { ...c, name: nm, ownerKey };

            // ✅ 버튼 숨기고, 캐릭 이미지 표시
            applyPickedCharacterUI(window.state.currentCharacter);

            // ✅ 스킬 페이지 갱신
            ensurePage4Init();
            renderSkillPageMobile(window.state.currentCharacter);

            // 모달 닫기
            const m = document.getElementById('charModal');
            if (m) {
              m.classList.remove('show');
              m.setAttribute('aria-hidden', 'true');
            }
          });

          body.appendChild(btn);
        }

        groupEl.appendChild(head);
        groupEl.appendChild(body);
        frag.appendChild(groupEl);
      }

      catalog.appendChild(frag);
    }

    async function openMobileCharacterPicker() {
      // init에서 경량리스트들 받아온다
      await initMobileAllLightListsOnce();

      // 핵심: char:list 배열
      const items = window.CORE?.lists?.['char:list'];

      renderMobileCharList(items);

      const m = document.getElementById('charModal');
      if (m) {
        m.classList.add('show');
        m.setAttribute('aria-hidden', 'false');
      }
    }

    // 닫기(backdrop + 닫기 버튼)
    document.querySelectorAll('[data-char-close]').forEach(el => {
      el.addEventListener('click', () => {
        const m = document.getElementById('charModal');
        m?.classList.remove('show');
        m?.setAttribute('aria-hidden', 'true');
      });
    });


    // ===== Toast =====
    function toast(msg) {
      const el = document.getElementById('toast');
      if (!el) return alert(msg);
      el.textContent = msg;
      el.classList.add('show');
      clearTimeout(el._t);
      el._t = setTimeout(() => el.classList.remove('show'), 1400);
    }

    // ✅ 페이지 열리면 즉시 경량리스트 전부 로드 + (원하면) 3페이지 init도 즉시 실행
    initMobileAllLightListsOnce()
      .then(() => {
        ensurePage3Init();
        ensurePage4Init();   // ✅ 추가
      })
      .catch((e) => {
        console.error(e);
        toast('초기 데이터 로딩 실패');
      });

    function fillSelectOptions_(sel, items, placeholder) {
      if (!sel) return;

      // 초기화
      sel.innerHTML = '';

      // placeholder
      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = placeholder;
      opt0.selected = true;
      sel.appendChild(opt0);

      // items
      for (const n of (items || [])) {
        const name = String(n ?? '').trim();
        if (!name) continue;
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
      }
    }

    // 3페이지: 아바타/무기압 드롭다운 채우기 (ENH list 기반)
    async function populateAvatarImprintMobile() {
      console.log('[AVATAR] start');
      await initMobileAllLightListsOnce();
      console.log('[AVATAR] after init', {
        hasCore: !!window.CORE,
        hasLists: !!window.CORE?.lists,
        keys: Object.keys(window.CORE?.lists || {}).slice(0, 20),
        enhListLen: Array.isArray(window.CORE?.lists?.['enh:list']) ? window.CORE.lists['enh:list'].length : null
      });

      const aSel = document.getElementById('selAvatarM');
      const iSel = document.getElementById('selImprintM');
      console.log('[AVATAR] selects', { aSel: !!aSel, iSel: !!iSel, aId: aSel?.id, iId: iSel?.id });

      const rows = Array.isArray(CORE?.lists?.['enh:list']) ? CORE.lists['enh:list'] : [];
      // 샘플 3개만 구조 확인
      console.log('[AVATAR] enh:list sample', rows.slice(0, 3));

      // 타입/이름이 실제로 어떤 키로 들어오는지 “자동 탐색”용
      const probe = rows.slice(0, 50).map(r => ({
        type: r?.type, 종류: r?.['종류'],
        name: r?.name, 이름: r?.['이름'],
        keys: Object.keys(r || {}).slice(0, 10)
      }));
      console.log('[AVATAR] probe(50)', probe);

      const pickNames = (wantType) => {
        const out = [];
        const seen = new Set();
        for (const r of rows) {
          const type = String(r?.type ?? r?.['종류'] ?? '').trim();
          if (type !== wantType) continue;
          const name = String(r?.name ?? r?.['이름'] ?? '').trim();
          if (!name || seen.has(name)) continue;
          seen.add(name);
          out.push(name);
        }
        return out;
      };

      const avatars = pickNames('아바타');
      const imprints = pickNames('무기압');
      console.log('[AVATAR] picked', { avatarsLen: avatars.length, imprintsLen: imprints.length, avatars0: avatars[0], imprints0: imprints[0] });

      try {
        console.log('[AVATAR] before fill', { aOptions: aSel?.options?.length, iOptions: iSel?.options?.length });
        fillSelectOptions_(aSel, avatars, '아바타 선택');
        fillSelectOptions_(iSel, imprints, '무기압 선택');
        console.log('[AVATAR] after fill', { aOptions: aSel?.options?.length, iOptions: iSel?.options?.length });
      } catch (e) {
        console.error('[AVATAR] fillSelectOptions_ crashed', e);
      }

      /* ✅✅✅ [추가 시작] 선택값을 window.state.avatarSel에 저장/복원 + change 바인딩 */
      window.state = window.state || {};
      const s = window.state;

      // state 슬롯 준비
      s.avatarSel = s.avatarSel || { avatarName: '', imprintName: '' };

      // 1) 기존 state 값이 있으면 UI에 복원, 없으면 첫 옵션을 기본값으로 state에 저장
      if (aSel) {
        const savedA = String(s.avatarSel.avatarName || '').trim();
        if (savedA && avatars.includes(savedA)) {
          aSel.value = savedA;
        } else if (avatars.length) {
          aSel.value = avatars[0];
          s.avatarSel.avatarName = String(aSel.value || '').trim();
        }
      }

      if (iSel) {
        const savedI = String(s.avatarSel.imprintName || '').trim();
        if (savedI && imprints.includes(savedI)) {
          iSel.value = savedI;
        } else if (imprints.length) {
          iSel.value = imprints[0];
          s.avatarSel.imprintName = String(iSel.value || '').trim();
        }
      }

      // 2) change 이벤트(중복 바인딩 방지)
      if (aSel && !aSel.dataset.boundAvatar) {
        aSel.addEventListener('change', () => {
          s.avatarSel = s.avatarSel || {};
          s.avatarSel.avatarName = String(aSel.value || '').trim();
          console.log('[AVATAR] state.avatarSel updated', s.avatarSel);
        });
        aSel.dataset.boundAvatar = '1';
      }

      if (iSel && !iSel.dataset.boundImprint) {
        iSel.addEventListener('change', () => {
          s.avatarSel = s.avatarSel || {};
          s.avatarSel.imprintName = String(iSel.value || '').trim();
          console.log('[AVATAR] state.avatarSel updated', s.avatarSel);
        });
        iSel.dataset.boundImprint = '1';
      }

      console.log('[AVATAR] init mirror done', s.avatarSel);
      /* ✅✅✅ [추가 끝] */

      console.log('[AVATAR] done');

    }

    // 3페이지: 몬스터 목록 (CORE.lists['monster:list'])
    async function populateMonsterMobile() {
      await initMobileAllLightListsOnce();

      const sel = document.getElementById('selMonsterM');
      if (!sel) return;

      const list = CORE?.lists?.['monster:list'] || [];
      console.log('[M3][MON] raw list len =', Array.isArray(list) ? list.length : -1, 'sample =', list?.[0]);

      // ✅ monster 시트는 '몬스터명' 컬럼이 핵심
      const names = (Array.isArray(list) ? list : [])
        .map(x => {
          if (typeof x === 'string') return x.trim();
          return String(
            x?.['몬스터명'] ?? x?.monName ?? x?.monsterName ?? x?.name ?? ''
          ).trim();
        })
        .filter(Boolean);

      console.log('[M3][MON] parsed names len =', names.length, 'head =', names.slice(0, 5));

      fillSelectOptions_(sel, names.length ? names : ['(데이터 없음)'], '몬스터 선택');

      window.state = window.state || {};
      const s = window.state;



      // ✅ 기존 선택 복원 + 기본값(맨 윗값) 자동 적용
      if (s.monsterName && names.includes(s.monsterName)) {
        sel.value = s.monsterName;
      } else if (names.length) {
        // ✅ 기본값: 가장 윗값
        sel.value = names[0];
        s.monsterName = String(sel.value || '').trim();
        console.log('[M3][MON] default applied:', s.monsterName);
      }


      // ✅ init이 여러 번 호출돼도 리스너 중복 등록 방지
      if (!sel.dataset.bound) {
        sel.addEventListener('change', () => { s.monsterName = (sel.value || '').trim(); });
        sel.dataset.bound = '1';
      }
    }


    // 3페이지: 룬각인 목록/세부설정 (ENH list의 '룬각인')
    async function populateRuneEngraveMobile() {
      await initMobileAllLightListsOnce();
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const sel1 = document.getElementById('selRuneEngraveM');
      const sel2 = document.getElementById('selRuneDetailM');
      if (!sel1 || !sel2) return;

      const rows = DBEnh?.byType?.['룬각인'] || [];

      // ✅ 이름 목록(중복 제거)
      const seen = new Set();
      const names = [];
      rows.forEach(r => {
        const n = String(r?.name ?? r?.['이름'] ?? '').trim();
        if (n && !seen.has(n)) { seen.add(n); names.push(n); }
      });

      // 룬각인 이름 드롭다운 채우기
      fillSelectOptions_(sel1, names, '룬 각인 선택');

      // ✅ 세부 설정 채우기 (escapeHtml 없이 DOM으로)
      const fillDetail = (name) => {
        // 초기화
        sel2.innerHTML = '';
        const opt0 = document.createElement('option');
        opt0.value = '';
        opt0.textContent = '세부 설정';
        opt0.selected = true;
        sel2.appendChild(opt0);

        const keyName = String(name || '').trim();
        if (!keyName) {
          sel2.disabled = true;
          return;
        }

        const hit = rows.filter(r => String(r?.name ?? r?.['이름'] ?? '').trim() === keyName);

        // ✅ PC와 동일한 우선순위: levelVal > tag > 렙제(등)
        const ds = [];
        const dseen = new Set();
        hit.forEach(r => {
          const v = String(
            r?.levelVal ??
            r?.['levelVal'] ??
            r?.tag ??
            r?.['렙제'] ??
            r?.level ??
            r?.['레벨'] ??
            ''
          ).trim();

          if (v && !dseen.has(v)) {
            dseen.add(v);
            ds.push(v);
          }
        });

        for (const v of ds) {
          const op = document.createElement('option');
          op.value = v;
          op.textContent = v;
          sel2.appendChild(op);
        }

        sel2.disabled = (ds.length === 0);
      };

      // state 준비
      window.state = window.state || {};
      const s = window.state;
      s.runeEngrave = s.runeEngrave || { type: '룬각인', name: '', level: '' };

      // 복원
      if (s.runeEngrave.name && names.includes(s.runeEngrave.name)) sel1.value = s.runeEngrave.name;
      if (sel1.value) fillDetail(sel1.value);
      if (s.runeEngrave.level && !sel2.disabled) sel2.value = s.runeEngrave.level;

      // ✅ 리스너 중복 방지
      if (!sel1.dataset.bound) {
        sel1.addEventListener('change', () => {
          s.runeEngrave.name = (sel1.value || '').trim();
          s.runeEngrave.level = '';
          fillDetail(s.runeEngrave.name);
        });
        sel1.dataset.bound = '1';
      }

      if (!sel2.dataset.bound) {
        sel2.addEventListener('change', () => {
          s.runeEngrave.level = (sel2.value || '').trim();
        });
        sel2.dataset.bound = '1';
      }
    }


    // 3페이지: 시간 기준 저장
    function bindTimeMobile() {
      const sel = document.getElementById('selTimeM');
      if (!sel) return;
      window.state = window.state || {};
      const s = window.state;
      if (s.timeKey) sel.value = s.timeKey;
      sel.addEventListener('change', () => { s.timeKey = sel.value; });
      if (!s.timeKey) s.timeKey = sel.value;
    }

    // 3페이지: 스킬룬(모달)
    const RUNE_LEVELS = [15, 20, 25, 30, 35, 40, 45, 65];
    const RUNE_CATS = [
      { key: 'awakening', label: '각성', icon: './img/etc/skillrune/각성.png' },
      { key: 'magic', label: '마력', icon: './img/etc/skillrune/마력.png' },
      { key: 'illusion', label: '허상', icon: './img/etc/skillrune/허상.png' },
      { key: 'training', label: '숙련', icon: './img/etc/skillrune/숙련.png' },
      { key: 'technique', label: '기교', icon: './img/etc/skillrune/기교.png' },
    ];

    function _emptyRunes_() {
      const o = {};
      RUNE_CATS.forEach(c => {
        o[c.key] = {};
        RUNE_LEVELS.forEach(lv => { o[c.key][lv] = 0; });
      });
      return o;
    }
    function ensureRunesInitialized() {
      window.state = window.state || {};
      const s = window.state;
      if (!s.runes || typeof s.runes !== 'object') s.runes = _emptyRunes_();

      // 누락된 키/레벨 채우기(구버전/프리셋 호환)
      RUNE_CATS.forEach(c => {
        if (!s.runes[c.key] || typeof s.runes[c.key] !== 'object') s.runes[c.key] = {};
        RUNE_LEVELS.forEach(lv => {
          const v = Number(s.runes[c.key][lv] ?? 0);
          s.runes[c.key][lv] = Number.isFinite(v) ? v : 0;
        });
      });
    }
    function ensureSpecialRunesInitialized() {
      window.state = window.state || {};
      const s = window.state;
      if (!s.specialRunes || typeof s.specialRunes !== 'object') s.specialRunes = { gaho: 0, jihe: 0, waegok: 0 };
      s.specialRunes.gaho = Number(s.specialRunes.gaho ?? 0) || 0;
      s.specialRunes.jihe = Number(s.specialRunes.jihe ?? 0) || 0;
      s.specialRunes.waegok = Number(s.specialRunes.waegok ?? 0) || 0;
    }

    function countSelectedRunes() {
      const s = window.state || {};
      let n = 0;
      const runes = s.runes || {};
      RUNE_CATS.forEach(c => {
        const row = runes[c.key] || {};
        RUNE_LEVELS.forEach(lv => { n += Number(row[lv] || 0); });
      });
      const sp = s.specialRunes || {};
      n += Number(sp.gaho || 0) + Number(sp.jihe || 0) + Number(sp.waegok || 0);
      return n;
    }

    function updateRuneCountSummary() {
      const n = countSelectedRunes();
      const main = document.getElementById('runeCountM');
      const lbl = document.getElementById('runeCountLabelM');
      if (main) main.textContent = String(n);
      if (lbl) lbl.textContent = String(n);
    }

    function _capTo20OrRevert_(applyFn, revertFn) {
      const n = countSelectedRunes();
      if (n <= 20) {
        updateRuneCountSummary();
        return true;
      }
      // 초과면 revert
      revertFn?.();
      updateRuneCountSummary();
      toast('스킬룬은 최대 20개까지 선택할 수 있어요.');
      return false;
    }



    // ✅ 스킬룬(모바일 행 UI) 전역 유틸: 행 정규화(중복 합치기/유효성 보정/최소 1행/최대 5행)
    const MAX_RUNE_ROWS_M = 5;

    function _getRuneDefaultsM_() {
      const cats = (typeof RUNE_CATS !== 'undefined' && Array.isArray(RUNE_CATS)) ? RUNE_CATS : [];
      const levels = (typeof RUNE_LEVELS !== 'undefined' && Array.isArray(RUNE_LEVELS)) ? RUNE_LEVELS : [];
      const defCat = (cats[0] != null) ? (cats[0].key ?? cats[0]) : 'awakening';
      const defTier = (levels[0] != null ? Number(levels[0]) : 15) || 15;
      return { cats, levels, defCat, defTier };
    }

    function _isValidRuneCatM_(cat) {
      const { cats } = _getRuneDefaultsM_();
      return (cats || []).some(c => (c.key ?? c) === cat);
    }
    function _isValidRuneTierM_(tier) {
      const { levels } = _getRuneDefaultsM_();
      return (levels || []).map(Number).includes(Number(tier));
    }

    function normalizeRuneRowsM() {
      window.state = window.state || {};
      const s = window.state;

      // 없으면 생성
      const src = Array.isArray(s.runeRowsM) ? s.runeRowsM : [];
      const { levels, defCat, defTier } = _getRuneDefaultsM_();

      const out = [];
      const idxMap = new Map();
      let merged = false, trimmed = false;

      for (const r of src) {
        const catRaw = String(r?.cat ?? '').trim();
        const cat = _isValidRuneCatM_(catRaw) ? catRaw : defCat;

        const tierN = Number(r?.tier ?? defTier) || defTier;
        const tier = _isValidRuneTierM_(tierN) ? Number(tierN) : Number(defTier);

        const cnt = Math.max(0, Math.min(20, Math.floor(Number(r?.cnt ?? 0) || 0)));

        const key = cat + '|' + String(tier);
        if (idxMap.has(key)) {
          const i = idxMap.get(key);
          out[i].cnt = Math.min(20, Number(out[i].cnt || 0) + cnt);
          merged = true;
        } else {
          idxMap.set(key, out.length);
          out.push({ cat, tier, cnt });
        }
      }

      if (out.length === 0) {
        out.push({ cat: defCat, tier: Number(defTier), cnt: 0 });
      }

      if (out.length > MAX_RUNE_ROWS_M) {
        out.length = MAX_RUNE_ROWS_M;
        trimmed = true;
      }

      s.runeRowsM = out;
      return { merged, trimmed };
    }
    function bindRunePickerMobile() {
      const wrap = document.getElementById('runePickRowsM');
      const addBtn = document.getElementById('btnRuneRowAddM');
      if (!wrap || !addBtn) return;

      ensureRunesInitialized();
      ensureSpecialRunesInitialized();

      window.state = window.state || {};
      const s = window.state;

      // ✅ 행 모델: [{cat, tier, cnt}] (모달 UI 전용)
      if (!Array.isArray(s.runeRowsM)) {
        s.runeRowsM = [];

        // 기존 state.runes(그리드 방식) → 행으로 변환
        try {
          (RUNE_CATS || []).forEach(c => {
            (RUNE_LEVELS || []).forEach(lv => {
              const n = Number(((s.runes || {})[c.key] || {})[lv] ?? 0) || 0;
              if (n > 0) s.runeRowsM.push({ cat: c.key, tier: Number(lv), cnt: n });
            });
          });
        } catch (_) { }

        // 아무것도 없으면 기본 1행
        if (s.runeRowsM.length === 0) {
          s.runeRowsM.push({
            cat: (RUNE_CATS && RUNE_CATS[0] ? RUNE_CATS[0].key : 'awakening'),
            tier: (RUNE_LEVELS && RUNE_LEVELS[0] ? Number(RUNE_LEVELS[0]) : 15),
            cnt: 0
          });
        }
      }

      // 초기 정규화(최대 5행 제한)
      const _initNorm_ = normalizeRuneRowsM();
      if (_initNorm_.trimmed) {
        toast('저장된 스킬룬 조합이 5개를 초과하여 일부가 표시/저장 제한으로 제외될 수 있어요.');
      }

      // ✅ 행 → state.runes(집계) 반영
      const buildAggregateRunes = () => {
        const agg = _emptyRunes_();
        (s.runeRowsM || []).forEach(r => {
          const catKey = String(r?.cat || '').trim();
          const tier = Number(r?.tier || 0) || 0;
          const cnt = Number(r?.cnt || 0) || 0;
          if (!catKey || !Number.isFinite(tier) || !Number.isFinite(cnt)) return;
          if (agg[catKey] && Object.prototype.hasOwnProperty.call(agg[catKey], tier)) {
            agg[catKey][tier] = Number(agg[catKey][tier] || 0) + Math.max(0, cnt);
          }
        });
        return agg;
      };

      const applyRowsToStateOrRevert = (revertFn) => {
        const beforeRunes = s.runes;
        const nextRunes = buildAggregateRunes();
        s.runes = nextRunes;

        const ok = _capTo20OrRevert_(
          () => { },
          () => {
            s.runes = beforeRunes;
            revertFn?.();
          }
        );
        return ok;
      };

      const makeSelect = (cls, aria) => {
        const el = document.createElement('select');
        el.className = cls || 'select rune-select';
        if (aria) el.setAttribute('aria-label', aria);
        return el;
      };

      const fillCatOptions = (sel) => {
        sel.innerHTML = '';
        (RUNE_CATS || []).forEach(c => {
          const opt = document.createElement('option');
          opt.value = c.key;
          opt.textContent = c.label;
          sel.appendChild(opt);
        });
      };

      const fillTierOptions = (sel) => {
        sel.innerHTML = '';
        (RUNE_LEVELS || []).forEach(lv => {
          const opt = document.createElement('option');
          opt.value = String(lv);
          opt.textContent = String(lv);
          sel.appendChild(opt);
        });
      };

      const fillCntOptions = (sel) => {
        sel.innerHTML = '';
        for (let i = 0; i <= 20; i++) {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = String(i);
          sel.appendChild(opt);
        }
      };

      const pickNextUnusedRunePairM = () => {
        const used = new Set((s.runeRowsM || []).map(r => `${r.cat}|${r.tier}`));

        const cats = (RUNE_CATS || []).map(c => c.key);
        const tiers = (RUNE_LEVELS || []).map(Number);

        const defCat = (cats[0] || 'awakening');
        const defTier = (tiers[0] || 15);

        // 1) 같은 cat에서 tier만 다음으로 돌리기(체감상 가장 자연스러움)
        const sameCatTiers = tiers.slice();
        // 기본 tier 다음부터 우선 시도
        const startIdx = Math.max(0, sameCatTiers.indexOf(defTier));
        const rotated = sameCatTiers.slice(startIdx).concat(sameCatTiers.slice(0, startIdx));

        for (const t of rotated) {
          const key = `${defCat}|${t}`;
          if (!used.has(key)) return { cat: defCat, tier: t };
        }

        // 2) 그래도 없으면 전체 cats×tiers에서 첫 미사용 조합 찾기
        for (const c of cats) {
          for (const t of tiers) {
            const key = `${c}|${t}`;
            if (!used.has(key)) return { cat: c, tier: t };
          }
        }

        // 전부 사용중(= 더 추가해봤자 중복합치기로 티도 안 남)
        return null;
      };

      const render = () => {
        // 중복/유효성 보정
        normalizeRuneRowsM();

        wrap.innerHTML = '';

        (s.runeRowsM || []).forEach((row, idx) => {
          const rowEl = document.createElement('div');
          rowEl.className = 'rune-picker-row';
          rowEl.style.cssText = 'display:flex;gap:8px;align-items:center;';

          const selCat = makeSelect('select rune-select', '룬 종류');
          const selTier = makeSelect('select rune-select', '레벨');
          const selCnt = makeSelect('select rune-select', '개수');

          fillCatOptions(selCat);
          fillTierOptions(selTier);
          fillCntOptions(selCnt);

          // 값 복원(유효성 보정)
          const defCat = (RUNE_CATS && RUNE_CATS[0] ? RUNE_CATS[0].key : 'awakening');
          const defTier = (RUNE_LEVELS && RUNE_LEVELS[0] ? Number(RUNE_LEVELS[0]) : 15);

          const catKey = String(row?.cat || defCat);
          const tier = Number(row?.tier ?? defTier) || defTier;
          const cnt = Math.max(0, Number(row?.cnt ?? 0) || 0);

          selCat.value = (RUNE_CATS || []).some(c => c.key === catKey) ? catKey : defCat;
          selTier.value = (RUNE_LEVELS || []).map(Number).includes(Number(tier)) ? String(tier) : String(defTier);
          selCnt.value = String(Math.min(20, cnt));

          // state에 정규화
          row.cat = selCat.value;
          row.tier = Number(selTier.value || defTier) || defTier;
          row.cnt = Number(selCnt.value || 0) || 0;

          const onChange = () => {
            // 변경 전 스냅샷(행/집계 revert 용)
            const prevRows = (s.runeRowsM || []).map(x => ({ cat: x.cat, tier: x.tier, cnt: x.cnt }));

            row.cat = String(selCat.value || defCat);
            row.tier = Number(selTier.value || defTier) || defTier;
            row.cnt = Number(selCnt.value || 0) || 0;

            // ✅ 중복 선택은 자동 합치기 + 행 최대 5개 제한
            const norm = normalizeRuneRowsM();

            const ok = applyRowsToStateOrRevert(() => {
              // revert rows
              s.runeRowsM = prevRows;
            });

            // 정규화/합치기 반영 위해 항상 재렌더
            render();

            if (ok) {
              if (norm.merged) toast('중복 선택은 자동으로 합쳐졌어요.');
              if (norm.trimmed) toast('스킬룬 행은 최대 5개까지 추가할 수 있어요.');
            } else {
              try { selCnt.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], { duration: 180 }); } catch (_) { }
            }
          };

          selCat.addEventListener('change', onChange);
          selTier.addEventListener('change', onChange);
          selCnt.addEventListener('change', onChange);

          // 🗑 행 삭제 버튼(× 아이콘형)
          const btnDel = document.createElement('button');
          btnDel.type = 'button';
          btnDel.className = 'btn rune-row-del rune-icon-btn';
          btnDel.innerHTML = '&times;';          // ×
          btnDel.title = '행 삭제';
          btnDel.setAttribute('aria-label', '행 삭제');

          btnDel.addEventListener('click', (e) => {
            e.preventDefault(); e.stopPropagation();
            if ((s.runeRowsM || []).length <= 1) {
              toast('최소 1행은 남겨야 해요.');
              return;
            }
            const prevRows = (s.runeRowsM || []).map(x => ({ cat: x.cat, tier: x.tier, cnt: x.cnt }));
            s.runeRowsM.splice(idx, 1);
            const ok = applyRowsToStateOrRevert(() => {
              s.runeRowsM = prevRows;
            });
            render();
            if (ok) toast('스킬룬 행이 삭제되었습니다.');
          });

          rowEl.appendChild(selCat);
          rowEl.appendChild(selTier);
          rowEl.appendChild(selCnt);
          rowEl.appendChild(btnDel);
          wrap.appendChild(rowEl);
        });

        updateRuneCountSummary();
      };

      // ✅ + 버튼(1회 바인딩)
      if (!addBtn.dataset.bound) {
        addBtn.addEventListener('click', () => {
          if ((s.runeRowsM || []).length >= MAX_RUNE_ROWS_M) {
            toast('스킬룬 행은 최대 5개까지 추가할 수 있어요.');
            return;
          }

          const nextPair = pickNextUnusedRunePairM();
          if (!nextPair) {
            toast('추가할 수 있는 조합이 없어요. (중복 선택은 자동으로 합쳐집니다)');
            return;
          }

          s.runeRowsM.push({ cat: nextPair.cat, tier: Number(nextPair.tier), cnt: 0 });

          applyRowsToStateOrRevert(() => { });
          render();
          toast('스킬룬 행이 추가되었습니다.');
        });
        addBtn.dataset.bound = '1';
      }

      // 최초: rows → runes 반영 + 렌더
      applyRowsToStateOrRevert(() => { });
      render();
    }



    function bindSpecialRuneSelectsMobile() {
      const gaho = document.getElementById('specialRune_gahoM');
      const jihe = document.getElementById('specialRune_jiheM');
      const waegok = document.getElementById('specialRune_waegokM');
      if (!gaho || !jihe || !waegok) return;

      ensureSpecialRunesInitialized();

      // 초기값 반영
      gaho.value = String(window.state.specialRunes.gaho || 0);
      jihe.value = String(window.state.specialRunes.jihe || 0);
      waegok.value = String(window.state.specialRunes.waegok || 0);

      const onChange = (key, el) => {
        const s = window.state || {};
        const before = Number(s.specialRunes?.[key] ?? 0) || 0;
        const after = Number(el.value || 0) || 0;

        s.specialRunes[key] = after;

        const ok = _capTo20OrRevert_(
          () => { },
          () => {
            s.specialRunes[key] = before;
            el.value = String(before);
          }
        );

        if (!ok) {
          try { el.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], { duration: 180 }); } catch (_) { }
        }
      };

      gaho.addEventListener('change', () => onChange('gaho', gaho));
      jihe.addEventListener('change', () => onChange('jihe', jihe));
      waegok.addEventListener('change', () => onChange('waegok', waegok));

      updateRuneCountSummary();
    }

    function openRuneModalMobile() {
      const modal = document.getElementById('runeModalM');
      if (!modal) return;

      ensureRunesInitialized();
      ensureSpecialRunesInitialized();

      // 렌더 + 바인딩
      bindRunePickerMobile();
      bindSpecialRuneSelectsMobile();

      modal.classList.add('show');
      modal.setAttribute('aria-hidden', 'false');
      updateRuneCountSummary();
    }

    function closeRuneModalMobile() {
      const modal = document.getElementById('runeModalM');
      if (!modal) return;
      modal.classList.remove('show');
      modal.setAttribute('aria-hidden', 'true');
      updateRuneCountSummary();
    }

    function bindRuneButtonMobile() {
      const btn = document.getElementById('btnRuneM');
      if (!btn) return;

      // 버튼 클릭 → 모달 오픈
      if (!btn.dataset.bound) {
        btn.addEventListener('click', () => {
          openRuneModalMobile();
        });
        btn.dataset.bound = '1';
      }

      // 모달 close / commit 바인딩은 1회만
      const modal = document.getElementById('runeModalM');
      if (modal && !modal.dataset.bound) {
        modal.addEventListener('click', (e) => {
          if (e.target?.dataset?.runeClose !== undefined) closeRuneModalMobile();
          if (e.target?.classList?.contains('backdrop')) closeRuneModalMobile();
        });
        modal.querySelectorAll('[data-rune-close]').forEach(el => {
          el.addEventListener('click', closeRuneModalMobile);
        });

        const commit = document.getElementById('runeCommitM');
        commit?.addEventListener('click', () => {
          // state에 이미 반영되어 있으므로 닫기만
          closeRuneModalMobile();
          toast('스킬룬 설정이 적용되었습니다.');
        });

        modal.dataset.bound = '1';
      }

      // 초기 카운트 반영
      ensureRunesInitialized();
      ensureSpecialRunesInitialized();
      updateRuneCountSummary();
    }



    async function bindCastleSealMobile() {
      // 0) 데이터 준비
      await initMobileAllLightListsOnce();
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const btn = document.getElementById('btnCastleSealM');
      const sum = document.getElementById('castleSealSummaryM');
      const modal = document.getElementById('castleSealModalM');

      if (!btn || !sum) return;

      window.state = window.state || {};
      const s = window.state;
      s.castleSeal = s.castleSeal || { mainName: '', subName: '' };

      const refresh = () => {
        const a = s.castleSeal.mainName ? `주요: ${s.castleSeal.mainName}` : '주요: -';
        const b = s.castleSeal.subName ? `추가: ${s.castleSeal.subName}` : '추가: -';
        sum.textContent = `선택: ${a} / ${b}`;
      };
      refresh();

      // 1) 옵션 목록(매번 최신 DBEnh 기준)
      const getLists = () => {
        const mains = (DBEnh?.byType?.['주요 옵션'] || [])
          .map(r => String(r?.name ?? r?.['이름'] ?? '').trim())
          .filter(Boolean);

        const subs = (DBEnh?.byType?.['추가 옵션'] || [])
          .map(r => String(r?.name ?? r?.['이름'] ?? '').trim())
          .filter(Boolean);

        return { mains, subs };
      };

      // ✅ [추가] 기본값 자동 세팅: 비어있으면 항상 “맨 위(0번)”로
      const ensureCastleSealDefaults = () => {
        const { mains, subs } = getLists();

        if (!s.castleSeal.mainName && mains.length) {
          s.castleSeal.mainName = mains[0];
        }
        if (!s.castleSeal.subName && subs.length) {
          s.castleSeal.subName = subs[0];
        }
      };

      // ✅ [추가] 바인딩 시점에 1번 기본값 확정 + 요약 갱신
      ensureCastleSealDefaults();
      refresh();

      const openModal = () => {
        if (!modal) {
          console.error('[CastleSeal] modal not found: #castleSealModalM');
          toast('성안의 봉인 모달이 없습니다. HTML을 확인하세요.');
          return;
        }

        const selMain = document.getElementById('castleSealMainSelM');
        const selSub = document.getElementById('castleSealSubSelM');
        if (!selMain || !selSub) {
          console.error('[CastleSeal] selects not found', { selMain: !!selMain, selSub: !!selSub });
          toast('성안의 봉인 셀렉트가 없습니다. HTML을 확인하세요.');
          return;
        }

        // ✅ [추가] 모달 열 때도 안전하게 기본값 보정
        ensureCastleSealDefaults();

        const { mains, subs } = getLists();

        const fill = (sel, arr, current) => {
          // DOM 방식으로 안전하게 채우기
          sel.innerHTML = '';
          const opt0 = document.createElement('option');
          opt0.value = '';
          opt0.textContent = '- 선택 안함 -';
          sel.appendChild(opt0);

          for (const name of arr) {
            const op = document.createElement('option');
            op.value = name;
            op.textContent = name;
            sel.appendChild(op);
          }
          sel.value = current || '';
        };

        fill(selMain, mains, s.castleSeal.mainName);
        fill(selSub, subs, s.castleSeal.subName);

        modal.classList.add('show');        // ✅ CSS가 .modal.show로 열리는 구조
        modal.setAttribute('aria-hidden', 'false');
      };

      const closeModal = () => {
        if (!modal) return;
        modal.classList.remove('show');
        modal.setAttribute('aria-hidden', 'true');
      };

      // 2) 모달 이벤트 바인딩(1회만)
      if (modal && !modal.dataset.bound) {
        // backdrop/닫기 버튼
        modal.addEventListener('click', (e) => {
          const t = e.target;
          if (t?.dataset?.sealClose !== undefined) closeModal();
          if (t?.classList?.contains('backdrop')) closeModal();
        });

        // 셀렉트 change → state 반영 + summary 갱신
        const selMain = document.getElementById('castleSealMainSelM');
        const selSub = document.getElementById('castleSealSubSelM');

        selMain?.addEventListener('change', () => {
          s.castleSeal.mainName = String(selMain.value || '').trim();
          refresh();
        });

        selSub?.addEventListener('change', () => {
          s.castleSeal.subName = String(selSub.value || '').trim();
          refresh();
        });

        // 커밋 버튼
        const commit = document.getElementById('castleSealCommitM');
        commit?.addEventListener('click', () => {
          closeModal();
          toast('성안의 봉인이 적용되었습니다.');
        });

        modal.dataset.bound = '1';
      }

      // 3) 버튼 클릭 바인딩(1회만)
      if (!btn.dataset.bound) {
        btn.addEventListener('click', () => {
          console.log('[CastleSeal] btn click'); // ✅ 디버깅용
          openModal();
        });
        btn.dataset.bound = '1';
      }
    }

    // ✅ Page 3 init을 '딱 1번만' 보장
    let __page3InitDone = false;

    async function ensurePage3Init() {
      if (__page3InitDone) return;
      __page3InitDone = true;
      try {
        await initPage3Mobile();
        console.log('[PAGE3] init ok');
      } catch (e) {
        __page3InitDone = false;
        console.error('[PAGE3] init fail', e);
      }
    }

    // ✅ 한 번에 묶어서 호출
    async function initPage3Mobile() {
      bindTimeMobile();
      await populateMonsterMobile();
      await populateAvatarImprintMobile();
      await populateRuneEngraveMobile();
      bindRuneButtonMobile();
      await bindCastleSealMobile();
    }
    // ================================
    // ✅ Page4: Skill (SP/TP) UI
    // ================================
    let __page4InitDone = false;

    function ensurePage4Init() {
      if (__page4InitDone) return;
      __page4InitDone = true;

      try {
        bindSkillPageMobile();
        renderSkillPageMobile();
      } catch (e) {
        __page4InitDone = false;
        console.error(e);
      }
    }

    function _num(x, def = 0) {
      const n = Number(x);
      return Number.isFinite(n) ? n : def;
    }

    function _clamp(v, a, b) {
      v = _num(v, a);
      if (v < a) return a;
      if (v > b) return b;
      return v;
    }

    function _pickAny(obj, keys) {
      for (const k of keys) {
        if (obj && obj[k] != null && String(obj[k]).trim() !== '') return obj[k];
      }
      return '';
    }

    function _getSkillListRaw() {
      // 서버/버전별 키 차이를 느슨하게 커버
      return (
        window.CORE?.lists?.['skill:list'] ||
        window.CORE?.lists?.['skills:list'] ||
        window.CORE?.lists?.['skillList'] ||
        window.CORE?.lists?.['skills'] ||
        []
      );
    }

    function _getSkillName(r) {
      return String(_pickAny(r, ['name', '이름', 'skillName', '스킬명']) || '').trim();
    }
    function _getSkillChar(r) {
      return String(_pickAny(r, ['charName', '캐릭터명', '캐릭터', 'char', 'job']) || '').trim();
    }
    function _getSkillReq(r) {
      return _num(_pickAny(r, ['reqLevel', '요구레벨', '레벨', 'Lv']), 0);
    }
    function _getSkillMin(r) {
      return _num(_pickAny(r, ['minLevel', '최소레벨', 'min', 'minLv']), 0);
    }
    function _getSkillMax(r) {
      // lvCap를 max로 쓰는 데이터도 있어서 느슨하게
      const a = _pickAny(r, ['maxLevel', '최대레벨', 'max', 'maxLv']);
      const b = _pickAny(r, ['lvCap', '레벨상한', 'cap']);
      const n = _num(a, NaN);
      return Number.isFinite(n) ? n : _num(b, 0);
    }
    function _getSkillTPCap(r) {
      // ✅ tpMax 컬럼이 없으므로: tp설정이 있으면 유저 수동 TP는 최대 5
      const set = _num(_pickAny(r, ['tp', 'tp설정', 'tp 설정', 'TP설정', 'TP 설정', 'tpSetting', 'tp_setting']), 0);
      return (set === 1 || set === 2) ? 5 : 0;
    }
    function _getSkillShow(r) {
      // 시트가 한글키로 들어오면 '노출여부', 가공된 리스트면 'show'를 쓰는 경우가 많음
      const v = _pickAny(r, ['노출여부', 'show', 'visible', '노출', '노출 여부']);
      const s = String(v ?? '').trim();
      return s === '1' || s.toLowerCase() === 'true';
    }
    function _getSkillImg(r) {
      return String(r?.['image'] ?? '').trim();
    }
    function _getSkillSpCost(r) {
      // 스킬 시트의 '소모 sp' 컬럼(PC에서는 skill.sp 로 들어감)
      return _num(_pickAny(r, ['costSP', '소모 sp', '소모sp', 'SP소모', 'sp', 'spCost', 'sp_cost', 'sp소모']), 0);
    }
    function _getSkillTpCost(r) {
      // ✅ TP 1레벨당 소모량:
      // 사용자가 말한 규칙: 시트의 'tp설정' 값이 1이면 1, 2이면 2를 소모
      const set = _num(_pickAny(r, ['tp', 'tp 설정', 'TP설정', 'TP 설정', 'tpSetting', 'tp_setting']), NaN);
      if (set === 1 || set === 2) return set;
    }

    // ===== Page4 Skill: 남은 SP/TP 표시 =====
    function _getCharTotalSpTp() {
      const s = window.state || {};
      const c = s.currentCharacter || {};

      // ✅ 모바일 char:list에서 총 SP/TP가 sp / tp 로 들어오는 경우가 많아서 포함
      const totalSP_1 = _num(_pickAny(c, [
        'TotalSP', 'totalSP', 'spTotal', '총SP', 'SP총합', 'spAll',
        'sp', 'SP', 'sp_total', 'totalSp'
      ]), NaN);

      const totalTP_1 = _num(_pickAny(c, [
        'TotalTP', 'totalTP', 'tpTotal', '총TP', 'TP총합', 'tpAll',
        'tp', 'TP', 'tp_total', 'totalTp'
      ]), NaN);

      // ✅ 폴백: state.sp.total / state.tp.total (PC쪽 구조를 따라온 경우)
      const totalSP = Number.isFinite(totalSP_1) ? totalSP_1 : _num(s?.sp?.total, NaN);
      const totalTP = Number.isFinite(totalTP_1) ? totalTP_1 : _num(s?.tp?.total, NaN);

      return { totalSP, totalTP };
    }


    function _calcUsedSpTp() {
      const charKey = _getCurrentCharKey() || '__nochar__';
      const store = window.state?.skillTrees?.[charKey] || {};
      let usedSP = 0;
      let usedTP = 0;

      for (const k in store) {
        const it = store[k];
        if (!it) continue;

        const spLv = _num(it.spLv, 0);
        const spMin = _num(it.spMin, 0);
        const tpLv = _num(it.tpLv, 0);

        const spCost = _num(it.spCost ?? it.sp ?? 0, 0);
        const tpCost = _num(it.tpCost ?? 1, 1);

        usedSP += Math.max(0, spLv - spMin) * (spCost > 0 ? spCost : 0);
        usedTP += Math.max(0, tpLv) * (tpCost > 0 ? tpCost : 0);
      }
      return { usedSP, usedTP };
    }

    function updateSkillRemainBar() {
      const bar = document.getElementById('skillRemainBarM');
      const elSp = document.getElementById('skillRemainSpM');
      const elTp = document.getElementById('skillRemainTpM');
      if (!bar || !elSp || !elTp) return;

      const { totalSP, totalTP } = _getCharTotalSpTp();
      const hasAny = Number.isFinite(totalSP) || Number.isFinite(totalTP);

      if (!hasAny) {
        bar.classList.add('is-hidden');
        elSp.textContent = '-';
        elTp.textContent = '-';
        return;
      }

      bar.classList.remove('is-hidden');

      const { usedSP, usedTP } = _calcUsedSpTp();

      elSp.textContent = Number.isFinite(totalSP) ? String(Math.max(0, Math.round(totalSP - usedSP))) : '-';
      elTp.textContent = Number.isFinite(totalTP) ? String(Math.max(0, Math.round(totalTP - usedTP))) : '-';
    }



    function _getCurrentCharKey() {
      const c = window.state?.currentCharacter || {};
      const k = String(c.ownerKey || c.charKey || '').trim();
      if (k) return k.replace(/\s+/g, '');

      // fallback: jobGroup + name 조합
      const job = String(c.jobGroupLabel || c.jobGroup || c.job || '').trim();
      const nm = String(c.name || c.charName || '').trim();
      return (job + nm).replace(/\s+/g, '');
    }


    function bindSkillPageMobile() {
      const listEl = document.getElementById('skillListM');
      const resetBtn = document.getElementById('btnSkillResetM');
      if (!listEl) return;

      // (1) 버튼 이벤트(위임)
      if (!listEl.dataset.bound) {
        listEl.dataset.bound = '1';

        listEl.addEventListener('click', (e) => {
          const btn = e.target?.closest?.('button[data-act]');
          if (!btn) return;

          const row = btn.closest('.skill-row');
          if (!row) return;

          const act = btn.dataset.act;        // sp-min/sp-dec/sp-inc/sp-max/tp-...
          const skillName = row.dataset.skill || '';
          if (!skillName) return;

          const s = (window.state || (window.state = {}));
          const charKey = _getCurrentCharKey() || '__nochar__';

          s.skillTrees = s.skillTrees || {};
          s.skillTrees[charKey] = s.skillTrees[charKey] || {};
          const store = s.skillTrees[charKey];

          const cur = store[skillName] || { spLv: 0, tpLv: 0, spMin: 0, spMax: 0, tpMax: 0 };
          const spMin = _num(cur.spMin, 0);
          const spMax = _num(cur.spMax, 0);
          const tpMax = _num(cur.tpMax, 0);

          let spLv = _num(cur.spLv, spMin);
          let tpLv = _num(cur.tpLv, 0);

          // ✅ (보너스) 남은 SP/TP 기반으로 이 스킬의 최대치(cap) 계산
          const spCost = Number(cur?.spCost ?? 0);
          const tpCost = Number(cur?.tpCost ?? 0);

          const { totalSP, totalTP } = _getCharTotalSpTp();
          const { usedSP, usedTP } = _calcUsedSpTp();

          // 현재 스킬이 이미 쓰고 있는 양(되돌릴 수 있으니 가용량 계산에서 제외)
          const curSpentSP = (spCost > 0) ? Math.max(0, spLv - spMin) * spCost : 0;
          const curSpentTP = (tpCost > 0) ? Math.max(0, tpLv) * tpCost : 0;

          // 이 스킬에 “실제로 쓸 수 있는” 가용 SP/TP
          const availSP = Math.max(0, totalSP - (usedSP - curSpentSP));
          const availTP = Math.max(0, totalTP - (usedTP - curSpentTP));

          // 남은 SP/TP로부터 계산되는 최대 레벨
          const spMaxByRemain = (spCost > 0) ? (spMin + Math.floor(availSP / spCost)) : spMax;
          const tpMaxByRemain = (tpCost > 0) ? Math.floor(availTP / tpCost) : tpMax;

          // 최종 cap (원래의 스킬 제한도 같이 적용)
          const spCap = Math.max(spMin, Math.min(spMax, spMaxByRemain));
          const tpCap = Math.max(0, Math.min(tpMax, tpMaxByRemain));

          switch (act) {
            case 'sp-min': spLv = spMin; break;
            case 'sp-dec': spLv = spLv - 1; break;
            case 'sp-inc':
              spLv = Math.min(spLv + 1, spCap);
              break;

            case 'sp-max':
              spLv = spCap;
              break;

            case 'tp-min': tpLv = 0; break;
            case 'tp-dec': tpLv = tpLv - 1; break;
            case 'tp-inc':
              tpLv = Math.min(tpLv + 1, tpCap);
              break;

            case 'tp-max':
              tpLv = tpCap;
              break;
          }

          spLv = _clamp(spLv, spMin, spMax);
          tpLv = _clamp(tpLv, 0, tpMax);

          store[skillName] = { ...cur, spLv, tpLv };
          // 화면 숫자만 즉시 갱신
          row.querySelector('[data-val="sp"]')?.replaceChildren(document.createTextNode(String(spLv)));
          row.querySelector('[data-val="tp"]')?.replaceChildren(document.createTextNode(String(tpLv)));
          updateSkillRemainBar(); // ✅ 추가
        });
      }

      // (2) 초기화 버튼
      if (resetBtn && !resetBtn.dataset.bound) {
        resetBtn.dataset.bound = '1';
        resetBtn.addEventListener('click', () => {
          const s = (window.state || (window.state = {}));
          const charKey = _getCurrentCharKey() || '__nochar__';
          if (s.skillTrees && s.skillTrees[charKey]) {
            delete s.skillTrees[charKey];
          }
          renderSkillPageMobile();
          updateSkillRemainBar(); // ✅ 추가
          toast('스킬이 초기화되었습니다.');
        });
      }
    }

    function renderSkillPageMobile(charObj) {
      const listEl = document.getElementById('skillListM');
      if (!listEl) return;

      const c = charObj || window.state?.currentCharacter || {};
      const charKey = String(c.ownerKey || '').trim().replace(/\s+/g, '') || _getCurrentCharKey();
      if (!charKey) {
        listEl.innerHTML = `<div style="padding:14px 10px; color:#c7b589;">캐릭터를 먼저 선택하세요.</div>`;
        updateSkillRemainBar();
        return;
      }

      const raw = _getSkillListRaw();
      const rows = Array.isArray(raw) ? raw : [];

      // 캐릭 필터
      const mine = rows.filter(r =>
        _getSkillChar(r).replace(/\s+/g, '') === charKey &&
        _getSkillShow(r)
      );

      if (!mine.length) {
        listEl.innerHTML = `<div style="padding:14px 10px; color:#c7b589;">표시할 스킬이 없습니다. (skill:list / 캐릭터명 매칭 확인)</div>`;
        return;
      }

      // 저장소(캐릭별)  ✅ charKey로 통일
      const s = (window.state || (window.state = {}));
      s.skillTrees = s.skillTrees || {};
      s.skillTrees[charKey] = s.skillTrees[charKey] || {};
      const store = s.skillTrees[charKey];


      // 정렬: 요구레벨 → 이름
      mine.sort((a, b) => {
        const da = _getSkillReq(a) - _getSkillReq(b);
        if (da !== 0) return da;
        return _getSkillName(a).localeCompare(_getSkillName(b), 'ko');
      });

      // 렌더
      listEl.innerHTML = '';
      const frag = document.createDocumentFragment();

      let lastReq = null;

      for (const r of mine) {
        const skillName = _getSkillName(r);
        if (!skillName) continue;

        const spMin = _getSkillMin(r);
        const spMax = _getSkillMax(r);
        const tpMax = _getSkillTPCap(r);
        const spCost = _getSkillSpCost(r);
        const tpCost = _getSkillTpCost(r);
        const reqLv = _getSkillReq(r);
        // ✅ 렙제 바뀌면 구분 헤더(구분선) 삽입
        if (lastReq !== reqLv) {
          lastReq = reqLv;

          const div = document.createElement('div');
          div.className = 'skill-divider';

          const t = document.createElement('div');
          t.className = 'txt';
          t.textContent = `Lv ${reqLv}`;

          const line = document.createElement('div');
          line.className = 'line';

          div.appendChild(t);
          div.appendChild(line);
          frag.appendChild(div);
        }
        const cur = store[skillName] || {};
        const spLv = _clamp(cur.spLv ?? spMin, spMin, spMax);
        const tpLv = _clamp(cur.tpLv ?? 0, 0, tpMax);

        // cap 정보도 저장(클릭 로직에서 사용)
        store[skillName] = { ...cur, spLv, tpLv, spMin, spMax, tpMax, spCost, tpCost };

        const row = document.createElement('div');
        row.className = 'skill-row';
        row.dataset.skill = skillName;
        row.dataset.spcost = String(spCost ?? 0);
        row.dataset.tpcost = String(tpCost ?? 1);


        const left = document.createElement('div');
        left.className = 'skill-left';

        // (추가) 스킬 이미지
        const imgSrc = _getSkillImg(r);   // 아래 2)에서 새로 만드는 헬퍼
        if (imgSrc) {
          const icon = document.createElement('div');
          icon.className = 'skill-icon';

          const img = document.createElement('img');
          img.alt = skillName;
          img.loading = 'lazy';
          img.decoding = 'async';
          img.src = imgSrc;

          icon.appendChild(img);
          left.appendChild(icon);
        }

        const nm = document.createElement('div');
        nm.className = 'skill-name';
        nm.textContent = skillName;

        // ✅ meta(요구Lv/SP/TP) 완전 제거
        left.appendChild(nm);


        const right = document.createElement('div');
        right.className = 'skill-right';

        const mkCtrl = (label, valKey, acts, disabledAll = false) => {
          const line = document.createElement('div');
          line.className = 'skill-ctrl';

          const lbl = document.createElement('span');
          lbl.className = 'lbl';
          lbl.textContent = label;

          const makeBtn = (text, act, wide = false, disabled = false) => {
            const b = document.createElement('button');
            b.type = 'button';
            b.className = 'skill-mini' + (wide ? ' is-wide' : '');
            b.textContent = text;
            b.dataset.act = act;
            if (disabledAll || disabled) b.disabled = true;
            return b;
          };

          const v = document.createElement('span');
          v.className = 'skill-val';
          v.dataset.val = valKey;
          v.textContent = String(valKey === 'sp' ? spLv : tpLv);

          line.appendChild(lbl);

          // ✅ 좌측: MAX, +
          line.appendChild(makeBtn('MAX', acts.max, true));
          line.appendChild(makeBtn('+', acts.inc));

          line.appendChild(v);

          // ✅ 우측: -, MIN
          line.appendChild(makeBtn('-', acts.dec));
          line.appendChild(makeBtn('MIN', acts.min, true));

          return line;

        };

        right.appendChild(mkCtrl('SP', 'sp', {
          min: 'sp-min', dec: 'sp-dec', inc: 'sp-inc', max: 'sp-max'
        }));

        right.appendChild(mkCtrl('TP', 'tp', {
          min: 'tp-min', dec: 'tp-dec', inc: 'tp-inc', max: 'tp-max'
        }, tpMax <= 0)); // tpCap=0이면 비활성

        row.appendChild(left);
        row.appendChild(right);
        frag.appendChild(row);
      }

      listEl.appendChild(frag);
      updateSkillRemainBar(); // ✅ 추가
    }

    // ===== Header actions =====
    function openModal(id) {
      const m = document.getElementById(id);
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function closeModal(id) {
      const m = document.getElementById(id);
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }

    document.getElementById('btnContactAdmin')?.addEventListener('click', () => openModal('contactModal'));
    document.getElementById('btnFaq')?.addEventListener('click', () => {
      // 나중에 PC의 getFaqItems/openFaqModal 로직을 그대로 붙이면 됨
      const list = document.getElementById('faqList');
      if (list) {
        list.innerHTML = '';
        const empty = document.createElement('div');
        empty.style.opacity = '0.8';
        empty.textContent = '등록된 Q&A가 없습니다.';
        list.appendChild(empty);
      }
      openModal('faqModal');
    });

    // backdrop/close 공통
    document.querySelectorAll('[data-contact-close]').forEach(el => {
      el.addEventListener('click', () => closeModal('contactModal'));
    });
    document.getElementById('contactModal')?.addEventListener('click', (e) => {
      if (e.target?.classList?.contains('backdrop')) closeModal('contactModal');
    });

    document.querySelectorAll('[data-faq-close]').forEach(el => {
      el.addEventListener('click', () => closeModal('faqModal'));
    });
    document.getElementById('faqModal')?.addEventListener('click', (e) => {
      if (e.target?.classList?.contains('backdrop')) closeModal('faqModal');
    });

    document.querySelectorAll('[data-faqans-close]').forEach(el => {
      el.addEventListener('click', () => closeModal('faqAnswerModal'));
    });
    document.getElementById('faqAnswerModal')?.addEventListener('click', (e) => {
      if (e.target?.classList?.contains('backdrop')) closeModal('faqAnswerModal');
    });

    // ===== Equip Picker =====
    const EQUIP_SLOT_LABELS = {
      headshoulder: '머리어깨',
      top: '상의',
      bottom: '하의',
      belt: '허리',
      shoes: '신발',
      bracelet: '팔찌',
      necklace: '목걸이',
      ring: '반지',
      sub: '보조장비',
      magestone: '마법석',
      earring: '귀걸이',
      weapon: '무기',
    };

    function _equipListKey(slot) {
      return `${slot}:list`;
    }
    function _baseJG_mobile(s) {
      s = String(s || '').trim();
      // 괄호 안 옵션 제거(예: 거너(남) -> 거너)
      return s.replace(/\(.*?\)/g, '').trim();
    }

    function _jgMatches_mobile(a, b) {
      a = String(a || '').trim();
      b = String(b || '').trim();
      if (!a || !b) return true;

      const aa = _baseJG_mobile(a);
      const bb = _baseJG_mobile(b);

      return (
        a === b ||
        aa === bb ||
        a.includes(b) || b.includes(a) ||
        aa.includes(bb) || bb.includes(aa)
      );
    }

    function _getEquipJobGroup_mobile(it) {
      // 데이터 키가 뭐든 최대한 잡아내기
      return String(_pick(it, ['jobGroup', '직업군', 'group', 'job_group', '직업군(필터)']) || '').trim();
    }

    function _getWeaponType_mobile(it) {
      // 무기 "종류" 컬럼(예: 소검/대검/권총 등) 최대한 잡아내기
      return String(_pick(it, ['type', '종류', 'weaponType', '무기종류', 'kind']) || '').trim();
    }

    function _ensureWeaponTypeBar_mobile() {
      let bar = document.getElementById('weaponTypeBar');
      if (bar) return bar;

      const dialog = document.querySelector('#equipModal .dialog');
      const catalog = document.getElementById('equipCatalog');
      if (!dialog || !catalog) return null;

      bar = document.createElement('div');
      bar.id = 'weaponTypeBar';
      bar.className = 'weapon-typebar';

      // equipCatalog 바로 위(=모달 안, 목록 위)에 끼워넣기
      dialog.insertBefore(bar, catalog);
      return bar;
    }

    function _hideWeaponTypeBar_mobile() {
      const bar = document.getElementById('weaponTypeBar');
      if (!bar) return;
      bar.style.display = 'none';
      bar.innerHTML = '';
    }

    function renderWeaponTypeBar_mobile(types, activeType, onPick) {
      const bar = _ensureWeaponTypeBar_mobile();
      if (!bar) return;

      if (!Array.isArray(types) || types.length === 0) {
        _hideWeaponTypeBar_mobile();
        return;
      }

      bar.style.display = 'flex';
      bar.innerHTML = '';

      // ✅ '전체' 없음: types만 렌더
      types.forEach(t => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'weapon-typebtn';
        b.textContent = t;
        if (t === activeType) b.classList.add('active');
        b.addEventListener('click', () => onPick(t));
        bar.appendChild(b);
      });
    }

    function closeEquipModal() {
      _hideWeaponTypeBar_mobile();

      closeEquipEnhModal();
      closeEquipSealUModal();
      closeEquipSealNModal();
      closeEquipEnchantModal();
      closeEquipEmblemModal();

      const m = document.getElementById('equipModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }

    function openEquipModal() {
      const m = document.getElementById('equipModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }

    // 닫기(backdrop + 닫기 버튼)
    document.querySelectorAll('[data-equip-close]').forEach(el => {
      el.addEventListener('click', closeEquipModal);
    });
    document.getElementById('equipModal')?.addEventListener('click', (e) => {
      if (e.target?.classList?.contains('backdrop')) closeEquipModal();
    });

    function renderMobileEquipList(slot, items) {
      const titleEl = document.getElementById('equipModalTitle');
      if (titleEl) titleEl.textContent = `${EQUIP_SLOT_LABELS[slot] || slot} 선택`;

      const catalog = document.getElementById('equipCatalog');
      if (!catalog) return;
      catalog.innerHTML = '';

      const wrap = document.createElement('div');
      wrap.className = 'meq-wrap';

      for (const it of items) {
        const name = String(it?.name || '').trim();
        if (!name) continue;

        const img = _normImg(it?.image || '');

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'meq-row';
        btn.innerHTML = `
      <img class="meq-thumb" src="${img}" alt="">
      <div class="meq-name">${name}</div>
    `;

        btn.addEventListener('click', () => {
          window.state = window.state || {};
          window.state.equips = window.state.equips || {};
          window.state.equips[slot] = it;


          // ✅ PC판과 동일한 스냅샷 구조(state.selections)도 함께 유지
          window.state.selections = window.state.selections || {};
          window.state.selections[slot] = {
            name: String((it && (it.name || it['이름'])) || '').trim(),
            code: (it && (it.code || it['코드'])) || '',
          };
          applyPickedEquipUI(slot, it);
          closeEquipModal();
        });

        wrap.appendChild(btn);
      }

      catalog.appendChild(wrap);
    }

    function applyPickedEquipUI(slot, it) {
      const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slot}"]`);
      if (!row) return;

      // 왼쪽 이미지
      const imgBox = row.querySelector('.equip-img');
      if (imgBox) {
        const src = _normImg(it?.image || '');
        imgBox.style.backgroundImage = src ? `url("${src}")` : '';
        imgBox.style.backgroundSize = 'cover';
        imgBox.style.backgroundPosition = 'center';
        imgBox.style.backgroundRepeat = 'no-repeat';
      }

      // 이미지 아래 “장비이름”
      const nameEl = row.querySelector('.equip-name');
      if (nameEl) {
        nameEl.textContent = String(it?.name || EQUIP_SLOT_LABELS[slot] || '').trim();
      }

      // 우측 고유/일반 옵션 칸은 우선 prefix/desc로 채워줌(없으면 -)
      const uniqueEl = row.querySelector('.equip-unique');
      if (uniqueEl) {
        uniqueEl.textContent = String(it?.prefix || '').trim() || '—';
      }
      const normalEl = row.querySelector('.equip-normal');
      if (normalEl) {
        normalEl.textContent = String(it?.desc || '').trim() || '—';
      }
      _syncEnhLabelFromState_mobile(slot);
      _syncSealLabelFromState_mobile(slot);
      _syncGrindLabelFromState_mobile(slot);
    }

    // ===== Enhancement Picker (Mobile) =====
    function _enhTypeForSlot_mobile(slot) {
      if (slot === 'weapon') return '무기강화';
      if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slot)) return '방어구강화';
      if (['bracelet', 'necklace', 'ring'].includes(slot)) return '악세강화';
      if (['sub', 'support', 'earring', 'magestone'].includes(slot)) return '보장강화';
      return null;
    }

    function _getLightEnhList_mobile() {
      const lists = window.CORE?.lists || {};
      const list = lists['enh:list'] || lists['enhList']; // 백엔드 키가 enh:list면 이걸로 잡힘
      return Array.isArray(list) ? list : [];
    }

    function _parseEnhLevel_mobile(name) {
      const s = String(name || '');
      let m = s.match(/\+(\d{1,2})/); if (m) return parseInt(m[1], 10);
      m = s.match(/(\d{1,2})\s*강/); if (m) return parseInt(m[1], 10);
      m = s.match(/(\d{1,2})/); if (m) return parseInt(m[1], 10);
      return 0;
    }

    function _normEnhItem_mobile(row) {
      const raw = row?._raw || row || {};

      // ✅ 빈 문자열('')도 fallback 되도록 || 체인 사용
      const name =
        String(row?.name || '').trim() ||
        String(raw['이름'] || raw.name || raw.title || '').trim();

      const type =
        String(row?.type || '').trim() ||
        String(raw['종류'] || raw.type || raw.category || '').trim();

      const lv =
        Number.isFinite(Number(row?.level)) ? Number(row.level) :
          Number.isFinite(Number(raw['강화'])) ? Number(raw['강화']) :
            _parseEnhLevel_mobile(name);

      return { name, type, level: lv, _raw: raw };
    }


    function _syncEnhLabelFromState_mobile(slot) {
      const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slot}"]`);
      if (!row) return;
      const el = row.querySelector('.equip-enh-val'); // 모바일 UI에 존재 
      if (!el) return;

      const info = window.state?.enh?.[slot];
      if (info?.name) el.textContent = String(info.name).trim();
    }

    function openEquipEnhModal() {
      const m = document.getElementById('equipEnhModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }

    function closeEquipEnhModal() {
      const m = document.getElementById('equipEnhModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }
    function openEquipEmblemModal() {
      const m = document.getElementById('equipEmblemModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function closeEquipEmblemModal() {
      const m = document.getElementById('equipEmblemModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }

    (function bindEquipEmblemModalCloseOnce() {
      const m = document.getElementById('equipEmblemModal');
      if (!m || m.__bound) return;
      m.__bound = 1;

      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipEmblemModal();
        if (e.target?.closest?.('[data-equip-emblem-close]')) return closeEquipEmblemModal();
      });
    })();

    // 닫기(backdrop + X)
    (function bindEquipEnhModalCloseOnce() {
      const m = document.getElementById('equipEnhModal');
      if (!m || m.__bound) return;
      m.__bound = 1;

      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipEnhModal();
        if (e.target?.closest?.('[data-equip-enh-close]')) return closeEquipEnhModal();
      });
    })();
    function _grindTypeForSlot_mobile(slot) {
      return (slot === 'weapon') ? '무기연마' : '보조장비연마';
    }

    function _getGrindLevelFromName(name) {
      const m = String(name || '').match(/^(\d+)연마$/);
      return m ? Number(m[1]) : 0;
    }

    function _syncGrindLabelFromState_mobile(slot) {
      const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slot}"]`);
      if (!row) return;

      const el = row.querySelector('.equip-grind');
      if (!el) return;

      const slotKey = (slot === 'weapon') ? 'weapon' : (slot === 'sub') ? 'sub' : '';
      const name = slotKey && window.state?.refines?.[slotKey]?.name ? String(window.state.refines[slotKey].name) : '';
      const lv = _getGrindLevelFromName(name);

      el.textContent = (lv > 0) ? `연마 ${lv}` : '연마 -';
    }

    function syncGrindTopbarLabel_mobile(slot) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;

      const btn = bar.querySelector('.equip-topbtn[data-eqtab="grind"]');
      if (!btn) return;

      const slotKey = (slot === 'weapon') ? 'weapon' : (slot === 'sub') ? 'sub' : '';
      const name = slotKey && window.state?.refines?.[slotKey]?.name ? String(window.state.refines[slotKey].name) : '';
      const lv = _getGrindLevelFromName(name);

      btn.textContent = (lv > 0) ? `연마 ${lv}` : '연마';
    }

    function renderMobileGrindList(slot) {
      bindEquipGrindModalCloseOnce();

      const title = document.getElementById('equipGrindModalTitle');
      if (title) {
        const slotName = (slot === 'weapon') ? '무기' : '보조장비';
        title.textContent = `${slotName} 연마 선택`;
      }

      const listEl = document.getElementById('equipGrindList');
      if (!listEl) return;

      const labels = ['연마없음', '1연마', '2연마', '3연마', '4연마', '5연마', '6연마', '7연마', '8연마', '9연마'];
      const slotKey = (slot === 'weapon') ? 'weapon' : 'sub';

      const curName = window.state?.refines?.[slotKey]?.name ? String(window.state.refines[slotKey].name) : '연마없음';

      listEl.innerHTML = '';
      labels.forEach(name => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'enh-option';
        b.textContent = (name === '연마없음') ? '없음' : name;

        if (String(name) === curName) b.classList.add('active');

        b.addEventListener('click', () => {
          window.state = window.state || {};
          window.state.refines = window.state.refines || {};

          const refineType = _grindTypeForSlot_mobile(slot);
          const level = _getGrindLevelFromName(name);

          window.state.refines[slotKey] = { name, refineType, level };

          _syncGrindLabelFromState_mobile(slot);
          syncGrindTopbarLabel_mobile(slot);

          showEquipGrindModal(false);
          toast(level > 0 ? `연마 ${level} 적용` : '연마 해제');
        });

        listEl.appendChild(b);
      });

      showEquipGrindModal(true);
    }

    function openMobileGrindPicker() {
      const slot = window.state?.ui?.equipPickerSlot;
      if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

      if (!(slot === 'weapon' || slot === 'sub')) {
        toast('이 슬롯은 연마를 지원하지 않습니다.');
        return;
      }

      renderMobileGrindList(slot);
    }


    function showEquipGrindModal(on) {
      const m = document.getElementById('equipGrindModal');
      if (!m) return;
      if (on) {
        m.classList.add('show');
        m.setAttribute('aria-hidden', 'false');
      } else {
        m.classList.remove('show');
        m.setAttribute('aria-hidden', 'true');
      }
    }

    function bindEquipGrindModalCloseOnce() {
      const m = document.getElementById('equipGrindModal');
      if (!m || m.dataset.bound) return;
      m.dataset.bound = '1';

      m.addEventListener('click', (e) => {
        if (e.target?.dataset?.equipGrindClose != null) {
          showEquipGrindModal(false);
        }
      });
    }

    // =========================
    // ✅ 마법봉인(고유/일반) 2중모달
    // =========================

    function openEquipSealUModal() {
      const m = document.getElementById('equipSealUModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function closeEquipSealUModal() {
      const m = document.getElementById('equipSealUModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }
    (function bindEquipSealUModalCloseOnce() {
      const m = document.getElementById('equipSealUModal');
      if (!m || m.__bound) return;
      m.__bound = 1;
      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipSealUModal();
        if (e.target?.closest?.('[data-equip-seal-u-close]')) return closeEquipSealUModal();
      });
    })();

    function openEquipSealNModal() {
      const m = document.getElementById('equipSealNModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function closeEquipSealNModal() {
      const m = document.getElementById('equipSealNModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }
    function openEquipEnchantModal() {
      const m = document.getElementById('equipEnchantModal');
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function closeEquipEnchantModal() {
      const m = document.getElementById('equipEnchantModal');
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }

    (function bindEquipSealNModalCloseOnce() {
      const m = document.getElementById('equipSealNModal');
      if (!m || m.__bound) return;
      m.__bound = 1;
      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipSealNModal();
        if (e.target?.closest?.('[data-equip-seal-n-close]')) return closeEquipSealNModal();
      });
    })();
    (function bindEquipEnchantModalCloseOnce() {
      const m = document.getElementById('equipEnchantModal');
      if (!m || m.__bound) return;
      m.__bound = 1;

      m.addEventListener('click', (e) => {
        if (e.target?.classList?.contains('backdrop')) return closeEquipEnchantModal();
        if (e.target?.closest?.('[data-equip-enchant-close]')) return closeEquipEnchantModal();
      });
    })();
    function _sealTypeKeysForSlot_mobile(slot) {
      if (slot === 'weapon') return { u: '무기고유', g: '무기일반' };

      // ✅ 모바일 방어구 슬롯키: headshoulder / top / bottom / belt / shoes
      if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slot)) return { u: '방어고유', g: '방어일반' };

      // ✅ 모바일 악세 슬롯키: bracelet / necklace / ring
      if (['bracelet', 'necklace', 'ring'].includes(slot)) return { u: '악세고유', g: '악세일반' };

      // ✅ 모바일 특수(보조/마법석/귀걸이) = PC 표준: 보장고유/보장일반
      if (['sub', 'magestone', 'earring'].includes(slot)) return { u: '보장고유', g: '보장일반' };

      return null;
    }

    function normalizeSealType_mobile(s) {
      const raw = String(s ?? '');
      const t = raw.replace(/\s+|-/g, '').replace(/[()]/g, '').trim();

      const has = (w) => t.includes(w);
      const isDef = /방어구|방어/.test(t);
      const isAks = /악세|악세서리|액세/.test(t);
      const isBoj = /보장|보조장비|보조/.test(t);

      const isUni = /고유/.test(t) || /고유옵션/.test(t);
      const isGen = /일반/.test(t) || /일반옵션/.test(t);

      if (has('무기') && isUni) return '무기고유';
      if (has('무기') && isGen) return '무기일반';
      if (isDef && isUni) return '방어고유';
      if (isDef && isGen) return '방어일반';
      if (isAks && isUni) return '악세고유';
      if (isAks && isGen) return '악세일반';
      if (isBoj && isUni) return '보장고유';
      if (isBoj && isGen) return '보장일반';
      return raw.trim();
    }


    function _syncSealLabelFromState_mobile(slot) {
      const row = document.querySelector(`.equip-row[data-slot="${slot}"]`);
      if (!row) return;

      const uEl = row.querySelector('.equip-unique');
      const nEl = row.querySelector('.equip-normal');

      const uName = window.state?.seals?.[slot]?.unique?.name
        ? String(window.state.seals[slot].unique.name).trim()
        : '';
      const nName = window.state?.seals?.[slot]?.general1?.name
        ? String(window.state.seals[slot].general1.name).trim()
        : '';

      // ✅ 라벨 대신 "선택값" 자체를 표시
      if (uEl) uEl.textContent = uName ? uName : '고유옵션';
      if (nEl) nEl.textContent = nName ? nName : '일반옵션';
    }

    function _syncEnchantLabelFromState_mobile(slot) {
      const row = document.querySelector(`.equip-row[data-slot="${slot}"]`);
      if (!row) return;

      const body = row.querySelector('.equip-enchant .equip-col-body');
      if (!body) return;

      const name = window.state?.enchants?.[slot]?.name
        ? String(window.state.enchants[slot].name).trim()
        : '';

      body.textContent = name ? name : '-';
    }


    function renderMobileSealUniqueList(slot) {
      const keys = _sealTypeKeysForSlot_mobile(slot);
      const type = keys?.u;
      if (!type) { toast('이 슬롯은 고유옵션 타입이 없습니다.'); return; }

      const list = _getLightEnhList_mobile()
        .map(_normEnhItem_mobile)
        .filter(x => x.name && normalizeSealType_mobile(x.type) === type);

      if (!list.length) {
        toast(`고유옵션 목록을 불러오지 못했습니다. (${type})`);
        return;
      }


      const titleEl = document.getElementById('equipSealUModalTitle');
      if (titleEl) titleEl.textContent = `${EQUIP_SLOT_LABELS[slot] || slot} 고유옵션 선택`;

      const listEl = document.getElementById('equipSealUList');
      if (!listEl) return;
      listEl.innerHTML = '';

      const curName = window.state?.seals?.[slot]?.unique?.name ? String(window.state.seals[slot].unique.name).trim() : '';

      for (const it of list) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'enh-option' + (curName && curName === it.name ? ' active' : '');
        b.textContent = it.name;

        b.onclick = () => {
          window.state = window.state || {};
          window.state.seals = window.state.seals || {};
          window.state.seals[slot] = window.state.seals[slot] || {};
          window.state.seals[slot].unique = { name: it.name, type: it.type };

          _syncSealLabelFromState_mobile(slot);
          syncSealTopbarLabel_mobile(slot);
          closeEquipSealUModal(); // ✅ 장비 모달은 유지
        };

        listEl.appendChild(b);
      }

      window.state.ui = window.state.ui || {};
      window.state.ui.sealTargetSlot = slot;

      openEquipSealUModal();
    }

    function renderMobileSealNormalList(slot) {
      const keys = _sealTypeKeysForSlot_mobile(slot);
      const type = keys?.g;
      if (!type) { toast('이 슬롯은 일반옵션 타입이 없습니다.'); return; }

      const list = _getLightEnhList_mobile()
        .map(_normEnhItem_mobile)
        .filter(x => x.name && x.type === type);

      if (!list.length) {
        toast(`일반옵션 목록을 불러오지 못했습니다. (${type})`);
        return;
      }

      const titleEl = document.getElementById('equipSealNModalTitle');
      if (titleEl) titleEl.textContent = `${EQUIP_SLOT_LABELS[slot] || slot} 일반옵션 선택`;

      const listEl = document.getElementById('equipSealNList');
      if (!listEl) return;
      listEl.innerHTML = '';

      const curName = window.state?.seals?.[slot]?.general1?.name ? String(window.state.seals[slot].general1.name).trim() : '';

      for (const it of list) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'enh-option' + (curName && curName === it.name ? ' active' : '');
        b.textContent = it.name;

        b.onclick = () => {
          window.state = window.state || {};
          window.state.seals = window.state.seals || {};
          window.state.seals[slot] = window.state.seals[slot] || {};
          window.state.seals[slot].general1 = { name: it.name, type: it.type };

          _syncSealLabelFromState_mobile(slot);
          syncSealTopbarLabel_mobile(slot);
          closeEquipSealNModal(); // ✅ 장비 모달은 유지
        };

        listEl.appendChild(b);
      }

      window.state.ui = window.state.ui || {};
      window.state.ui.sealTargetSlot = slot;

      openEquipSealNModal();
    }


    function renderMobileEnhList(slot) {
      const type = _enhTypeForSlot_mobile(slot);
      if (!type) {
        toast('이 슬롯은 강화 타입이 없습니다.');
        return;
      }

      const list = _getLightEnhList_mobile()
        .map(_normEnhItem_mobile)
        .filter(x => x.name && x.type === type);

      if (!list.length) {
        toast(`강화 목록을 불러오지 못했습니다. (${type})`);
        return;
      }

      // 레벨 오름차순 정렬(보기 편하게)
      list.sort((a, b) => (a.level || 0) - (b.level || 0) || a.name.localeCompare(b.name, 'ko'));

      // ✅ (방법B) 강화 모달에 렌더
      const titleEl = document.getElementById('equipEnhModalTitle');
      if (titleEl) titleEl.textContent = `${EQUIP_SLOT_LABELS[slot] || slot} 강화 선택`;

      const listEl = document.getElementById('equipEnhList');
      if (!listEl) return;
      listEl.innerHTML = '';

      const curName = window.state?.enh?.[slot]?.name ? String(window.state.enh[slot].name).trim() : '';

      for (const it of list) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'enh-option' + (curName && curName === it.name ? ' active' : '');
        b.textContent = it.name;

        b.onclick = () => {
          window.state = window.state || {};
          window.state.enh = window.state.enh || {};
          // ✅ PC버전/백코드가 기대하는 형태로 저장(name/type/level)
          const lv = Number.isFinite(Number(it.level)) ? Number(it.level) : _parseEnhLevel_mobile(it.name);
          window.state.enh[slot] = { name: it.name, type: it.type, level: lv };

          _syncEnhLabelFromState_mobile(slot);
          // ✅ 추가: 상단 '강화' 버튼 텍스트도 즉시 +수치로 변경
          syncEnhTopbarLabel_mobile(slot);
          closeEquipEnhModal(); // ✅ 장비 모달은 유지하고, 강화 모달만 닫기
        };

        listEl.appendChild(b);
      }

      // UI 상태 기록(선택적)
      window.state.ui = window.state.ui || {};
      window.state.ui.enhTargetSlot = slot;

      openEquipEnhModal();
    }

    function _enchantTypeForSlot_mobile(slot) {
      switch (slot) {
        case 'weapon': return '무기마부';
        case 'headshoulder': return '머리어깨마부';
        case 'top': return '상의마부';
        case 'bottom': return '하의마부';
        case 'belt': return '허리마부';
        case 'shoes': return '신발마부';

        case 'bracelet': return '팔찌마부';
        case 'necklace': return '목걸이마부';
        case 'ring': return '반지마부';

        case 'sub': return '보장마부';
        case 'magestone': return '마법석마부';
        case 'earring': return '귀걸이마부';
        default: return '';
      }
    }

    function normalizeEnchantType_mobile(t) {
      const raw = String(t ?? '');
      // 공백/하이픈/괄호 제거로 최대한 표준화
      const s = raw.replace(/\s+|-/g, '').replace(/[()]/g, '').trim();
      if (!s) return '';

      // ✅ 핵심: "마부/마법부여" 계열만 마부로 인정 (무기강화/무기마봉/연마 등은 여기서 컷)
      if (!/(마부|마법부여)/.test(s)) return '';

      // 이미 표준키(…마부)면 그대로 + 일부 동의어만 정리
      if (s.endsWith('마부')) {
        const alias = {
          '머리/어깨마부': '머리어깨마부',
          '보조장비마부': '보장마부',
        };
        return alias[s] || s;
      }

      // "무기마법부여" 같은 형태면 표준키로 변환
      if (/칭호/.test(s)) return '칭호마부';
      if (/무기/.test(s)) return '무기마부';
      if (/머리어깨|머리\/어깨|어깨/.test(s)) return '머리어깨마부';
      if (/상의/.test(s)) return '상의마부';
      if (/하의/.test(s)) return '하의마부';
      if (/허리|벨트/.test(s)) return '허리마부';
      if (/신발/.test(s)) return '신발마부';
      if (/팔찌/.test(s)) return '팔찌마부';
      if (/목걸이/.test(s)) return '목걸이마부';
      if (/반지/.test(s)) return '반지마부';
      if (/보장|보조/.test(s)) return '보장마부';
      if (/마법석/.test(s)) return '마법석마부';
      if (/귀걸이/.test(s)) return '귀걸이마부';

      // 변환 실패면 마부로 취급하지 않음(섞여 들어오는 것 방지)
      return '';
    }

    function renderMobileEnchantList(slot) {
      const typeKey = _enchantTypeForSlot_mobile(slot);
      if (!typeKey) {
        toast('이 슬롯은 마법부여를 지원하지 않습니다.');
        return;
      }

      const listEl = document.getElementById('equipEnchantList');
      if (!listEl) return;

      const map = window.EQUIP_SLOT_LABELS || {};
      const slotLabel =
        map[slot]
        || (slot === 'headshoulder' ? (map.headshoulder || map.shoulder || '머리어깨') : '')
        || slot;

      const titleEl = document.getElementById('equipEnchantModalTitle');
      if (titleEl) titleEl.textContent = `${slotLabel} 마법부여 선택`;

      // ✅ 목록은 "강화마봉마부 시트"에서 가져오는 라이트 리스트를 재사용
      const raw = _getLightEnhList_mobile().map(_normEnhItem_mobile);

      const items = raw.filter(x => {
        if (!x || !x.name) return false;
        return normalizeEnchantType_mobile(x.type) === typeKey;
      });

      // ✅ 렌더
      const picked = window.state?.enchants?.[slot]?.name ? String(window.state.enchants[slot].name) : '';

      let html = '';
      // 없음
      html += `
    <button type="button" class="enh-btn ${picked ? '' : 'active'}" data-none="1">
      없음
    </button>
  `;

      // 실제 옵션들 (정렬 X: 시트 순서 유지)
      for (const it of items) {
        const name = String(it.name || '').trim();
        const active = (picked && picked === name) ? 'active' : '';
        html += `
      <button type="button" class="enh-btn ${active}"
        data-name="${name.replace(/"/g, '&quot;')}"
        data-typekey="${typeKey.replace(/"/g, '&quot;')}">
        ${name}
      </button>
    `;
      }

      listEl.innerHTML = html;

      // 클릭 핸들러(중복 바인딩 방지)
      if (!listEl.dataset.bound) {
        listEl.dataset.bound = '1';
        listEl.addEventListener('click', (e) => {
          const btn = e.target.closest('.enh-btn');
          if (!btn) return;

          const slot = window.state?.ui?.equipPickerSlot;
          if (!slot) return;

          (window.state = window.state || {}).enchants = (window.state.enchants || {});

          // 없음
          if (btn.dataset.none === '1') {
            delete window.state.enchants[slot];
            _syncEnchantLabelFromState_mobile(slot);
            syncEnchantTopbarLabel_mobile(slot);
            closeEquipEnchantModal();
            return;
          }

          // 선택
          const name = (btn.dataset.name || '').trim();
          const typeKey = (btn.dataset.typekey || '').trim();

          window.state.enchants[slot] = { name, typeKey };
          _syncEnchantLabelFromState_mobile(slot);
          syncEnchantTopbarLabel_mobile(slot);
          closeEquipEnchantModal();
        });
      }

      openEquipEnchantModal();
    }


    function _isSpecialSlot(slot) {
      return slot === 'sub' || slot === 'magestone' || slot === 'earring';
    }

    function _getEnhLevelFromState_mobile(slot) {
      const info = window.state?.enh?.[slot];
      if (!info) return 0;

      const lv = Number(info.level);
      if (Number.isFinite(lv) && lv > 0) return lv;

      // ✅ level이 없거나 0이면 name에서 숫자 파싱(12강 / +12 / 12)
      const name = String(info.name || '');
      return _parseEnhLevel_mobile(name);
    }

    function syncEnhTopbarLabel_mobile(slot) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;

      const enhBtn = bar.querySelector('.equip-topbtn[data-eqtab="enh"]');
      if (!enhBtn) return;

      // 기본 라벨 기억(처음 1회만)
      if (!enhBtn.dataset.baseLabel) {
        enhBtn.dataset.baseLabel = (enhBtn.textContent || '강화').trim();
      }

      const lv = _getEnhLevelFromState_mobile(slot);

      // ✅ 원하는 표기: +12 처럼 "수치"로 바꾸기
      enhBtn.textContent = (lv > 0) ? `+${lv}` : enhBtn.dataset.baseLabel;

      // 만약 "강화 +12"로 표기하고 싶으면 위 줄 대신:
      // enhBtn.textContent = (lv > 0) ? `강화 +${lv}` : enhBtn.dataset.baseLabel;
    }
    /* =========================
     * ✅ 모바일 엠블렘 시스템
     * ========================= */

    // (PC와 동일) 플래티넘 7라인
    const PLAT_LINES = [
      { label: '화', key: '화' },
      { label: '수', key: '수' },
      { label: '명', key: '명' },
      { label: '암', key: '암' },
      { label: '모속', key: '모속' },
      { label: '힘', key: '힘' },
      { label: '지능', key: '지능' },
    ];

    // (PC와 동일) 슬롯별 허용 엠블렘 타입
    const SOCKET_RULES = {
      headshoulder: ['노란빛엠블렘'],
      belt: ['노란빛엠블렘'],
      top: ['붉은빛엠블렘'],
      bottom: ['붉은빛엠블렘'],
      shoes: ['푸른빛엠블렘'],
      bracelet: ['푸른빛엠블렘'],
      necklace: ['녹색빛엠블렘'],
      ring: ['녹색빛엠블렘'],
      weapon: ['붉은빛엠블렘', '노란빛엠블렘', '녹색빛엠블렘', '푸른빛엠블렘'],
      sub: ['플래티넘엠블렘'],
      // title: ['플래티넘엠블렘'], // 모바일에 칭호 슬롯 붙일 때 사용
      earring: ['플래티넘엠블렘'],
      magestone: ['플래티넘엠블렘'],
    };
    const SOCKET_COUNT = (slotKey) => _isSpecialSlot(slotKey) ? 1 : 2;

    // DBEnh.byType 준비(모바일은 init에서 CORE.lists만 있으니 여기서 그룹핑)
    const PLACEHOLDER_IMG = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
    function _ensureDBEnhByType_mobile() {
      window.DBEnh = window.DBEnh || {};
      if (DBEnh.byType && DBEnh.__byTypeReady && Object.keys(DBEnh.byType).length > 0) return;

      DBEnh.byType = {};
      const list = (window.CORE?.lists && (CORE.lists['enh:list'] || CORE.lists.enh || CORE.lists.enhList)) || [];
      for (const row of list) {
        const it = _normEnhItem_mobile(row);
        const raw = it._raw || {};
        const type = String(it.type || '').trim();
        const name = String(it.name || '').trim();
        if (!type || !name) continue;

        // 이미지
        const img = _normImg(row?.image ?? raw['이미지'] ?? raw.image ?? '');
        // 플래티넘 라인 분류용(PC는 levelVal/tag를 쓰므로 여기서 하나 만들어 둠)
        const levelVal = String(
          row?.levelVal ??
          row?.level ??          // ✅ CORE 경량리스트에서 '렙제'가 level로 들어오는 케이스 대응
          raw['렙제'] ??
          raw['태그'] ??
          raw['tag'] ??
          raw.level ??
          ''
        ).trim();


        // 숫자 뱃지(이름에서 1~2자리 숫자)
        let level_num = '';
        const m = name.match(/(\d{1,2})/);
        if (m) level_num = m[1];

        const out = { name, type, img: img || PLACEHOLDER_IMG, levelVal, level_num, _raw: raw };
        (DBEnh.byType[type] = DBEnh.byType[type] || []).push(out);
      }
      DBEnh.__byTypeReady = true;
    }

    // state.emblems[slot] 배열 보장
    function _ensureEmblemArray_mobile(slotKey) {
      window.state = window.state || {};
      state.emblems = state.emblems || {};
      const cnt = SOCKET_COUNT(slotKey);
      if (!Array.isArray(state.emblems[slotKey])) state.emblems[slotKey] = new Array(cnt).fill(null);

      // 길이 보정
      if (state.emblems[slotKey].length !== cnt) {
        const arr = state.emblems[slotKey].slice(0, cnt);
        while (arr.length < cnt) arr.push(null);
        state.emblems[slotKey] = arr;
      }
      return state.emblems[slotKey];
    }

    // 상단바(엠블렘 구멍) 이미지 동기화
    function syncEmblemTopbarDots_mobile(slotKey) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;
      const emblemBtn = bar.querySelector('.equip-topbtn[data-eqtab="emblem"]');
      if (!emblemBtn) return;

      const dots = emblemBtn.querySelectorAll('.top-embs .emb');
      const arr = _ensureEmblemArray_mobile(slotKey);
      dots.forEach((d, i) => {
        const picked = arr[i] || null;

        const badge = picked?.level_num
          ? String(picked.level_num).replace(/[^\d]/g, '')
          : (picked?.name ? String(picked.name).replace(/[^\d]/g, '') : '');

        d.classList.toggle('has-img', !!picked);
        d.textContent = picked ? (badge || '') : '';

        if (picked?.img) d.style.backgroundImage = `url("${String(picked.img).replace(/"/g, '\\"')}")`;
        else d.style.backgroundImage = '';
      });
    }

    // 장비 리스트(메인 페이지) 엠블렘 아이콘 동기화
    function syncEquipRowEmblemIcons_mobile(slotKey) {
      const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slotKey}"]`);
      if (!row) return;
      const box = row.querySelector('.equip-emblem-icons');
      if (!box) return;

      const arr = _ensureEmblemArray_mobile(slotKey);
      const dots = box.querySelectorAll('.emb');
      dots.forEach((d, i) => {
        const picked = arr[i] || null;

        // ✅ 숫자(레벨) 표시: level_num 우선, 없으면 name에서 숫자 추출
        const badge = picked?.level_num
          ? String(picked.level_num).replace(/[^\d]/g, '')
          : (picked?.name ? String(picked.name).replace(/[^\d]/g, '') : '');

        d.classList.toggle('has-img', !!picked);
        d.textContent = picked ? (badge || '') : '';   // ✅ 숫자 표시

        if (picked?.img) d.style.backgroundImage = `url("${String(picked.img).replace(/"/g, '\\"')}")`;
        else d.style.backgroundImage = '';
      });
      // ✅ 특수장비(플래티넘) 속성 텍스트 미리보기(보조/마법석/귀걸이)
      // CSS는 이미 존재하며(:empty면 숨김) DOM이 없으면 여기서 생성해서 붙임 :contentReference[oaicite:4]{index=4}
      if (typeof _isSpecialSlot === 'function' && _isSpecialSlot(slotKey)) {
        let desc = row.querySelector('.equip-emblem-desc');
        if (!desc) {
          const emWrap = row.querySelector('.equip-emblems');
          if (emWrap) {
            desc = document.createElement('div');
            desc.className = 'equip-emblem-desc';
            emWrap.appendChild(desc);
          }
        }

        if (desc) {
          const p0 = arr[0] || null; // 특수장비는 소켓 1개
          const txt = (p0 && p0.type === '플래티넘엠블렘' && p0.tag) ? String(p0.tag).trim() : '';
          desc.textContent = txt;
        }
      } else {
        // 다른 부위는 혹시 남아있으면 비움
        const desc = row.querySelector('.equip-emblem-desc');
        if (desc) desc.textContent = '';
      }
    }

    // 모달 상단 타겟(소켓 선택 UI) 렌더
    function renderEmblemTarget_mobile(slotKey) {
      const wrap = document.getElementById('equipEmblemTarget');
      if (!wrap) return;

      const cnt = SOCKET_COUNT(slotKey);
      const slotKo =
        (window.EQUIP_SLOT_LABELS && EQUIP_SLOT_LABELS[slotKey]) ||
        (document.querySelector(`#pageEquip .equip-row[data-slot="${slotKey}"] .equip-name`)?.textContent || slotKey);

      state.ui = state.ui || {};
      state.ui.emblemTarget = state.ui.emblemTarget || { slotKey, sockIndex: 0 };
      state.ui.emblemTarget.slotKey = slotKey;

      const arr = _ensureEmblemArray_mobile(slotKey);
      const cur = Math.max(0, Math.min(cnt - 1, Number(state.ui.emblemTarget.sockIndex) || 0));
      state.ui.emblemTarget.sockIndex = cur;

      wrap.innerHTML = `
    <div class="em-target-top">
      <div class="em-slot-title">${String(slotKo).trim()} · 엠블렘</div>
      <div class="em-sockets">
        ${Array.from({ length: cnt }).map((_, i) => {
        const p = arr[i];
        const bg = p?.img ? `style="background-image:url('${String(p.img).replace(/'/g, "\\'")}')"` : '';
        const active = (i === cur) ? 'active' : '';
        const has = p?.img ? 'has-img' : '';
        const num = p?.level_num ? `<span class="num">${p.level_num}</span>` : '';
        const line = (p?.type === '플래티넘엠블렘' && p?.tag)
          ? `<span class="em-line-badge">${String(p.tag).trim()}</span>`
          : '';

        return `
  <span class="em-sock-wrap" data-sock="${i}">
    ${line}
    <button type="button" class="em-sock ${active} ${has}" data-sock="${i}" ${bg}>${num}</button>
  </span>
`;

      }).join('')}
      </div>
    </div>
    <div style="font-size:12px;color:rgba(240,230,210,0.75);">
      소켓을 눌러 대상을 바꾸고, 아래에서 엠블렘을 선택하세요.
    </div>
  `;

      // 소켓 클릭 바인딩(한 번만)
      if (!wrap.dataset.bound) {
        wrap.dataset.bound = '1';
        wrap.addEventListener('click', (e) => {
          const b = e.target.closest('.em-sock, .em-sock-wrap');
          if (!b) return;
          const i = Number(b.dataset.sock);
          if (!Number.isFinite(i)) return;
          state.ui.emblemTarget.sockIndex = i;
          renderEmblemTarget_mobile(slotKey);
        });
      }
    }

    // 모달 리스트(가로 행) 렌더
    function renderEmblemList_mobile(slotKey) {
      function _emNum(x) {
        const n = parseInt(String(x?.level_num ?? '').replace(/[^\d]/g, ''), 10);
        return Number.isFinite(n) ? n : -1;
      }
      // ✅ 내림차순: level_num 큰 것 먼저 → 이름(내림차순)
      function _sortEmblemsDesc(a, b) {
        const na = _emNum(a), nb = _emNum(b);
        if (nb !== na) return nb - na;
        const an = String(a?.name || '');
        const bn = String(b?.name || '');
        return bn.localeCompare(an, 'ko'); // name desc
      }

      const listEl = document.getElementById('equipEmblemList');
      if (!listEl) return;

      // ✅ 추가: enh:list → DBEnh.byType 준비(엠블렘 포함)
      _ensureDBEnhByType_mobile();

      const allowRaw = SOCKET_RULES[slotKey] || [];
      const allow = allowRaw
        .map(s => String(s || '').trim().replace(/^"+|"+$/g, ''))  // 앞/뒤 따옴표 제거
        .filter(Boolean);

      // ✅ DEBUG: 렌더 시점(진짜로 목록 채우기 직전)
      if (slotKey === 'weapon') {
        const by = window.DBEnh?.byType || {};
        console.log('[DBG weapon render] allow=', allow);
        allow.forEach(t => {
          console.log('  - type', t, 'len=', (by[t] || []).length);
        });
      }

      listEl.innerHTML = '';

      if (!allow.length) {
        listEl.innerHTML = `<div style="color:rgba(240,230,210,0.75);padding:8px;">선택 가능한 엠블렘이 없습니다.</div>`;
        return;
      }

      const isPlatinumOnly = (allow.length === 1 && allow[0] === '플래티넘엠블렘');

      const makeItemBtn = (item, isNone = false) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'em-item' + (isNone ? ' none' : '');
        const img = isNone ? '' : (item?.img || PLACEHOLDER_IMG);
        const name = isNone ? '없음' : (item?.name || '');
        const sub = isNone ? '선택한 소켓을 비웁니다' : (item?.type || '');
        const badge = (!isNone && item?.level_num) ? String(item.level_num) : '';

        btn.innerHTML = `
    <div class="thumb" style="${isNone ? '' : `background-image:url('${String(img).replace(/'/g, "\\'")}')`}">
      ${isNone ? '없음' : ''}
    </div>
    <div class="meta">
      <div class="name">${name}</div>
      <div class="sub">${sub}</div>
    </div>
    <div class="badge">${badge}</div>
  `;
        return btn;
      };

      const pick = (pickedItemOrNull) => {
        const t = state.ui?.emblemTarget || { slotKey, sockIndex: 0 };
        const sKey = t.slotKey;
        const idx = Number(t.sockIndex) || 0;

        _ensureEmblemArray_mobile(sKey);
        state.emblems[sKey][idx] = pickedItemOrNull ? {
          name: pickedItemOrNull.name,
          type: pickedItemOrNull.type,
          img: pickedItemOrNull.img,
          level_num: pickedItemOrNull.level_num,
          tag: pickedItemOrNull.levelVal,
        } : null;

        // UI 동기화
        syncEquipRowEmblemIcons_mobile(sKey);
        syncEmblemTopbarDots_mobile(sKey);
        renderEmblemTarget_mobile(sKey);

        // ✅ 자동 다음 소켓으로 이동(마지막이면 닫기)
        const cnt = SOCKET_COUNT(sKey);
        if (idx < cnt - 1) {
          state.ui.emblemTarget.sockIndex = idx + 1;
          renderEmblemTarget_mobile(sKey);
        } else {
          closeEquipEmblemModal();
        }
      };

      if (isPlatinumOnly) {
        let base = (DBEnh.byType['플래티넘엠블렘'] || []);
        const isSpecial = _isSpecialSlot(slotKey); // sub / magestone / earring

        // ✅ 특수장비: "속성 선택" → 선택한 속성의 단계(이름)만 아래에 표시
        if (isSpecial) {
          const ui = (state.ui || (state.ui = {}));
          const mem = (ui.emblemPlatLine || (ui.emblemPlatLine = {})); // 슬롯별 선택 기억
          const cur = (mem[slotKey] || '').trim();

          const group = document.createElement('div');
          group.className = 'em-group';

          const title = document.createElement('div');
          title.className = 'em-group-title plat';
          title.innerHTML = `
      <span>플래티넘 · <b class="em-plat-cur">${cur || '선택'}</b></span>
      <button type="button" class="em-line-btn">속성 선택</button>
    `;
          group.appendChild(title);

          const vlist = document.createElement('div');
          vlist.className = 'em-vlist';
          group.appendChild(vlist);

          // 속성 선택 패널(기본 숨김, 버튼 누르면 펼침)
          const chooser = document.createElement('div');
          chooser.className = 'em-line-choices';
          chooser.innerHTML = (PLAT_LINES || []).map(line => {
            const k = String(line.key || '').trim();
            const lb = String(line.label || k);
            return `<button type="button" class="em-line-opt" data-key="${k}">${lb}</button>`;
          }).join('');
          vlist.appendChild(chooser);

          const setActiveChooser = () => {
            const now = (mem[slotKey] || '').trim();
            chooser.querySelectorAll('.em-line-opt').forEach(b => {
              b.classList.toggle('active', (b.dataset.key || '') === now);
            });
            const curEl = title.querySelector('.em-plat-cur');
            if (curEl) curEl.textContent = now || '선택';
          };

          const renderStageList = () => {
            // 기존 단계 버튼/힌트 제거(chooser는 유지)
            vlist.querySelectorAll('.em-item, .em-plat-hint').forEach(el => el.remove());

            setActiveChooser();

            const now = (mem[slotKey] || '').trim();
            if (!now) {
              const hint = document.createElement('div');
              hint.className = 'em-plat-hint';
              hint.textContent = '속성(화/수/명/암/모속/힘/지능)을 먼저 선택해주세요.';
              vlist.appendChild(hint);
              return;
            }

            // 해제(없음)
            const noneBtn = document.createElement('button');
            noneBtn.type = 'button';
            noneBtn.className = 'em-item none';
            noneBtn.innerHTML = `
        <span class="thumb">없음</span>
        <span class="meta">
          <div class="name">없음</div>
          <div class="sub">플래티넘엠블렘</div>
        </span>
        <span class="badge">해제</span>
      `;
            noneBtn.addEventListener('click', () => {
              applyEmblem_mobile(slotKey, sockIdx, null);
              closeEquipEmblemModal();
            });
            vlist.appendChild(noneBtn);

            // ✅ 선택 속성과 일치하는 것만 "이름" 목록으로
            const items = base
              .filter(it => String((it.levelVal || '')).trim() === now)
              .sort(_sortEmblemsDesc);

            items.forEach(it => {
              const btn = makeItemBtn(it, false);
              btn.addEventListener('click', () => pick(it)); // ✅ 선택 적용
              vlist.appendChild(btn);
            });
          };

          // 버튼 눌러 chooser 토글
          const btnToggle = title.querySelector('.em-line-btn');
          if (btnToggle) {
            btnToggle.addEventListener('click', () => {
              chooser.classList.toggle('show');
            });
          }

          // chooser에서 속성 선택
          chooser.addEventListener('click', (e) => {
            const b = e.target.closest('.em-line-opt');
            if (!b) return;
            mem[slotKey] = (b.dataset.key || '').trim();
            chooser.classList.remove('show');
            renderStageList();
          });

          renderStageList();
          listEl.appendChild(group);
          return;
        }

        // (기존) 방어구/악세 등: 화/수/명/암 그룹 표시 유지
        const lines = PLAT_LINES.slice(0, 4);
        const SYNS = {
          '화': ['화', '화속', '화속성', '불'],
          '수': ['수', '수속', '수속성', '물'],
          '명': ['명', '명속', '명속성', '빛'],
          '암': ['암', '암속', '암속성', '어둠'],
          '모속': ['모속', '모든속성', '전속성'],
          '힘': ['힘'],
          '지능': ['지능'],
        };

        lines.forEach(line => {
          const keys = SYNS[line.key] || [line.key];
          const group = document.createElement('div');
          group.className = 'em-group';
          group.innerHTML = `<div class="em-group-title">플래티넘 · ${line.label}</div>`;
          const vlist = document.createElement('div');
          vlist.className = 'em-vlist';

          const noneBtn = document.createElement('button');
          noneBtn.type = 'button';
          noneBtn.className = 'em-item none';
          noneBtn.innerHTML = `
      <span class="thumb">없음</span>
      <span class="meta">
        <div class="name">없음</div>
        <div class="sub">플래티넘엠블렘</div>
      </span>
      <span class="badge">해제</span>
    `;
          noneBtn.addEventListener('click', () => pick(null));
          vlist.appendChild(noneBtn);

          const filtered = base
            .filter(x => {
              const lv = String(x.levelVal || '').trim();
              return keys.some(k => lv === k);
            })
            .sort(_sortEmblemsDesc);

          filtered.forEach(item => {
            vlist.appendChild(makeItemBtn(item));
          });

          group.appendChild(vlist);
          listEl.appendChild(group);
        });

      } else {
        const orderMap = { '붉은빛엠블렘': 0, '노란빛엠블렘': 1, '녹색빛엠블렘': 2, '푸른빛엠블렘': 3 };

        allow.slice().sort((a, b) => (orderMap[a] ?? 9) - (orderMap[b] ?? 9)).forEach(type => {
          const group = document.createElement('div');
          group.className = 'em-group';

          const title = document.createElement('div');
          title.className = 'em-group-title';
          const key = String(type || '').trim().replace(/^"+|"+$/g, '');
          title.textContent = key.replace('엠블렘', '');
          group.appendChild(title);

          const vlist = document.createElement('div');
          vlist.className = 'em-vlist';

          // ✅ 없음은 항상 맨 위
          const noneBtn = makeItemBtn(null, true);
          noneBtn.addEventListener('click', () => pick(null));
          vlist.appendChild(noneBtn);

          // ✅ 내림차순 정렬
          const items = (DBEnh.byType[key] || []).slice().sort(_sortEmblemsDesc);
          items.forEach(item => {
            const b = makeItemBtn(item, false);
            b.addEventListener('click', () => pick(item));
            vlist.appendChild(b);
          });

          group.appendChild(vlist);
          listEl.appendChild(group);
        });
      }
    }

    // 외부 진입점: 슬롯/소켓으로 엠블렘 모달 열기
    function openMobileEmblemPicker(slotKey, sockIndex = 0) {
      _ensureDBEnhByType_mobile();

      // ✅ DEBUG: 무기 엠블렘 모달 진입 시점 점검
      try {
        const allow = SOCKET_RULES[slotKey] || [];
        const allowRaw = SOCKET_RULES[slotKey] || [];
        const allowNorm = allowRaw.map(s => String(s || '').trim().replace(/^"+|"+$/g, '')).filter(Boolean);

        console.log('[DBG emblem open]', { slotKey, allowRaw, allowNorm });

        const by = window.DBEnh?.byType || {};
        console.log('[DBG byType counts]', {
          red: (by['붉은빛엠블렘'] || []).length,
          yel: (by['노란빛엠블렘'] || []).length,
          grn: (by['녹색빛엠블렘'] || []).length,
          blu: (by['푸른빛엠블렘'] || []).length,
          keysEmblem: Object.keys(by).filter(k => k.includes('엠블렘')).slice(0, 30)
        });

        // 무기일 때만 샘플도 몇 개 찍기
        if (slotKey === 'weapon') {
          console.log('[DBG weapon sample red]', (by['붉은빛엠블렘'] || []).slice(0, 5).map(x => x.name));
          console.log('[DBG weapon sample yel]', (by['노란빛엠블렘'] || []).slice(0, 5).map(x => x.name));
          console.log('[DBG weapon sample grn]', (by['녹색빛엠블렘'] || []).slice(0, 5).map(x => x.name));
          console.log('[DBG weapon sample blu]', (by['푸른빛엠블렘'] || []).slice(0, 5).map(x => x.name));
        }
      } catch (e) { console.warn('[DBG emblem open] err', e); }


      window.state = window.state || {};
      state.ui = state.ui || {};
      state.ui.emblemTarget = { slotKey, sockIndex };

      // 제목
      const titleEl = document.getElementById('equipEmblemModalTitle');
      if (titleEl) {
        const slotKo =
          (window.EQUIP_SLOT_LABELS && EQUIP_SLOT_LABELS[slotKey]) ||
          (document.querySelector(`#pageEquip .equip-row[data-slot="${slotKey}"] .equip-name`)?.textContent || slotKey);
        titleEl.textContent = `${String(slotKo).trim()} 엠블렘 선택`;
      }

      _ensureEmblemArray_mobile(slotKey);
      renderEmblemTarget_mobile(slotKey);
      renderEmblemList_mobile(slotKey);

      openEquipEmblemModal();
    }

    function _shortTopbarText_mobile(s, maxLen = 7) {
      s = String(s || '').trim();
      if (!s) return '';
      return (s.length > maxLen) ? (s.slice(0, maxLen - 1) + '…') : s;
    }

    function syncSealTopbarLabel_mobile(slot) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;

      const uBtn = bar.querySelector('.equip-topbtn[data-eqtab="seal_u"]');
      const nBtn = bar.querySelector('.equip-topbtn[data-eqtab="seal_n"]');

      if (uBtn && !uBtn.dataset.baseLabel) {
        uBtn.dataset.baseLabel = (uBtn.textContent || '고유옵션').trim();
      }
      if (nBtn && !nBtn.dataset.baseLabel) {
        nBtn.dataset.baseLabel = (nBtn.textContent || '일반옵션').trim();
      }

      const uName = window.state?.seals?.[slot]?.unique?.name
        ? String(window.state.seals[slot].unique.name).trim()
        : '';
      const nName = window.state?.seals?.[slot]?.general1?.name
        ? String(window.state.seals[slot].general1.name).trim()
        : '';

      if (uBtn) uBtn.textContent = uName ? _shortTopbarText_mobile(uName) : uBtn.dataset.baseLabel;
      if (nBtn) nBtn.textContent = nName ? _shortTopbarText_mobile(nName) : nBtn.dataset.baseLabel;
    }

    function syncEnchantTopbarLabel_mobile(slot) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;

      const btn = bar.querySelector('.equip-topbtn[data-eqtab="enchant"]');
      if (!btn) return;

      if (!btn.dataset.baseLabel) {
        btn.dataset.baseLabel = (btn.textContent || '마법부여').trim();
      }

      const name = window.state?.enchants?.[slot]?.name
        ? String(window.state.enchants[slot].name).trim()
        : '';

      btn.textContent = name ? _shortTopbarText_mobile(name) : btn.dataset.baseLabel;
    }




    function setEquipTopbarSlot(slot) {
      const bar = document.getElementById('equipTopbar');
      if (!bar) return;

      // ✅ 연마 탭: data-grind="1" 인 슬롯에서만 노출 (무기/보조장비)
      const grindBtn = bar.querySelector('.equip-topbtn[data-eqtab="grind"]');
      if (grindBtn) {
        const row = document.querySelector(`#pageEquip .equip-row[data-slot="${slot}"]`);
        const canGrind = !!(row && row.dataset.grind === '1');
        grindBtn.style.display = canGrind ? '' : 'none';
        if (canGrind) syncGrindTopbarLabel_mobile(slot);
      }

      // active 기본은 강화
      bar.querySelectorAll('.equip-topbtn').forEach(b => {
        b.classList.toggle('active', b.dataset.eqtab === 'enh');
      });

      // ✅ 추가: 현재 슬롯의 강화 수치로 '강화 버튼 텍스트' 갱신
      syncEnhTopbarLabel_mobile(slot);

      // ✅ 추가: 현재 슬롯의 고유/일반 선택값으로 상단 버튼 텍스트 갱신
      syncSealTopbarLabel_mobile(slot);
      syncEnchantTopbarLabel_mobile(slot);

      // ✅ 엠블렘 구멍 개수: 특수장비(보조/마법석/귀걸이)=1개, 그 외=2개
      const emblemBtn = bar.querySelector('.equip-topbtn[data-eqtab="emblem"]');
      if (emblemBtn) {
        const cnt = _isSpecialSlot(slot) ? 1 : 2;
        emblemBtn.innerHTML = `
      <span class="top-embs">
        ${Array.from({ length: cnt }).map(() => `<span class="emb"></span>`).join('')}
      </span>
    `;
        // 구멍 만든 직후, 현재 선택된 엠블렘 이미지 반영
        syncEmblemTopbarDots_mobile(slot);
      }

      // (선택) 현재 슬롯 저장해두면 나중에 탭 클릭 시 분기하기 편함
      (window.state = window.state || {}).ui = (window.state.ui || {});
      window.state.ui.equipPickerSlot = slot;
    }

    // ✅ 상단바 클릭(구멍 포함) → 탭 활성화
    (function bindEquipTopbarOnce() {
      const bar = document.getElementById('equipTopbar');
      if (!bar || bar.dataset.bound) return;
      bar.dataset.bound = '1';

      bar.addEventListener('click', async (e) => { // ✅ async로 변경
        const btn = e.target.closest('.equip-topbtn');
        if (!btn) return;

        bar.querySelectorAll('.equip-topbtn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const tab = btn.dataset.eqtab;

        // ✅ 강화 탭: enhList 버튼 목록 보여주기
        if (tab === 'enh') {
          const slot = window.state?.ui?.equipPickerSlot; // setEquipTopbarSlot에서 저장
          if (!slot) {
            toast('슬롯 정보가 없습니다.');
            return;
          }
          await initMobileAllLightListsOnce();  // 경량리스트 보장
          renderMobileEnhList(slot);
          return;
        }

        // 나머지는 일단 기존대로 토스트
        if (tab === 'grind') {
          openMobileGrindPicker();
          return;
        }
        else if (tab === 'seal_u') {
          const slot = window.state?.ui?.equipPickerSlot; // ✅ setEquipTopbarSlot에서 저장한 슬롯
          if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

          await initMobileAllLightListsOnce(); // ✅ 경량리스트 보장
          renderMobileSealUniqueList(slot);    // ✅ 고유옵션 모달 오픈 + 목록 렌더
          return;

        } else if (tab === 'seal_n') {
          const slot = window.state?.ui?.equipPickerSlot; // ✅ setEquipTopbarSlot에서 저장한 슬롯
          if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

          await initMobileAllLightListsOnce(); // ✅ 경량리스트 보장
          renderMobileSealNormalList(slot);    // ✅ 일반옵션 모달 오픈 + 목록 렌더
          return;
        } else if (tab === 'enchant') {
          const slot = window.state?.ui?.equipPickerSlot;
          if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

          initMobileAllLightListsOnce().then(() => {
            renderMobileEnchantList(slot);
          });
          return;
        } else if (tab === 'emblem') {
          const slot = window.state?.ui?.equipPickerSlot;
          if (!slot) { toast('슬롯 정보가 없습니다.'); return; }

          await initMobileAllLightListsOnce(); // 경량리스트 보장
          openMobileEmblemPicker(slot, 0);     // ✅ 엠블렘 모달 오픈
          return;
        }
      });
    })();



    async function openEquipPicker(slot) {
      // ✅ 무기 선택(캐릭터 직업군 + 무기종류 필터 반영)
      if (slot === 'weapon') {
        _hideWeaponTypeBar_mobile();
        await initMobileAllLightListsOnce(); // 경량리스트 보장

        // 1) 현재 선택 캐릭터 직업군 확보 (프로젝트 내 상태키가 다를 수 있어 방어적으로)
        const ch = window.state?.currentCharacter || window.state?.char || window.state?.pickedChar || null;
        const jobGroup = _getCharJobGroup(ch) || '';
        if (!jobGroup) {
          toast('캐릭터를 먼저 선택해주세요.');
          return;
        }

        // 2) 무기 리스트 가져오기
        //    - 직업군별로 따로 내려주는 키가 있으면 그걸 우선
        //    - 없으면 weapon:list 전체에서 jobGroup으로 필터
        const keyByJob = `weapon:${jobGroup}:list`;
        const byJob = window.CORE?.lists?.[keyByJob];
        let items = Array.isArray(byJob) ? byJob.slice() : (window.CORE?.lists?.['weapon:list'] || []).slice();

        // 직업군별 키가 없어서 전체 weapon:list를 쓰는 경우만 jobGroup 필터
        if (!Array.isArray(byJob)) {
          const base = _baseJG_mobile(jobGroup);
          items = items.filter(it => _jgMatches_mobile(_getEquipJobGroup_mobile(it), jobGroup));
        }

        // 3) 무기종류 탭(버튼) 구성 + 선택 시 목록 갱신
        const baseItems = items.slice();

        // 직업군에 해당하는 무기들에서 "종류" 목록 뽑기
        let types = Array.from(new Set(
          baseItems.map(it => _getWeaponType_mobile(it)).filter(Boolean)
        ));

        // 보기 좋게 정렬(원하면 제거 가능)
        types.sort((a, b) => String(a).localeCompare(String(b), 'ko-KR'));

        // state.ui 준비
        window.state = window.state || {};
        window.state.ui = window.state.ui || {};

        let activeType = String(window.state.ui.weaponType || '전체').trim() || '전체';
        if (activeType !== '전체' && !types.includes(activeType)) activeType = '전체';
        window.state.ui.weaponType = activeType;

        // ✅ 탭 클릭 시: active 갱신 + 목록 재렌더
        const onPickType = (t) => {
          t = String(t || '전체').trim() || '전체';
          window.state.ui.weaponType = t;

          // 탭 active 다시 그리기
          renderWeaponTypeBar_mobile(types, t, onPickType);

          // 목록 필터링 후 다시 렌더
          let filtered = baseItems;
          if (t !== '전체') filtered = baseItems.filter(it => _getWeaponType_mobile(it) === t);

          const catalog = document.getElementById('equipCatalog');
          if (!filtered.length) {
            toast('표시할 무기 목록이 없습니다.');
            if (catalog) {
              catalog.innerHTML = `<div style="padding:14px 16px; color:#c7b589;">표시할 무기 목록이 없습니다.</div>`;
            }
            return;
          }
          renderMobileEquipList('weapon', filtered);
        };

        // 최초 1회 탭 렌더
        renderWeaponTypeBar_mobile(types, activeType, onPickType);

        // 최초 진입 시 현재 선택 타입으로 필터 적용
        items = baseItems;
        if (activeType !== '전체') {
          items = baseItems.filter(it => _getWeaponType_mobile(it) === activeType);
        }


        if (!items.length) {
          toast('표시할 무기 목록이 없습니다.');
          return;
        }

        setEquipTopbarSlot(slot);
        renderMobileEquipList(slot, items);
        openEquipModal();
        return;
      }


      // init에서 경량리스트 전부 받기
      await initMobileAllLightListsOnce();

      const key = _equipListKey(slot);
      const items = window.CORE?.lists?.[key];

      if (!Array.isArray(items) || !items.length) {
        console.error('equip list missing:', key, items);
        toast(`장비 목록을 불러오지 못했습니다. (${key})`);
        return;
      }

      setEquipTopbarSlot(slot);
      renderMobileEquipList(slot, items);
      openEquipModal();
    }

    /* =========================
   ✅ (NEW) Set Equip (Mobile)
========================= */

    function _openModalById_(id) {
      const m = document.getElementById(id);
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function _closeModalById_(id) {
      const m = document.getElementById(id);
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }

    /* ✅ 공통 닫기 바인딩: backdrop 클릭 또는 [data-mset-close] */
    (function bindMSetCloseOnce() {
      const ids = ['mArmorSetModal', 'mAccSetModal', 'mSpecSetModal', 'mUniqueBulkModal', 'mUniquePickModal'];
      ids.forEach(id => {
        const m = document.getElementById(id);
        if (!m || m.__bound) return;
        m.__bound = 1;
        m.addEventListener('click', (e) => {
          if (e.target?.classList?.contains('backdrop')) return _closeModalById_(id);
          if (e.target?.closest?.('[data-mset-close]')) return _closeModalById_(id);
        });
      });
    })();

    /* ✅ 세트 적용: state.equips + UI 동기화 */
    function applySetPieces_mobile(setCard) {
      if (!setCard?.pieces) return;
      window.state = window.state || {};
      state.equips = state.equips || {};

      for (const p of setCard.pieces) {
        if (!p?.slot || !p?.item) continue;
        state.equips[p.slot] = p.item;

        // ✅ 모바일에 “장비 선택 시 UI 반영” 함수가 이미 존재하는 경우를 우선 사용
        if (typeof applyPickedEquipUI === 'function') {
          applyPickedEquipUI(p.slot, p.item);
        } else if (typeof syncEquipUI_mobile === 'function') {
          syncEquipUI_mobile(p.slot);
        }
      }
    }

    /* =========================
       ✅ PC의 세트 카드 생성 로직 이식
       - 아래 3개 함수는 PC(새로운프론트249)에서 가져오는 것을 권장
       - buildAccSetCardsFromSheets / buildSpecSetCardsFromSheets / buildArmorSetCardsFromSheets
    ========================= */
    function buildArmorSetCardsFromSheets() {
      // 현재 토글 상태 (기본값은 익시드)
      const mode = (typeof armorSetMode === 'string') ? armorSetMode : 'exceed';
      // --- CORE.lists 접근 ---
      const lists = (function _coreRoot() {
        const core =
          (window.CORE && (window.CORE.data || window.CORE)) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)) ||
          null;
        return core ? (core.lists || {}) : null;
      })();
      if (!lists) return [];

      // 1) 세트 시트 로우들
      let setRows = lists['set:list'];
      if (setRows && typeof setRows === 'object' && Array.isArray(setRows.rows)) {
        setRows = setRows.rows;
      }
      if (!Array.isArray(setRows)) setRows = [];

      const norm = (v) => String(v ?? '').trim();
      const toNum = (v) => {
        const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
        return Number.isFinite(n) ? n : 0;
      };

      // 2) 방어구 세트만 type 기준으로 대표 1개씩 뽑기 (보통 5세트 행)
      const armorSetByType = new Map(); // type -> { type, name, num }

      for (const r of setRows) {
        const category = norm(r.category || r['분류'] || '');
        const armp = toNum(r.armpoint);

        // 방어구 세트만 대상으로
        if (!category && !armp) continue;
        if (category && category !== '방어구') continue;

        const type = norm(r.type);
        if (!type) continue;

        const rarity = norm(r.rarity || r['레어리티'] || '');
        const num = toNum(r.num);
        const name = norm(r.name || r['이름'] || type);

        const prev = armorSetByType.get(type);
        if (!prev || num > prev.num) {
          armorSetByType.set(type, { type, name, num, rarity });
        }
      }


      if (!armorSetByType.size) return [];

      // 3) 각 부위 시트에서, 해당 세트 type 과 같은 '종류' 를 가진 장비 찾기
      const slotKeys = ['top', 'bottom', 'headshoulder', 'belt', 'shoes'];

      // itemModal 쪽에서 쓰는 헬퍼 재사용
      function _getListArray(slotKey) {
        const lists2 =
          (window.CORE && (window.CORE.data || window.CORE)?.lists) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)?.lists) ||
          null;
        if (!lists2) return [];
        const key1 = `${slotKey}:list`;
        const key2 = `${slotKey}:lists`;
        const key3 = slotKey;
        let arr = lists2[key1] ?? lists2[key2] ?? lists2[key3] ?? [];
        if (arr && typeof arr === 'object' && Array.isArray(arr.rows)) arr = arr.rows;
        return Array.isArray(arr) ? arr : [];
      }

      function _mapEquipRow(row) {
        const S = (v) => (v == null ? '' : String(v));
        const N = (v) => {
          const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
          return Number.isFinite(n) ? n : 0;
        };
        const 이름 = row['이름'] ?? row.name ?? row.title ?? '';
        const 종류 = row['종류'] ?? row.type ?? row.category ?? '';
        const 렙제 = row['레벨제한'] ?? row['렙제'] ?? row.level ?? row.reqLevel ?? 0;
        const 이미지 = row['이미지'] ?? row.image ?? row.img ?? '';
        const 레어리티 = row['레어리티'] ?? row.rarity ?? '';
        return {
          name: S(이름),
          type: S(종류),
          level: N(렙제),
          img: S(이미지),
          rarity: S(레어리티),
          _raw: row,
        };
      }

      const equipBySlot = {};
      for (const slotKey of slotKeys) {
        equipBySlot[slotKey] = _getListArray(slotKey).map(_mapEquipRow);
      }

      // 4) 세트별 카드 데이터 구성
      const cards = [];

      armorSetByType.forEach((info, typeKey) => {
        const pieces = [];

        for (const slotKey of slotKeys) {
          const rows = equipBySlot[slotKey] || [];

          let row;

          if (mode === 'epic') {
            // ✅ 에픽 모드: 종류가 세트 type 이고, 레어리티가 '에픽' 인 장비 우선 선택
            row = rows.find(
              (r) =>
                norm(r.type) === norm(typeKey) &&
                norm(r.rarity || r['레어리티']) === '에픽'
            );

            // 혹시 에픽 장비가 없으면(데이터 누락 등) 그냥 종류만 맞는 첫 장비로 fallback
            if (!row) {
              row = rows.find((r) => norm(r.type) === norm(typeKey));
            }
          } else {
            // ✅ 익시드 모드: 기존과 동일 (종류만 맞으면 사용)
            row = rows.find((r) => norm(r.type) === norm(typeKey));
          }

          if (row) {
            pieces.push({
              slot: slotKey,
              name: row.name,
              level: row.level,
              img: row.img || PLACEHOLDER_IMG,
              rarity: row.rarity,
              item: row,              // ★ 실제 장비 객체 저장
            });
          } else {
            pieces.push({
              slot: slotKey,
              name: '',
              level: null,
              img: PLACEHOLDER_IMG,
              rarity: '',
              item: null,             // 없으면 null
            });
          }
        }

        cards.push({
          id: typeKey,
          type: typeKey,
          name: info.name,
          num: info.num,
          pieces,
        });
      });

      // 보기 좋게 세트 이름 순 정렬
      //cards.sort((a, b) => a.name.localeCompare(b.name, 'ko'));

      // 디버그용으로 한 번 볼 수 있게
      window._debugArmorSets = cards;

      return cards;
    }

    function buildAccSetCardsFromSheets() {
      const mode = (typeof armorSetMode === 'string') ? armorSetMode : 'exceed';

      const lists = (function _coreRoot() {
        const core =
          (window.CORE && (window.CORE.data || window.CORE)) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)) ||
          null;
        return core ? (core.lists || {}) : null;
      })();
      if (!lists) return [];

      // 1) 세트 시트
      let setRows = lists['set:list'];
      if (setRows && typeof setRows === 'object' && Array.isArray(setRows.rows)) {
        setRows = setRows.rows;
      }
      if (!Array.isArray(setRows)) setRows = [];

      const norm = (v) => String(v ?? '').trim();
      const toNum = (v) => {
        const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
        return Number.isFinite(n) ? n : 0;
      };

      // 2) 악세사리 세트만 type 기준으로 대표 1개씩 뽑기
      const accSetByType = new Map(); // type -> { type, name, num }

      for (const r of setRows) {
        const category = norm(r.category || r['분류'] || '');
        const acp = toNum(r.accpoint); // 악세 포인트

        // 분류가 '악세사리' 이거나, accpoint 가 있는 행만 악세 세트 취급
        if (!category && !acp) continue;
        if (category && category !== '악세') continue;

        const type = norm(r.type);
        if (!type) continue;

        const rarity = norm(r.rarity || r['레어리티'] || '');
        const num = toNum(r.num);
        const name = norm(r.name || r['이름'] || type);

        const prev = accSetByType.get(type);
        if (!prev || num > prev.num) {
          accSetByType.set(type, { type, name, num, rarity });
        }
      }

      if (!accSetByType.size) return [];

      // 3) 장비 시트에서 팔찌/목걸이/반지 찾기
      const slotKeys = ['bracelet', 'necklace', 'ring'];

      function _getListArray(slotKey) {
        const lists2 =
          (window.CORE && (window.CORE.data || window.CORE)?.lists) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)?.lists) ||
          null;
        if (!lists2) return [];
        const key1 = `${slotKey}:list`;
        const key2 = `${slotKey}:lists`;
        const key3 = slotKey;
        let arr = lists2[key1] ?? lists2[key2] ?? lists2[key3] ?? [];
        if (arr && typeof arr === 'object' && Array.isArray(arr.rows)) arr = arr.rows;
        return Array.isArray(arr) ? arr : [];
      }

      function _mapEquipRow(row) {
        const S = (v) => (v == null ? '' : String(v));
        const N = (v) => {
          const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
          return Number.isFinite(n) ? n : 0;
        };
        const 이름 = row['이름'] ?? row.name ?? row.title ?? '';
        const 종류 = row['종류'] ?? row.type ?? row.category ?? '';
        const 렙제 = row['레벨제한'] ?? row['렙제'] ?? row.level ?? row.reqLevel ?? 0;
        const 이미지 = row['이미지'] ?? row.image ?? row.img ?? '';
        const 레어리티 = row['레어리티'] ?? row.rarity ?? '';
        return {
          name: S(이름),
          type: S(종류),
          level: N(렙제),
          img: S(이미지),
          rarity: S(레어리티),
          _raw: row,
        };
      }

      const equipBySlot = {};
      for (const slotKey of slotKeys) {
        equipBySlot[slotKey] = _getListArray(slotKey).map(_mapEquipRow);
      }

      const cards = [];

      accSetByType.forEach((info, typeKey) => {
        const pieces = [];

        for (const slotKey of slotKeys) {
          const rows = equipBySlot[slotKey] || [];
          let row;

          if (mode === 'epic') {
            // 에픽 모드: 종류 + 레어리티 '에픽' 우선
            row = rows.find(
              (r) =>
                norm(r.type) === norm(typeKey) &&
                norm(r.rarity || r['레어리티']) === '에픽'
            );
            if (!row) {
              row = rows.find((r) => norm(r.type) === norm(typeKey));
            }
          } else {
            // 익시드 모드: 종류만 맞으면 OK
            row = rows.find((r) => norm(r.type) === norm(typeKey));
          }

          if (row) {
            pieces.push({
              slot: slotKey,
              name: row.name,
              level: row.level,
              img: row.img || PLACEHOLDER_IMG,
              rarity: row.rarity,
              item: row,
            });
          } else {
            pieces.push({
              slot: slotKey,
              name: '',
              level: null,
              img: PLACEHOLDER_IMG,
              rarity: '',
              item: null,
            });
          }
        }

        cards.push({
          id: typeKey,
          type: typeKey,
          name: info.name,
          num: info.num,
          pieces,
        });
      });

      // 시트 순서 유지 (정렬 안 함)
      window._debugAccSets = cards;
      return cards;
    }

    function buildSpecSetCardsFromSheets() {
      const mode = (typeof armorSetMode === 'string') ? armorSetMode : 'exceed';

      const lists = (function _coreRoot() {
        const core =
          (window.CORE && (window.CORE.data || window.CORE)) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)) ||
          null;
        return core ? (core.lists || {}) : null;
      })();
      if (!lists) return [];

      let setRows = lists['set:list'];
      if (setRows && typeof setRows === 'object' && Array.isArray(setRows.rows)) {
        setRows = setRows.rows;
      }
      if (!Array.isArray(setRows)) setRows = [];

      const norm = (v) => String(v ?? '').trim();
      const toNum = (v) => {
        const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
        return Number.isFinite(n) ? n : 0;
      };

      const specSetByType = new Map();

      for (const r of setRows) {
        const categoryRaw = r.category ?? r['분류'] ?? '';
        const category = norm(categoryRaw);
        const categoryNoSpace = category.replace(/\s+/g, '');

        const subp = toNum(r.subpoint || r['subpoint'] || r['특수장비포인트'] || 0);

        // ✅ 분류에 '특수', '보조', '마법석', '귀걸이' 포함 또는 특수장비포인트가 있으면 특수세트로 취급
        const isSpecCategory =
          categoryNoSpace.includes('특수') ||
          categoryNoSpace.includes('보조') ||
          categoryNoSpace.includes('마법석') ||
          categoryNoSpace.includes('귀걸이');

        if (!isSpecCategory && !subp) continue;

        const type = norm(r.type);
        if (!type) continue;

        const rarity = norm(r.rarity || r['레어리티'] || '');
        const num = toNum(r.num);
        const name = norm(r.name || r['이름'] || type);

        const prev = specSetByType.get(type);
        if (!prev || num > prev.num) {
          specSetByType.set(type, { type, name, num, rarity });
        }
      }

      if (!specSetByType.size) return [];

      // ✅ 특수장비 슬롯 키: 보조 / 마법석 / 귀걸이
      const slotKeys = ['sub', 'magestone', 'earring'];

      function _getListArray(slotKey) {
        const core =
          (window.CORE && (window.CORE.data || window.CORE)) ||
          (window.CORE_DATA && (window.CORE_DATA.data || window.CORE_DATA)) ||
          null;
        const lists2 = core ? (core.lists || {}) : {};
        let arr =
          lists2[`${slotKey}:list`] ??
          lists2[`${slotKey}:lists`] ??
          lists2[slotKey] ??
          [];
        if (arr && typeof arr === 'object' && Array.isArray(arr.rows)) arr = arr.rows;
        return Array.isArray(arr) ? arr : [];
      }

      function _mapEquipRow(row) {
        const S = (v) => (v == null ? '' : String(v));
        const N = (v) => {
          const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
          return Number.isFinite(n) ? n : 0;
        };
        const 이름 = row['이름'] ?? row.name ?? row.title ?? '';
        const 종류 = row['종류'] ?? row.type ?? row.category ?? '';
        const 렙제 = row['레벨제한'] ?? row['렙제'] ?? row.level ?? row.reqLevel ?? 0;
        const 이미지 = row['이미지'] ?? row.image ?? row.img ?? '';
        const 레어리티 = row['레어리티'] ?? row.rarity ?? '';
        return {
          name: S(이름),
          type: S(종류),
          level: N(렙제),
          img: S(이미지),
          rarity: S(레어리티),
          _raw: row,
        };
      }

      const equipBySlot = {};
      for (const slotKey of slotKeys) {
        equipBySlot[slotKey] = _getListArray(slotKey).map(_mapEquipRow);
      }

      const cards = [];

      specSetByType.forEach((info, typeKey) => {
        const pieces = [];

        for (const slotKey of slotKeys) {
          const rows = equipBySlot[slotKey] || [];
          let row;

          if (mode === 'epic') {
            // 에픽 모드: 종류 + 레어리티 '에픽' 우선
            row = rows.find(
              (r) =>
                norm(r.type) === norm(typeKey) &&
                norm(r.rarity || r['레어리티']) === '에픽'
            );
            if (!row) {
              row = rows.find((r) => norm(r.type) === norm(typeKey));
            }
          } else {
            // 익시드 모드: 종류만 맞으면 OK
            row = rows.find((r) => norm(r.type) === norm(typeKey));
          }

          if (row) {
            pieces.push({
              slot: slotKey,
              name: row.name,
              level: row.level,
              img: row.img || PLACEHOLDER_IMG,
              rarity: row.rarity,
              item: row,
            });
          } else {
            pieces.push({
              slot: slotKey,
              name: '',
              level: null,
              img: PLACEHOLDER_IMG,
              rarity: '',
              item: null,
            });
          }
        }

        cards.push({
          id: typeKey,
          type: typeKey,
          name: info.name,
          num: info.num,
          pieces,
        });
      });

      window._debugSpecSets = cards;
      return cards;
    }


    /* ⚠️ 여기부터는 “PC의 함수 본문을 그대로 복사”해서 넣어야 함
       - PC 파일에 이미 구현되어 있고(set:list + 슬롯별 list에서 아이템 찾아 pieces 구성),
       - 그 구조가 가장 안전함
    */
    function ensureCustomSkillsMobile() {
      window.state = window.state || {};
      state.customSkills = state.customSkills || {};
      if (typeof state.customSkills.weaponType !== "string") state.customSkills.weaponType = "";
      if (typeof state.customSkills.armorType !== "string") state.customSkills.armorType = "";
      if (typeof state.customSkills.braceletType !== "string") state.customSkills.braceletType = "";
      if (typeof state.customSkills.earringType !== "string") state.customSkills.earringType = "";
    }

    function syncUniqueMiniLabels() {
      ensureCustomSkillsMobile();

      const map = {
        weaponType: state.customSkills.weaponType,
        armorType: state.customSkills.armorType,
        braceletType: state.customSkills.braceletType,
        earringType: state.customSkills.earringType
      };

      // ✅ 색상 매핑
      // - 무기: 강타/광채/분쇄/선명 그대로
      // - 나머지: 선봉=분쇄색, 의지=광채색, 이상=선명색
      const mapColor = (key, rawVal) => {
        const v = String(rawVal || '').trim();
        if (!v || v === '-' || v === '없음') return 'none';

        if (key === 'weaponType') {
          // 강타/광채/분쇄/선명
          return v;
        }
        if (v === '선봉') return '분쇄';
        if (v === '의지') return '광채';
        if (v === '이상') return '선명';
        return 'none';
      };

      document.querySelectorAll("[data-uval]").forEach(el => {
        const k = el.getAttribute("data-uval");

        const v = (map[k] && String(map[k]).trim()) ? String(map[k]).trim() : "";
        el.textContent = v ? v : "-";

        // ✅ [data-uval] span의 부모 미니버튼(.equip-u-mini)에 색상 주입
        const mini = el.closest('.equip-u-mini');
        if (mini) {
          mini.dataset.ucolor = mapColor(k, v);
        }
      });
    }


    // ✅ 전역 escapeHTML 보장 (없을 때만 생성)
    if (typeof window.escapeHTML !== 'function') {
      window.escapeHTML = (s) => String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    // ✅ PC의 unique-desc 설명 매핑을 모바일에서도 재사용
    function updateUniqueEffectDescriptionsMobile(rootEl) {
      const root = rootEl || document;

      // PC처럼 custom:list를 소스로 사용
      const customList = window.CORE?.lists?.['custom:list'] || [];
      if (!Array.isArray(customList) || !customList.length) {
        // 데이터가 없으면 설명은 비워둠
        root.querySelectorAll('.unique-desc').forEach(el => el.innerHTML = '');
        return;
      }

      // (모바일 state 구조) 현재 캐릭터의 직업군 라벨
      const jobGroupLabel =
        (window.state?.currentCharacter?.jobGroupLabel)
        || (window.state?.currentCharacter?.jobGroup)
        || '';

      // 간단 escape (PC도 innerHTML 넣기 전에 처리)
      const escapeHTML = window.escapeHTML;

      // ✅ customName(강타/광채/...) → custom:list에서 설명 가져오기 (PC 매칭 방식)
      const pickDescByCustomName = (customName) => {
        const name = (customName || '').trim();
        if (!name || name === '없음') return '';

        const norm = (v) => String(v ?? '').trim();

        const jobGroup = norm(window.state?.currentCharacter?.jobGroupLabel
          ?? window.state?.currentCharacter?.jobGroup
          ?? '');
        const charName = norm(window.state?.currentCharacter?.name ?? '');

        // 1차: type(종류)로 매칭 (PC와 동일)
        let rowsBase = customList.filter(r =>
          norm(r?.type ?? r?.['종류']) === name
        );
        if (!rowsBase.length) return '';

        // 2차: 직업군 + 캐릭명(있으면)까지 맞는 row 우선
        let candidates = rowsBase.filter(r =>
          (!jobGroup || norm(r?.jobGroupLabel ?? r?.jobGroup ?? r?.['직업군']) === jobGroup || !norm(r?.jobGroupLabel ?? r?.jobGroup ?? r?.['직업군'])) &&
          (!charName || norm(r?.name ?? r?.['이름']) === charName || !norm(r?.name ?? r?.['이름']))
        );
        if (!candidates.length) candidates = rowsBase;

        // 3차: num(갯수) 기준 — 모달 설명은 기본 1개 효과를 보여주기 위해 num=1 우선
        const scored = candidates.map(r => {
          const rawNum = norm(r?.num ?? r?.['갯수']);
          const rowNum = rawNum ? (parseInt(rawNum, 10) || 0) : 1;
          return { r, rowNum };
        }).filter(x => x.rowNum > 0);

        let best = scored.find(x => x.rowNum === 1) || scored[0];
        if (!best) return '';

        const r = best.r;
        const parts = [
          r?.desc1, r?.desc2, r?.desc3, r?.desc4, r?.desc5,
          r?.['설명1'], r?.['설명2'], r?.['설명3'], r?.['설명4'], r?.['설명5'],
        ].map(v => norm(v)).filter(Boolean);

        if (!parts.length) return '';

        const raw = parts.join('\n');
        // PC처럼 <br> 처리 + escape
        return raw.includes('<')
          ? raw.replace(/\n/g, '<br>')
          : window.escapeHTML(raw).replace(/\n/g, '<br>');
      };


      // ✅ root 안의 unique-desc 모두 채우기
      root.querySelectorAll('.unique-desc').forEach(descEl => {
        const v = (descEl.dataset.value || '').trim();
        const raw = pickDescByCustomName(v);

        if (!raw) { descEl.innerHTML = ''; return; }

        // PC처럼 "<"가 들어간 경우는 HTML로 취급, 아니면 escape 후 줄바꿈 처리
        descEl.innerHTML = raw.includes('<')
          ? raw
          : escapeHTML(raw).replace(/\n/g, '<br>');
      });
    }

    function openUniquePickModalMobile(targetKey) {
      ensureCustomSkillsMobile();

      const isWeapon = (targetKey === "weaponType");
      const opts = isWeapon
        ? ["강타", "광채", "분쇄", "선명", "없음"]
        : ["선봉", "의지", "이상", "없음"];

      const titleMap = {
        weaponType: "고유효과 (무기)",
        armorType: "고유효과 (상의)",
        braceletType: "고유효과 (팔찌)",
        earringType: "고유효과 (귀걸이)"
      };

      const cur = (state.customSkills[targetKey] || "").trim();
      const $title = document.getElementById("mUniquePickTitle");
      const $list = document.getElementById("mUniquePickList");
      if ($title) $title.textContent = titleMap[targetKey] || "고유효과";

      if ($list) {
        const kind = isWeapon ? "weapon" : "other"; // (설명 매칭용)

        // ✅ (1) 컨테이너에 weapon/other 클래스를 붙여서 CSS 스코프가 매칭되게
        $list.classList.remove("unique-options-weapon", "unique-options-other");
        $list.classList.add(isWeapon ? "unique-options-weapon" : "unique-options-other");

        // ✅ (2) 버튼에 data-value도 같이 넣어서 CSS 셀렉터([data-value="..."])가 먹게
        $list.innerHTML = opts.map(v => {
          const on = (cur === v);
          return `
    <div class="unique-row ${on ? "is-selected" : ""}">
      <button type="button"
              class="unique-btn ${on ? "active" : ""}"
              data-uvalpick="${v}" data-value="${v}">
        ${v}
      </button>
      <div class="unique-desc" data-kind="${kind}" data-value="${v}"></div>
    </div>
  `;
        }).join("");
      }

      const modal = document.getElementById("mUniquePickModal");
      if (modal) {
        modal.dataset.utarget = targetKey;

        // ✅ 추가: PC처럼 unique-desc 실제 텍스트 채우기
        updateUniqueEffectDescriptionsMobile(modal);
      }

      _openModalById_("mUniquePickModal");
    }

    function bindUniquePickModalOnce() {
      const modal = document.getElementById("mUniquePickModal");
      if (!modal || modal.dataset.bound === "1") return;
      modal.dataset.bound = "1";

      modal.addEventListener("click", (e) => {
        // 1) 버튼 클릭이면 그대로
        let btn = e.target.closest("[data-uvalpick]");

        // 2) 버튼이 아니면(= 설명칸 클릭 등) 같은 row의 버튼을 찾아서 대신 선택 처리
        if (!btn) {
          const desc = e.target.closest(".unique-desc");
          if (desc) {
            const row = desc.closest(".unique-row");
            btn = row ? row.querySelector("[data-uvalpick]") : null;
          }
        }

        if (!btn) return;

        ensureCustomSkillsMobile();
        const v = btn.getAttribute("data-uvalpick") || "";
        const targetKey = modal.dataset.utarget;

        if (targetKey) {
          state.customSkills[targetKey] = v;
          syncUniqueMiniLabels();

          // ✅ PC처럼 "선택됨"을 버튼 자체(active)에 부여
          modal.querySelectorAll(".unique-btn.active").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");

          // (선택 강조가 row 기반인 CSS도 같이 쓰는 중이라면 row도 동기화)
          modal.querySelectorAll(".unique-row.is-selected").forEach(r => r.classList.remove("is-selected"));
          const row = btn.closest(".unique-row");
          if (row) row.classList.add("is-selected");
        }

        _closeModalById_("mUniquePickModal");
      });
      // 닫기
      modal.querySelectorAll("[data-mset-close]").forEach(el => {
        el.addEventListener("click", () => _closeModalById_("mUniquePickModal"));
      });
    }

    // ✅ 고유효과 "일괄 적용" 모달: 선택(무기/기타) 바인딩 + 현재 state 반영
    function bindUniqueBulkModalOnce() {
      const modal = document.getElementById('mUniqueBulkModal');
      if (!modal || modal.dataset.bound === "1") return;
      modal.dataset.bound = "1";

      // 버튼/설명 어디를 눌러도 "row" 기준으로 선택되게 + hover 강조를 is-selected로 고정
      modal.addEventListener('click', (e) => {
        const row = e.target.closest('.unique-row');
        if (!row || !modal.contains(row)) return;

        const btn = row.querySelector('.unique-btn');
        const desc = row.querySelector('.unique-desc');
        const kind = desc?.dataset?.kind; // "weapon" | "other"
        if (!btn || !kind) return;

        const val = btn.getAttribute('data-value') || btn.textContent.trim();

        // 같은 kind 내에서 active + is-selected를 "현재 row"로만 고정
        modal.querySelectorAll(`.unique-desc[data-kind="${kind}"]`).forEach(d => {
          const r = d.closest('.unique-row');
          const b = r?.querySelector('.unique-btn');
          const on = (r === row);
          if (b) b.classList.toggle('active', on);
          if (r) r.classList.toggle('is-selected', on);
        });

        // 선택값 저장
        modal.dataset[`sel_${kind}`] = val;
      });

      // 닫기 버튼들
      modal.querySelectorAll('[data-mset-close]').forEach(el => {
        el.addEventListener('click', () => _closeModalById_('mUniqueBulkModal'));
      });
    }

    function syncUniqueBulkModalSelectionFromState() {
      const modal = document.getElementById('mUniqueBulkModal');
      if (!modal) return;

      ensureCustomSkillsMobile();

      // 현재 state를 모달 선택값으로 주입
      const weaponPick = (state.customSkills.weaponType ?? '');
      const otherPick =
        (state.customSkills.armorType || state.customSkills.braceletType || state.customSkills.earringType || '');

      if (weaponPick) modal.dataset.sel_weapon = weaponPick;
      if (otherPick) modal.dataset.sel_other = otherPick;

      // UI active + is-selected 표시(weapon/other만)
      ["weapon", "other"].forEach(kind => {
        const v = modal.dataset[`sel_${kind}`] ?? '';
        modal.querySelectorAll(`.unique-desc[data-kind="${kind}"]`).forEach(desc => {
          const row = desc.closest('.unique-row');
          const btn = row?.querySelector('.unique-btn');
          const val = btn?.getAttribute('data-value') || btn?.textContent?.trim() || '';
          const on = (v !== '' && v === val);

          if (btn) btn.classList.toggle('active', on);
          if (row) row.classList.toggle('is-selected', on);
        });
      });
    }

    /* =========================
       ✅ 익시드/에픽 토글 상태 (Mobile)
    ========================= */
    let armorSetMode = 'exceed'; // 'exceed' | 'epic'

    function updateArmorSetToggleUI_mobile() {
      const ids = ['mArmorSetToggle', 'mAccSetToggle', 'mSpecSetToggle'];
      ids.forEach((id) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.classList.toggle('mode-exceed', armorSetMode === 'exceed');
        el.classList.toggle('mode-epic', armorSetMode === 'epic');
      });
    }

    function setArmorSetMode_mobile(nextMode) {
      armorSetMode = (nextMode === 'epic') ? 'epic' : 'exceed';
      updateArmorSetToggleUI_mobile();

      // ✅ 열려있는 세트 모달이면 즉시 재렌더(익시드/에픽 반영)
      const armorOpen = document.getElementById('mArmorSetModal')?.getAttribute('aria-hidden') === 'false';
      const accOpen = document.getElementById('mAccSetModal')?.getAttribute('aria-hidden') === 'false';
      const specOpen = document.getElementById('mSpecSetModal')?.getAttribute('aria-hidden') === 'false';

      if (armorOpen) renderSetModal_mobile('armor');
      else if (accOpen) renderSetModal_mobile('acc');
      else if (specOpen) renderSetModal_mobile('spec');
    }

    function bindArmorSetTogglesOnce_mobile() {
      const ids = ['mArmorSetToggle', 'mAccSetToggle', 'mSpecSetToggle'];

      ids.forEach((id) => {
        const el = document.getElementById(id);
        if (!el || el.__bound) return;
        el.__bound = 1;

        const toggle = () => {
          setArmorSetMode_mobile(armorSetMode === 'exceed' ? 'epic' : 'exceed');
        };

        el.addEventListener('click', toggle);
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggle();
          }
        });
      });

      updateArmorSetToggleUI_mobile();
    }

    function renderSetModal_mobile(kind) {
      if (typeof updateArmorSetToggleUI_mobile === 'function') updateArmorSetToggleUI_mobile();

      let sets = [];
      let modalId = '';
      let listId = '';

      if (kind === 'armor') {
        modalId = 'mArmorSetModal';
        listId = 'mArmorSetList';
        sets = (typeof buildArmorSetCardsFromSheets === 'function') ? buildArmorSetCardsFromSheets() : [];
      } else if (kind === 'acc') {
        modalId = 'mAccSetModal';
        listId = 'mAccSetList';
        sets = (typeof buildAccSetCardsFromSheets === 'function') ? buildAccSetCardsFromSheets() : [];
      } else if (kind === 'spec') {
        modalId = 'mSpecSetModal';
        listId = 'mSpecSetList';
        sets = (typeof buildSpecSetCardsFromSheets === 'function') ? buildSpecSetCardsFromSheets() : [];
      }

      const box = document.getElementById(listId);
      if (!box) return;

      box.innerHTML = '';

      if (!Array.isArray(sets) || !sets.length) {
        box.innerHTML =
          '<div class="empty-hint" style="padding:16px;font-size:13px;color:#ddd;">세트 데이터를 찾을 수 없습니다.</div>';
        _openModalById_(modalId);
        return;
      }

      const applyAndClose = (s) => {
        applySetPieces_mobile(s);
        _closeModalById_(modalId);
        if (typeof toast === 'function') toast('세트가 적용되었습니다.');
      };

      sets.forEach((s, idx) => {
        // (PC 느낌) 첫 줄 3번째 칸 맞추기용 스페이서
        if (idx === 2) {
          const spacer = document.createElement('div');
          spacer.className = 'armor-set-spacer';
          box.appendChild(spacer);
        }

        const card = document.createElement('div');
        card.className = 'armor-set-card';

        // header
        const header = document.createElement('div');
        header.className = 'armor-set-header';

        const titleSpan = document.createElement('span');
        titleSpan.textContent = s?.name || '(세트)';
        header.appendChild(titleSpan);

        const applyBtn = document.createElement('button');
        applyBtn.type = 'button';
        applyBtn.className = 'set-auto-toggle';
        applyBtn.textContent = '이 세트 적용';
        applyBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          applyAndClose(s);
        });
        header.appendChild(applyBtn);

        card.appendChild(header);

        // items
        const items = document.createElement('div');
        items.className = 'armor-set-items';

        (s.pieces || []).forEach((p) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'armor-set-item';
          btn.title = p?.item?.name || p?.name || '';

          // ✅ 아이콘/레벨을 눌러도 "세트 적용"되도록
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            applyAndClose(s);
          });

          const box2 = document.createElement('div');
          box2.className = 'iconbox';

          const img = document.createElement('img');
          img.className = 'icon';
          img.src = p?.img || p?.item?.img || (typeof PLACEHOLDER_I !== 'undefined' ? PLACEHOLDER_I : '');
          img.alt = '';
          box2.appendChild(img);

          const lv = p?.level ?? p?.item?.level ?? null;
          if (lv) {
            const badge = document.createElement('div');
            badge.className = 'badge-lv';
            badge.textContent = String(lv);
            box2.appendChild(badge);
          }

          btn.appendChild(box2);
          items.appendChild(btn);
        });

        card.appendChild(items);
        box.appendChild(card);
      });

      _openModalById_(modalId);
    }


    function wireSetButtons_mobile() {
      const a = document.getElementById('btnMSetArmor');
      const b = document.getElementById('btnMSetAcc');
      const c = document.getElementById('btnMSetSpec');
      const d = document.getElementById('btnMUniqueBulk');

      if (a && !a.__bound) { a.__bound = 1; a.addEventListener('click', () => renderSetModal_mobile('armor')); }
      if (b && !b.__bound) { b.__bound = 1; b.addEventListener('click', () => renderSetModal_mobile('acc')); }
      if (c && !c.__bound) { c.__bound = 1; c.addEventListener('click', () => renderSetModal_mobile('spec')); }

      if (d && !d.__bound) {
        d.__bound = 1;
        d.addEventListener('click', () => {
          const modal = document.getElementById('mUniqueBulkModal');

          // ✅ 1) 바인딩 보장
          bindUniqueBulkModalOnce();

          // ✅ 2) PC처럼 설명 텍스트 채우기
          if (modal) updateUniqueEffectDescriptionsMobile(modal);

          // ✅ 3) 현재 state 선택값을 모달 active 표시로 동기화
          syncUniqueBulkModalSelectionFromState();

          _openModalById_('mUniqueBulkModal');
        });
      }



      const applyBtn = document.getElementById('mUniqueBulkApplyBtn');
      if (applyBtn && !applyBtn.__bound) {
        applyBtn.__bound = 1;
        applyBtn.addEventListener('click', () => {
          const modal = document.getElementById('mUniqueBulkModal');
          if (!modal) return;

          ensureCustomSkillsMobile();

          // 모달에서 고른 값(없으면 기존 state 유지)
          const pickWeapon = (modal.dataset.sel_weapon ?? state.customSkills.weaponType ?? '');
          const pickOther =
            (modal.dataset.sel_other ??
              state.customSkills.armorType ??
              state.customSkills.braceletType ??
              state.customSkills.earringType ??
              '');

          // ✅ 실제 적용 (모바일 state 구조)
          state.customSkills.weaponType = pickWeapon;
          state.customSkills.armorType = pickOther;
          state.customSkills.braceletType = pickOther;
          state.customSkills.earringType = pickOther;

          // 소제목 옆 mini 라벨 갱신
          syncUniqueMiniLabels();

          if (typeof toast === 'function') toast('고유효과가 적용되었습니다.');
          _closeModalById_('mUniqueBulkModal');
        });
      }
        // ✅ 여기 1줄 추가
  bindArmorSetTogglesOnce_mobile();
    }

    /* ✅ page init / DOMContentLoaded / resetAll() 이후 한 번 호출 */
    wireSetButtons_mobile();
    syncUniqueMiniLabels();



    /* ✅ 개별 고유효과(소제목 옆) 버튼 클릭 */
    document.getElementById('pageEquip')?.addEventListener('click', (e) => {
      const u = e.target?.closest?.('.equip-u-mini');
      if (!u) return;

      e.preventDefault();
      e.stopPropagation();

      const targetKey = u.getAttribute('data-utarget');
      if (!targetKey) return;

      bindUniquePickModalOnce();       // 모달 내부 클릭/닫기 바인딩 보장
      openUniquePickModalMobile(targetKey);
    }, true);


    // ✅ 장비 슬롯 클릭 → 장비 선택
    document.getElementById('pageEquip')?.addEventListener('click', async (e) => {
      const btn = e.target?.closest?.('.equip-row');
      if (!btn) return;

      const slot = btn.getAttribute('data-slot');
      if (!slot) return;

      try {
        await openEquipPicker(slot);
      } catch (err) {
        console.error(err);
        toast('장비 목록을 불러오지 못했습니다.');
      }
    });

    // ✅ 무기 상단 자동 입력 버튼(PC버전 동일 기능 연결)
    document.getElementById('btnWeaponAutoEnh')?.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openAutoEnhModal_mobile();
    });
    document.getElementById('btnWeaponAutoSeal')?.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openAutoSealModal_mobile();
    });
    document.getElementById('btnWeaponAutoEnchant')?.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openAutoEnchantModal_mobile();
    });
    document.getElementById('btnWeaponAutoEmblem')?.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      openAutoEmblemModal_mobile();
    });

    // ===== Main actions (placeholders) =====
    document.getElementById('btnPickChar')?.addEventListener('click', async () => {
      try {
        await openMobileCharacterPicker();
      } catch (e) {
        console.error(e);
        toast('캐릭터 목록을 불러오지 못했습니다.');
      }
    });

    document.getElementById('btnContactSend')?.addEventListener('click', () => {
      toast('문의 전송(apiJSON contact_admin)은 다음 단계에서 연결합니다.');
    });

    // ============================================================
    // ✅ PC판과 동일한 calc_all payload 구성 (모바일 스냅샷 → 백코드 세션 반영)
    // - 장비: state.selections
    // - 강화: state.enh
    // - 고유옵션/일반옵션: state.seals.unique / state.seals.general1  (PC의 seals 구조 유지)
    // - 마법부여: state.enchants
    // - 엠블렘: state.emblems
    // ============================================================
    async function saveSkillSelectionsMobile() {
      const s = window.state || {};

      // 1) ownerKey 계산 (PC와 동일 로직)
      let ownerKey = '';
      if (s.currentCharacter) {
        const jg = String(s.currentCharacter.jobGroupLabel || s.currentCharacter.jobGroup || '').trim();
        const nm = String(s.currentCharacter.name || s.currentCharacter.charName || '').trim();
        if (jg || nm) ownerKey = (jg + nm).replace(/\s+/g, '');
      }
      if (!ownerKey) ownerKey = String(s.CurrentSumStats?.ownerKey || s.ownerKey || '').trim();
      if (!ownerKey) throw new Error('missing_owner');

      // state에도 캐시(다음 호출들에서 재사용)
      s.ownerKey = ownerKey;

      // 2) 모바일 skillTrees -> skills 배열로 변환 (PC가 보내는 형태)
      // Page4와 동일하게 "ownerKey(=charKey)"로 읽어야 한다
      const charKey = String(s.currentCharacter?.ownerKey || ownerKey || '').trim().replace(/\s+/g, '');
      const tree = (s.skillTrees && charKey && s.skillTrees[charKey]) ? s.skillTrees[charKey] : {};

      const skills = [];
      for (const [name, v] of Object.entries(tree)) {
        const lv = Number(v?.spLv ?? 0);
        const tp = Number(v?.tpLv ?? 0);
        // lv/tp 둘 중 하나라도 있으면 보내기 (tp만 찍는 케이스 방어)
        if (lv > 0 || tp > 0) skills.push({ name, lv, tp });
      }

      // ✅ 핵심: byName이 아니라 skills 배열로 보낸다 (PC 동일)
      const res = await apiJSON('skill_state_set', { ownerKey, skills });
      if (!res?.ok) throw new Error(res?.message || res?.error || 'skill_state_set_failed');
      return res;
    }


    async function simulateSkillUsageMobile() {
      const s = window.state || {};

      // ownerKey 확보 (saveSkillSelectionsMobile에서 캐시된 값 우선)
      let ownerKey = String(s.ownerKey || s.CurrentSumStats?.ownerKey || '').trim();
      if (!ownerKey && s.currentCharacter) {
        const jg = String(s.currentCharacter.jobGroupLabel || s.currentCharacter.jobGroup || '').trim();
        const nm = String(s.currentCharacter.name || s.currentCharacter.charName || '').trim();
        ownerKey = (jg + nm).replace(/\s+/g, '');
      }
      if (!ownerKey) throw new Error('missing_owner');

      const timeKey = String(s.timeKey || '180');

      const res = await apiJSON('skill_uses', {
        ownerKey,
        window: timeKey,
        wantDbg: false,
      });

      if (!res?.ok) throw new Error(res?.message || res?.error || 'skill_uses_failed');
      return res;
    }



    function buildCalcAllPayloadMobile() {
      const s = window.state || {};
      const c = s.currentCharacter || {};

      const charPayload = {
        name: String(c.name || c.charName || '').trim(),
        jobGroup: String(c.jobGroup || c.jobGroupLabel || '').trim(),
        sp: Number(c.sp ?? 0) || 0,
        tp: Number(c.tp ?? 0) || 0,
        power: String(c.power ?? '').trim(),
      };

      // 최소 유효성(백엔드 calc_all 에서 missing_char 체크)
      if (!charPayload.name || !charPayload.jobGroup) {
        throw new Error('missing_char');
      }

      // 1) equip
      const equipPayload = {};
      const sel = s.selections || {};
      for (const [slotKey, info] of Object.entries(sel)) {
        const name = String(info?.name || '').trim();
        if (!name) continue;
        equipPayload[slotKey] = {
          name,
          code: info?.code || '',
        };
      }

      // 2) enh
      const enhPayload = {};
      const enh = s.enh || {};
      for (const [slotKey, up] of Object.entries(enh)) {
        const name = String(up?.name || '').trim();
        if (!name) continue;
        enhPayload[slotKey] = {
          name,
          type: up?.type || '',
          level: up?.level ?? null,
        };
      }

      // 3) seals (모바일: 고유옵션/일반옵션 → PC: unique/general1)
      const sealPayload = {};
      const seals = s.seals || {};
      for (const [slotKey, sv] of Object.entries(seals)) {
        if (!sv) continue;
        const uniqueName = String(sv.unique?.name || sv.unique || '').trim();
        const general1Name = String(sv.general1?.name || sv.general1 || '').trim();
        if (!uniqueName && !general1Name) continue;
        sealPayload[slotKey] = {
          unique: uniqueName || null,
          general1: general1Name || null,
        };
      }

      // 4) enchants
      const enchantPayload = {};
      const enchants = s.enchants || {};
      for (const [slotKey, eInfo] of Object.entries(enchants)) {
        const name = String(eInfo?.name || '').trim();
        if (!name) continue;
        enchantPayload[slotKey] = {
          name,
          enchType: eInfo?.typeKey || eInfo?.enchType || '',
        };
      }

      // 5) emblems
      const emblemPayload = {};
      const emState = s.emblems || {};
      for (const [slotKey, arr] of Object.entries(emState)) {
        if (!Array.isArray(arr)) continue;
        const mapped = arr.map(e => {
          const name = String(e?.name || '').trim();
          if (!name) return null;
          return {
            name,
            levelVal: e?.levelVal,
            type: e?.type,
          };
        });
        if (mapped.some(x => x)) emblemPayload[slotKey] = mapped;
      }

      // 6) refines(연마) - 모바일이 이미 쓰고 있으면 그대로 전송
      const refinePayload = {};
      const refState = s.refines || {};
      for (const [slotKey, info] of Object.entries(refState)) {
        const name = String(info?.name || '').trim();
        if (!name) continue;
        refinePayload[slotKey] = {
          name,
          refineType: info?.refineType || '',
        };
      }

      // 최종 payload (PC 방식 그대로)
      const payload = { char: charPayload };
      if (Object.keys(equipPayload).length) payload.equip = equipPayload;
      if (Object.keys(enhPayload).length) payload.enh = enhPayload;
      if (Object.keys(sealPayload).length) payload.seals = sealPayload;
      if (Object.keys(enchantPayload).length) payload.enchants = enchantPayload;
      if (Object.keys(emblemPayload).length) payload.emblems = emblemPayload;
      if (Object.keys(refinePayload).length) payload.refines = refinePayload;

      // ✅ 7) Page3 옵션들(아바타/무기압, 시간/몬스터, 룬각인, 성안의 봉인, 스킬룬)
      const s3 = window.state || {};

      // 아바타 / 무기압
      if (s3.avatarSel && (s3.avatarSel.avatarName || s3.avatarSel.imprintName)) {
        payload.avatar = {
          avatarName: String(s3.avatarSel.avatarName || '').trim(),
          imprintName: String(s3.avatarSel.imprintName || '').trim(),
        };
      }

      // 시간 기준 / 몬스터
      if (s3.timeKey) payload.window = String(s3.timeKey || '').trim();      // 예: '1m'
      if (s3.monsterName) payload.monsterName = String(s3.monsterName || '').trim();

      // 룬 각인
      if (s3.runeEngrave && typeof s3.runeEngrave === 'object') {
        // 너 state 구조가 {type:'룬각인', name:'', level:''}라면 그대로 전달
        if (s3.runeEngrave.name && s3.runeEngrave.level) {
          payload.runeEngrave = {
            type: '룬각인',
            name: String(s3.runeEngrave.name || '').trim(),
            level: String(s3.runeEngrave.level || '').trim(),
          };
        }
      }

      // 성안의 봉인
      if (s3.castleSeal && typeof s3.castleSeal === 'object') {
        if (s3.castleSeal.mainName || s3.castleSeal.subName) {
          payload.castleSeal = {
            mainName: String(s3.castleSeal.mainName || '').trim(),
            subName: String(s3.castleSeal.subName || '').trim(),
          };
        }
      }

      // ✅ 고유효과(커스텀옵) - PC처럼 calc_all payload에 실어 보내야 서버 세션에 반영됨
      // (state.customSkills 구조는 너가 모달에서 이미 채우고 있는 그대로 전달)
      if (s.customSkills && typeof s.customSkills === 'object') {
        // structuredClone이 없을 수 있으니 안전하게 처리
        const cs = (typeof structuredClone === 'function')
          ? structuredClone(s.customSkills)
          : JSON.parse(JSON.stringify(s.customSkills));

        // ✅ 핵심: 모바일은 weaponType에 저장하지만,
        // 백엔드는 (customType/type/kind) 중 하나로 무기 고유효과를 읽는다.
        const hasBackendWeaponKey =
          (typeof cs.customType === 'string' && cs.customType.trim()) ||
          (typeof cs.type === 'string' && cs.type.trim()) ||
          (typeof cs.kind === 'string' && cs.kind.trim());

        if (!hasBackendWeaponKey && typeof cs.weaponType === 'string') {
          cs.type = cs.weaponType;   // ← 이 1줄이 무기 고유효과 적용의 핵심
        }

        payload.customSkills = cs;
      }


      // 스킬룬 (나중에 모달 붙이면 state에 채워질 구조 그대로 전달)
      if (s3.runes && typeof s3.runes === 'object') {
        payload.runes = s3.runes;
      }
      if (s3.specialRunes && typeof s3.specialRunes === 'object') {
        payload.specialRunes = {
          gaho: Number(s3.specialRunes.gaho || 0),
          jihe: Number(s3.specialRunes.jihe || 0),
          waegok: Number(s3.specialRunes.waegok || 0),
        };
      }

      return payload;
    }

    // (디버그) 현재 스냅샷을 콘솔에서 바로 확인하고 싶을 때
    window.__buildCalcAllPayloadMobile = buildCalcAllPayloadMobile;

    document.getElementById('btnMobileCompute')?.addEventListener('click', async () => {
      try {
        // 0) payload 구성
        const payload = buildCalcAllPayloadMobile();
        window.state = window.state || {};
        window.state.lastCalcAllPayload = payload;

        // 1) 장비/옵션/아바타/룬각인/시간기준/몬스터 등 세션 반영
        const resCalc = await apiJSON('calc_all', { payload, p: null });
        if (!resCalc?.ok) throw new Error(resCalc?.message || resCalc?.error || 'calc_all_failed');

        // 2) (선택) sum_stats로 세션 정리/확인
        const sum = await apiJSON('sum_stats', { wantDbg: false });
        if (!sum?.ok) console.warn('[MOBILE sum_stats fail]', sum);

        if (sum?.ok) window.state.CurrentSumStats = sum.sum;   // ★ PC와 동일하게 sum만 저장

        // 3) ✅ 스킬 상태 저장 (skill_state_set)
        await saveSkillSelectionsMobile();

        // 4) ✅ 스킬 사용횟수 시뮬레이션 (skill_uses)
        const uses = await simulateSkillUsageMobile();
        window.state.lastSkillUses = uses;

        // 5) ✅ 최종 compute
        const s = window.state || {};
        const timeKey = String(s.timeKey || '180');
        const monster = s.monster || (s.monsterName ? { name: s.monsterName } : null);

        const resCompute = await apiJSON('compute', {
          p: null,
          window: timeKey,
          monster,
        });

        if (!resCompute?.ok) throw new Error(resCompute?.message || resCompute?.error || 'compute_failed');

        const total = Number(resCompute.total || 0);
        document.getElementById('mobileFinalDamage').textContent = Math.floor(total).toLocaleString();

        toast('계산 완료!');
        console.log('[MOBILE calc_all payload]', payload);
        console.log('[MOBILE skill_uses]', uses);
        console.log('[MOBILE compute]', resCompute);

      } catch (e) {
        console.error(e);
        document.getElementById('mobileFinalDamage').textContent = '-';
        toast('계산 실패: ' + String(e?.message || e || ''));
      }
    });


    /* ===== Auto Input (PC 동일 기능) ===== */

    function _showModal_mobile(id) {
      const m = document.getElementById(id);
      if (!m) return;
      m.classList.add('show');
      m.setAttribute('aria-hidden', 'false');
    }
    function _hideModal_mobile(id) {
      const m = document.getElementById(id);
      if (!m) return;
      m.classList.remove('show');
      m.setAttribute('aria-hidden', 'true');
    }
    function _wireModalClose_mobile(id) {
      const m = document.getElementById(id);
      if (!m || m.__wiredClose) return;
      m.__wiredClose = true;
      m.addEventListener('click', (e) => {
        const t = e.target;
        if (t && (t.matches('[data-close]') || t.closest?.('[data-close]'))) {
          e.preventDefault();
          _hideModal_mobile(id);
        }
      });
    }

    function openAutoEnhModal_mobile() {
      _wireModalClose_mobile('autoEnhModal');
      _buildAutoEnhButtons_mobile();
      _showModal_mobile('autoEnhModal');
    }
    function openAutoSealModal_mobile() {
      _wireModalClose_mobile('autoSealModal');
      _wireAutoSealClicks_mobile();
      _showModal_mobile('autoSealModal');
    }
    function openAutoEnchantModal_mobile() {
      _wireModalClose_mobile('autoEnchantModal');
      renderAutoEnchantChoices_mobile();
      _showModal_mobile('autoEnchantModal');
    }
    function openAutoEmblemModal_mobile() {
      _wireModalClose_mobile('autoEmblemModal');
      renderAutoEmblemChoices_mobile();
      _showModal_mobile('autoEmblemModal');
    }

    /* --- Auto Enhance --- */
    function _buildAutoEnhButtons_mobile() {
      const wrap = document.getElementById('autoEnhList');
      if (!wrap || wrap.__built) return;
      wrap.__built = true;
      wrap.innerHTML = '';
      for (let lv = 12; lv <= 20; lv++) {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'opt-btn';
        b.textContent = `${lv}강`;
        b.addEventListener('click', async () => {
          b.disabled = true;
          try {
            await autoEnhanceApply_mobile(lv);
          } finally {
            b.disabled = false;
          }
          _hideModal_mobile('autoEnhModal');
        });
        wrap.appendChild(b);
      }
    }
    function _findEnhOptByLevel_mobile(typeKey, lv) {
      const list = (window.DBEnh?.byType?.[String(typeKey).trim()] || []);
      if (!list.length) return null;
      const target = Number(lv) || 0;

      // 1) level_num/level 추출
      let hit = list.find(o => Number(o?.level_num ?? o?.level) === target);
      if (hit) return hit;

      // 2) name에 숫자 포함
      const re = new RegExp(`(^|\\D)${target}(\\D|$)`);
      hit = list.find(o => re.test(String(o?.name || '')));
      if (hit) return hit;

      // 3) 마지막 폴백
      return list[list.length - 1] || null;
    }
    async function autoEnhanceApply_mobile(level) {
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      window.state = window.state || {};
      state.enh = state.enh || {};

      const slots = ['weapon', 'headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring', 'sub', 'magestone', 'earring'];

      for (const slot of slots) {
        const typeKey = (typeof _enhTypeForSlot_mobile === 'function') ? _enhTypeForSlot_mobile(slot) : null;
        if (!typeKey) continue;

        const opt = _findEnhOptByLevel_mobile(typeKey, level);
        if (!opt) continue;

        state.enh[slot] = { name: String(opt.name || '').trim(), type: String(opt.type || typeKey).trim(), level: Number(level) || 0 };

        // UI sync
        if (typeof _syncEnhLabelFromState_mobile === 'function') _syncEnhLabelFromState_mobile(slot);
        if (typeof syncEnhTopbarLabel_mobile === 'function') syncEnhTopbarLabel_mobile(slot);
      }
    }

    /* --- Auto Seal (추천 마법봉인) --- */
    const _AUTO_ELEM_KOR = { fire: '화', water: '수', light: '명', dark: '암' };

    function _jobGroupKeyFromState_mobile() {
      const s = window.state || {};
      const p = String(s?.currentCharacter?.power ?? '').trim();

      // PC판과 동일하게 power를 '물리'/'마법'으로 정규화
      if (p === 'mag' || p === '마법' || p === 'magic') return '마법';
      if (p === 'phys' || p === '물리' || p === 'physical') return '물리';

      // 안전장치: base['물마공']도 확인
      const basePM = String(s?.currentCharacter?.base?.['물마공'] ?? '').trim();
      if (basePM === '마법') return '마법';
      if (basePM === '물리') return '물리';

      // 마지막 기본값
      return '물리';
    }
    function _parseJobFlags_mobile(s) {
      const t = String(s ?? '').toLowerCase().replace(/\s+/g, '');
      const phys = /(물리|물공)/.test(t);
      const magic = /(마법|마공)/.test(t);
      const both = phys && magic;
      const common = /공용|모두|all/.test(t);
      return { phys, magic, both, common };
    }
    function _getJobGroupText_mobile(it) {
      return String(
        it?._raw?.jobGroup ??
        it?._raw?.['직업군'] ??
        it?.raw?.jobGroup ??
        it?.raw?.['직업군'] ??
        it?.jobGroup ?? ''
      ).trim();
    }

    function findSealOption_mobile(typeKey, { jobKey, elemKor }) {
      const key = String(typeKey || '').trim();
      if (!key) return null;

      let list = (window.DBEnh?.byType?.[key] || []).slice();
      if (!list.length && Array.isArray(window.DBEnh?.list)) {
        list = window.DBEnh.list.filter(o => String(o?.type || '').trim() === key);
      }
      if (!list.length) return null;

      const isAcc = key.startsWith('악세');
      if (isAcc) {
        // ✅ 악세는 속성(화/수/명/암) "정확히 일치"로 찾는 게 맞음
        for (const it of list) {
          const v = _getJobGroupText_mobile(it);
          if (v === String(elemKor || '').trim()) return it;
        }
        return null;
      }

      // ✅ 비악세(무기/방어/보장): PC판과 동일하게 "물리/마법/공용" 포함 규칙
      const wantPhys = jobKey === '물리';
      const wantMagic = jobKey === '마법';

      // 1) 우선: 물리/마법(또는 물리마법) 포함
      for (const it of list) {
        const v = _getJobGroupText_mobile(it);
        const f = _parseJobFlags_mobile(v);
        if (wantPhys && (f.phys || f.both)) return it;
        if (wantMagic && (f.magic || f.both)) return it;
      }

      // 2) 다음: 공용
      for (const it of list) {
        const v = _getJobGroupText_mobile(it);
        if (_parseJobFlags_mobile(v).common) return it;
      }

      // 3) 마지막: 직업군 미표기(빈칸)
      for (const it of list) {
        const v = _getJobGroupText_mobile(it);
        if (!v) return it;
      }

      return null;
    }

    async function applyAutoSeal_mobile(elementKey) {
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const elemKor = _AUTO_ELEM_KOR[elementKey] || '';
      const jobKey = _jobGroupKeyFromState_mobile();

      window.state = window.state || {};
      state.seals = state.seals || {};

      const slots = ['weapon', 'headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring', 'sub', 'magestone', 'earring'];

      for (const slot of slots) {
        const types = (typeof _sealTypeKeysForSlot_mobile === 'function') ? _sealTypeKeysForSlot_mobile(slot) : null;
        if (!types) continue;

        const pickU = findSealOption_mobile(types.u, { jobKey, elemKor });
        const pickG = findSealOption_mobile(types.g, { jobKey, elemKor });
        if (!pickU || !pickG) continue;

        state.seals[slot] = {
          unique: { name: String(pickU.name || '').trim(), typeKey: String(pickU.type || types.u).trim() },
          general1: { name: String(pickG.name || '').trim(), typeKey: String(pickG.type || types.g).trim() },
        };

        if (typeof _syncSealLabelFromState_mobile === 'function') _syncSealLabelFromState_mobile(slot);
        if (typeof syncSealTopbarLabel_mobile === 'function') syncSealTopbarLabel_mobile(slot);
      }

      _hideModal_mobile('autoSealModal');
    }

    function _wireAutoSealClicks_mobile() {
      const m = document.getElementById('autoSealModal');
      if (!m || m.__wiredSeal) return;
      m.__wiredSeal = true;
      m.querySelectorAll('[data-ele]').forEach(btn => {
        btn.addEventListener('click', () => {
          const k = String(btn.dataset.ele || '').trim();
          if (!k) return;
          applyAutoSeal_mobile(k);
        });
      });
    }

    /* --- Auto Enchant --- */
    const autoEnchantState_mobile = { attr: null, tier: null };

    function _updateAutoEnchantConfirmBtn_mobile() {
      const btn = document.getElementById('autoEnchantConfirmBtn');
      if (!btn) return;
      const ready = !!(autoEnchantState_mobile.attr && autoEnchantState_mobile.tier);
      btn.disabled = !ready;
    }

    function _bindAutoEnchantConfirmBtn_mobile() {
      const btn = document.getElementById('autoEnchantConfirmBtn');
      if (!btn || btn.__bound) return;
      btn.__bound = true;

      btn.addEventListener('click', async () => {
        if (!(autoEnchantState_mobile.attr && autoEnchantState_mobile.tier)) return;

        btn.disabled = true;
        try {
          await applyAutoEnchant_mobile(autoEnchantState_mobile.attr, autoEnchantState_mobile.tier);
          _hideModal_mobile('autoEnchantModal'); // ✅ 확인 누를 때만 닫힘
        } catch (e) {
          console.error(e);
          toast('추천 마법부여 자동 입력 실패');
        } finally {
          _updateAutoEnchantConfirmBtn_mobile();
        }
      });
    }

    function _updateAutoEmblemConfirmBtn_mobile() {
      const btn = document.getElementById('autoEmblemConfirmBtn');
      if (!btn) return;
      const ready = !!(autoEmblemState_mobile.attr && autoEmblemState_mobile.stage);
      btn.disabled = !ready;
    }

    function _bindAutoEmblemConfirmBtn_mobile() {
      const btn = document.getElementById('autoEmblemConfirmBtn');
      if (!btn || btn.__bound) return;
      btn.__bound = true;

      btn.addEventListener('click', async () => {
        if (!(autoEmblemState_mobile.attr && autoEmblemState_mobile.stage)) return;

        btn.disabled = true;
        try {
          await autoEmblemApply_mobile(autoEmblemState_mobile.attr, autoEmblemState_mobile.stage);
          _hideModal_mobile('autoEmblemModal'); // ✅ 확인 누를 때만 닫힘
        } catch (e) {
          console.error(e);
          toast('엠블렘 자동 입력 실패');
        } finally {
          _updateAutoEmblemConfirmBtn_mobile();
        }
      });
    }

    function _normTier_mobile(t) {
      const s = String(t || '').replace(/\s+/g, '').trim();
      if (!s) return '종결';
      if (s.includes('준')) return '준결';
      if (s.includes('종결')) return '종결';
      if (s.includes('보통')) return '보통';
      if (s.includes('가성비')) return '가성비';
      return s;
    }
    function _findEnchant_mobile(typeKey, keyword) {
      const list = (window.DBEnh?.byType?.[String(typeKey).trim()] || []);
      const kw = String(keyword || '').trim();
      if (!list.length || !kw) return null;
      const N = (v) => String(v ?? '').replace(/\s+|-/g, '').replace(/[()]/g, '').trim();
      const kwN = N(kw);

      const getJobGroupText = (o) => {
        return String(o?._raw?.jobGroup ?? o?._raw?.['직업군'] ?? o?._raw?.['조건'] ?? o?.raw?.jobGroup ?? o?.jobGroup ?? '').trim();
      };

      let hit = list.find(o => N(getJobGroupText(o)).includes(kwN));
      if (hit) return hit;

      hit = list.find(o => N(String(o?.name || '')).includes(kwN));
      return hit || null;
    }

    async function applyAutoEnchant_mobile(attrPicked, tierPicked) {
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const attr = String(attrPicked || '').trim(); // '화속성'
      const tier = _normTier_mobile(tierPicked);

      window.state = window.state || {};
      state.enchants = state.enchants || {};

      const targets = [
        { slot: 'weapon', needAttr: true },
        { slot: 'bracelet', needAttr: true },
        { slot: 'necklace', needAttr: true },
        { slot: 'ring', needAttr: true },
        { slot: 'headshoulder', needAttr: false },
        { slot: 'top', needAttr: false },
        { slot: 'bottom', needAttr: false },
        { slot: 'belt', needAttr: false },
        { slot: 'shoes', needAttr: false },
        { slot: 'sub', needAttr: false },
        { slot: 'magestone', needAttr: false },
        { slot: 'earring', needAttr: false },
      ];

      for (const t of targets) {
        const slot = t.slot;
        const typeKey = (typeof _enchantTypeForSlot_mobile === 'function') ? _enchantTypeForSlot_mobile(slot) : '';
        if (!typeKey) continue;

        let pick = null;
        if (t.needAttr) {
          const attrFull = attr;                         // '화속성'
          const attrShort = attrFull.replace('속성', ''); // '화'

          const keywords = [
            attrFull + tier,
            attrShort + tier,
            attrFull + (tier === '준종결' ? '준결' : tier),
            attrShort + (tier === '준종결' ? '준결' : tier),
          ];
          for (const kw of keywords) {
            if (!kw) continue;
            pick = _findEnchant_mobile(typeKey, kw);
            if (pick) break;
          }
        } else {
          pick = _findEnchant_mobile(typeKey, tier);
        }
        if (!pick) continue;

        state.enchants[slot] = { name: String(pick.name || '').trim(), typeKey: String(typeKey).trim(), raw: pick._raw || null };

        if (typeof _syncEnchantLabelFromState_mobile === 'function') _syncEnchantLabelFromState_mobile(slot);
        if (typeof syncEnchantTopbarLabel_mobile === 'function') syncEnchantTopbarLabel_mobile(slot);
      }

      _hideModal_mobile('autoEnchantModal');
    }

    function renderAutoEnchantChoices_mobile() {
      const m = document.getElementById('autoEnchantModal');
      if (!m) return;
      const wrapAttrs = m.querySelector('.lists.attrs');
      const wrapTiers = m.querySelector('.lists.tiers');
      if (!wrapAttrs || !wrapTiers) return;

      wrapAttrs.innerHTML = '';
      wrapTiers.innerHTML = '';

      const makeBtn = (txt, group) => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'opt-btn';
        b.textContent = txt;

        // '준종결' 버튼은 내부값 '준결'로 들고다님(PC 동일)
        let internalVal = txt;
        if (group === 'tier') {
          internalVal = (txt.includes('준')) ? '준결' : txt;
          b.dataset.value = internalVal;
        }

        b.addEventListener('click', () => {
          if (group === 'attr') autoEnchantState_mobile.attr = txt;
          else autoEnchantState_mobile.tier = internalVal;

          renderAutoEnchantChoices_mobile();
          _updateAutoEnchantConfirmBtn_mobile(); // ✅ 선택만 반영, 적용은 확인 버튼에서

        });

        // active
        if (group === 'attr' && autoEnchantState_mobile.attr === txt) b.classList.add('active');
        if (group === 'tier' && autoEnchantState_mobile.tier === internalVal) b.classList.add('active');
        return b;
      };

      ['화속성', '수속성', '명속성', '암속성'].forEach(a => wrapAttrs.appendChild(makeBtn(a, 'attr')));
      ['종결', '준종결', '보통', '가성비'].forEach(t => wrapTiers.appendChild(makeBtn(t, 'tier')));
      _updateAutoEnchantConfirmBtn_mobile();
      _bindAutoEnchantConfirmBtn_mobile();
    }

    /* --- Auto Emblem --- */
    const autoEmblemState_mobile = { attr: null, stage: null };

    function pickEmblemByTypeAndStage_mobile(typeKey, stageNum) {
      const list = (window.DBEnh?.byType?.[String(typeKey).trim()] || []);
      if (!list.length) return null;
      const st = Number(stageNum) || 0;
      // stage는 이름(예: '15단계')로 들어오므로 level_num이 있으면 우선, 없으면 name에서 파싱
      const parseStage = (o) => {
        const n = Number(o?.level_num);
        if (Number.isFinite(n) && n > 0) return n;
        const m = String(o?.name || '').match(/(\d+)\s*단/);
        return m ? Number(m[1]) : 0;
      };
      let hit = list.find(o => parseStage(o) === st);
      if (hit) return hit;
      // 폴백: stage 이하 중 가장 큰 것
      const sorted = list.slice().sort((a, b) => parseStage(a) - parseStage(b));
      for (let i = sorted.length - 1; i >= 0; i--) {
        if (parseStage(sorted[i]) <= st) return sorted[i];
      }
      return sorted[sorted.length - 1] || null;
    }

    function pickPlatForAttr_mobile(attrKey, stageNum) {
      const arr = (window.DBEnh?.byType?.['플래티넘엠블렘'] || []);
      if (!arr.length) return null;

      const normMap = {
        fire: '화',
        water: '수',
        light: '명',
        dark: '암',
        all: '모속',
        str: '힘',
        int: '지능',
      };

      const normAttr = normMap[String(attrKey || '').trim()] || String(attrKey || '').trim();
      const st = Number(stageNum) || 0;

      // ✅ PC와 동일: levelVal + level_num “정확히 일치” 매칭
      const hit = arr.find(r =>
        String(r?.levelVal ?? '').trim() === normAttr &&
        Number(r?.level_num ?? 0) === st
      );

      // ✅ fallback 제거: 매칭 실패면 null (랜덤/고정값 방지)
      return hit || null;
    }


    async function autoEmblemApply_mobile(attrKey, stage) {
      // ✅ 1) CORE.lists(=enh:list 등) 로딩 보장 (미로딩 상태에서 byType이 빈 채로 캐시되는 버그 방지)
      if (typeof initMobileAllLightListsOnce === 'function') {
        await initMobileAllLightListsOnce();
      }

      // ✅ 2) byType 재구성 보장
      if (window.DBEnh) DBEnh.__byTypeReady = false;  // (안전장치) 빈 캐시로 굳는 것 방지
      if (typeof _ensureDBEnhByType_mobile === 'function') _ensureDBEnhByType_mobile();

      const stageNum = Number(stage) || 0;

      const slots = ['headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring', 'weapon', 'sub', 'earring', 'magestone'];

      window.state = window.state || {};
      state.emblems = state.emblems || {};

      for (const sk of slots) {
        const RULES =
          (typeof SOCKET_RULES !== 'undefined' && SOCKET_RULES) ? SOCKET_RULES :
            (window.SOCKET_RULES || null);

        const allow = (RULES && RULES[sk]) ? RULES[sk].slice() : [];

        if (!allow.length) continue;

        // PC 동일: 무기는 붉은빛만 자동입력
        const useTypes = (sk === 'weapon') ? ['붉은빛엠블렘'] : allow;

        const cnt = (typeof SOCKET_COUNT === 'function') ? SOCKET_COUNT(sk) : 2;

        for (let i = 0; i < cnt; i++) {
          const typeKey = useTypes[i % useTypes.length];
          let pick = null;

          if (typeKey === '플래티넘엠블렘') {
            pick = pickPlatForAttr_mobile(attrKey, stageNum);
          } else {
            pick = pickEmblemByTypeAndStage_mobile(typeKey, stageNum);
          }
          _ensureEmblemArray_mobile(sk);
          state.emblems[sk][i] = pick ? {
            name: String(pick.name || '').trim(),
            type: String(pick.type || typeKey).trim(),
            img: pick.img,
            level_num: pick.level_num,
            tag: pick.levelVal || pick.tag || '',
          } : null;
        }

        // UI sync (특수장비 텍스트 포함)
        if (typeof syncEquipRowEmblemIcons_mobile === 'function') syncEquipRowEmblemIcons_mobile(sk);
        if (typeof syncEmblemTopbarDots_mobile === 'function') syncEmblemTopbarDots_mobile(sk);
      }
    }

    function renderAutoEmblemChoices_mobile() {
      const m = document.getElementById('autoEmblemModal');
      if (!m) return;
      const wrapAttrs = m.querySelector('.lists.attrs');
      const wrapTiers = m.querySelector('.lists.tiers');
      if (!wrapAttrs || !wrapTiers) return;

      wrapAttrs.innerHTML = '';
      wrapTiers.innerHTML = '';

      const makeBtn = (txt, group) => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'opt-btn';
        b.textContent = txt;

        b.addEventListener('click', () => {
          if (group === 'attr') {
            autoEmblemState_mobile.attr = txt; // fire/water/light/dark
          } else {
            autoEmblemState_mobile.stage = Number(txt) || 0;
          }
          renderAutoEmblemChoices_mobile();

          _updateAutoEmblemConfirmBtn_mobile();
        });

        // active
        if (group === 'attr' && autoEmblemState_mobile.attr === txt) b.classList.add('active');
        if (group === 'stage' && autoEmblemState_mobile.stage === Number(txt)) b.classList.add('active');
        return b;
      };

      // attrs (PC 동일 키)
      const attrs = [
        { key: 'fire', label: '화속성' },
        { key: 'water', label: '수속성' },
        { key: 'light', label: '명속성' },
        { key: 'dark', label: '암속성' },
      ];
      attrs.forEach(a => wrapAttrs.appendChild(makeBtn(a.key, 'attr')).textContent = a.label);

      // stages 5~15
      const makeRow = (from, to) => {
        const row = document.createElement('div');
        row.className = 'grid';
        row.style.gridTemplateColumns = 'repeat(4, 1fr)';
        for (let lv = from; lv <= to; lv++) {
          const b = document.createElement('button');
          b.type = 'button';
          b.className = 'opt-btn';
          b.textContent = `${lv}단계`;
          if (autoEmblemState_mobile.stage === lv) b.classList.add('active');
          b.addEventListener('click', () => {
            autoEmblemState_mobile.stage = lv;
            renderAutoEmblemChoices_mobile();
            _updateAutoEmblemConfirmBtn_mobile();

          });
          row.appendChild(b);
        }
        return row;
      };
      // tiers wrapper uses grid; just append rows
      wrapTiers.appendChild(makeRow(5, 8));
      wrapTiers.appendChild(makeRow(9, 12));
      wrapTiers.appendChild(makeRow(13, 15));
      _updateAutoEmblemConfirmBtn_mobile();
      _bindAutoEmblemConfirmBtn_mobile();

      // active attr highlight: rebuild attr buttons with active class
      // (attrs button rebuild above is a quick build; to keep minimal, we re-render by calling itself once more when state changes)
    }

    /* ===== end auto input ===== */

  </script>

  <!-- ===== Auto Input Modals (PC 동일 기능) ===== -->
  <div id="autoEnhModal" class="modal simple-auto" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEnhTitle">
      <header>
        <h3 id="autoEnhTitle">강화 자동 입력</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body">
        <div class="titles">강화 레벨 선택</div>
        <div id="autoEnhList" class="lists"></div>
      </div>
    </div>
  </div>

  <div id="autoSealModal" class="modal simple-auto" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoSealTitle">
      <header>
        <h3 id="autoSealTitle">추천 마법봉인 자동 입력</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body">
        <div class="titles">속성 선택</div>
        <div class="lists">
          <button type="button" class="opt-btn" data-ele="fire">화속성</button>
          <button type="button" class="opt-btn" data-ele="water">수속성</button>
          <button type="button" class="opt-btn" data-ele="light">명속성</button>
          <button type="button" class="opt-btn" data-ele="dark">암속성</button>
        </div>
      </div>
    </div>
  </div>

  <div id="autoEnchantModal" class="modal simple-auto" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEnchantTitle">
      <header>
        <h3 id="autoEnchantTitle">추천 마법부여 자동 입력</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body two-col">
        <div>
          <div class="titles">속성 선택</div>
          <div class="lists attrs"></div>
        </div>
        <div>
          <div class="titles">추천 티어</div>
          <div class="lists tiers"></div>
        </div>
      </div>
      <!-- ✅ 여기 추가 -->
      <div class="footer">
        <button type="button" class="confirm-btn" id="autoEnchantConfirmBtn" disabled>확인</button>
      </div>
    </div>
  </div>

  <div id="autoEmblemModal" class="modal simple-auto" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEmblemTitle">
      <header>
        <h3 id="autoEmblemTitle">엠블렘 자동 입력</h3>
        <button class="close" data-close>✕</button>
      </header>
      <div class="body two-col">
        <div>
          <div class="titles">속성 선택</div>
          <div class="lists attrs"></div>
        </div>
        <div>
          <div class="titles">단계 선택</div>
          <div class="lists tiers"></div>
        </div>
      </div>
      <!-- ✅ 여기 추가 -->
      <div class="footer">
        <button type="button" class="confirm-btn" id="autoEmblemConfirmBtn" disabled>확인</button>
      </div>
    </div>
  </div>
</body>

</html>
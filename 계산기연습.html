<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>게임실험연구소 계산기 (시즌5)</title>
  <style>
/*기본 변수 색상*/
    :root {
      --bg: #0f1115;
      --panel: #151922;
      --text: #e6e9ef;
      --muted: #9aa3b2;
      --accent: #6ea8ff;
      --ring: rgba(110, 168, 255, 0.45);
      --gold: #cfa24f;
      --gold-2: #8f6b2b;
      --card-bg: #17120f;
    }
    /*모든 박스*/
    * {
      box-sizing: border-box;
    }
/*html과 body에 대해 */
    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 50% -10%, #1b2130 0%, #0f1115 60%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial;
      overflow: auto;
    }
/*클래스선택자(색상세트)*/
    .shell {
      height: 100dvh;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    /*맨 위 제목임*/
/*header는 제목, head는 메타정보*/
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      /*정렬*/
      padding: 12px 18px;
      /*안쪽 여백*/
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0));
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(4px);
    }
/*header : 태그선택자, title : 클래스, h1 : 태그선택자, header안 -> title안 -> h1만 선택*/
    header .title h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
    }
/*앞쪽에 태그선택자가 없으므로, 전역에 actions 클래스 사용가능*/
    .actions {
      font-size: 12px;
      color: var(--muted);
    }

    /* 레이아웃: 오른쪽에 합산 패널 열 추가 (고정폭) */
    .layout {
      display: grid;
      grid-template-columns: minmax(220px, 1fr) minmax(320px, 36vw) minmax(220px, 1fr) minmax(220px, 260px) 300px;
      gap: clamp(8px, 2vw, 24px);
      height: calc(100dvh - 54px);
      padding: clamp(8px, 1.6vw, 18px);
      align-items: center;
      justify-items: center;
    }
/* justify-content 는 가로방향정렬, align-items 은 세로방향정렬
 flex-start는 아이템들을 시작지점에 붙여서정렬 가로면 왼쪽정렬, 세로면 위쪽정렬
 flex-end는 아이템들을 끝지점에 붙여서 정렬, 가로면 오른쪽정렬, 세로면 아래쪽정렬*/
    .column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 10px 6px;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .slot-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
/*slot-row 와 left 두가지 클래스 모두를 가지고 있는것, slot-row와 left 중 하나만 있으면 적용되지 않는다)
//slot-row left 점이 아닌 띄어쓰기를 하면, left가 앞 요소 안의 요소가 되는데, 이때 left는 태그이다. .left로 쓰게되면 클래스가 된다.
//html(클래스)에 넣어서 쓸때는 띄어쓰기로 쓴다. class = "slot-row left" */
    .slot-row.left {
      justify-content: flex-end;
    }

    .slot-row.right {
      justify-content: flex-start;
    }

    .slot {
      width: clamp(64px, 10vh, 120px);
      aspect-ratio: 1/1;
      border-radius: 12px;
      background: radial-gradient(120px 120px at 40% 35%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02) 50%, rgba(255, 255, 255, 0.01) 100%);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: grid;
      place-items: center;
      position: relative;
      cursor: pointer;
      user-select: none;
      transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25) inset, 0 1px 0 rgba(255, 255, 255, 0.04);
    }
/* :는 의사클래스, hover는 마우스를 위에 올린 상태를 뜻함. 따라서 slot 클래스에 마우스를 올리면 이라는 뜻
// 그외에도 active : 클릭한 순간(마우스 버튼 누르고 있을때), focus : 입력창 클릭했을때, visited : 방문한 링크, link : 방문하지 않은 링크
// first-child : 부모 안에서 첫번째 자식, last-child : 부모 안에서 마지막 자식, ntn-child(n) : 부모 안에서 n번째 자식
//checked : 체크박스나 라디오버튼에 체크된상태, valid, invalid : 입력값이 유효성 검사에 맞거나 아닐때
//root : 문서 최상위 요소 */
    .slot:hover {
      transform: translateY(-2px);
      border-color: rgba(110, 168, 255, 0.5);
      box-shadow: 0 0 0 4px var(--ring), 0 10px 24px rgba(0, 0, 0, 0.35) inset;
    }
/* slot-label 클래스는 slot의 자손선택자이다. 따라서 slot 클래스를 선언하고 그 안에 또 slot-label 클래스를 선언해야한다. */
    .slot .slot-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      color: var(--muted);
      background: rgba(0, 0, 0, 0.35);
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      white-space: nowrap;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .outer-rects {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .rect {
      width: clamp(52px, 8vh, 96px);
      height: clamp(18px, 3vh, 28px);
      border-radius: 10px;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.06) inset, 0 6px 16px rgba(0, 0, 0, 0.25) inset;
      color: var(--text);
      font-size: 10px;
    }

    .rect:hover {
      border-color: rgba(110, 168, 255, 0.55);
      box-shadow: 0 0 0 3px var(--ring), 0 8px 18px rgba(0, 0, 0, 0.35) inset;
    }

    .rect.disabled {
      opacity: .45;
      pointer-events: none;
    }

    .center {
      display: grid;
      place-items: center;
      min-width: min(34vw, 460px);
      height: 100%;
    }

    .character-card {
      width: clamp(240px, 34vw, 520px);
      aspect-ratio: 3/4;
      border-radius: 22px;
      background: radial-gradient(60% 40% at 50% 10%, rgba(110, 168, 255, 0.08), transparent 60%),
        linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: grid;
      place-items: center;
      position: relative;
      overflow: hidden;
      cursor: pointer;
      box-shadow: 0 0 0 6px rgba(110, 168, 255, 0.08) inset, 0 20px 50px rgba(0, 0, 0, 0.45);
    }

    .character-ghost {
      width: 80%;
      height: 80%;
      border-radius: 24px;
      border: 2px dashed rgba(255, 255, 255, 0.18);
      display: grid;
      place-items: center;
      color: var(--muted);
      text-align: center;
    }

    .character-img {
      position: absolute;
      inset: 12px;
      width: calc(100% - 24px);
      height: calc(100% - 24px);
      object-fit: contain;
      filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.45));
      display: none;
    }

    /* ▼ 하단 4개 슬롯 */
    .mini-bar {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    .mini-cell {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .slot.mini {
      width: clamp(64px, 10vh, 120px);
      aspect-ratio: 1 / 1;
      border-radius: 12px;
      flex: 0 0 auto;
    }
/*slot클래스와 mini클래스 동시에 적용하며 그 두 클래스의 자손클래스가 slot-label이 된다.*/
    .slot.mini .slot-label {
      position: absolute;
      top: 50%;
      left: 50%;
      bottom: auto;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      z-index: 50;
    }

    .modal.show {
      display: grid;
    }

    .backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(2px);
    }

    .dialog {
      position: relative;
      width: min(1100px, 95vw);
      height: min(720px, 92vh);
      background: #0e0b09;
      border: 1px solid #2a211a;
      border-radius: 18px;
      padding: 12px 14px;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
    }
/*header와 h2는 dialog의 자손태그들이다. 태그는 쓰려면 <header> </header>을 써야한다.
//이 코드만 보고는 종속관계를 알수는 없다. header가 더 높은지, h2가 높은지 알수없다. */
    .dialog header {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 10px;
      padding: 6px 4px 8px;
      border-bottom: 1px solid #2a211a;
    }

    .dialog h2 {
      margin: 0;
      font-size: 15px;
      font-weight: 700;
      color: #f0e6d2;
    }

    .input {
      height: 34px;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      padding: 0 10px;
      background: #1a130f;
      color: #f0e6d2;
    }

    /* 캐릭터 카탈로그 */
    .catalog {
      overflow: auto;
      padding: 10px 6px 14px;
    }

    .row {
      display: grid;
      grid-template-columns: 56px 1fr 56px;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    .badge-img {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      object-fit: cover;
      background: #20170f;
      border: 2px solid #6e5124;
    }

    .cards {    /* 카드의 스타일 */
      display: grid;    /* 그리드 레이아웃 배치*/
      grid-template-columns: repeat(5, minmax(160px, 1fr));   /* 가로칸(columns) 4개, 각칸은 최소 160px, 최대 1fr(=남는 공간 균등 분배) 크기 */
      gap: 12px;    /*카드들 사이 가로/세로 간격 */
    }

    .char-card {
      position: relative;
      display: grid;
      grid-template-rows: auto auto;    /*세로로 2줄 그리드 (첫줄 이미지, 두번째줄 이름*/
      gap: 6px;   /* 줄 사이 6px 간격 */
      padding: 8px;   /* 안쪽 여백 */
      border-radius: 12px; 
      background: var(--card-bg);
      cursor: pointer;    /*마우스 올리면 손가락 모양*/
      border: 1px solid var(--gold-2);    /* 카드 테두리 (금색 계열 변수) */
    }

    .char-card:hover {    /*마우스 올렸을때 효과 */
      box-shadow: inset 0 0 0 2px rgba(207, 162, 79, 0.22), 0 8px 22px rgba(0, 0, 0, 0.55);
    }

    .char-img {
      width: 100%;    /* 부모 카드의 가로폭을 전부 차지 */
      aspect-ratio: 16/7;   /* 가로:세로 비율 16:7 유지 */
      object-fit: cover;    /* 이미지 잘리더라도 영역 꽉 채움 */
      border-radius: 8px;
      border: 1px solid rgba(207, 162, 79, 0.35);
      background: #0c0a08;
    }

    .char-name {
      font-size: 14px;
      color: #f0e6d2;
      font-weight: 700;
    }

    /* 무기 탭 */
    .weapon-tabs {
      display: flex;
      gap: 8px;
      margin: 0 10px;
      flex-wrap: wrap
    }

    .weapon-tabs .tab-btn {
      height: 30px;
      padding: 0 12px;
      border-radius: 999px;
      cursor: pointer;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #c7b589
    }

    .weapon-tabs .tab-btn.active {
      background: #2a211a;
      border-color: #cfa24f;
      color: #f0e6d2;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset
    }
/*overflow는 요소크기보다 내용이 넘치면 어떻게 처리할지를 나타냄
//auto는 자동 스크롤바 생김, visible은 그냥 밖으로 삐져나옴, hidden은 넘치는 부분 잘라냄, scroll은 항상 스크롤바 표시 */
    /* 리스트형 카드 */
    .items {
      overflow: auto;
      padding: 12px 8px 16px;
      display: grid;
      gap: 14px;
    }

    .item-list {
      display: grid;
      grid-template-columns: repeat(2, minmax(280px, 1fr));
      gap: 12px
    }

    .item-row {
      display: grid;
      grid-template-columns: 72px 1fr 64px;
      align-items: center;
      gap: 12px;
      background: #15100c;
      border: 1px solid #3a2c21;
      border-radius: 12px;
      padding: 10px;
      cursor: pointer
    }

    .item-row:hover {
      border-color: #7c5b37;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset
    }

    .iconbox {
      position: relative;
      width: 64px;
      height: 64px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(207, 162, 79, .35);
      background: #0c0a08
    }

    .iconbox .icon {
      width: 100%;
      height: 100%;
      object-fit: cover
    }

    .badge-lv {
      position: absolute;
      left: 4px;
      top: 4px;
      font-size: 11px;
      padding: 2px 5px;
      border-radius: 6px;
      background: #1e2b1e;
      color: #9fe19f;
      border: 1px solid #254c25
    }

    .meta .meta-top {
      display: flex;
      align-items: baseline;
      gap: 8px
    }

    .meta .lvl {
      color: #9fe19f;
      font-weight: 700;
      font-size: 13px
    }

    .meta .name {
      color: #f0e6d2;
      font-weight: 800;
      font-size: 15px
    }

    .meta-sub {
      color: #c7b589;
      font-size: 12px;
      margin-top: 4px
    }

    .rarity-chip {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid #7c5b37;
      background: #2a211a;
      color: #e7c27a;
      font-weight: 700;
      font-size: 12px;
      text-align: center
    }

    /* === Options panel (우측 옵션 열) === */
    .column.options {
      align-items: stretch;
      /* 너비 꽉 차게 */
      gap: 12px;
    }

    .opt-box {
      width: 100%;
      border-radius: 14px;
      padding: 12px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: grid;
      gap: 10px;
    }

    .opt-title {
      margin: 0 0 2px;
      font-size: 13px;
      font-weight: 800;
      color: #f0e6d2;
      letter-spacing: .2px;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field .label {
      font-size: 11px;
      color: var(--muted);
    }

    .select {
      height: 34px;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      padding: 0 10px;
      background: #1a130f;
      color: #f0e6d2;
      outline: none;
    }

    .select:focus {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }
/*@는 모바일 전환시 사용하는 부호. 정확히는 폭이 좁아지면.
    /* 모바일 1열 전환 시 자연스럽게 흐르도록(기존 규칙 유지) */
    @media (max-width: 900px) {
      .column.options {
        order: 3;
      }

      /* 중앙/오른쪽 다음에 위치 */
    }

    /* ▶ 합산 패널 (우측 고정 + 최종데미지) */
    aside.stats {
      align-self: stretch;
      width: 100%;
      height: 100%;
      position: sticky;
      top: clamp(8px, 1.6vw, 18px);
    }

    .stats-panel {
      width: 100%;
      height: 100%;
      border-radius: 18px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
    }

    .stats-panel h3 {
      margin: 4px 0 0;
      font-size: 14px;
      color: #f0e6d2;
    }

    .stat-list {
      overflow: auto;
      padding-right: 6px;
      display: grid;
      gap: 8px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 8px 10px;
    }

    .stat-label {
      color: var(--muted);
      font-size: 12px;
    }

    .stat-value {
      color: #e8edd6;
      font-weight: 800;
      font-size: 14px;
      text-align: right;
    }

    .final-damage {
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      padding-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 6px;
    }

    .final-damage .label {
      color: #f0e6d2;
      font-size: 13px;
      line-height: 1;
      text-align: left;
    }

    .final-damage .value {
      color: #ff5a6a;
      font-weight: 900;
      font-size: 25px;
      letter-spacing: .3px;
      line-height: 1.15;
      align-self: flex-end;
      text-align: right;
    }

/* #은 고유 id를 뜻한다. 클래스와 다른점은 고유하기때문에 단한번만 사용한다는 차이가 있음
    /* 강화 선택 모달(텍스트 리스트) */
    #enhanceModal .dialog {
      width: min(520px, 95vw);
      height: min(520px, 85vh);
    }

    .enh-list {
      overflow: auto;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .enh-option {
      height: 36px;
      padding: 0 12px;
      text-align: left;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #f0e6d2;
      cursor: pointer;
    }

    .enh-option:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
        grid-auto-rows: max-content;
        gap: 18px;
        height: auto;
        overflow: auto;
      }

      .center {
        min-width: 0;
      }

      .cards,
      .item-list {
        grid-template-columns: repeat(2, 1fr);
      }

      .row {
        grid-template-columns: 40px 1fr 40px;
      }

      .badge-img {
        width: 40px;
        height: 40px;
      }

      aside.stats {
        position: static;
      }
    }
/* autoEnchantModal 전용 2-컬럼 레이아웃 */
#autoEnchantModal .dialog { /* 강화설정 모달과 같은 폭/패딩을 공유한다면 생략 가능 */
  max-width: 700px; /*모달너비*/
}

#autoEnchantModal .body.two-col {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

/* 각 컬럼 내부 버튼 리스트 레이아웃 */
#autoEnchantModal .col .list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* 타이틀 여백/스타일도 강화설정 모달과 톤을 맞춤 */
#autoEnchantModal .col .title {
  font-weight: 600;
  margin-bottom: 8px;
}

/* 추천 마법부여 모달: 선택 강조 */
#autoEnchantModal .opt-btn.active {
  border-color: var(--brand, #2563eb);
  box-shadow: 0 0 0 2px rgba(37,99,235,0.25);
  /* 필요시 배경도 살짝 */
  background: rgba(37,99,235,0.06);
}

/* 키보드 포커스 접근성도 보정(선택과 구분되게) */
#autoEnchantModal .opt-btn:focus-visible {
  outline: 2px solid var(--brand, #2563eb);
  outline-offset: 2px;
}

/* 모바일 좁은 화면에선 1열로 떨어지도록 */
@media (max-width: 520px) {
  #autoEnchantModal .body.two-col {
    grid-template-columns: 1fr;
  }
}

    /* 고정 높이 아이템 모달 */
    #itemModal .dialog {
      grid-template-rows: auto auto;
    }

    #itemModal .items {
      height: clamp(420px, 60vh, 560px);
      max-height: clamp(420px, 60vh, 560px);
      overflow: auto;
    }

    /* === Emblem sockets & modal — FINAL MERGED === */

    /* Stack of 2 sockets (vertical) */
    .emblem-stack {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    /* Socket dot (small circular button) */
    .emblem-dot {
      width: 28px;
      height: 28px;
      position: relative;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, .25);
      background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35) inset, 0 0 0 3px rgba(110, 168, 255, 0);
      display: grid;
      place-items: center;
      /* Hard guarantee: perfect circle in every browser */
      border-radius: 999px !important;
      overflow: hidden !important;
      clip-path: circle(50% at 50% 50%) !important;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
      background-clip: padding-box;
    }

    .emblem-dot:hover {
      box-shadow: 0 0 0 3px var(--ring);
    }

    /* When an emblem image is applied from JS as CSS var */
    .emblem-dot.has-img {
      background:
        var(--emblem) center/cover no-repeat,
        linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02)) !important;
    }

    .emblem-dot.has-img::after {
      display: none !important;
    }

    /* hide dashed guide when filled */

    /* Empty socket guide */
    .emblem-dot.empty {
      opacity: .45;
    }

    .emblem-dot.empty::after {
      content: "";
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px dashed rgba(255, 255, 255, .3);
    }

    /* Images inside sockets always clipped to circle */
    .emblem-dot img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      border-radius: 999px !important;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
    }

    /* Center number (socket & picker) — bright & legible */
    .emblem-dot .num,
    .em-thumb .num {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      color: #fff;
      font-weight: 900;
      letter-spacing: .2px;
      -webkit-text-stroke: 1px rgba(0, 0, 0, .35);
      text-shadow:
        0 1px 1px rgba(0, 0, 0, .55),
        0 0 4px rgba(255, 255, 255, .65),
        0 0 10px rgba(255, 255, 255, .45);
    }

    .emblem-dot .num {
      font-size: 16px;
    }

    /* 28px socket */
    .em-thumb .num {
      font-size: 22px;
    }

    /* 56px picker */

    /* Subtle center darkening behind number (not too strong) */
    .emblem-dot .num::before,
    .em-thumb .num::before {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 80%;
      border-radius: 999px;
      pointer-events: none;
      background: radial-gradient(circle,
          rgba(0, 0, 0, .18) 0%,
          rgba(0, 0, 0, .10) 45%,
          rgba(0, 0, 0, 0) 70%);
    }

    /* Hover: enhance number legibility */
    .emblem-dot:hover .num,
    .em-thumb:hover .num {
      -webkit-text-stroke: 1px rgba(0, 0, 0, .45);
      text-shadow:
        0 1px 2px rgba(0, 0, 0, .75),
        0 0 6px rgba(255, 255, 255, .60),
        0 0 14px rgba(255, 255, 255, .50);
    }

    /* === Emblem picker rows (horizontal scrollers) === */
    .em-rows {
      display: grid;
      gap: 12px;
      padding: 12px;
    }

    .em-row {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 6px;
    }

    /* Picker thumbnail (badge-like) */
    .em-thumb {
      width: 56px;
      height: 56px;
      position: relative;
      cursor: pointer;
      border-radius: 999px;
      padding: 0;
      border: 1px solid #3a2c21;
      background: #1a130f;
      display: grid;
      place-items: center;
      overflow: hidden;
    }

    .em-thumb:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    /* Always circular images */
    .em-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      border-radius: 999px !important;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      mask-image: radial-gradient(circle, #000 99%, transparent 100%) !important;
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
    }

    /* 'None' option as a circular crossed badge */
    .em-thumb.none {
      background: linear-gradient(135deg, #1a130f 0%, #0c0a08 100%);
      border-radius: 999px;
    }

    .em-thumb.none::before,
    .em-thumb.none::after {
      content: "";
      position: absolute;
      left: 10px;
      right: 10px;
      top: 50%;
      height: 2px;
      background: rgba(255, 255, 255, .35);
    }

    .em-thumb.none::after {
      transform: rotate(90deg);
    }

    /* Caption (for accessary/title slots) */
    .emblem-caption {
      margin-top: 4px;
      font-size: 11px;
      line-height: 1.1;
      color: #e7c27a;
      text-align: center;
      max-width: 84px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
    }

    /* === Seal text captions inside slots === */
    .seal-captions {
      position: absolute;
      left: 6px;
      bottom: 6px;
      display: flex;
      flex-direction: column;
      gap: 2px;
      /* 행 간격 2px */
      pointer-events: none;
      /* 비클릭 */
    }

    .seal-captions .seal-row {
      display: flex;
      gap: 2px;
      justify-content: flex-start;
    }

    /* 좌측정렬 */
    .seal-captions .seal-chip {
      max-width: calc(100% - 12px);
      font-size: 9px;
      line-height: 1.2;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(207, 162, 79, 0.35);
      /* 기존 골드 톤과 어울리게 */
      color: inherit;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }



    /* === Skill Rune === */
    .rune-grid {
      --col-w: minmax(64px, 1fr);
      display: grid;
      grid-auto-rows: 40px;
      gap: 8px;
      overflow: auto;
    }

    .rune-grid .row {
      display: grid;
      grid-template-columns: 120px repeat(8, var(--col-w));
      align-items: center;
      gap: 8px;
    }

    .rune-grid .head {
      position: sticky;
      left: 0;
      z-index: 1;
      padding: 0 10px;
      border: 1px solid #3a2c21;
      border-radius: 10px;
      background: #1a130f;
      color: #f0e6d2;
      font-weight: 800;
      font-size: 13px;
      white-space: nowrap;
    }

    .rune-grid .cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .rune-select {
      width: 100%;
      height: 30px;
      border-radius: 8px;
      border: 1px solid #3a2c21;
      background: #15100c;
      color: #f0e6d2;
      padding: 0 8px;
    }

    .rune-select:focus {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    /* 룬 각인 UI */
    .rune-engrave-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .field.compact {
      flex: 1 1 220px;
    }

    /* === Skill Tree UI — FINAL MERGED === */

    /* Header row */
    .skilltree-head {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }

    /* Small counters next to the Skill Tree button (outside modal) */
    .skilltree-head .st-counters {
      display: flex;
      gap: 12px;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
    }

    .skilltree-head .st-counters b {
      color: #9fe19f;
      font-size: 13px;
    }

    /* Top utility bar */
    .st-topbar {
      display: flex;
      gap: 14px;
      align-items: center;
      font-size: 12px;
      color: #c7b589;
    }

    /* ===== Universal counter styles (base) ===== */
    .st-counters {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .st-counter {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, .25);
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 10px;
      font-size: 13px;
      /* base size; overridden in modal scope */
    }

    .st-counter .label {
      font-weight: 800;
      letter-spacing: .3px;
      font-size: 13px;
    }

    .st-counter .label.sp {
      color: #6ec6ff;
    }

    /* cyan-like */
    .st-counter .label.tp {
      color: #ff4444;
    }

    /* red */
    .st-counter .val {
      min-width: 18px;
      text-align: right;
      color: #e6e9ef;
      font-variant-numeric: tabular-nums;
      font-size: 13px;
    }

    /* Keep modal header balanced */
    .modal .dialog header {
      justify-content: space-between;
    }

    /* ===== Optional large pills elsewhere (kept for compatibility) ===== */
    :root {
      --sp-blue: #2BCCED;
      --tp-red: #F03231;
    }

    .actions .sp-tp {
      display: none;
      gap: 18px;
      align-items: center;
      font-size: 20pt;
    }

    .counter-pill {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-weight: 800;
      letter-spacing: .1px;
      color: var(--text);
      text-shadow: 0 1px 2px rgba(0, 0, 0, .55);
    }

    .counter-pill .lab {
      font-size: 1em;
      font-style: italic;
      font-weight: 900;
    }

    .counter-pill.sp .lab {
      color: var(--sp-blue);
    }

    .counter-pill.tp .lab {
      color: var(--tp-red);
    }

    /* ===== Modal-only: big counters aligned to the right ===== */
    #skillTreeModal .st-counters {
      margin-left: auto;
      font-size: 20pt;
    }

    #skillTreeModal .st-counter,
    #skillTreeModal .st-counter .label,
    #skillTreeModal .st-counter .val {
      font-size: 20pt;
    }

    /* Modal size */
    #skillTreeModal .dialog {
      width: min(1600px, 98vw) !important;
      height: min(920px, 95vh) !important;
    }

    /* ===== SkillTree v1 (legacy banded columns) ===== */
    .st-grid {
      grid-auto-flow: column;
      grid-auto-columns: 320px;
      /* generous column width */
      gap: 12px;
      padding: 12px;
    }

    .st-col {
      gap: 8px;
      align-content: start;
    }

    .st-band {
      position: sticky;
      top: 0;
      z-index: 2;
      padding: 6px 10px;
      border: 1px solid #3a2c21;
      border-radius: 10px;
      background: #1a130f;
      color: #e7c27a;
      font-weight: 800;
      font-size: 13px;
      text-align: center;
    }

    /* ===== SkillTree v2 (bands / coordinate grid) ===== */

    /* Wrapper for bands */
    .st2-wrap {
      display: grid;
      gap: 14px;
    }

    /* Each band's grid sits a bit below its dashed label line */
    .st2-band>.st2-grid {
      margin-top: 3px;
    }

    /* Band container: prevent clipping; add room above/below */
    .st2-band {
      position: relative;
      margin: 1px 0;
      padding-top: 10px;
      /* room for label/dashed line */
      padding-bottom: 1px;
      /* room for controls */
      overflow: visible;
    }

    /* Band dashed line */
    .st2-band::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      border-top: 1px dashed rgba(207, 162, 79, .55);
    }

    /* Band label sitting over dashed line */
    .st2-band-label {
      position: absolute;
      left: 0;
      top: 0;
      transform: translateY(-50%);
      padding: 0 6px;
      border-radius: 8px;
      background: #0e0b09;
      color: #e7c27a;
      font-weight: 800;
      font-size: 12px;
      line-height: 1.4;
      z-index: 1;
    }

    /* 6-column responsive grid; variable row height */
    .st2-grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(100px, 1fr));
      grid-auto-rows: minmax(164px, max-content);
      gap: 10px;
    }

    /* ===== Skill tiles ===== */

    /* Tile: icon (top) / name (middle) / controls (bottom) */
    .st2-tile {
      display: grid;
      grid-template-rows: auto auto auto;
      align-items: center;
      justify-items: center;
      gap: 6px;
      max-width: 100%;
      overflow: hidden;
    }

    /* Skill name */
    .st2-name {
      width: 100%;
      max-width: 340px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 17px;
      font-weight: 800;
      line-height: 1.1;
      color: #e7c27a;
    }

    /* Circular icon */
    .st2-skill {
      width: clamp(68px, 7.6vw, 92px);
      height: clamp(68px, 7.6vw, 92px);
      border-radius: 999px;
      border: 1px solid #3a2c21;
      background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35) inset;
      display: grid;
      place-items: center;
      overflow: hidden;
      -webkit-mask-image: radial-gradient(circle, #000 99%, transparent 100%);
      mask-image: radial-gradient(circle, #000 99%, transparent 100%);
    }

    .st2-skill img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 999px;
    }

    /* Controls: left stack / center level box / right stack */
    .st2-ctrl2 {
      display: grid;
      grid-template-columns: max-content auto max-content;
      grid-template-rows: auto auto;
      align-items: center;
      justify-items: center;
      column-gap: 8px;
      row-gap: 2px;
    }

    /* Left/Right button stacks */
    .st2-side-left,
    .st2-side-right {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    /* Central level box */
    .st2-lv {
      grid-column: 2;
      grid-row: 1 / span 2;
      min-width: 110px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #f0e6d2;
      text-align: center;
      font-weight: 800;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .st2-lvnums {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .st2-lv .cur,
    .st2-lv .tp {
      font-size: 16px;
      line-height: 1;
    }

    .st2-lv .sep {
      opacity: .6;
      margin: 0;
    }

    /* Buttons */
    .st2-btn {
      height: 24px;
      padding: 0 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #c7b589;
      cursor: pointer;
      white-space: nowrap;
    }

    .st2-btn:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .18) inset;
    }

    .st2-btn:disabled {
      opacity: .5;
      cursor: default;
      border-color: #2a211a;
      box-shadow: none;
    }

    /* ===== Auto Input Panels ===== */
    .auto-box {
      width: 100%;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
      margin-bottom: 10px;
    }

    .auto-box h4 {
      margin: 0 0 8px;
      font-size: 14px;
      color: #e7c27a;
    }

    .auto-box .btn {
      width: 100%;
      height: 34px;
      border-radius: 10px;
      border: 1px solid #3a2c21;
      background: #1a130f;
      color: #f0e6d2;
      cursor: pointer;
    }

    .auto-box .btn:hover {
      border-color: #cfa24f;
      box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset;
    }

    .auto-box .btn[disabled] {
      opacity: .5;
      cursor: not-allowed;
    }

    /* Simple list modal */
    .simple-modal .dialog {
      width: min(420px, 92vw);
    }

    .simple-modal .list {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      padding: 10px;
    }

    .simple-modal .list .opt-btn {
      height: 38px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: #1a1b27;
      color: #e6e9ef;
      cursor: pointer;
    }

    .simple-modal .list .opt-btn:hover {
      border-color: #6ea8ff;
      box-shadow: 0 0 0 2px rgba(110, 168, 255, .25) inset;
    }


  </style>
</head>

<body>
  <div class="shell">
    <header>
      <div class="title">
        <div class="dot" aria-hidden="true"></div>
        <h1>게임실험연구소 계산기 (시즌5)</h1>
      </div>
 <!--span 은 한줄에서 특별히 강조 할때 쓴다. div는 한줄이 강제로 나뉘기때문에 쓴다.-->
      <div class="actions">
        <div class="sp-tp" id="spTpTop">
          <span class="counter-pill sp"><span class="lab">SP</span><span id="spLeftTop"
              style="min-width:24px;display:inline-block;text-align:right;">—</span></span>
          <span class="counter-pill tp"><span class="lab">TP</span><span id="tpLeftTop"
              style="min-width:24px;display:inline-block;text-align:right;">—</span></span>

        </div>
      </div>
    </header>

    <section class="layout">
      <div class="column left">
        <div class="auto-box">
          <h4>자동 입력</h4>
          <button id="btnAutoEnh" class="btn">강화 자동 입력</button>
          <div style="height:8px;"></div>
          <button id="btnAutoSeal" class="btn">추천 마법봉인 자동 입력</button>
        </div>

        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L1"><span class="slot-label">머리어깨</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L2"><span class="slot-label">상의</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L3"><span class="slot-label">하의</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L4"><span class="slot-label">허리</span></div>
        </div>
        <div class="slot-row left">
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
          <div class="slot" data-slot="L5"><span class="slot-label">신발</span></div>
        </div>
      </div>

      <div class="center">
        <div id="characterCard" class="character-card">
          <img id="characterImg" class="character-img" alt="캐릭터" />
          <div id="characterGhost" class="character-ghost">클릭하여 캐릭터 선택</div>
        </div>
        <div class="mini-bar">
          <div class="mini-cell">
            <div class="outer-rects">
              <button class="rect" data-unused="true">선택</button>
              <button class="rect" data-unused="true">선택</button>
            </div>
            <div class="slot mini" data-slot="C2"><span class="slot-label">칭호</span></div>
          </div>
          <div class="slot mini" data-slot="C1"><span class="slot-label">오라</span></div>
          <div class="slot mini" data-slot="C3"><span class="slot-label">크리쳐</span></div>
          <div class="slot mini" data-slot="C4"><span class="slot-label">아티팩트</span></div>
        </div>
      </div>

      <div class="column right">
        <div class="auto-box">
          <h4>자동 입력</h4>
          <button id="btnAutoEnchant" class="btn">추천 마법부여 자동 입력</button>
          <div style="height:8px;"></div>
          <button id="btnAutoEmblem" class="btn">엠블렘 자동 입력</button>
        </div>

        <div class="slot-row right">
          <div class="slot" data-slot="R1"><span class="slot-label">무기</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button><button class="rect">선택</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R2"><span class="slot-label">팔찌</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R3"><span class="slot-label">목걸이</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R4"><span class="slot-label">반지</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button></div>
        </div>
        <div class="slot-row right">
          <div class="slot" data-slot="R5"><span class="slot-label">보조장비</span></div>
          <div class="outer-rects"><button class="rect">선택</button><button class="rect">선택</button><button
              class="rect">선택</button><button class="rect">선택</button></div>
        </div>
      </div>
      <div class="column options">
        <div class="opt-box">
          <h4 class="opt-title">아바타 세부 선택</h4>
          <label class="field">
            <span class="label">아바타</span>
            <select id="selAvatar" class="select" aria-label="아바타 선택">
              <option value="" selected disabled>아바타 선택</option>
              <option value="rare">레어 아바타</option>
              <option value="advanced">상급 아바타</option>
            </select>
          </label>
          <label class="field">
            <span class="label">무기압</span>
            <select id="selImprint" class="select" aria-label="무기압 선택">
              <option value="" selected disabled>무기압 선택</option>
              <option value="add5">추뎀 5% 무기압</option>
              <option value="patkmatk5">물/마공 5% 무기압</option>
              <option value="patkmatk3">물/마공 3% 무기압</option>
              <option value="monster">몬스터 무기압</option>
              <option value="quest">퀘스트 무기압</option>
            </select>
          </label>
        </div>

        <div class="opt-box">
          <h4 class="opt-title">계산 세부 옵션 조절</h4>
          <label class="field">
            <span class="label">시간 기준</span>
            <select id="selTime" class="select" aria-label="시간 기준">
              <option value="" selected disabled>시간 기준</option>
              <option value="30s">30초딜</option>
              <option value="1m">1분딜</option>
              <option value="3m">3분딜</option>
              <option value="5m">5분딜</option>
              <option value="10m">10분딜</option>
            </select>
          </label>
<!--document.getElementById("selMonster").value 라고 쓰면 설정된 몬스터값 불러올 수 있음-->
          <label class="field">
            <span class="label">몬스터 설정</span>
            <select id="selMonster" class="select" aria-label="몬스터 설정">
              <option value="" selected disabled>몬스터 설정</option>
              <option value="nugol">거대누골</option>
              <option value="blackdragon">흑룡</option>
              <option value="anton">안톤</option>
              <option value="asmar_calix">아스마르/칼릭스</option>
            </select>
          </label>

          <label class="field">
            <span class="label">던전 난이도</span>
            <select id="selDifficulty" class="select" aria-label="던전 난이도 설정">
              <option value="" selected disabled>던전 난이도 설정</option>
              <option value="hard">어려움</option>
              <option value="normal">보통</option>
              <option value="easy">쉬움</option>
              <option value="nugol_room">누골방</option>
            </select>
          </label>
        </div>
        <div class="opt-box">
          <h4 class="opt-title">스킬룬</h4>
          <div style="display:flex; gap:8px; align-items:center;">
            <button id="btnRune" class="btn" type="button" style="height:30px;padding:0 12px;border-radius:10px;">
              스킬룬 설정
            </button>
            <div style="font-size:12px;color:var(--muted);">
              선택한 스킬룬 개수: <b id="runeCount" style="color:#e7c27a;">0</b>
            </div>
          </div>
          <div class="rune-engrave-row">
            <label class="field compact">
              <span class="label">룬 각인 설정</span>
              <select id="selRuneEngrave" class="select" aria-label="룬 각인 설정">
                <option value="" selected disabled>룬 각인 설정</option>
              </select>
            </label>

            <label class="field compact">
              <span class="label">세부 설정</span>
              <select id="selRuneDetail" class="select" aria-label="세부 설정" disabled>
                <option value="" selected disabled>세부 설정</option>
              </select>
            </label>
          </div>


        </div>

        <div class="opt-box">
          <h4 class="opt-title">스킬트리</h4>
          <div class="skilltree-head">
            <button id="btnSkillTree" class="btn" type="button"
              style="height:30px;padding:0 12px;border-radius:10px;">스킬트리 설정</button>
            <div class="st-counters">
              <span>SP 남음: <b id="stSpLeft">—</b></span>
              <span>TP 남음: <b id="stTpLeft">—</b></span>
            </div>
          </div>
        </div>


      </div>

      <aside class="stats">
        <div class="stats-panel">
          <h3>합산 스탯</h3>
          <div id="statList" class="stat-list"></div>
          <div class="final-damage">
            <span class="label">최종데미지</span>
            <strong class="value" id="finalDamageValue">47,978,023,776</strong>
          </div>
        </div>
      </aside>
    </section>
  </div>
<!--ㅇ-->
  <div id="charModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div><!--모달 뒤 배경 검정, data-close 속성 붙은 요소 클릭하면 모달 닫힘-->
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="dlgTitle">
      <header>
        <h2 id="dlgTitle">캐릭터 선택</h2>
        <div></div>
      </header>
      <div id="catalog" class="catalog"></div>
    </div>
  </div>

  <div id="itemModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="itemDlgTitle">
      <header>
        <h2 id="itemDlgTitle">아이템 선택</h2>
        <nav id="weaponTabs" class="weapon-tabs" style="display:none"></nav>
        <input id="itemSearch" class="input" type="text" placeholder="아이템 검색 (이름 / 종류)" />
      </header>
      <div class="items">
        <div id="itemList" class="item-list"></div>
      </div>
    </div>
  </div>

  <div id="enhanceModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="enhDlgTitle">
      <header>
        <h2 id="enhDlgTitle">강화 선택</h2>
      </header>
      <div class="items">
        <div id="enhanceList" class="enh-list"></div>
      </div>
    </div>
  </div>

  <div id="enchantModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="enchantDlgTitle">
      <header>
        <h2 id="enchantDlgTitle">마법부여 선택</h2>
      </header>
      <div class="items">
        <div id="enchantList" class="enh-list"></div>
      </div>
    </div>
  </div>

  <div id="emblemModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="emblemDlgTitle"
      style="width:min(920px,95vw);height:min(620px,88vh);">
      <header>
        <h2 id="emblemDlgTitle">엠블렘 선택</h2>
      </header>
      <div id="emblemRows" class="em-rows"></div>
    </div>
  </div>

  <div id="runeModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="runeDlgTitle"
      style="width:min(980px,95vw);height:min(620px,88vh);">
      <header>
        <h2 id="runeDlgTitle">스킬룬 설정</h2>
        <div style="justify-self:end;font-size:12px;color:#c7b589;">
          선택한 스킬룬 개수: <b id="runeCountLabel" style="color:#ff6b6b;">0</b> / 20
        </div>
      </header>
      <div class="items" style="padding:10px;">
        <div id="runeGrid" class="rune-grid"></div>
      </div>
    </div>
  </div>

  <div id="skillTreeModal" class="modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="stDlgTitle"
      style="width:min(1100px,96vw);height:min(720px,92vh);">
      <header>
        <h2 id="stDlgTitle">스킬트리</h2>
        <div class="st-counters">
          <div class="st-counter"><span class="label sp">SP</span><span class="val" id="stSpLeftMini">0</span></div>
          <div class="st-counter"><span class="label tp">TP</span><span class="val" id="stTpLeftMini">0</span></div>
        </div>
      </header>
      <div class="items" style="padding:10px;">
        <div id="stGrid"></div>
      </div>
    </div>
  </div>


  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>


    /* ===== 상태/상수 ===== */
    const state = {
      currentCharacter: { jobGroup: null, jobGroupLabel: null, name: null, imgSrc: null, power: null },
      selections: {}, // 장비
      upgrades: {},   // 슬롯별 강화 선택
      enchants: {},   // 슬롯별 마법부여 선택
      ui: { weaponTypeTab: null, enhTargetSlot: null, enhTargetBtn: null },
      currentSlotKey: null
    };
    state.skillLv = state.skillLv || {}; // {skillId: 현재레벨}
    state.stUsedSP = state.stUsedSP || 0;
    state.stUsedTP = state.stUsedTP || 0;
    // ===== SP/TP 상태 및 렌더 =====
    state.sp = state.sp || { total: 0, left: 0 };
    state.tp = state.tp || { total: 0, left: 0 };

    

// === [ENCHANT] 전역 캐시 & 프리로드 ===
const ENCHANT_CACHE = {
  ready: false,            // 프리로드 완료 여부
  byType: new Map(),       // '무기마부' -> [{name, typeKey}, ...]
  version: 'v1',           // 캐시 버전(시트가 바뀌면 여기 문자열만 바꿔 새로 받도록)
};

async function preloadEnchantSheet(){
  const urlBase = (typeof ENHANCE_SHEET_SAFE!=='undefined' && ENHANCE_SHEET_SAFE)
    ? ENHANCE_SHEET_SAFE
    : (typeof ENHANCE_SHEET!=='undefined' ? ENHANCE_SHEET : null);

  if(!urlBase){ ENCHANT_CACHE.ready = true; return; }

  // 캐시 허용. (필요 시 버전 쿼리로 강제 갱신)
  const url = urlBase + (urlBase.includes('?') ? '&' : '?') + ENCHANT_CACHE.version;

  const text = await fetch(url, { cache: 'default' }).then(r=>r.text());
  const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
  const rows = parsed.data || [];

  const byType = new Map();
// (수정) 프리로드 루프
for (const r of rows) {
  const typeKey = String(r['종류'] || '').trim();
  if (!typeKey) continue;

  // 1) 기존 변환기가 있으면 재사용(권장)
  const obj = (typeof mapRowToEnhance === 'function') ? mapRowToEnhance(r) : null;

  // 2) 이름/스탯/직업군 안전 추출
  const name  = String(obj?.name ?? r['이름'] ?? r['name'] ?? '').trim();
  if (!name) continue;

  const stats = obj?.stats ?? null;                  // ← undefined 방지
  const jobGroup = String(r['직업군'] ?? obj?.jobGroup ?? '').trim();

  // 3) 종류별 바구니 확보
  if (!byType.has(typeKey)) byType.set(typeKey, []);

  // 4) 캐시에 푸시(원본도 보존)
  byType.get(typeKey).push({
    name,
    typeKey,
    stats,            // ← 반드시 정의된 값만(없으면 null)
    jobGroup,         // ← 추천 키 검색용
    raw: r
  });
}



  ENCHANT_CACHE.byType = byType;
  ENCHANT_CACHE.ready = true;
}

async function ensureEnchantCache(){
  if(!ENCHANT_CACHE.ready){
    try { await preloadEnchantSheet(); }
    catch(e){ console.warn('[ENCHANT] preload failed:', e); ENCHANT_CACHE.ready = true; }
  }
}



    // === [ENCHANT] 0) 세부상자(3번째) 기본 라벨 "마법 부여"로 세팅 ===
    // === [ENCHANT] 0) 세부상자 기본 라벨/역할 세팅 ===
function setDefaultEnchantLabels() {
  // ① 장비 슬롯 행: 세 번째 세부상자 → "마법 부여"
  document.querySelectorAll('.slot-row').forEach(row => {
    const third = row.querySelector('.outer-rects .rect:nth-child(3)');
    if (third) {
      third.textContent = '마법 부여';
      third.dataset.role = 'enchant';
      third.removeAttribute('data-unused');
      third.removeAttribute('aria-disabled');
      third.disabled = false;
      third.classList.remove('disabled','is-disabled');
      third.style.pointerEvents = ''; // 혹시 막혀 있으면 해제
    }
  });

  // ② C2(칭호) mini-cell: 첫 번째 세부버튼 활성화 → "마법 부여"
  const c2cell = document.querySelector('.slot.mini[data-slot="C2"]')?.closest('.mini-cell');
  if (c2cell) {
    const firstBtn = c2cell.querySelector('.outer-rects .rect:nth-child(1)');
    if (firstBtn) {
      firstBtn.textContent = '마법 부여';
      firstBtn.dataset.role = 'enchant';
      firstBtn.removeAttribute('data-unused');
      firstBtn.removeAttribute('aria-disabled');
      firstBtn.disabled = false;
      firstBtn.classList.remove('disabled','is-disabled');
      firstBtn.style.pointerEvents = '';
    }
  }
}

    document.addEventListener('DOMContentLoaded', () => {
      setDefaultEnchantLabels();
      ensureEnchantCache();
    });

    // === [ENCHANT] 1) 슬롯키 → 마법부여 종류키 매핑 ===
    // L1 머리어깨, L2 상의, L3 하의, L4 허리, L5 신발
    // R1 무기, R2 팔찌, R3 목걸이, R4 반지, R5 보조장비
    function enchantTypeForSlot(slotKey) {
      const map = {
        'R1': '무기마부',
        'L2': '상의마부',
        'L3': '하의마부',
        'L1': '머리어깨마부',
        'L4': '허리마부',
        'L5': '신발마부',
        'R2': '팔찌마부',
        'R3': '목걸이마부',
        'R4': '반지마부',
        'R5': '보장마부',
        'C2': '칭호마부',
      };
      return map[String(slotKey).toUpperCase()] || null;
    }

    // === [ENCHANT] 2) ENHANCE_SHEET 로딩 & 옵션 추출 ===
// === [ENCHANT] 캐시 우선 옵션 로더 ===
async function loadEnchantOptions(typeKey){
  await ensureEnchantCache();
  const list = ENCHANT_CACHE.byType.get(String(typeKey).trim());
  return Array.isArray(list) ? list : [];
}



    // === [ENCHANT] 3) 모달 핸들러 ===
const $enchantModal  = document.getElementById('enchantModal');
const $enchantList   = document.getElementById('enchantList');

function openEnchantModalFor(slotKey){
  state.currentSlotKey = slotKey;
  const typeKey = enchantTypeForSlot(slotKey);
  if(!typeKey){ alert('해당 슬롯의 마법부여 종류를 찾을 수 없습니다.'); return; }
  renderEnchantList(typeKey);
  showModal($enchantModal, true);
}

async function renderEnchantList(typeKey){
  const list = await loadEnchantOptions(typeKey);
  if(!list.length){
    $enchantList.innerHTML = '<div style="color:#c7b589;">해당 부위의 마법부여가 없습니다.</div>';
    return;
  }
  // 캡션 사용하지 않음(요구 5). 이름만 버튼으로.
  $enchantList.innerHTML = '';
  list.forEach(opt=>{
    const btn = document.createElement('button');
    btn.className = 'enh-option';
    btn.type = 'button';
    btn.textContent = opt.name;
    btn.addEventListener('click', ()=>applyEnchantSelection(opt));
    $enchantList.appendChild(btn);
  });
}
// === [ENCHANT][AUTO] 속성+티어/티어만 규칙대로 전체 자동 적용
async function applyAutoEnchant(attr, tier){
  await ensureEnchantCache(); // 캐시 보장

  const combo = `${attr}${tier}`;

  // 규칙: 무기/팔/목/반지는 "속성+티어"로 찾는다
  const USE_COMBO = new Set(['무기마부','팔찌마부','목걸이마부','반지마부']);
  // 규칙: 머어/상의/하의/허리/신발/보장/칭호는 "티어"만으로 찾는다
  const USE_TIER  = new Set(['머리어깨마부','상의마부','하의마부','허리마부','신발마부','보장마부','칭호마부']);

  // 적용 대상 슬롯 코드(좌/우/보조/칭호 포함)
  const targetSlots = ['R1','R2','R3','R4','R5','L1','L2','L3','L4','L5','C2'];

  const applied = [];
  // 한 슬롯씩 찾아서 state.enchants에 넣고 버튼 라벨도 갱신
  for (const slotCode of targetSlots){
    const typeKey = enchantTypeForSlot(slotCode); // 예: R1 -> '무기마부' :contentReference[oaicite:2]{index=2}
    if (!typeKey) continue;

    const keyToUse = USE_COMBO.has(typeKey) ? combo
                   : USE_TIER.has(typeKey)  ? tier
                   : null;
    if (!keyToUse) continue;

    const opt = findEnchantByJobGroup(typeKey, keyToUse);
    if (!opt) continue;

    // 기존 단일 적용 로직을 재사용해서 라벨/합산까지 동일 동작
    const prev = state.currentSlotKey;
    state.currentSlotKey = slotCode;
    applyEnchantSelection(opt); // 이 함수 안에서 버튼명 갱신 + 재계산 + 모달닫기까지 처리됨 :contentReference[oaicite:3]{index=3}
    state.currentSlotKey = prev;

    applied.push({ slot: slotCode, name: opt.name });
  }

  if (!applied.length){
    // 찾을 수 없는 케이스를 안내(선택한 조합이 시트에 없는 경우)
    if (typeof toast === 'function') toast('조건에 맞는 추천 마법부여를 찾지 못했습니다.');
    else alert('조건에 맞는 추천 마법부여를 찾지 못했습니다.');
  }
}

function applyEnchantSelection(opt){
  const slotKey = state.currentSlotKey;
  if(!slotKey) return;
   state.enchants[slotKey] = {
    name: opt.name,
    typeKey: opt.typeKey,
    stats: opt.stats || null,
    raw: opt.raw || null
  };

  // 1) 장비 슬롯 행(.slot-row)에 있으면: 마법부여 버튼(data-role) 또는 3번째 버튼 갱신
  const row = document.querySelector(`.slot-row .slot[data-slot="${slotKey}"]`)?.closest('.slot-row');
  if (row) {
    const target = row.querySelector('.outer-rects .rect[data-role="enchant"]')
               || row.querySelector('.outer-rects .rect:nth-child(3)');
    if (target) target.textContent = opt.name;
  } else {
    // 2) 미니 셀(C1~C4)에 있으면: 마법부여 버튼(data-role) 또는 1번째 버튼 갱신
    const cell = document.querySelector(`.mini-cell .slot.mini[data-slot="${slotKey}"]`)?.closest('.mini-cell');
    if (cell) {
      const target = cell.querySelector('.outer-rects .rect[data-role="enchant"]')
                   || cell.querySelector('.outer-rects .rect:nth-child(1)');
      if (target) target.textContent = opt.name;
    }
  }

  showModal($enchantModal, false);
  recalcAndRenderPanel();
}

// 공용 모달 show/hide 유틸(파일 내 다른 모달과 동일 방식 사용)
function showModal(modal, on){
  if(!modal) return;
  if(on){ modal.classList.add('show'); modal.setAttribute('aria-hidden','false'); }
  else { modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }
}
$enchantModal?.querySelector('.backdrop[data-close]')?.addEventListener('click', ()=>showModal($enchantModal,false));

// === [ENCHANT] 4) 세 번째 세부상자 클릭 시 모달 ===
document.addEventListener('click', (e)=>{
  const btn = e.target.closest('.rect');
  if(!btn) return;

  // 3번째 버튼만 처리 (dataset.role='enchant'는 A단계에서 부여)
  if(btn.dataset.role === 'enchant'){
    // ★ slot-row 또는 mini-cell(하단 C1~C4 영역) 모두 지원
    const container = btn.closest('.slot-row, .mini-cell, .mini-bar');
    const slotKey = container?.querySelector('.slot')?.getAttribute('data-slot');
    if(!slotKey) return;
    openEnchantModalFor(slotKey);
  }
});






    function _setText(id, v) { const el = document.getElementById(id); if (el) el.textContent = String(v); }

    function renderSpTp() {
      const sp = state.sp || {};
      const tp = state.tp || {};
      const set = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = String(v); };
      // Top header (if visible)
      set('spLeftTop', sp.left ?? 0);
      set('tpLeftTop', tp.left ?? 0);
      // Modal right-top mini counters
      set('stSpLeftMini', sp.left ?? 0);
      set('stTpLeftMini', tp.left ?? 0);
      // Any small counters near the button (outside modal)
      set('stSpLeft', sp.left ?? 0);
      set('stTpLeft', tp.left ?? 0);
      // Used/Total for detailed displays
      set('stSpUsed', (sp.total ?? 0) - (sp.left ?? 0));
      set('stSpTotal', sp.total ?? 0);
      set('stTpUsed', (tp.total ?? 0) - (tp.left ?? 0));
      set('stTpTotal', tp.total ?? 0);
    }

    function setTotals(spTotal, tpTotal) {
      const spt = Number(spTotal || 0), tpt = Number(tpTotal || 0);
      state.sp.total = spt;
      state.sp.left = spt;
      state.tp.total = tpt; state.tp.left = tpt;
      renderSpTp();
    }

    function canSpendSp(cost) { return (state.sp.left ?? 0) >= (Number(cost) || 0); }
    function spendSp(cost) { state.sp.left = Math.max(0, (state.sp.left ?? 0) - (Number(cost) || 0)); renderSpTp(); }
    function refundSp(cost) { state.sp.left = Math.min((state.sp.total ?? 0), (state.sp.left ?? 0) + (Number(cost) || 0)); renderSpTp(); }
    function canSpendTp(cost) { return (state.tp.left ?? 0) >= (Number(cost) || 0); }
    function spendTp(cost) { state.tp.left = Math.max(0, (state.tp.left ?? 0) - (Number(cost) || 0)); renderSpTp(); }
    function refundTp(cost) { state.tp.left = Math.min((state.tp.total ?? 0), (state.tp.left ?? 0) + (Number(cost) || 0)); renderSpTp(); }
    function noSpFeedback() { alert('SP가 부족합니다.'); }
    function noTpFeedback() { alert('TP가 부족합니다.'); }
    async function loadCharTotalsAndApply(charName) {
      try {
        const url = (typeof CHAR_SHEET_SAFE !== 'undefined' && CHAR_SHEET_SAFE) ?
          CHAR_SHEET_SAFE : (typeof CHAR_SHEET !== 'undefined' ? CHAR_SHEET : null);
        if (!url) { setTotals(0, 35); return; }
        const text = await fetch(url, { cache: 'no-store' }).then(r => r.text());
        const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
        const rows = parsed.data || [];
        const key = String(charName || '').replace(/\s+/g, '');
        const row = rows.find(r => String((r['이름'] || r['캐릭터명'] || '')).replace(/\s+/g, '') === key);
        const spTotal = Number(row?.['총스포'] ?? row?.['총SP'] ?? 0) || 0;
        const tpTotal = Number(row?.['총티피'] ?? row?.['총TP'] ?? 35) || 35;
        setTotals(spTotal, tpTotal);
      } catch (e) { console.warn('[SP/TP] load totals failed', e); setTotals(0, 35); }
    }


    /* ===== 스킬 시트 로더 & 게임형(가로 칼럼) 렌더러 ===== */

    const ST_BANDS = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 65, 70, 75, 80];
    const DBSkills = { loaded: false, rows: [] };

    function parseNumber(v) {
      if (v == null) return 0;
      const m = String(v).match(/-?\d+(\.\d+)?/);
      return m ? Number(m[0]) : 0;
    }
    function bandOf(v) {
      const n = parseNumber(v);
      if (!n) return '기본';
      let best = ST_BANDS[0], dmin = 1e9;
      for (const b of ST_BANDS) { const d = Math.abs(n - b); if (d < dmin) { dmin = d; best = b; } }
      return best;
    }

    async function ensureSkillLoaded() {
      if (DBSkills.loaded) return;
      const text = await fetch(SKILL_SHEET_SAFE || SKILL_SHEET, { cache: 'no-store' }).then(r => r.text());
      const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
      const rows = (parsed.data || [])
        .map(r => {
          const name = (r['이름'] || r.name || '').toString().trim();
          if (!name) return null;
          const icon = (r['이미지'] || r.img || '').toString().trim();
          const id = (r.id || r.ID || name).toString().trim();
          const band = bandOf(r['레벨'] || r['습득레벨'] || r['레벨대'] || r['권장레벨']);
          const type = (r['분류'] || r['타입'] || '').toString().toLowerCase();
          const max = parseNumber(r['최대레벨'] || r['Max'] || r['MAX'] || 1) || 1;
          const sp = parseNumber(r['SP'] || r['sp']);
          const tp = parseNumber(r['TP'] || r['tp']);
          const cd = (r['쿨타임'] || r['쿨'] || '').toString().trim();
          const prereq = (r['선행'] || r['선행스킬'] || '').toString().trim();

          // 선택 캐릭터 필터용(있으면 사용, 없으면 전체)
          const ownerGroup = (r['직업군'] || '').toString().trim();
          const ownerName = (r['직업명'] || r['캐릭터'] || '').toString().trim();
          const ownerKey = (ownerGroup + ownerName).replace(/\s+/g, '');

          return { id, name, icon, band, type, max, sp, tp, cd, prereq, ownerKey };
        })
        .filter(Boolean);

      DBSkills.rows = rows;
      DBSkills.loaded = true;
    }

    function skillsForCurrentChar(rows) {
      const key = (state.currentCharacter?.jobGroupLabel || '') + (state.currentCharacter?.name || '');
      const want = key.replace(/\s+/g, '');
      if (!want) return rows;
      const fil = rows.filter(s => !s.ownerKey || s.ownerKey === want);
      return fil.length ? fil : rows;
    }

    /* 25.09.20 스킬트리 추가S */
    /* ===== SkillTree v2: 로더/필터/렌더 ===== */
    /** 캐시 */
    const ST2 = { loaded: false, rows: [] };
    /** 유틸: 안전 숫자 */
    const toInt = (v, def = 0) => {
      const n = Number(String(v || '').trim()); return Number.isFinite(n) ? n : def;
    };
    /** 시트 → 표준 스킬 객체 매핑 */
    // 교체할 함수
    function mapRowToSkill2(r) {
      // 1) 캐릭터 키(시트 '캐릭터명'과 정확히 일치, 공백 제거)
      const who = String(r['캐릭터명'] || '').replace(/\s+/g, '');
      // 2) 노출/정렬/좌표
      const show = Number(String(r['노출여부'] || '').trim()) === 1;
      const level = Number(String(r['스킬렙제'] || '').trim()) || 0;
      const x = Math.min(6, Math.max(1, Number(String(r['가로위치'] || '').trim()) || 1));
      const y = Math.max(1, Number(String(r['세로위치'] || '').trim()) || 1);
      // 3) 핵심 필드(스펙: 스킬명/이미지 사용)
      const name = String(r['스킬명'] || '').trim();
      const img = cleanUrl(r['이미지'] || '') || PLACEHOLDER_IMG;
      // 4) 최소/최대 스킬 레벨
      const minLv = Math.max(0, Number(String(r['최소스킬레벨'] || '').trim()) || 0);
      const maxLv = Math.max(minLv, Number(String(r['최대스킬레벨'] || '').trim()) || minLv); // 최소보다 작지 않게

      // 5) ID(없으면 스킬명 기반 대체)
      const idSrc = String(r['ID'] ?? r['id'] ?? name).trim();
      const id = idSrc || ('SK_' + Math.random().toString(36).slice(2));
      // SP cost per level
      const sp = toInt(r['소모 SP'] ?? r['소모SP'] ?? r['SP'] ?? r['sp'] ?? 0, 0);
      const tpCost = toInt(r['tp설정'] ?? r['TP설정'] ?? r['tp 설정'] ?? r['TP 설정'] ?? r['tp'] ?? r['TP'] ?? 0, 0);
      return { id, name, img, who, show, level, x, y, minLv, maxLv, sp, tpCost };
    }



    /** 시트 로드(1회) */
    async function ensureSkillLoaded2() {
      if (ST2.loaded) return;
      const text = await fetch(SKILL_SHEET, { cache: 'no-store' }).then(r => r.text());
      const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
      const rows = (parsed.data || []).map(mapRowToSkill2).filter(s => s.id && s.name && s.who);
      ST2.rows = rows;
      ST2.loaded = true;
    }

    /** 현재 캐릭터 키 얻기 (남귀검사+이름) */
    function currentCharKey() {
      const k = currentSkillOwnerKey?.() || '';      // 이미 코드에 있는 함수 재활용
      return String(k).replace(/\s+/g, '') || null;
    }

    /* ===== TP 범위 & 상태 ===== */
    const TP_MIN = 0, TP_MAX = 7;
    state.skillTpLv = state.skillTpLv || {}; // { skillId: tpLevel }

    /* ===== 길게누르기(민감 완화): pointer 이벤트 기반 ===== */
    function attachPressRepeat(btn, stepFn) {
      let timer = null, active = false, interval = 180;
      const start = (e) => {
        e.preventDefault();
        if (btn.disabled) return;
        active = true;
        stepFn(); // 첫 눌림 즉시 1회
        let firstDelay = 500; // 초기 지연
        timer = setTimeout(function kick() {
          if (!active) return;
          stepFn();
          interval = Math.max(120, interval);     // 최소 120ms
          timer = setTimeout(kick, interval);
        }, firstDelay);
      };
      const stop = () => {
        active = false;
        if (timer) { clearTimeout(timer); timer = null; interval = 180; }
      };

      // pointer 계열만 사용해 중복 이벤트 방지
      btn.addEventListener('pointerdown', start);
      ['pointerup', 'pointerleave', 'pointercancel', 'blur'].forEach(ev => btn.addEventListener(ev, stop));
      window.addEventListener('pointerup', stop);
    }

    /* ===== 렌더러 교체 ===== */
    async function renderSkillTreeBands() {
      await ensureSkillLoaded2();

      // 현재 캐릭터 키
      const key = currentCharKey?.();
      const wrap = document.getElementById('stGrid');
      wrap.className = 'st2-wrap';
      wrap.innerHTML = '';

      {
        const nmEl = document.getElementById('stCharName');
        if (nmEl) nmEl.textContent = (state.currentCharacter && state.currentCharacter.name) ? state.currentCharacter.name : '—';
      }
      if (!key) {
        wrap.innerHTML = `<div style="color:#c7b589; padding:8px;">캐릭터를 먼저 선택해 주세요.</div>`;
        return;
      }

      // 1) 캐릭터 일치 + 노출=1
      let list = ST2.rows.filter(s => s.who === String(key).replace(/\s+/g, '') && s.show);
      // 2) 정렬: 스킬렙제 → 세로 → 가로 → 이름
      list.sort((a, b) => a.level - b.level || a.y - b.y || a.x - b.x || a.name.localeCompare(b.name));
      const levels = [...new Set(list.map(s => s.level))];
      if (levels.length === 0) {
        wrap.innerHTML = `<div style="color:#c7b589; padding:8px;">표시할 스킬이 없습니다.</div>`;
        return;
      }

      // 유틸: 경계 보정
      const clampSkill = (s, v) => Math.max(s.minLv ?? 0, Math.min(s.maxLv ?? 0, Number(v) || 0));
      const clampTp = (v) => Math.max(TP_MIN, Math.min(TP_MAX, Number(v) || 0));
      const getSkill = (s) => {
        if (state.skillLv[s.id] === undefined) state.skillLv[s.id] = clampSkill(s, s.minLv ?? 0);
        return clampSkill(s, state.skillLv[s.id]);
      };
      const setSkill = (s, v) => {
        const target = clampSkill(s, v);
        const cur = getSkill(s);
        const delta = target - cur;
        const per = Number(s.sp || 0);
        if (delta > 0) {
          const cost = per * delta;
          if (!canSpendSp(cost)) { noSpFeedback(); return; }
          state.skillLv[s.id] = target;
          spendSp(cost);
        } else if (delta < 0) {
          state.skillLv[s.id] = target;
          refundSp(per * (-delta));
        } else {
          state.skillLv[s.id] = target;
        }
      };
      const getTp = (s) => {
        if (state.skillTpLv[s.id] === undefined) state.skillTpLv[s.id] = TP_MIN;
        return clampTp(state.skillTpLv[s.id]);
      };
      const setTp = (s, v) => {
        const unit = Number(s.tpCost || 0);
        if (!Number.isFinite(unit) || unit <= 0) return; // TP 강화 미지원
        const target = clampTp(v);
        const cur = getTp(s);
        if (target > cur) {
          const need = (target - cur) * unit;
          if (!canSpendTp(need)) { noTpFeedback(); return; }
          spendTp(need);
        } else if (target < cur) {
          const back = (cur - target) * unit;
          refundTp(back);
        }
        state.skillTpLv[s.id] = target;
      };

      // 레벨 밴드 단위로 DOM 생성
      levels.forEach(lvl => {
        const group = list.filter(s => s.level === lvl);

        // ✅ 밴드 컨테이너(점선+라벨+그리드 포함)
        const band = document.createElement('div');
        band.className = 'st2-band';

        const label = document.createElement('div');
        label.className = 'st2-band-label';
        label.textContent = String(lvl);
        band.appendChild(label);

        // 이 밴드 안의 6열 그리드
        const grid = document.createElement('div');
        grid.className = 'st2-grid';

        group.forEach(s => {
          const tile = document.createElement('div');
          tile.className = 'st2-tile';
          tile.style.gridColumn = String(s.x);
          tile.style.gridRow = String(s.y || 1);

          // 아이콘(원형)
          const icon = document.createElement('div');
          icon.className = 'st2-skill';
          const img = document.createElement('img');
          img.alt = s.name; img.src = s.img || PLACEHOLDER_IMG;
          img.onerror = () => {
            icon.classList.add('st2-empty');
            img.remove();
            const ini = document.createElement('div');
            ini.className = 'st2-initial';
            ini.textContent = (s.name || '?').slice(0, 1);
            icon.appendChild(ini);
          };
          icon.appendChild(img);

          // ★ 스킬명 (아이콘과 레벨박스 사이의 '독립' 줄)
          const nameEl = document.createElement('div');
          nameEl.className = 'st2-name';
          nameEl.textContent = s.name;
          nameEl.title = s.name; // 말줄임 보완용 툴팁

          // 컨트롤(2행 × 3열)
          const ctrl = document.createElement('div');
          ctrl.className = 'st2-ctrl2';

          // 좌측-상단(스킬: Max 위, + 아래) — 가운데 정렬
          const LTop = document.createElement('div');
          LTop.className = 'st2-side-left';
          const btnSkillMax = document.createElement('button'); btnSkillMax.className = 'st2-btn'; btnSkillMax.textContent = 'Max';
          const btnSkillPlus = document.createElement('button'); btnSkillPlus.className = 'st2-btn'; btnSkillPlus.textContent = '+';
          LTop.appendChild(btnSkillMax);
          LTop.appendChild(btnSkillPlus);

          // 좌측-하단(스킬: − 위, Min 아래)
          const LBot = document.createElement('div');
          LBot.className = 'st2-side-left';
          const btnSkillMinus = document.createElement('button'); btnSkillMinus.className = 'st2-btn'; btnSkillMinus.textContent = '−';
          const btnSkillMin = document.createElement('button'); btnSkillMin.className = 'st2-btn'; btnSkillMin.textContent = 'Min';
          LBot.appendChild(btnSkillMinus);
          LBot.appendChild(btnSkillMin);

          // 중앙 레벨 표시(“스킬 │ TP”)
          // 중앙 레벨 표시(세로 중앙 고정, “스킬명” + “스킬 │ TP”)
          const lvBox = document.createElement('div');
          lvBox.className = 'st2-lv';



          // 숫자 라인(아랫줄): “스킬 │ TP”
          const nums = document.createElement('div');
          nums.className = 'st2-lvnums';

          const spanCur = document.createElement('span');
          spanCur.className = 'cur';
          const spanSep = document.createElement('span'); spanSep.className = 'sep'; spanSep.textContent = '│';
          const spanTp = document.createElement('span');
          spanTp.className = 'tp';

          nums.appendChild(spanCur);
          nums.appendChild(spanSep);
          nums.appendChild(spanTp);


          lvBox.appendChild(nums);


          // 우측-상단(TP: Max 위, + 아래)
          const RTop = document.createElement('div');
          RTop.className = 'st2-side-right';
          const btnTpMax = document.createElement('button'); btnTpMax.className = 'st2-btn'; btnTpMax.textContent = 'Max';
          const btnTpPlus = document.createElement('button'); btnTpPlus.className = 'st2-btn'; btnTpPlus.textContent = '+';
          RTop.appendChild(btnTpMax);
          RTop.appendChild(btnTpPlus);

          // 우측-하단(TP: − 위, Min 아래)
          const RBot = document.createElement('div');
          RBot.className = 'st2-side-right';
          const btnTpMinus = document.createElement('button'); btnTpMinus.className = 'st2-btn'; btnTpMinus.textContent = '−';
          const btnTpMin = document.createElement('button'); btnTpMin.className = 'st2-btn'; btnTpMin.textContent = 'Min';
          RBot.appendChild(btnTpMinus);
          RBot.appendChild(btnTpMin);

          // 컨트롤 그리드 배치
          LTop.style.gridColumn = '1'; LTop.style.gridRow = '1';
          LBot.style.gridColumn = '1'; LBot.style.gridRow = '2';
          lvBox.style.gridColumn = '2'; lvBox.style.gridRow = '1 / span 2';
          RTop.style.gridColumn = '3'; RTop.style.gridRow = '1';
          RBot.style.gridColumn = '3'; RBot.style.gridRow = '2';

          ctrl.appendChild(LTop); ctrl.appendChild(LBot);
          ctrl.appendChild(lvBox);
          ctrl.appendChild(RTop); ctrl.appendChild(RBot);

          tile.appendChild(icon);
          tile.appendChild(nameEl);
          tile.appendChild(ctrl);
          grid.appendChild(tile);

          // 상태 → UI 반영
          const refresh = () => {
            const cur = getSkill(s);
            const tp = getTp(s);
            spanCur.textContent = String(cur);
            spanTp.textContent = String(tp);
            // 스킬 경계
            btnSkillPlus.disabled = (cur >= s.maxLv);
            btnSkillMax.disabled = (cur >= s.maxLv);
            btnSkillMinus.disabled = (cur <= s.minLv);
            btnSkillMin.disabled = (cur <= s.minLv);
            // TP 경계 (스킬별 tpCost 적용)
            const unit = Number(s.tpCost || 0);
            if (!Number.isFinite(unit) || unit <= 0) {
              btnTpPlus.disabled = true;
              btnTpMax.disabled = true;
              btnTpMinus.disabled = true;
              btnTpMin.disabled = true;
            } else {
              btnTpPlus.disabled = (tp >= TP_MAX) || !canSpendTp(unit);
              btnTpMax.disabled = (tp >= TP_MAX) || !canSpendTp((TP_MAX - tp) * unit);
              btnTpMinus.disabled = (tp <= TP_MIN);
              btnTpMin.disabled = (tp <= TP_MIN);
            }
          };
          refresh();
          // 조작 함수
          const stepSkillUp = () => { setSkill(s, getSkill(s) + 1); refresh(); };
          const stepSkillDn = () => { setSkill(s, getSkill(s) - 1); refresh(); };
          const toSkillMax = () => { setSkill(s, s.maxLv); refresh(); };
          const toSkillMin = () => { setSkill(s, s.minLv); refresh(); };

          const stepTpUp = () => { setTp(s, getTp(s) + 1); refresh(); };
          const stepTpDn = () => { setTp(s, getTp(s) - 1); refresh(); };
          const toTpMax = () => { setTp(s, TP_MAX); refresh(); };
          const toTpMin = () => { setTp(s, TP_MIN); refresh(); };

          // 길게누르기(민감도 완화)
          attachPressRepeat(btnSkillPlus, stepSkillUp);
          attachPressRepeat(btnSkillMinus, stepSkillDn);
          attachPressRepeat(btnSkillMax, toSkillMax);
          attachPressRepeat(btnSkillMin, toSkillMin);

          attachPressRepeat(btnTpPlus, stepTpUp);
          attachPressRepeat(btnTpMinus, stepTpDn);
          attachPressRepeat(btnTpMax, toTpMax);
          attachPressRepeat(btnTpMin, toTpMin);
        });

        band.appendChild(grid);
        wrap.appendChild(band);
      });
    }




    /** 버튼 연결 (기존 old 렌더러 바인딩이 있다면 교체) */
    const stModal = document.getElementById('skillTreeModal');
    const btnST = document.getElementById('btnSkillTree');
    if (btnST) {
      btnST.onclick = async () => {
        await renderSkillTreeBands();
        stModal?.classList.add('show');
        stModal?.setAttribute('aria-hidden', 'false');
      };
    }

    /* ESC로 닫기(선택 사항) */
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.querySelectorAll('.modal.show').forEach(m => {
          m.classList.remove('show'); m.setAttribute('aria-hidden', 'true');
        });
      }
    });
    /* 25.09.20 스킬트리 추가 F*/

    /* 버튼으로 열기 */
    document.getElementById('btnSkillTree')?.addEventListener('click', async () => {
      await renderSkillTreeBands(); /*25.09.20변경*/
      stModal?.classList.add('show');
      stModal?.setAttribute('aria-hidden', 'false');
    });
    stModal?.addEventListener('click', (e) => {
      if (e.target.classList?.contains('backdrop') || e.target.hasAttribute?.('data-close')) {
        stModal.classList.remove('show');
        stModal.setAttribute('aria-hidden', 'true');
      }
    });
    // 룬 각인 선택 결과(한 개만 유지)
    state.runeEngrave = state.runeEngrave || null; // {name, tag, stats, ...}
//일반스킬룬
    const RUNE_LEVELS = [15, 20, 25, 30, 35, 40, 45, 65];
    const RUNE_CATS = [
      { key: 'awakening', label: '각성' },
      { key: 'magic', label: '마력' },
      { key: 'illusion', label: '허상' },
      { key: 'training', label: '숙련' },
      { key: 'technique', label: '기교' }
    ];
    state.runes = state.runes || {}; // {catKey: {level: count}}
    function ensureRunesInitialized() {
      RUNE_CATS.forEach(c => {
        state.runes[c.key] ||= {};
        RUNE_LEVELS.forEach(lvl => {
          if (typeof state.runes[c.key][lvl] !== 'number') state.runes[c.key][lvl] = 0;
        });
      });
    }

    function countSelectedRunes() {
      let sum = 0;
      Object.values(state.runes).forEach(row => {
        Object.values(row).forEach(v => sum += (Number(v) || 0));
      });
      return sum;
    }
    function updateRuneCountSummary() {
      const n = countSelectedRunes();
      const a = document.getElementById('runeCount'); if (a) a.textContent = n;
      const b = document.getElementById('runeCountLabel'); if (b) b.textContent = n;
    }

    state.options = state.options || {
      avatar: null,        // 'rare' | 'advanced'
      weaponImprint: null, // 'add5' | 'patkmatk5' | 'patkmatk3' | 'monster' | 'quest'
      timeWindow: null,    // '30s' | '1m' | '3m' | '5m' | '10m'
      monster: null,       // 'nugol' | 'blackdragon' | 'asmar_calix'
      difficulty: null     // 'hard' | 'normal' | 'easy' | 'nugol_room'
    };
    /* ▼ 드롭다운 value → 시트 '이름' 매핑 */
    const AVATAR_NAME = {
      rare: '레어 아바타',
      advanced: '상급 아바타'
    };
    const IMPRINT_NAME = {
      add5: '추뎀 5% 무기압',
      patkmatk5: '물/마공 5% 무기압',
      patkmatk3: '물/마공 3% 무기압',
      monster: '몬스터 무기압',
      quest: '퀘스트 무기압'
    };
    /* ▼ 드롭다운 value → 시트 '몬스터명' 매핑 */
const MONSTER_NAME = {
  nugol: '거대누골',
  blackdragon: '흑룡',
  anton: '안톤',
  asmar_calix: '아스마르/칼릭스'
};

// 드롭다운 변경 시 호출
async function onMonsterChange(selectedName) {
  await ensureMonsterLoaded();
  const row = DBMonster.rows.find(r => String(r['몬스터명']).trim() === selectedName);

  state.options = state.options || {};
  state.options.monster = selectedName;

  if (row) {
    state.monster = {
      level:   Number(row['몬스터레벨']) || 0,
      defRate: Number(row['방어율']) || 0,
      fire:    Number(row['화속성저항']) || 0,
      water:   Number(row['수속성저항']) || 0,
      light:   Number(row['명속성저항']) || 0,
      dark:    Number(row['암속성저항']) || 0,
    };
  } else {
    state.monster = { level:0, defRate:0, fire:0, water:0, light:0, dark:0 };
  }
}

document.getElementById('selMonster').value

    /* 선택된 시트 아이템(스탯 묶음) 보관 슬롯 */
    state.options.avatarEnh = state.options.avatarEnh || null; // {name,type,img,stats...}
    state.options.imprintEnh = state.options.imprintEnh || null;
    /* 몬스터 선택 결과 저장 슬롯(정보/저항 등) */
    state.monster = state.monster || null; // { name, info, stats, raw }
    // 슬롯 키 매핑
    const SLOT_MAP = {    //슬롯 약어, 사용할땐 SLOT_MAP["L1"]; 처럼 씀
      L1: 'headshoulder', L2: 'top', L3: 'bottom', L4: 'belt', L5: 'shoes',
      R1: 'weapon', R2: 'bracelet', R3: 'necklace', R4: 'ring', R5: 'support',
      C1: 'aura', C2: 'title', C3: 'creature', C4: 'artifact'
    };
    window.SLOT_MAP = SLOT_MAP;   // 브라우저 전역 객체, SLOT_MAP을 전역 변수로 등록 = 다른 스크립트 파일이나 브라우저 콘솔에서도 접근 가능
    // 시트 CSV
    const SHEETS = {
      weapon: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=0&single=true&output=csv',
      headshoulder: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1000757262&single=true&output=csv',
      top: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1569046334&single=true&output=csv',
      bottom: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1718584858&single=true&output=csv',
      belt: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=838932361&single=true&output=csv',
      shoes: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1115829955&single=true&output=csv',
      bracelet: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=536618777&single=true&output=csv',
      necklace: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=153115539&single=true&output=csv',
      ring: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1055177081&single=true&output=csv',
      support: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=764071293&single=true&output=csv',
      aura: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1219077337&single=true&output=csv',
      title: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=155098088&single=true&output=csv',
      creature: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1416838764&single=true&output=csv',
      artifact: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1677465031&single=true&output=csv'
    };
    const CHAR_SHEET = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=303201035&single=true&output=csv';
    /* 강화마봉마부 시트(강화/엠블렘 공용) */
    const ENHANCE_SHEET = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=680909478&single=true&output=csv';
    /* ▼ 스킬트리 시트 (CSV Publish URL로 교체) */
    const SKILL_SHEET = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1356906568&single=true&output=csv';
    const Monster_SHEET = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=1366990880&single=true&output=csv';
    window.BUFF_SHEET = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTBbUTibxtZhRBO7zEeoaJYoymn2m2RfYZ-S80O4DiUxE0r3NKzGJmikkjSUDjiFg8Kpnls7ucSIrFX/pub?gid=113170614&single=true&output=csv';
    
    const ALLOWED_WEAPON_TYPES = {
      slayer: ['소검', '도', '둔기', '대검', '광검'],
      gunner: ['리볼버', '자동권총', '머스켓', '핸드캐넌', '보우건'],
      fighter: ['너클', '건틀릿', '클로', '권투글러브', '통파'],
      priest: ['십자가', '염주', '토템', '낫', '배틀액스'],
      warrior: ['락소드', '윙블레이드'],
      mage: ['스태프', '로드', '봉', '창', '빗자루'],
      spear: ['미늘창', '투창'],
      thief: ['단검', '쌍검', '차크라웨펀']
    };
    // DB
    const DB = { itemsBySlot: {}, loaded: {}, chars: { loaded: false, groups: [] } };
    const DBEnh = { loaded: false, list: [], byType: {} };
    /* ===== 유틸 ===== */
    const num = v => (v === '' || v == null ? 0 : Number(v));
    const pct = v => { if (v === '' || v == null) return 0; const s = String(v).trim().replace('%', ''); const n = Number(s); return isNaN(n) ? 0 : n / 100; };
    const list = v => (v ? String(v).replaceAll(';', ',').split(',').map(s => s.trim()).filter(Boolean) : []);
    const normalizeJobGroup = (s) => {
      s = (s || '').toLowerCase();
      if (['남귀검사', '여귀검사', '귀검사', 'slayer'].some(k => s.includes(k))) return 'slayer';
      if (['마법사', '여마법사', '남마법사', 'mage'].some(k => s.includes(k))) return 'mage';
      if (['남거너', '여거너'].some(k => s.includes(k))) return 'gunner';
      if (['격투가', '남격투가', '여격투가'].some(k => s.includes(k))) return 'fighter';
      if (['프리스트', '여프리스트', '남프리스트'].some(k => s.includes(k))) return 'priest';
      if (['워리어'].some(k => s.includes(k))) return 'warrior';
      if (['마창사'].some(k => s.includes(k))) return 'spear';
      if (['도적'].some(k => s.includes(k))) return 'thief';
      return s || 'slayer';
    };
    const normalizePower = (s) => {     //물 을 phys 로 변경, 마 를 mag 로 변경
      s = (s || '').toLowerCase();
      if (['물', 'phys', 'str', 'physical'].some(k => s.includes(k))) return 'phys';
      if (['마', 'mag', 'int', 'magic', '마법'].some(k => s.includes(k))) return 'mag';
      return null;
    };
    const powerLabel = (p) => p === 'phys' ? '물리' : p === 'mag' ? '마법' : '물리/마법';   // phys 를 물리 로 변경, mag를 마법, ?(이면), :(아니면) 따라서 p가 phys 이면 물리, 아니면 p가 mag 이면 마법 아니면 물리/마법

    const PLACEHOLDER_IMG = 'data:image/svg+xml;utf8,' + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='10' fill='#0c0a08'/><path d='M10 48L26 30l10 12 8-8 10 14' stroke='#9cc7ff' stroke-width='4' fill='none'/></svg>");
    function cleanUrl(u) { if (!u) return ''; return String(u).replace(/^\s+|\s+$/g, '').replace(/^["']|["']$/g, '').replace(/\\/g, '/'); }

    /* ===== 행 → 아이템 매핑 ===== */
    function mapRowToItem(r) {
      const pick = (...ks) => { for (const k of ks) { if (r[k] != null && String(r[k]).trim() !== '') return r[k]; } return ''; };  // 이건 그냥 헬퍼 : 처음으로 값이 제대로 있는 컬럼 반환
      const skill_levels = [];    //레벨링(10), 레벨렝(15) 같은 컬럼 있으면 숫자로 변환하여 누적
      [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 65, 70, 75, 80].forEach(lv => {
        const v = Number(pick(`레벨링(${lv})`));
        if (!isNaN(v) && v !== 0) skill_levels.push({ skill_id: `LV${lv}`, delta: v });
      });
      const jgs = list(pick('직업군', 'job_groups')).map(normalizeJobGroup);    // 직업군 텍스트를 배열화 하고 표준코드로 통일 (귀검사, 남거너 등)
      return {        // 최종 아이템 객체 반환
        id: String(r.id || r.ID || Date.now().toString(36) + Math.random().toString(36).slice(2)),
        slot: 'unknown',
        name: String(pick('이름', 'name')),
        img: cleanUrl(pick('이미지', 'img')) || PLACEHOLDER_IMG,
        job_groups: jgs,
        type: String(pick('종류', 'type')),
        rarity: r.rarity || r.등급 || 'epic',
        rarity_kr: pick('등급') || undefined,
        level: num(pick('렙제', '레벨', 'level')) || 65,
        level_text: (() => { const v = pick('렙제', '레벨', 'level'); return (v === undefined || v === null || String(v).trim() === '') ? '' : String(v).trim(); })(),
        stats: {
          phys_atk: num(pick('물리 데미지', '물리데미지', 'phys_atk')),
          mag_atk: num(pick('마법 데미지', '마법데미지', 'mag_atk')),
          str: num(pick('힘', 'str')),
          int: num(pick('지능', 'int')),
          acc: num(pick('적중', 'acc')),
          phys_crit: num(pick('물리 크리티컬', '물리크리티컬', 'phys_crit')),
          mag_crit: num(pick('마법 크리티컬', '마법크리티컬', 'mag_crit')),
          phys_crit_rate: pct(pick('물리 크리티컬(%)', 'phys_crit_rate%')),
          mag_crit_rate: pct(pick('마법 크리티컬(%)', 'mag_crit_rate%')),
          add_damage: pct(pick('추가데미지(%)', 'add_damage%')),
          counter_add_damage: pct(pick('카운터뎀증(%)', 'counter_add_damage%')) || pct(pick('카운터추뎀(%)')),
          str_pct: pct(pick('힘(%)', 'str_pct%')),
          int_pct: pct(pick('지능(%)', 'int_pct%')),
          damage_inc: pct(pick('뎀증(%)', 'damage_inc%')),
          counter_damage_inc: pct(pick('카운터뎀증(%)', 'counter_damage_inc%')),
          crit_damage_inc: pct(pick('크증뎀(%)', 'crit_damage_inc%')),
          phys_atk_pct: pct(pick('물리 공격력(%)', '물리공격력(%)', 'phys_atk_pct%')),
          mag_atk_pct: pct(pick('마법 공격력(%)', '마법공격력(%)', 'mag_atk_pct%')),
          skill_atk_inc: pct(pick('스증(%)', 'skill_atk_inc%')),
          elem: { fire: num(pick('화', 'elem_fire')), water: num(pick('수', 'elem_water')), light: num(pick('명', 'elem_light')), dark: num(pick('암', 'elem_dark')), all: 0 },
          elem_add_damage: {
            fire: pct(pick('화속추', 'elem_add_fire%')),
            water: pct(pick('수속추', 'elem_add_water%')),
            light: pct(pick('명속추', 'elem_add_light%')),
            dark: pct(pick('암속추', 'elem_add_dark%'))
          },
          speed: { attack: pct(pick('공속', 'speed_attack%')), move: pct(pick('이속', 'speed_move%')), cast: pct(pick('캐속', 'speed_cast%')) },
          cdr: pct(pick('쿨감')),
          dot_add: { poison: pct(pick('중독추뎀')), bleed: pct(pick('출혈추뎀')), burn: pct(pick('화상추뎀')), shock: pct(pick('감전추뎀')) },
          dot_inc: { poison: pct(pick('중독뎀증')), bleed: pct(pick('출혈뎀증')), burn: pct(pick('화상뎀증')), shock: pct(pick('감전뎀증')) },
          other: { def_break_inc: pct(pick('방깎뎀증')), enchant_bleed: num(pick('인챈출혈')) }
        },
        effects: [],
        notes: [pick('설명', 'notes1'), pick('설명2', 'notes2'), pick('설명3', 'notes3')].filter(Boolean),
        skill_levels,
        raw: r
      };
    }

    /* ===== 강화 행 매핑 (이미지/태그/단계 지원) ===== */
    function mapRowToEnhance(r) {
      const get = (k) => r[k] ?? r[k?.toLowerCase()] ?? '';
      const num = (v) => (v === '' || v == null ? 0 : Number(v));
      const pct = (v) => { if (v === '' || v == null) return 0; const s = String(v).trim().replace('%', ''); const n = Number(s); return isNaN(n) ? 0 : n / 100; };
      const name = String(get('이름') || get('강화명') || get('표시명') || '').trim();
      const type = String(get('종류') || '').trim(); // ex) 붉은빛엠블렘 / 플래티넘엠블렘 / 무기강화 ...
      const img = cleanUrl(get('이미지')) || PLACEHOLDER_IMG;
      const tag = String(get('렙제') || '').trim();        // 플래티넘 분류용(화속성/수속성/..)
      const lvlMatch = name.match(/(\d+)\s*단계/);
      const level_num = lvlMatch ? parseInt(lvlMatch[1], 10) : null;

      const stats = {
        phys_atk: num(get('물리 데미지')) || num(get('물리데미지')),
        mag_atk: num(get('마법 데미지')) || num(get('마법데미지')),
        str: num(get('힘')), int: num(get('지능')),
        phys_crit: num(get('물리 크리티컬')) || num(get('물리크리티컬')),
        mag_crit: num(get('마법 크리티컬')) || num(get('마법크리티컬')),
        phys_crit_rate: pct(get('물리 크리티컬(%)')),
        mag_crit_rate: pct(get('마법 크리티컬(%)')),
        add_damage: pct(get('추가데미지(%)')),
        str_pct: pct(get('힘(%)')), int_pct: pct(get('지능(%)')),
        damage_inc: pct(get('뎀증(%)')),
        crit_damage_inc: pct(get('크증뎀(%)')),
        phys_atk_pct: pct(get('물리 공격력(%)')) || pct(get('물리공격력(%)')),
        mag_atk_pct: pct(get('마법 공격력(%)')) || pct(get('마법공격력(%)')),
        skill_atk_inc: pct(get('스증(%)')),
        elem: { fire: num(get('화')), water: num(get('수')), light: num(get('명')), dark: num(get('암')), all: 0 },
        cdr: pct(get('쿨감')),
        speed: { attack: pct(get('공속')), move: pct(get('이속')), cast: pct(get('캐속')) },
        other: { def_break_inc: pct(get('방깎뎀증')) }
      };
      return { name, type, img, tag, level_num, stats };
    }

    /* ===== 시트 로더 ===== */
    async function loadSheet(slotKey) {
      if (DB.loaded[slotKey]) return;
      const url = SHEETS[slotKey]; if (!url) return;
      const text = await fetch(url, { cache: 'no-store' }).then(r => r.text());
      const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
      const items = parsed.data.map(mapRowToItem).map(it => ({ ...it, slot: slotKey }));
      DB.itemsBySlot[slotKey] = items;
      DB.loaded[slotKey] = true;
      console.log(`[Sheets] ${slotKey} loaded:`, items.length);
    }
    async function ensureLoaded(slotKey) { if (!DB.loaded[slotKey]) await loadSheet(slotKey); }

    /* 강화/엠블렘 시트 로더 */
    async function ensureEnhLoaded() {
      if (DBEnh.loaded) return;
      const text = await fetch(ENHANCE_SHEET, { cache: 'no-store' }).then(r => r.text());
      const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
      const rows = (parsed.data || []).map(mapRowToEnhance).filter(x => (x.name && x.type));
      DBEnh.list = rows;
      DBEnh.byType = rows.reduce((acc, x) => { (acc[x.type] ||= []).push(x); return acc; }, {});
      DBEnh.loaded = true;
      console.log('[Enhance] loaded:', rows.length);
    }

//몬스터 시트 로더
let DBMonster = { loaded: false, rows: [] };

async function ensureMonsterLoaded() {
  if (DBMonster.loaded) return;
  try {
    const res = await fetch(Monster_SHEET);
    const text = await res.text();

    // Papa.parse 사용
    const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
    DBMonster.rows = parsed.data;

    DBMonster.loaded = true;
    console.log('[Monster] 로드 성공:', DBMonster.rows.length, '행');
  } catch (e) {
    console.error('[Monster] 시트 로딩 실패', e);
  }
}


    /* ===== 룬 각인 드롭다운(시트 연동) ===== */

    // 시트에서 '룬각인'만 추리기 (byType 우선, 없으면 filter)
    function getRuneEngraveRows() {
      const base = (DBEnh?.byType?.['룬각인']) || (DBEnh?.list || []).filter(x => x.type === '룬각인');
      return base || [];
    }

    // 이름 목록(중복 제거, “시트 순서 유지”)
    async function buildRuneEngraveNameOptions() {
      await ensureEnhLoaded();
      const rows = getRuneEngraveRows();
      const seen = new Set(); const names = [];
      rows.forEach(r => { const k = (r.name || '').trim(); if (k && !seen.has(k)) { seen.add(k); names.push(k); } });
      const sel1 = document.getElementById('selRuneEngrave');
      if (!sel1) return;
      sel1.innerHTML = `<option value="" selected disabled>룬 각인 설정</option>`;
      names.forEach(n => {
        const op = document.createElement('option'); op.value = n; op.textContent = n; sel1.appendChild(op);
      });
      // 이전 선택 복구가 필요하면 여기서 sel1.value = ... 후 detail 채우기
    }

    // 세부 설정(렙제) 옵션 채우기 — 이름과 종류=룬각인 일치 행들의 tag(렙제)만
    async function populateRuneDetailOptions(name) {
      await ensureEnhLoaded();
      const sel2 = document.getElementById('selRuneDetail');
      if (!sel2) return;

      sel2.disabled = true;
      sel2.innerHTML = `<option value="" selected disabled>세부 설정</option>`;

      if (!name) return;
      const rows = getRuneEngraveRows().filter(r => (r.name || '').trim() === String(name).trim());
      // 중복 제거(시트 순서 유지)
      const seenTag = new Set();
      rows.forEach(r => {
        const t = (r.tag || '').trim(); if (!t) return;
        if (!seenTag.has(t)) { seenTag.add(t); const op = document.createElement('option'); op.value = t; op.textContent = t; sel2.appendChild(op); }
      });
      sel2.disabled = false;
    }

    // (이름, tag)로 정확히 1행 매칭하여 합산에 반영
    function applyRuneEngraveByNameTag(name, tag) {
      const rows = getRuneEngraveRows();
      const row = rows.find(r => (r.name || '').trim() === String(name).trim() && (r.tag || '').trim() === String(tag).trim()) || null;
      state.runeEngrave = row ? { name: row.name, tag: row.tag, stats: row.stats } : null;
      recalcAndRenderPanel();
    }
    /* ENHANCE_SHEET에서 '이름' 정확 일치로 1개 찾기 */
    function findEnhByExactName(name) {
      if (!name) return null;
      const list = DBEnh?.list || [];
      const key = String(name).trim();
      return list.find(x => (x?.name || '').trim() === key) || null;
    }

    /* 아바타/무기압 선택 → 시트에서 찾아 상태에 보관 → 합산 갱신 */
    async function applyAvatarEnhFromState() {
      await ensureEnhLoaded();
      const name = AVATAR_NAME[state.options.avatar] || null;
      state.options.avatarEnh = name ? findEnhByExactName(name) : null;
      recalcAndRenderPanel();
    }
    async function applyImprintEnhFromState() {
      await ensureEnhLoaded();
      const name = IMPRINT_NAME[state.options.weaponImprint] || null;
      state.options.imprintEnh = name ? findEnhByExactName(name) : null;
      recalcAndRenderPanel();
    }
    /* ===== 캐릭터 시트 로더 ===== */
    const characterCard = document.getElementById('characterCard');
    const characterImg = document.getElementById('characterImg');
    const characterGhost = document.getElementById('characterGhost');
    const charModal = document.getElementById('charModal');
    const catalogEl = document.getElementById('catalog'); /*<div id="catalog" class="catalog"></div> 를 JS변수 catalogEl로 참조*/
    const DBChars = { loaded: false, groups: [] }; //전역 캐시 객체, 한번 로드되면 다시 안불러오게함, loaded : 시트가 이미 로드됐는지, groups : 화면에 뿌릴 최종 데이터(그룹배열)

    async function loadCharacterSheet() {     //시트 텍스트를 받아 파싱 - 그룹화 - DBChars 에 저장
      if (DBChars.loaded) return;   // DBChars 가 이미 로드되어있다면 재호출 방지(중복 fetch막기)
      try {   // try는 예외처리(오류처리) 구문, try {...} 안에서 오류가 발생하면 프로그램이 죽지 않고 catch 블록으로 넘어가게된다. await는 비동기 작업 끝날때까지 기다리라는 뜻, 반드시 async function 에서 쓸수 있음
        const text = await fetch(CHAR_SHEET).then(r => r.text());    //CHAR_SHEET(캐릭터시트 CSV URL)에서 텍스트로 가져오기, 브라우저 캐시 쓰지 않고 항상 새로 받기
        const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });    //header: true = 첫 행을 컬럼명으로 사용
        const rows = parsed.data || [];
        const groupsMap = new Map();    //그룹(직업군)별로 묶기 위해 Map 사용(키: 직업군 제목), Map은 자바스크립트의 키값 저장소. 객체 {}랑 비슷하지만, 문자열뿐아니라 객체도 가능, 삽입순서기억.
        rows.forEach(r => {       // r => r.text() 는 function(r) { return r.text(); } 와 동일함. 간단버전. 즉, 응답 객체 r을 받아서 r.text()를 반환한다는 함수.
          const groupTitle = (r['직업군'] || '').toString().trim();   //각 행에서 직업군/이름 추출
          const name = (r['이름'] || '').toString().trim();
          if (!groupTitle || !name) return;   // 둘 중 하나라도 없으면 스킵
          const thumb = cleanUrl(r['렙제']);   // 카드 썸네일, cleanUrl은 URL 잘못된곳 정리 하는 유틸
          const full = cleanUrl(r['이미지']);  // 중앙 큰 이미지
          const badge = cleanUrl(r['종류']);   // 직업군 배지
          const power = normalizePower(r['물마공']); // normalizePower 함수로 물리/마법 공격 구분
          if (!groupsMap.has(groupTitle)) {   // 처음 보는 직업군이면 새로운 그룹 객체 생성, title : 그룹명(남귀검사), badgeSrc : 배지 이미지
            groupsMap.set(groupTitle, { title: groupTitle, badgeSrc: badge || PLACEHOLDER_IMG, items: [] });
          }
          const g = groupsMap.get(groupTitle);
          if (badge && (!g.badgeSrc || g.badgeSrc === PLACEHOLDER_IMG)) g.badgeSrc = badge;
          g.items.push({ id: name, name, thumbSrc: thumb || PLACEHOLDER_IMG, fullSrc: full || PLACEHOLDER_IMG, power });  //그룹의 items에 캐릭터 카드 데이터 추가, 썸네일과 큰 이미지
        });
        DBChars.loaded = true;    // 모든 행 처리후 loaded=true 로 표시
        DBChars.groups = Array.from(groupsMap.values());    //groupsMap을 배열로 변환하여 DBChars.groups 에 저장
      } catch (e) {   // 실패시에도 loaded = true 로 막아 무한 재시도 방지.
        console.error('[Chars] load failed', e);
        DBChars.loaded = true;
        DBChars.groups = [];
      }
    }
    async function ensureCharactersLoaded() {   //필요 할때만 loadCharactersheet() 호출
       if (!DBChars.loaded) await loadCharacterSheet(); 
      }

    /*실제 캐릭터 선택창 내용을 채우는 로직*/
    function renderCatalog() {
      catalogEl.innerHTML = '';   /*catalog 영역 안에 있는 HTML 모두 지움 = 새로운 목록 그리기 전에 항상 기존 내용 초기화*/
      const groups = DBChars.groups || [];    /*DBChars.groups 라는 배열 가져옴, 없으면 [](빈배열) 사용*/
      if (!groups.length) {   /*위 groups의 배열 길이가 0이면 = 데이터가 없으면 아래코드 실행*/
        const msg = document.createElement('div');    /* 새로운 <div> 요소 만듬*/
        msg.style.color = '#c7b589';    /*글자색 베이지색*/
        msg.textContent = '시트에서 캐릭터 목록을 불러올 수 없습니다.';   /*텍스트 출력*/
        catalogEl.appendChild(msg); /*만든 메시지를 catalog 영역에 추가, appendChild는 자식 요소로 맨 뒤에 붙인다 는 메서드, 즉, catalogEl(부모)에 msg(자식)을 넣는것*/
        return; 
      }
      groups.forEach(group => {   /*groups 배열을 돌면서 각 그룹(남귀검사, 여마법사 등)에 대해 <div clas="row" 하나 만든다*/
        const row = document.createElement('div'); row.className = 'row';
        const left = document.createElement('img'); left.className = 'badge-img'; left.src = group.badgeSrc || PLACEHOLDER_IMG; left.alt = '배지';    /*row 왼쪽엔 배지 이미지 넣는다*/
        left.onerror = () => { left.src = PLACEHOLDER_IMG; };
        const cards = document.createElement('div'); cards.className = 'cards';  /*캐릭터 카드들을 담는 <div clas="cards">*/
        group.items.forEach(item => {   /*group.items 배열 안의 캐릭터를 돌면서 캐릭터 카드 버튼을 만듦*/
          const card = document.createElement('button'); card.className = 'char-card';
          const img = document.createElement('img'); img.className = 'char-img'; img.alt = item.name; img.src = item.thumbSrc || PLACEHOLDER_IMG;
          img.onerror = () => { img.src = PLACEHOLDER_IMG; };
          const name = document.createElement('div'); name.className = 'char-name'; name.textContent = item.name;
          card.appendChild(img); card.appendChild(name);
          card.addEventListener('click', () => {    /*이 카드 버튼 클릭하면 applyCharacter() 함수 실행되어 캐릭터 정보 넘김*/
            applyCharacter({
              src: item.fullSrc || PLACEHOLDER_IMG,
              jobGroup: normalizeJobGroup(group.title),   // 내부 코드용 그룹명(slayer, mage 등)
              jobGroupLabel: group.title,                  // 사용자 표시용 그룹명(예: 남귀검사, 여마법사 등)
              name: item.name,
              power: item.power
            });
            closeCharacterPicker(); /*모달 닫기*/
          });
          cards.appendChild(card);    //만든 캐릭터 카드들을 cards 컨테이너에 추가
        });
        const right = document.createElement('div'); right.textContent = '✶'; right.style.opacity = '.3'; right.style.textAlign = 'center';
        right.style.color = '#d8c088';    // row 오른쪽에 장식용 별표 하나를 배치
        row.appendChild(left); row.appendChild(cards); //row.appendChild(right);
        catalogEl.appendChild(row);   //최종적으로 한줄(row) 안에, 왼쪽(left) 배지 이미지, 가운데(cards) 캐릭터 카드 목록, 오른쪽(right) 별표 를 넣고 완성된 row를 catalog에 추가.
      });
    }
    async function openCharacterPicker() {    // 모달 열때 씀
       await ensureCharactersLoaded();    // 시트 데이터를 아직 안받았다면 받아올때까지 기다림
       renderCatalog();   // 로드된 데이터로 카탈로그 그리기
       charModal.classList.add('show');   //모달에 show 클래스 추가 - 화면에 보이게, 보통 .modal.show {display:block;} 같이 제어
       charModal.setAttribute('aria-hidden', 'false');    // 스크린리더에 '보이는 상태' 알림, 모달열릴때 false, 모달 닫힐때 true.
      }
    function closeCharacterPicker() {   // 모달 닫을 때 씀
      charModal.classList.remove('show');   // show 제거 - 숨김
      charModal.setAttribute('aria-hidden', 'true');    // 접근성 : 숨김 상태 알림
    }
    function applyCharacter({ src, jobGroup, jobGroupLabel, name, power }) {    //카드 클릭 시 이 함수가 호출됨, ui 이미지 교체 - 상태 업데이트 - 파생 ui업데이트까지 한번에 처리
      characterImg.src = src;   // 메인 캐릭터 이미지 교체
      characterImg.style.display = 'block';   // 실제 이미지 보이기
      characterGhost.style.display = 'none';    // 플레이스홀더(유령 이미지) 숨김
      state.currentCharacter = {    // 전역/상태에 현재 선택 기록
        jobGroup,
        jobGroupLabel: jobGroupLabel || null,  // ← 한글 직업군 라벨(예: 남귀검사)
        name,
        imgSrc: src,
        power: power || null
      };
      recalcAndRenderPanel();   // 장비/스탯/버프 등 계산 후 표시를 갱신하는 내부 함수
      loadCharTotalsAndApply(name);   // 캐릭터 이름 기준으로 누적값/상세값 불러와 적용
    }

    characterCard.addEventListener('click', openCharacterPicker);
    charModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeCharacterPicker(); });
    /* 스킬시트 매칭용 키: 직업군(라벨)+이름 → 공백 제거 */
    function currentSkillOwnerKey() {
      const ch = state.currentCharacter || {};
      const key = String((ch.jobGroupLabel || '') + (ch.name || '')).replace(/\s+/g, '');
      return key || null; // 예: '남귀검사소울브링어'
    }

    /* ===== 아이템 피커 (공용) ===== */
    const itemModal = document.getElementById('itemModal');
    const itemList = document.getElementById('itemList');
    const itemSearch = document.getElementById('itemSearch');
    const weaponTabs = document.getElementById('weaponTabs');
    const itemDlgTitle = document.getElementById('itemDlgTitle');
    function getItemsForSlot(slotKey) { return (DB.itemsBySlot[slotKey] || []).slice(); }
    function getWeaponsFilteredByJob(jobGroup) {
      const allowed = new Set(ALLOWED_WEAPON_TYPES[jobGroup] || []);
      return getItemsForSlot('weapon').filter(it => allowed.has(it.type));
    }
    function renderWeaponTabs(jobGroup) {
      const types = ALLOWED_WEAPON_TYPES[jobGroup] || [];
      weaponTabs.innerHTML = '';
      if (!types.length) { weaponTabs.style.display = 'none'; return; }
      if (!state.ui.weaponTypeTab || !types.includes(state.ui.weaponTypeTab)) state.ui.weaponTypeTab = types[0];
      types.forEach(t => {
        const b = document.createElement('button');
        b.className = 'tab-btn' + (t === state.ui.weaponTypeTab ? ' active' : '');
        b.textContent = t;
        b.onclick = () => { state.ui.weaponTypeTab = t; renderItems('weapon', itemSearch.value); updateActive(); };
        weaponTabs.appendChild(b);
      });
      function updateActive() { [...weaponTabs.children].forEach(ch => ch.classList.toggle('active', ch.textContent === state.ui.weaponTypeTab)); }
      weaponTabs.style.display = 'flex';
    }

    function renderItems(slotKey, query = '') {
      itemList.innerHTML = '';
      const q = (query || '').trim().toLowerCase();
      let items = slotKey === 'weapon' && state.currentCharacter.jobGroup ? getWeaponsFilteredByJob(state.currentCharacter.jobGroup) : getItemsForSlot(slotKey);
      if (slotKey === 'weapon' && state.ui.weaponTypeTab) items = items.filter(it => it.type === state.ui.weaponTypeTab);
      if (q) items = items.filter(it => (it.name || '').toLowerCase().includes(q) || (it.type || '').toLowerCase().includes(q));
      if (!items.length) {
        const msg = document.createElement('div'); msg.style.color = '#c7b589';
        msg.textContent = '조건과 일치하는 아이템이 없습니다.'; itemList.appendChild(msg); return;
      }
      items.forEach(it => {
        const row = document.createElement('button');
        row.className = 'item-row';
        const isBottom = (slotKey === 'aura' || slotKey === 'title' || slotKey === 'creature' || slotKey === 'artifact');
        const badge = isBottom ? (it.level_text && String(it.level_text).trim()) : `Lv.${it.level ?? 65}`;
        const lvlLabel = isBottom ? (it.level_text && String(it.level_text).trim()) : `${it.level ?? 65}레벨`;
        row.innerHTML = `
          <div class="iconbox">
            <img class="icon" src="${it.img || PLACEHOLDER_IMG}" alt="${it.name}">
            ${badge ? `<span class="badge-lv">${badge}</span>` : ``}
          </div>
          <div class="meta">
            <div class="meta-top">${lvlLabel ? `<span class="lvl">${lvlLabel}</span>` : ``}<span class="name">${it.name}</span></div>
            <div class="meta-sub">${it.type || ''}</div>
          </div>
          <div class="right"><span class="rarity-chip">${it.rarity_kr || (it.rarity === 'epic' ? '에픽' : (it.rarity || ''))}</span></div>`;
        row.onclick = () => { applyItemToSlot(slotKey, it); closeItemPicker(); };
        const icon = row.querySelector('.icon');
        icon.onerror = () => { icon.src = PLACEHOLDER_IMG; };
        itemList.appendChild(row);
      });
    }

    async function openItemPicker(slotKey) {
      state.currentSlotKey = slotKey;
      await ensureLoaded(slotKey);
      if (slotKey === 'weapon') {
        itemDlgTitle.textContent = '무기 선택';
        if (!state.currentCharacter.jobGroup) { openCharacterPicker(); return; }
        renderWeaponTabs(state.currentCharacter.jobGroup);
      } else {
        itemDlgTitle.textContent = labelForSlot(slotKey) + ' 선택';
        weaponTabs.style.display = 'none';
      }
      renderItems(slotKey);
      itemModal.classList.add('show'); itemModal.setAttribute('aria-hidden', 'false');
      itemSearch.value = ''; itemSearch.oninput = () => renderItems(slotKey, itemSearch.value);
    }
    function closeItemPicker() { itemModal.classList.remove('show'); itemModal.setAttribute('aria-hidden', 'true'); }
    itemModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeItemPicker(); });
    function applyItemToSlot(slotKey, item) {
      if (!item.raw && item._raw) item.raw = item._raw;
      state.selections[slotKey] = item;
      const tile = tileElForSlot(slotKey); if (!tile) return;
      tile.innerHTML = `<img class="item-img" alt="${item.name}" src="${item.img || PLACEHOLDER_IMG}" style="width:70%;height:70%;border-radius:8px;">`;
      const img = tile.querySelector('img');
      if (img) img.onerror = () => { img.src = PLACEHOLDER_IMG; };
      recalcAndRenderPanel();
      refreshSealCaptionsForSlot(slotKey);
      refreshSealLabelsFromState();
    }
    function tileElForSlot(slotKey) { const domKey = Object.keys(SLOT_MAP).find(k => SLOT_MAP[k] === slotKey); return document.querySelector(`.slot[data-slot="${domKey}"]`); }
    function labelForSlot(slotKey) {
      return ({
        weapon: '무기', headshoulder: '머리어깨', top: '상의', bottom: '하의', belt: '허리', shoes: '신발',
        bracelet: '팔찌', necklace: '목걸이', ring: '반지', support: '보조장비',
        aura: '오라', title: '칭호', creature: '크리쳐', artifact: '아티팩트'
      })[slotKey] || '아이템';
    }

    /* ===== 강화 선택 ===== */
    const enhanceModal = document.getElementById('enhanceModal');
    const enhanceListEl = document.getElementById('enhanceList');

    function enhTypeForSlot(slotKey) {
      if (slotKey === 'weapon') return '무기강화';
      if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slotKey)) return '방어구강화';
      if (['bracelet', 'necklace', 'ring'].includes(slotKey)) return '악세강화';
      if (slotKey === 'support') return '보장강화';
      return null;
    }
    async function openEnhPicker(slotKey, btnEl) {
      const type = enhTypeForSlot(slotKey);
      if (!type) return;
      await ensureEnhLoaded();
      const list = (DBEnh.byType[type] || []).slice();
      enhanceListEl.innerHTML = '';
      list.forEach(opt => {
        const b = document.createElement('button'); b.className = 'enh-option'; b.textContent = opt.name || '(이름없음)';
        b.onclick = () => { state.upgrades[slotKey] = opt; if (btnEl) btnEl.textContent = opt.name; closeEnhPicker(); recalcAndRenderPanel(); };
        enhanceListEl.appendChild(b);
      });
      state.ui.enhTargetSlot = slotKey; state.ui.enhTargetBtn = btnEl || null;
      enhanceModal.classList.add('show'); enhanceModal.setAttribute('aria-hidden', 'false');
    }
    function closeEnhPicker() { enhanceModal.classList.remove('show'); enhanceModal.setAttribute('aria-hidden', 'true'); }
    enhanceModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeEnhPicker(); });

    /* ===== 합산 패널 ===== */
    const statListEl = document.getElementById('statList');
    function sumSelections() {
      const S = {     //모든 항목 0으로 시작
        phys_atk: 0, mag_atk: 0, str: 0, int: 0, phys_crit: 0, mag_crit: 0, phys_crit_rate: 0, mag_crit_rate: 0, add_damage: 0, elem_add_sum: 0,
        str_pct: 0, int_pct: 0, damage_inc: 0, crit_damage_inc: 0, phys_atk_pct: 0, mag_atk_pct: 0, skill_atk_inc: 0,
        elem: { fire: 0, water: 0, light: 0, dark: 0 }, cdr: 0, speed: { attack: 0, move: 0, cast: 0 }, def_break_inc: 0
      };
        // ★ 스증 전용 임시 누적기(베이스부터 누적 시작)
  S.__skillMul = 1;        // 곱연산 대상(아이템/강화/엠블렘/옵션/룬/마봉/마부 등)
  S.__skillAddBuff = 0;    // 합연산 대상(버프 시트에서 온 스증)
      const addStats = (s) => {   // 아이템 하나의 stats를 받아 S에 누적
    if (!s) return;
    S.phys_atk += s.phys_atk || 0; S.mag_atk += s.mag_atk || 0;
    S.str += s.str || 0; S.int += s.int || 0;
    S.phys_crit += s.phys_crit || 0; S.mag_crit += s.mag_crit || 0;
    S.phys_crit_rate += s.phys_crit_rate || 0; S.mag_crit_rate += s.mag_crit_rate || 0;
    S.add_damage += s.add_damage || 0;

    if (s.elem_add_damage) {
      S.elem_add_sum += (s.elem_add_damage.fire || 0) + (s.elem_add_damage.water || 0)
                      + (s.elem_add_damage.light || 0) + (s.elem_add_damage.dark || 0);
    }

    S.str_pct += s.str_pct || 0; S.int_pct += s.int_pct || 0;
    S.damage_inc += s.damage_inc || 0; S.crit_damage_inc += s.crit_damage_inc || 0;
    S.phys_atk_pct += s.phys_atk_pct || 0; S.mag_atk_pct += s.mag_atk_pct || 0;

    // ★ 스증은 더하지 말고 곱 누적(버프는 아직 안 들어옴)
    if (s.skill_atk_inc) {
      S.__skillMul *= (1 + (s.skill_atk_inc || 0));
    }

    if (s.elem) { S.elem.fire += s.elem.fire || 0; S.elem.water += s.elem.water || 0; S.elem.light += s.elem.light || 0; S.elem.dark += s.elem.dark || 0; }
    S.cdr += s.cdr || 0;
    if (s.speed) { S.speed.attack += s.speed.attack || 0; S.speed.move += s.speed.move || 0; S.speed.cast += s.speed.cast || 0; }
    if (s.other) { S.def_break_inc += s.other.def_break_inc || 0; }
  };
      Object.values(state.selections).forEach(it => addStats(it?.stats));   //선택 장비들 모두 누적해서 최종 s반환
      // 장비 합
      Object.values(state.upgrades).forEach(up => addStats(up?.stats));   // 선택 강화들 모두 누적해서 최종 s반환
      // 강화 합(요청: 합연산)
      //Object.values(state.enchants || {}).forEach(en => addStats(en?.stats));
      // 마법부여 합산
      return S;
    }

    const fmtInt = (v) => (v == null ? '—' : Math.round(v).toString());   // 정수,퍼센트를 ui 표시용 문자열로 바꿈(없으면 -)
    const fmtPct = (v) => (v == null ? '—' : (Math.round((v || 0) * 1000) / 10).toFixed(1) + '%');
    const show = (label, value) => {    // 하나의 통계 행 DOM 을 만들어주는 팩토리
      const row = document.createElement('div'); row.className = 'stat-row';
      const L = document.createElement('div'); L.className = 'stat-label'; L.textContent = label;
      const R = document.createElement('div'); R.className = 'stat-value'; R.textContent = value;
      row.appendChild(L); row.appendChild(R); return row;
    };

    function renderStats(S) {     //물공캐 마공캐에 따라 라벨과 값 선택을 바꿔줌
      statListEl.innerHTML = '';
      const p = state.currentCharacter.power; // 'phys' | 'mag' | null
      const atkLabel = (p ? powerLabel(p) : '물리/마법') + ' 공격력';
      const mainStatLabel = (p === 'phys' ? '힘' : p === 'mag' ? '지능' : '힘/지능');
      const critLabel = (p ? powerLabel(p) : '물리/마법') + ' 크리티컬';
      const mainPctLabel = (p === 'phys' ? '힘(%)' : p === 'mag' ? '지능(%)' : '힘/지능(%)');
      const atkPctLabel = (p ? powerLabel(p) : '물리/마법') + ' 공격력(%)';
      const atkVal = p === 'phys' ? S.phys_atk : p === 'mag' ? S.mag_atk : null;
      const mainStatVal = p === 'phys' ? S.str : p === 'mag' ? S.int : null;
      const critVal = p === 'phys' ? S.phys_crit : p === 'mag' ? S.mag_crit : null;
      const critRateVal = p === 'phys' ? S.phys_crit_rate : p === 'mag' ? S.mag_crit_rate : null;
      const finalCritPct = (critVal == null || critRateVal == null) ? null : (((critVal || 0) / ((3.8665*(100/97.25)**80/*몬스터레벨*/)*100)) * 100 + (critRateVal || 0) * 100) + 3;   //최종크리티컬 계산식
      const mainPctVal = p === 'phys' ? S.str_pct : p === 'mag' ? S.int_pct : null;
      const atkPctVal = p === 'phys' ? S.phys_atk_pct : p === 'mag' ? S.mag_atk_pct : null;
      const elems = S.elem; const maxVal = Math.max(elems.fire, elems.water, elems.light, elems.dark);
      const winners = []; const tag = (k) => ({ fire: '화', water: '수', light: '명', dark: '암' }[k]);
      for (const k of ['fire', 'water', 'light', 'dark']) if (elems[k] === maxVal && maxVal > 0) winners.push(tag(k));
      const elemText = winners.length ? (winners.join('/') + ' ' + Math.round(maxVal)) : '—';

      statListEl.appendChild(show(atkLabel, fmtInt(atkVal)));   // 실제 화면 UI에 행추가
      statListEl.appendChild(show(mainStatLabel, fmtInt(mainStatVal)));
      statListEl.appendChild(show(critLabel, fmtInt(critVal)));
      statListEl.appendChild(show('최종 크리티컬(%)', finalCritPct == null ? '—' : (Math.round(finalCritPct * 10) / 10).toFixed(1) + '%'));
      statListEl.appendChild(show('최종 추가데미지(%)', fmtPct((S.add_damage || 0) + (S.elem_add_sum || 0))));
      statListEl.appendChild(show(mainPctLabel, fmtPct(mainPctVal)));
      statListEl.appendChild(show('데미지증가(%)', fmtPct(S.damage_inc)));
      statListEl.appendChild(show('크리티컬데미지증가(%)', fmtPct(S.crit_damage_inc)));
      statListEl.appendChild(show(atkPctLabel, fmtPct(atkPctVal)));
      statListEl.appendChild(show('스킬공격력증가(%)', fmtPct(S.skill_atk_inc)));
      statListEl.appendChild(show('속성강화', elemText));
      statListEl.appendChild(show('방어력감소(%)', fmtPct(S.def_break_inc)));
      statListEl.appendChild(show('전체 쿨타임 감소(%)', fmtPct(S.cdr)));
      statListEl.appendChild(show('공격속도(%)', fmtPct(S.speed.attack)));
      statListEl.appendChild(show('이동속도(%)', fmtPct(S.speed.move)));
      statListEl.appendChild(show('캐스팅속도(%)', fmtPct(S.speed.cast)));
    }

async function recalcAndRenderPanel() {
  // 1) 버프 먼저 계산
  state.__buffStats = await BuffLeveling.computeBuffStats();
  console.log("[BUFF-DEBUG] state.__buffStats 저장됨:", state.__buffStats); //로그값

  // 2) 합산
  const S = sumSelections();
  console.log("[BUFF-DEBUG] sumSelections 최종 합산:", S);  //로그값

  // 3) 렌더링 (네 기존 함수들 그대로)
  renderStats(S);
  const el = document.getElementById("finalDamageValue");
  if (el) el.textContent = "47,978,023,776"; // ← 네 기존 값 갱신 로직
}

    /* ===== 엠블렘 시스템 ===== */

    /** 슬롯별 허용 엠블렘 타입 */
    const SOCKET_RULES = {
      headshoulder: ['노란빛엠블렘'],
      belt: ['노란빛엠블렘'],
      top: ['붉은빛엠블렘'],
      bottom: ['붉은빛엠블렘'],
      shoes: ['푸른빛엠블렘'],
      bracelet: ['푸른빛엠블렘'],
      necklace: ['녹색빛엠블렘'],
      ring: ['녹색빛엠블렘'],
      weapon: ['붉은빛엠블렘', '노란빛엠블렘', '녹색빛엠블렘', '푸른빛엠블렘'],
      support: ['플래티넘엠블렘'],
      title: ['플래티넘엠블렘']  // 칭호 좌측 원 1개
    };
    const SOCKET_COUNT = (slotKey) => (slotKey === 'support' || slotKey === 'title') ? 1 : 2;

    const emblemModal = document.getElementById('emblemModal');
    const emblemRows = document.getElementById('emblemRows');

    state.emblems = state.emblems || {};  // { slotKey: [null, null] }
    state.ui.emblemTarget = { slotKey: null, sockIndex: 0 };
    function ensureEmblemArray(slotKey) {
      if (!state.emblems[slotKey]) state.emblems[slotKey] = new Array(SOCKET_COUNT(slotKey)).fill(null);
    }

    /** 작은 원 UI 업데이트 */
    function paintEmblemDot(slotKey, sockIndex) {
      const dot = document.querySelector(`.emblem-dot[data-slot="${slotKey}"][data-sock="${sockIndex}"]`);
      if (!dot) return;
      const picked = (state.emblems[slotKey] || [])[sockIndex] || null;
      // 초기화
      dot.innerHTML = '';
      dot.classList.toggle('empty', !picked);
      if (picked) {
        // 배경 이미지로 주입 (원형 클리핑 100% 보장)
        const src = (picked.img || PLACEHOLDER_IMG).replace(/"/g, '\\"');
        dot.style.setProperty('--emblem', `url("${src}")`);
        dot.classList.add('has-img');

        // 중앙 숫자
        const n = document.createElement('span');
        n.className = 'num';
        n.textContent = picked.level_num ?? '';
        dot.appendChild(n);
      } else {
        // 비워짐 상태
        dot.classList.remove('has-img');
        dot.style.removeProperty('--emblem');
      }
      /* ▼ 보조장비/칭호(플래티넘)일 때 캡션 표시 */
      const isPlatSocket = (slotKey === 'support' || slotKey === 'title');
      if (isPlatSocket) {
        // dot 바로 아래에 .emblem-caption을 만들거나 찾아서 갱신
        let cap = dot.nextElementSibling;
        if (!cap || !cap.classList.contains('emblem-caption')) {
          cap = document.createElement('div');
          cap.className = 'emblem-caption';
          dot.parentNode.insertBefore(cap, dot.nextSibling);
        }
        // 선택 시엔 '렙제' 텍스트(item.tag), 미선택이면 숨김
        if (picked && picked.tag) {
          cap.textContent = picked.tag;
          cap.style.display = 'block';
        } else {
          cap.textContent = '';
          cap.style.display = 'none';
        }
      }

    }

    /** 모든 점 새로고침 */
    function refreshAllDots() { Object.keys(state.emblems).forEach(slotKey => { (state.emblems[slotKey] || []).forEach((_, i) => paintEmblemDot(slotKey, i)); }); }

    /** 없음 썸네일 */
    function makeNoneThumb(onPick) {
      const b = document.createElement('button');
      b.type = 'button'; b.className = 'em-thumb none'; b.title = '없음'; b.onclick = onPick; return b;
    }
    /** 일반 썸네일(이미지 중앙 숫자) */
    function makeEmblemThumb(item, onPick) {
      const b = document.createElement('button');
      b.type = 'button'; b.className = 'em-thumb';
      const img = document.createElement('img'); img.src = item.img || PLACEHOLDER_IMG;
      img.onerror = () => { img.src = PLACEHOLDER_IMG; };
      const num = document.createElement('span'); num.className = 'num'; num.textContent = item.level_num ?? '';
      b.appendChild(img); b.appendChild(num); b.onclick = onPick; return b;
    }

    /** 플래티넘 7줄 분류 키워드 */
    const PLAT_LINES = [
      { label: '화', key: '화' },
      { label: '수', key: '수' },
      { label: '명', key: '명' },
      { label: '암', key: '암' },
      { label: '모속', key: '모속' },
      { label: '힘', key: '힘' },
      { label: '지능', key: '지능' },
    ];

    /** 엠블렘 모달 열기 */
    async function openEmblemPicker(slotKey, sockIndex) {
      await ensureEnhLoaded();
      ensureEmblemArray(slotKey);

      state.ui.emblemTarget = { slotKey, sockIndex };
      emblemRows.innerHTML = '';

      const allow = SOCKET_RULES[slotKey] || [];
      const isPlatinumOnly = allow.length === 1 && allow[0] === '플래티넘엠블렘';
      if (isPlatinumOnly) {
        const base = DBEnh.byType['플래티넘엠블렘'] || [];
        PLAT_LINES.forEach(line => {
          const row = document.createElement('div'); row.className = 'em-row';
          row.appendChild(makeNoneThumb(() => pickEmblem(null)));
          base.filter(x => (x.tag || '').includes(line.key)).forEach(item => {
            row.appendChild(makeEmblemThumb(item, () => pickEmblem(item)));
          });
          emblemRows.appendChild(row);
        });
      } else {
        // 일반 색 엠블렘: 슬롯 규칙대로 한 줄씩 가로 리스트
        const orderMap = { '붉은빛엠블렘': 0, '노란빛엠블렘': 1, '녹색빛엠블렘': 2, '푸른빛엠블렘': 3 };
        allow.slice().sort((a, b) => (orderMap[a] ?? 9) - (orderMap[b] ?? 9)).forEach(type => {
          const row = document.createElement('div'); row.className = 'em-row';
          row.appendChild(makeNoneThumb(() => pickEmblem(null)));
          (DBEnh.byType[type] || []).forEach(item => {
            row.appendChild(makeEmblemThumb(item, () => pickEmblem(item)));
          });
          emblemRows.appendChild(row);
        });
      }

      document.getElementById('emblemDlgTitle').textContent = `엠블렘 선택 - ${labelForSlot(slotKey)} (소켓 ${sockIndex + 1})`;
      emblemModal.classList.add('show'); emblemModal.setAttribute('aria-hidden', 'false');
      function pickEmblem(item) {
        state.emblems[slotKey][sockIndex] = item
          ? { img: item.img, level_num: item.level_num, stats: item.stats, tag: item.tag } // ← tag 추가
          : null;
        paintEmblemDot(slotKey, sockIndex);
        recalcAndRenderPanel(); // 합연산 반영
        closeEmblemPicker();
      }
    }
    function closeEmblemPicker() { emblemModal.classList.remove('show'); emblemModal.setAttribute('aria-hidden', 'true'); }
    emblemModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeEmblemPicker(); });
    /** 작은 원(소켓) 주입: 좌측열은 slot 오른쪽, 우측열은 slot 왼쪽. 보조장비는 1개. */
    function injectEmblemDots() {
      // 메인 좌/우 열
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot'); if (!slotEl) return;
        const code = slotEl.getAttribute('data-slot'); const slotKey = SLOT_MAP[code]; if (!slotKey) return;

        // 중앙 미니 4칸(C1~C4)은 뒤에서 따로 처리
        if (['aura', 'title', 'creature', 'artifact'].includes(slotKey)) return;

        if (!SOCKET_RULES[slotKey]) return; // 엠블렘 미지원 슬롯은 스킵

        const stack = document.createElement('div'); stack.className = 'emblem-stack';
        const count = SOCKET_COUNT(slotKey);
        for (let i = 0; i < count; i++) {
          const dot = document.createElement('button');
          dot.type = 'button'; dot.className = 'emblem-dot empty';
          dot.setAttribute('data-slot', slotKey); dot.setAttribute('data-sock', String(i));
          dot.onclick = (e) => { e.stopPropagation(); openEmblemPicker(slotKey, i); };
          stack.appendChild(dot);
        }
        ensureEmblemArray(slotKey);
        // 좌측열(L*) → slot 오른쪽 / 우측열(R*) → slot 왼쪽
        if (code && code.startsWith('L')) {
          row.appendChild(stack);
        } else if (code && code.startsWith('R')) {
          row.insertBefore(stack, slotEl);
        }
      });

      // 칭호(Title) 처리: 왼쪽 2개 선택칸 중 '아래 선택칸' 제거하고 원 1개 넣기 (플래티넘)
      const titleSlot = document.querySelector('.slot.mini[data-slot="C2"]');
      if (titleSlot) {
        const miniCell = titleSlot.closest('.mini-cell');
        if (miniCell) {
          const outer = miniCell.querySelector('.outer-rects');
          if (outer) {
            const btns = outer.querySelectorAll('.rect');
            if (btns[1]) btns[1].remove(); // 아래 버튼 제거
          }
          const stack = document.createElement('div');
          stack.className = 'emblem-stack';
          const dot = document.createElement('button'); dot.type = 'button'; dot.className = 'emblem-dot empty';
          dot.setAttribute('data-slot', 'title'); dot.setAttribute('data-sock', '0');
          dot.onclick = (e) => { e.stopPropagation(); openEmblemPicker('title', 0); };
          stack.appendChild(dot);
          ensureEmblemArray('title');
          miniCell.insertBefore(stack, miniCell.querySelector('.slot.mini'));
        }
      }

      refreshAllDots();
    }
    const runeModal = document.getElementById('runeModal');
    const runeGridEl = document.getElementById('runeGrid');
    function renderRuneGrid() {
      ensureRunesInitialized();
      runeGridEl.innerHTML = '';

      const header = document.createElement('div'); header.className = 'row';
      const headCell = document.createElement('div'); headCell.className = 'head'; headCell.textContent = '스킬룬';
      header.appendChild(headCell);
      RUNE_LEVELS.forEach(lvl => {
        const c = document.createElement('div'); c.className = 'cell';
        const tag = document.createElement('div'); tag.className = 'head'; tag.textContent = String(lvl);
        tag.style.textAlign = 'center';
        c.appendChild(tag); header.appendChild(c);
      });
      runeGridEl.appendChild(header);

      RUNE_CATS.forEach(cat => {
        const row = document.createElement('div'); row.className = 'row';
        const head = document.createElement('div'); head.className = 'head'; head.textContent = cat.label;
        row.appendChild(head);

        RUNE_LEVELS.forEach(lvl => {
          const c = document.createElement('div'); c.className = 'cell';
          const sel = document.createElement('select'); sel.className = 'rune-select';
          for (let i = 0; i <= 20; i++) { const o = document.createElement('option'); o.value = String(i); o.textContent = String(i); sel.appendChild(o); }
          sel.value = String((state.runes[cat.key] || {})[lvl] || 0);
          sel.addEventListener('change', () => {
            const before = (state.runes[cat.key] || {})[lvl] || 0;
            const after = Number(sel.value) || 0;
            const currentTotal = countSelectedRunes();
            const diff = after - before;
            if (currentTotal + diff > 20) {
              sel.value = String(before);
              sel.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.05)' }, { transform: 'scale(1)' }], { duration: 180 });
              return;
            }
            state.runes[cat.key][lvl] = after;
            updateRuneCountSummary();
          });
          c.appendChild(sel);
          row.appendChild(c);
        });
        runeGridEl.appendChild(row);
      });
    }

    function openRuneModal() { renderRuneGrid(); runeModal.classList.add('show'); runeModal.setAttribute('aria-hidden', 'false'); }
    function closeRuneModal() { runeModal.classList.remove('show'); runeModal.setAttribute('aria-hidden', 'true'); }
    runeModal.addEventListener('click', (e) => { if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeRuneModal(); });
    /* ===== 스킬트리 로더 & UI (UI 전용, 계산 미연결) ===== */
    const DBTree = { loaded: false, rows: [], byChar: new Map() };
    const ST_CONF = { SP_TOTAL: 1210, TP_TOTAL: 35 };
    const LEVEL_BANDS_DEFAULT = [1, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 65, 70, 75, 80];
    function pickCol(r, ...ks) { for (const k of ks) { if (r[k] != null && String(r[k]).trim() !== '') return r[k]; } return ''; }
    function toNum(v) { if (v === '' || v == null) return 0; const n = Number(String(v).replace(/[, ]/g, '')); return isNaN(n) ? 0 : n; }
    function toList(v) { return (v ? String(v).split(/[,;]/).map(s => s.trim()).filter(Boolean) : []); }

    function mapRowToSkill(r) {
      // 네가 준 컬럼 키 그대로 사용
      const whoRaw = r['캐릭터명'];
      const name = String(r['스킬명'] ?? '').trim();
      const band = toNum(r['스킬렙제']);
      const cd = (r['쿨타임'] ?? '').toString().trim();
      const minLv = toNum(r['최소스킬레벨']);
      const maxLv = toNum(r['최대스킬레벨']);       // (= 마스터스킬레벨)
      const sp = toNum(r['소모 SP']); // SP 비용(레벨당)
      const icon = cleanUrl(r['이미지']) || PLACEHOLDER_IMG;
      // 캐릭터 식별 키: 공백 제거만(시트와 동일 포맷 가정)
      const who = String(whoRaw ?? '').replace(/\s+/g, '').trim();
      // 스킬ID가 시트에 없을 수 있으므로, (이름 + 밴드) 조합으로 고유 ID 구성
      const idBase = (r['스킬ID'] ?? name).toString().trim();
      const id = idBase ? `${idBase}#${band || 0}` : (Date.now().toString(36) + Math.random().toString(36).slice(2));
      // 현재 단계는 UI만: TP/선행은 일단 생략(추후 컬럼 확장 시 연결)
      return {
        id, who, name, icon,
        band: band || 1,
        min: Math.max(0, minLv || 0),
        max: Math.max(1, maxLv || 1),
        sp: Math.max(0, sp || 0),
        tp: 0,
        cd,
        prereq: [],
        desc: ''
      };
    }


    /* ===== 엠블렘 합연산 포함을 위해 합산 함수 확장 ===== */
const _sumSelections_base = sumSelections;
sumSelections = function () {
  const S = _sumSelections_base();

  // 누적기 안전 보정(베이스가 항상 넣지만, 혹시 모를 재정의 대비)
  S.__skillMul = S.__skillMul || 1;
  S.__skillAddBuff = S.__skillAddBuff || 0;

  const add = (st, src = 'other') => {
    if (!st) return;

    // 1) 스증만 분기
    if (st.skill_atk_inc) {
      if (src === 'buff') S.__skillAddBuff += (st.skill_atk_inc || 0);  // 버프는 합산
      else                S.__skillMul *= (1 + (st.skill_atk_inc || 0)); // 나머지는 곱산
    }

    // 2) 나머지 스탯은 기존처럼 가산
    S.phys_atk += st.phys_atk || 0; S.mag_atk += st.mag_atk || 0;
    S.str += st.str || 0; S.int += st.int || 0;
    S.phys_crit += st.phys_crit || 0; S.mag_crit += st.mag_crit || 0;
    S.phys_crit_rate += st.phys_crit_rate || 0; S.mag_crit_rate += st.mag_crit_rate || 0;
    S.add_damage += st.add_damage || 0;
    S.str_pct += st.str_pct || 0; S.int_pct += st.int_pct || 0;
    S.damage_inc += st.damage_inc || 0; S.crit_damage_inc += st.crit_damage_inc || 0;
    S.phys_atk_pct += st.phys_atk_pct || 0; S.mag_atk_pct += st.mag_atk_pct || 0;
    if (st.elem) { S.elem.fire += st.elem.fire || 0; S.elem.water += st.elem.water || 0; S.elem.light += st.elem.light || 0; S.elem.dark += st.elem.dark || 0; }
    S.cdr += st.cdr || 0;
    if (st.speed) { S.speed.attack += st.speed.attack || 0; S.speed.move += st.speed.move || 0; S.speed.cast += st.speed.cast || 0; }
    if (st.other) { S.def_break_inc += st.other.def_break_inc || 0; }
  };

  // 엠블렘(곱 대상)
  Object.keys(state.emblems || {}).forEach(slotKey => {
    (state.emblems[slotKey] || []).forEach(it => { if (it?.stats) add(it.stats, 'other'); });
  });

  // 옵션(아바타/무기압)도 곱 대상
  if (state.options?.avatarEnh?.stats) add(state.options.avatarEnh.stats, 'other');
  if (state.options?.imprintEnh?.stats) add(state.options.imprintEnh.stats, 'other');

  // 룬 각인(곱 대상)
  if (state.runeEngrave?.stats) add(state.runeEngrave.stats, 'other');

  // 버프 시트(합 대상)
  if (state.__buffStats) add(state.__buffStats, 'buff');

  // ★ 아직 S.skill_atk_inc 확정하지 않음 (5번째에서 마봉·마부까지 포함 후 최종 확정)
  return S;
};
    // 초기화
    document.addEventListener('DOMContentLoaded', () => {
      refreshEnhLabelsFromState();
      renderSpTp();
      // 슬롯 클릭 → 아이템 선택
      document.querySelectorAll('.slot').forEach(el => {
        const code = el.getAttribute('data-slot'); const slotKey = SLOT_MAP[code]; if (!slotKey) return;
        el.addEventListener('click', (e) => { e.stopPropagation(); openItemPicker(slotKey); });
      });

      // 첫 번째 선택칸 = 강화 선택 연결
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot'); const code = slotEl?.getAttribute('data-slot'); const slotKey = SLOT_MAP[code];
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!slotKey || !rects.length) return;
        const firstBtn = rects[0];
        /* ▼ 추가: 기본 라벨을 '강화 설정'으로 보이게 */
        firstBtn.textContent = '강화 설정';
        firstBtn.addEventListener('click', (e) => { e.stopPropagation(); openEnhPicker(slotKey, firstBtn); });
      });

      // 두 번째 선택칸 = 마봉 선택 연결
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot');
        const code = slotEl?.getAttribute('data-slot');
        const slotKey = SLOT_MAP[code];
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!slotKey || rects.length < 2) return;

        const secondBtn = rects[1];
        // 기본 라벨
        secondBtn.textContent = '마봉 설정';

        // 중복 바인딩 방지 (페이지 재렌더 시 다중 등록 예방)
        if (secondBtn.dataset.boundSeal === '1') return;
        secondBtn.dataset.boundSeal = '1';

        secondBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof openSealModal === 'function') {
            // slotKey에 맞는 3분할 모달 열기 (고유/일반1/일반2)
            openSealModal(slotKey, secondBtn);
          } else {
            console.warn('openSealModal 함수가 아직 로드되지 않았습니다.');
          }
        });
      });


      // 칭호 왼쪽 두 선택칸 비활성화
      document.querySelectorAll('[data-unused="true"]').forEach(b => { b.classList.add('disabled'); b.title = '추후 사용 예정'; });
      // 엠블렘 소켓 주입
      injectEmblemDots();
      const btnRune = document.getElementById('btnRune');
      if (btnRune) { btnRune.addEventListener('click', openRuneModal); }
      ensureRunesInitialized();
      updateRuneCountSummary();

      // 룬 각인 드롭다운 바인딩
      const selRuneEngrave = document.getElementById('selRuneEngrave');
      const selRuneDetail = document.getElementById('selRuneDetail');

      if (selRuneEngrave) {
        selRuneEngrave.addEventListener('change', async () => {
          // 이름 선택/변경 시: 세부설정 초기화 + 비활성화 → 새 목록 구성 후 활성화
          state.runeEngrave = null;
          if (selRuneDetail) {
            selRuneDetail.innerHTML = `<option value="" selected disabled>세부 설정</option>`;
            selRuneDetail.disabled = true;
          }
          const pickedName = selRuneEngrave.value || null;
          if (pickedName) {
            await populateRuneDetailOptions(pickedName);   // 목록 채우기
            if (selRuneDetail) selRuneDetail.disabled = false; // 활성화
          }
          // 세부 설정이 아직 선택되지 않았으므로 합산은 여기서 하지 않음
        });
      }

      if (selRuneDetail) {
        selRuneDetail.addEventListener('change', () => {
          const name = selRuneEngrave?.value || null;
          const tag = selRuneDetail.value || null;
          if (name && tag) {
            applyRuneEngraveByNameTag(name, tag); // 즉시 합산 반영
          } else {
            state.runeEngrave = null;
            recalcAndRenderPanel();
          }
        });
      }

      // 초기 이름 목록 구성
      buildRuneEngraveNameOptions();

      recalcAndRenderPanel();
      // 옵션 드롭다운 상태 반영 (아바타/무기압은 시트 연동)
      const $ = (id) => document.getElementById(id);
      const bind = (id, key) => {
        const el = $(id);
        if (!el) return;
        el.addEventListener('change', () => {
          state.options[key] = el.value || null;

          // 위쪽 2개만 시트연동 즉시 반영
          if (key === 'avatar') {
            applyAvatarEnhFromState();      // async 함수지만 대기 불필요
          } else if (key === 'weaponImprint') {
            applyImprintEnhFromState();      // async 함수지만 대기 불필요
          } else if (key === 'monster') {
            const txt = el.options[el.selectedIndex]?.textContent ?? el.value;
            onMonsterChange(txt);
          }
          // 아래 3개(시간/몬스터/난이도)는 계산과 연결하지 않음(요청대로)
        });
      }; // ← bind 함수 닫힘 (중요)

      bind('selAvatar', 'avatar');
      bind('selImprint', 'weaponImprint');
      bind('selTime', 'timeWindow');
      bind('selMonster', 'monster');
      bind('selDifficulty', 'difficulty');


      console.log('[Init] Ready. Click slots to load sheets. First select = 강화. Dots = 엠블렘.');
    });
  </script>
  <div id="autoEnhModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEnhTitle">
      <header>
        <h3 id="autoEnhTitle">강화 자동 입력</h3><button class="close" data-close>✕</button>
      </header>
      <div class="list" id="autoEnhList"></div>
    </div>
  </div>
<div id="autoEnchantModal" class="modal simple-modal" aria-hidden="true">
  <div class="backdrop" data-close></div>
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEnchantTitle">
    <header>
      <h3 id="autoEnchantTitle">추천 마법부여</h3>
      <button class="close" data-close>✕</button>
    </header>
    <div class="body two-col">
      <div class="col left">
        <div class="title">속성 선택</div>
        <div class="list attrs"></div>
      </div>
      <div class="col right">
        <div class="title">추천 티어</div>
        <div class="list tiers"></div>
      </div>
    </div>
  </div>
</div>

  <div id="autoEmblemModal" class="modal simple-modal" aria-hidden="true">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoEmblemTitle">
      <header>
        <h3 id="autoEmblemTitle">엠블렘 자동 입력</h3><button class="close" data-close>✕</button>
      </header>
      <div class="list" id="autoEmblemList"></div>
    </div>
  </div>

  <div id="autoSealModal" class="modal simple-modal" aria-hidden="true">
  <div class="backdrop" data-close></div>
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="autoSealTitle">
    <header>
      <h3 id="autoSealTitle">추천 마법봉인</h3>
      <button class="close" data-close>✕</button>
    </header>
    <div class="list">
      <button class="opt-btn" data-ele="fire">화속성</button>
      <button class="opt-btn" data-ele="water">수속성</button>
      <button class="opt-btn" data-ele="light">명속성</button>
      <button class="opt-btn" data-ele="dark">암속성</button>
    </div>
  </div>
</div>

  <script>

    /* ===== Auto Input: Helpers ===== */

    /* Reflect chosen enhance names on first rect of each slot */
    function refreshEnhLabelsFromState() {
      document.querySelectorAll('.slot-row').forEach(row => {
        const slotEl = row.querySelector('.slot');
        const code = slotEl?.getAttribute('data-slot');
        const slotKey = SLOT_MAP[code];
        const rects = row.querySelectorAll('.outer-rects .rect');
        if (!slotKey || !rects.length) return;
        const up = state.upgrades?.[slotKey];
        rects[0].textContent = up?.name || '강화 설정';
      });
    }

    const REVERSE_SLOT_MAP = Object.fromEntries(Object.entries(SLOT_MAP).map(([k, v]) => [v, k]));
    function firstEnhButtonFor(slotKey) {
      const code = REVERSE_SLOT_MAP[slotKey]; if (!code) return null;
      const row = document.querySelector(`.slot-row .slot[data-slot="${code}"]`)?.closest('.slot-row');
      if (!row) return null;
      return row.querySelector('.outer-rects .rect');
    }

    function matchEnhByLevelName(list, level) {
      const want = Number(level);
      const pattern1 = new RegExp(String.raw`(?:^|[^\d])${want}\s*강`);
      const pattern2 = new RegExp(String.raw`\+\s*${want}(?:[^\d]|$)`);
      const pattern3 = new RegExp(String.raw`(?:^|[^\d])${want}(?:[^\d]|$)`);
      let best = null;
      for (const o of list) {
        const name = (o.name || '').trim();
        if (pattern1.test(name) || pattern2.test(name)) return o;
        if (!best && pattern3.test(name)) best = o;
      }
      return best || list.find(o => String(o.name || '').includes(String(want))) || null;
    }


    async function autoEnhanceApply(level) {
      try {
        await ensureEnhLoaded();
      } catch (e) { console.warn('ensureEnhLoaded failed', e); }
      const lvl = Number(level) || 0;
      const sets = {
        weapon: '무기강화',
        headshoulder: '방어구강화', top: '방어구강화', bottom: '방어구강화', belt: '방어구강화', shoes: '방어구강화',
        bracelet: '악세강화', necklace: '악세강화', ring: '악세강화',
        support: '보장강화'
      };
      const slots = Object.keys(sets);
      let success = 0;
      for (const sk of slots) {
        const type = sets[sk];
        let list = (DBEnh?.byType?.[type] || []).slice();
        if (!list.length && Array.isArray(DBEnh?.list)) {
          list = DBEnh.list.filter(o => String(o?.type || '').includes(type));
        }
        const pick = matchEnhByLevelName(list, lvl);
        if (!pick) { console.warn('No enhance match for', sk, type, lvl); continue; }
        state.upgrades[sk] = pick;
        success++;
      }
      // Re-render totals/panels
      if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
      // Refresh button labels from state after re-render
      if (typeof refreshEnhLabelsFromState === 'function') refreshEnhLabelsFromState();
      return success;
    }


    /* ===== Auto Emblem Apply: stage 5~15 ===== */
    async function autoEmblemApply(stage) {
      await ensureEnhLoaded();
      const stageNum = Number(stage) || 0;
      const slots = ['headshoulder', 'top', 'bottom', 'belt', 'shoes', 'bracelet', 'necklace', 'ring', 'weapon'];
      for (const sk of slots) {
        ensureEmblemArray(sk);
        const types = SOCKET_RULES[sk] || [];
        let useTypes = types.slice();
        if (sk === 'weapon') useTypes = ['붉은빛엠블렘']; // 요구사항
        const picks = [];
        useTypes.forEach(t => {
          const arr = (DBEnh.byType[t] || []).filter(it => it.level_num === stageNum);
          if (arr.length) picks.push(arr[0]);
        });
        const pick = picks[0] || null;
        const count = SOCKET_COUNT(sk);
        for (let i = 0; i < count; i++) {
          state.emblems[sk][i] = pick ?
            { img: pick.img, level_num: pick.level_num, stats: pick.stats, tag: pick.tag } : null;
          paintEmblemDot(sk, i);
        }
      }
      recalcAndRenderPanel();
    }
const AUTO_ATTRS = ['화속성','수속성','명속성','암속성'];
const AUTO_TIERS = ['종결','준종결','보통','가성비'];
const autoEnchantState = { attr:null, tier:null };

// 전역 상태 예시:
// const autoEnchantState = { attr: null, tier: null };

function renderAutoEnchantChoices(){
  const m = document.getElementById('autoEnchantModal');
  const wrapAttrs = m.querySelector('.list.attrs');
  const wrapTiers = m.querySelector('.list.tiers');
  wrapAttrs.innerHTML = '';
  wrapTiers.innerHTML = '';

  const makeBtn = (txt, group) => {
    const b = document.createElement('button');
    b.className = 'opt-btn';
    b.type = 'button';
    b.textContent = txt;
    b.setAttribute('role', 'button');
    b.setAttribute('aria-pressed', 'false');
    b.addEventListener('click', () => {
      if (group === 'attr') autoEnchantState.attr = txt;
      else autoEnchantState.tier = txt;

      updateAutoActive();        // ✅ 즉시 시각 강조
      tryApplyAutoIfReady();     // 두 값이 모두 선택되면 적용+닫기
    });
    return b;
  };

  ['화속성','수속성','명속성','암속성'].forEach(a => wrapAttrs.appendChild(makeBtn(a, 'attr')));
  ['종결','준종결','보통','가성비'].forEach(t => wrapTiers.appendChild(makeBtn(t, 'tier')));

  // 열 때 초기화 상태 반영(둘 다 null이면 전부 비활성 표시)
  updateAutoActive();
}
// === [ENCHANT][AUTO] 직업군 텍스트 얻기
function getJobGroupText(opt){
  if (!opt) return '';
  if (opt.jobGroup) return String(opt.jobGroup).trim();
  const raw = opt.raw || {};
  return String(raw['직업군'] ?? raw.jobGroup ?? raw['분류'] ?? '').trim();
}

// === [ENCHANT][AUTO] 직업군으로 옵션 찾기
function findEnchantByJobGroup(typeKey, keyword){
  const list = ENCHANT_CACHE.byType.get(String(typeKey).trim()) || [];
  const kw = String(keyword || '').trim();
  if (!kw) return null;

  // 1순위: 직업군열 포함
  let hit = list.find(o => getJobGroupText(o).includes(kw));
  if (hit) return hit;

  // 2순위(폴백): 이름에라도 포함
  hit = list.find(o => String(o.name||'').includes(kw));
  return hit || null;
}

// 두 그룹에서 단일 선택 강조
function updateAutoActive(){
  const modal = document.getElementById('autoEnchantModal');
  const mark = (selector, pickedText) => {
    modal.querySelectorAll(selector).forEach(btn => {
      const on = (btn.textContent.trim() === (pickedText || ''));
      btn.classList.toggle('active', on);
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
    });
  };
  mark('.list.attrs .opt-btn', autoEnchantState.attr);
  mark('.list.tiers .opt-btn', autoEnchantState.tier);
}


// 맨 위 편한 곳에 추가
const $autoEnchantModal = document.getElementById('autoEnchantModal');

// 기존 함수 교체
function tryApplyAutoIfReady(){
  if (autoEnchantState.attr !== null && autoEnchantState.tier !== null) {
    applyAutoEnchant(autoEnchantState.attr, autoEnchantState.tier);
    autoEnchantState.attr = null;
    autoEnchantState.tier = null;
    showModal(document.getElementById('autoEnchantModal'), false);
  }
}

// === [ENCHANT][AUTO] 속성+티어/티어만 규칙대로 전체 자동 적용
async function applyAutoEnchant(attr, tier){
  await ensureEnchantCache();

  const combo = `${attr}${tier}`;

  // 무기/팔찌/목걸이/반지 = 속성+티어, 그 외 = 티어만
  const USE_COMBO = new Set(['무기마부','팔찌마부','목걸이마부','반지마부']);
  const USE_TIER  = new Set(['머리어깨마부','상의마부','하의마부','허리마부','신발마부','보장마부','칭호마부']);

  const targetSlots = ['R1','R2','R3','R4','R5','L1','L2','L3','L4','L5','C2'];

  const applied = [];
  const prev = state.currentSlotKey;

  for (const slotCode of targetSlots){
    const typeKey = enchantTypeForSlot(slotCode); // 예: R1 -> '무기마부'
    if (!typeKey) continue;

    const keyToUse = USE_COMBO.has(typeKey) ? combo
                   : USE_TIER.has(typeKey)  ? tier
                   : null;
    if (!keyToUse) continue;

    const opt = findEnchantByJobGroup(typeKey, keyToUse); // ← 1)에서 만든 헬퍼
    if (!opt) continue;

    // 실제 적용 (state 저장 + 버튼 라벨 갱신 + 재계산)
    state.currentSlotKey = slotCode;
    applyEnchantSelection(opt);
    applied.push({ slot: slotCode, name: opt.name });
  }

  state.currentSlotKey = prev;

  if (!applied.length){
    (typeof toast==='function' ? toast : alert)('조건에 맞는 추천 마법부여를 찾지 못했습니다.');
  }
}





    /* ===== Bind Auto Panels ===== */
    document.addEventListener('DOMContentLoaded', () => {
      const autoEnhModal = document.getElementById('autoEnhModal');
      const autoEnhList = document.getElementById('autoEnhList');
      const autoEmblemModal = document.getElementById('autoEmblemModal');
      const autoEmblemList = document.getElementById('autoEmblemList');
      const autoEnchantModal = document.getElementById('autoEnchantModal');
      // ▼ 추천 마법봉인 자동 입력 버튼 활성화 + 모달 오픈
const btnAutoSeal = document.getElementById('btnAutoSeal');
if (btnAutoSeal) {
  // 혹시 남아있을지 모르는 속성 정리(이중안전)
  btnAutoSeal.disabled = false;
  btnAutoSeal.removeAttribute('title');

  btnAutoSeal.addEventListener('click', () => {
    const modal = document.getElementById('autoSealModal');
    if (modal) {
      modal.classList.add('show');
      modal.setAttribute('aria-hidden', 'false');
    }
  });
}

// ▼ 추천 마법봉인 모달 닫기 및 버튼 클릭 처리(선택 시 닫기)
const autoSealModal = document.getElementById('autoSealModal');
if (autoSealModal) {
  autoSealModal.addEventListener('click', (e) => {
    if (
      e.target.hasAttribute('data-close') ||
      e.target.classList.contains('backdrop')
    ) {
      autoSealModal.classList.remove('show');
      autoSealModal.setAttribute('aria-hidden', 'true');
    }
  });

  // 4개 속성 버튼(화/수/명/암) 클릭 시 동작(현재는 모달만 닫기)
  autoSealModal.querySelectorAll('.opt-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      // TODO: 여기서 선택한 속성에 맞춰 '추천 마법봉인 자동 입력' 로직을 이어가면 됩니다.
      // const element = btn.dataset.ele; // "fire" | "water" | "light" | "dark"

      autoSealModal.classList.remove('show');
      autoSealModal.setAttribute('aria-hidden', 'true');
    });
  });
}
 
      // Build level buttons 10~20
      if (autoEnhList) {
        autoEnhList.innerHTML = '';
        for (let lv = 10; lv <= 20; lv++) {
          const b = document.createElement('button'); b.className = 'opt-btn'; b.textContent = `${lv}강`;
          b.addEventListener('click', async () => { await autoEnhanceApply(lv); autoEnhModal.classList.remove('show'); autoEnhModal.setAttribute('aria-hidden', 'true'); });
          autoEnhList.appendChild(b);
        }
      }
      // Build emblem stage buttons 5~15
      if (autoEmblemList) {
        autoEmblemList.innerHTML = '';
        for (let lv = 5; lv <= 15; lv++) {
          const b = document.createElement('button');
          b.className = 'opt-btn'; b.textContent = `${lv}단계`;
          b.addEventListener('click', async () => { await autoEmblemApply(lv); autoEmblemModal.classList.remove('show'); autoEmblemModal.setAttribute('aria-hidden', 'true'); });
          autoEmblemList.appendChild(b);
        }
      }

      // Openers
      document.getElementById('btnAutoEnh')?.addEventListener('click', () => {
        autoEnhModal.classList.add('show'); autoEnhModal.setAttribute('aria-hidden', 'false');
      });
      document.getElementById('btnAutoEmblem')?.addEventListener('click', () => {
        autoEmblemModal.classList.add('show'); autoEmblemModal.setAttribute('aria-hidden', 'false');
      });
      document.getElementById('btnAutoEnchant')?.addEventListener('click', () => {
   // 모달 열기만; 닫기는 tryApplyAutoIfReady에서 두 값이 모두 선택됐을 때만
   autoEnchantState.attr = null;
   autoEnchantState.tier = null;
   renderAutoEnchantChoices();
   showModal(document.getElementById('autoEnchantModal'), true);
});
      // Modal close bindings
      document.querySelectorAll('#autoEnhModal, #autoEmblemModal, #autoEnchantModal').forEach(modal => {
        modal.addEventListener('click', (e) => {
          if (e.target.hasAttribute('data-close') || e.target.classList.contains('close') || e.target.classList.contains('backdrop')) {
            modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true');
          }
        });
      });
      /* ===== [SEAL][AUTO] 추천 마법봉인 자동 입력 ===== */

// 슬롯코드 → "마법부여 종류키"와 별개로, 봉인용 "종류" 매핑
// - 무기부위: 무기고유 / 무기일반
// - 방어부위(L1~L5): 방어고유 / 방어일반
// - 보조장비(R5): 보장고유 / 보장일반
// - 액세서리(R2~R4): 악세고유 / 악세일반  (← 속성으로 찾기)
function sealTypeForSlot(slotCode) {
  switch (String(slotCode).toUpperCase()) {
    case 'R1': return { unique: '무기고유',  general: '무기일반'  };
    case 'R5': return { unique: '보장고유',  general: '보장일반'  };
    case 'R2':
    case 'R3':
    case 'R4': return { unique: '악세고유',  general: '악세일반'  };
    default:   return { unique: '방어고유',  general: '방어일반'  }; // L1~L5
  }
}

// 현재 선택 캐릭터의 공격 분류를 '물리' / '마법'로 변환
function jobGroupKeyFromState() {
  const p = String(state?.currentCharacter?.power || '').toLowerCase();
  return p.includes('mag') || p.includes('마법') ? '마법' : '물리';
}

// 시트의 속성 한글 키 매핑
const ELEM_KOR = { fire: '화', water: '수', light: '명', dark: '암' };

// byType 캐시에서 조건(직업군/속성)에 맞는 "첫 번째" 봉인 옵션을 찾아 반환
function findSealOption(typeKey, { jobKey, elemKor }) {
  const key = String(typeKey).trim();
  const list = ENCHANT_CACHE.byType.get(String(typeKey).trim()) || [];
  // 악세는 속성으로, 나머지는 직업군으로 찾는다
  const isAcc = typeKey.startsWith('악세');
    if (key === '무기고유') {
    const isCommon = (v) => {
      const s = String(v || '').trim();
      return ['공용', '공통', 'ALL', '무기공용'].includes(s);
    };
    // 1순위: 직업군열이 공용/ALL류인 행
    const pick =
      list.find(it => isCommon((it.raw && it.raw['직업군']) ?? it.jobGroup)) ||
      list[0] || null; // 2순위: 첫 행(없으면 null)
    return pick;
  }
  for (const it of list) {
    const raw = it.raw || {};
    if (isAcc) {
      const v = String(raw['직업군'] ?? raw['element'] ?? raw['elem'] ?? '').trim();
      if (v === elemKor) return it;
    } else {
      const v = String(raw['직업군'] ?? it.jobGroup ?? '').trim();
      if (v === jobKey) return it;
    }
  }
  return null;
}

// 도우미: raw에서 최소한의 스탯을 뽑아내는 보조 (시트에 stats가 없을 때 대비)
function statsFrom(opt) {
  if (!opt) return null;
  // ENCHANT_CACHE 프리로드에서 이미 obj.stats를 살려둠. 없으면 raw에서 필요한 키만 최소 추출
  return opt.stats || null; // 필요시 raw 기반 파싱 추가
}

// 실제 적용: 속성 클릭 시 전 슬롯에 맞는 고유/일반을 찾아 state.seals에 저장 + 캡션 갱신
async function applyAutoSeal(elementKey) {
  await ensureEnchantCache();             // 시트 캐시 보장 (기존 캐시 사용)
  const elemKor = ELEM_KOR[elementKey] || '';
  const jobKey  = jobGroupKeyFromState(); // '물리' or '마법'
  const targetSlots = ['R1','R2','R3','R4','R5','L1','L2','L3','L4','L5'];

  state.seals = state.seals || {};

  for (const slotCode of targetSlots) {
    const types = sealTypeForSlot(slotCode);
    const u = findSealOption(types.unique,  { jobKey, elemKor });
    const g = findSealOption(types.general, { jobKey, elemKor });

    // 슬롯키(SLOT_MAP: 'R1'→실제 내부키 등)를 얻어서 상태에 반영
    const slotKey = (window.SLOT_MAP || {})[slotCode];
    if (!slotKey) continue;

    // 적용 규칙: 고유 1개 + 일반 2개(동일 일반일 경우 g를 두 칸 복제)
    // (시트 설계상 일반이 2종으로 구분돼 있다면 여기를 확장)
// 적용 규칙: 고유 1 + 일반 2
state.seals[slotKey] = {
  unique:   u ? { name: u.name, typeKey: u.typeKey, stats: statsFrom(u), raw: u.raw } : null,
  general1: g ? { name: g.name, typeKey: g.typeKey, stats: statsFrom(g), raw: g.raw } : null,
  general2: g ? { name: g.name, typeKey: g.typeKey, stats: statsFrom(g), raw: g.raw } : null,
};

// 슬롯 칩(라벨) 즉시 갱신
refreshSealCaptionsForSlot(slotKey);
 // 이미 코드에 존재하는 유틸 재사용 :contentReference[oaicite:5]{index=5}
  }
    // ✅ 여기서 전체 갱신 + 버튼 라벨 + 합산
// 전체 칩 리프레시(화면 동기화)
refreshSealCaptionsFromState();

// 두 번째 버튼 라벨을 '마봉 설정완료'로 일괄 갱신
if (typeof refreshSealLabelsFromState === 'function') {
  refreshSealLabelsFromState();
}

// 합산 재계산 + 우측 패널 렌더
if (typeof recalcAndRenderPanel === 'function') {
  recalcAndRenderPanel();
}

  // 모달 닫기
  const modal = document.getElementById('autoSealModal');
  if (modal) { modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }
}

// ▼ 모달의 속성 버튼과 연결
const $autoSealModal = document.getElementById('autoSealModal');
if ($autoSealModal) {
  $autoSealModal.querySelectorAll('.opt-btn[data-ele]').forEach(btn => {
    btn.addEventListener('click', () => {
      const ele = btn.getAttribute('data-ele'); // 'fire' | 'water' | 'light' | 'dark'
      applyAutoSeal(ele);
    });
  });
}

    });

  </script>
  <script>
// ===== BuffLeveling: "레벨링(N)" 합산 → BUFF_SHEET의 스킬렙제=N에 적용 =====
// 시트 요약
// - BUFF_SHEET: [직업군, 캐릭터, 스킬명, 스킬렙제, 증가율, (힘, 지능, 물크(%), … 레벨0 기준치들)]
// - 아이템시트(선택 객체 sel.raw): ["레벨링(10)", "레벨링(15)", "레벨링(25)", ...] 열에 숫자(정수)

const BUFF_SHEET_URL = window.BUFF_SHEET_URL || window.BUFF_SHEET;

const BuffLeveling = (() => {
  const cache = { ready:false, rows:[] };

  // 숫자/퍼센트 파서
  const num = v => {
    const n = Number(String(v ?? "").replace(/[, ]/g,""));
    return Number.isFinite(n) ? n : 0;
  };
  const pct = v => num(v) / 100;

  // BUFF_SHEET 한 행 → 레벨0 기준 stats
  function rowToBaseStats(r) {
    return {
      phys_atk: num(r["물뎀"]),  mag_atk: num(r["마뎀"]),
      str: num(r["힘"]),        int: num(r["지능"]),
      acc: num(r["적중"]),
      phys_crit: num(r["물크"]) || num(r["물/마크"]),
      mag_crit:  num(r["마크"]) || num(r["물/마크"]),
      phys_crit_rate: pct(r["물크(%)"]),
      mag_crit_rate:  pct(r["마크(%)"]),
      add_damage: pct(r["추뎀(%)"]),
      damage_inc: pct(r["뎀증(%)"]),
      crit_damage_inc: pct(r["크증뎀(%)"]),
      phys_atk_pct: pct(r["물공(%)"]),
      mag_atk_pct:  pct(r["마공(%)"]),
      skill_atk_inc: pct(r["스증(%)"]),
      elem: {
        fire: num(r["화"]), water: num(r["수"]), light: num(r["명"]), dark: num(r["암"]), all: 0
      },
      elem_add_damage: {
        fire:pct(r["화속추"]), water:pct(r["수속추"]), light:pct(r["명속추"]), dark:pct(r["암속추"])
      },
      speed: { attack:pct(r["공속(%)"]), move:pct(r["이속(%)"]), cast:pct(r["캐속(%)"]) },
      cdr: pct(r["쿨감(%)"]),
      dot_add: { poison:0, bleed:pct(r["출혈추뎀"]), burn:pct(r["화상추뎀"]), shock:pct(r["감전추뎀"]) },
      dot_inc: { poison:0, bleed:pct(r["출혈뎀증"]), burn:pct(r["화상뎀증"]), shock:pct(r["감전뎀증"]) },
      other: { def_break_inc:pct(r["방깎뎀증(%)"]), enchant_bleed:num(r["인챈출혈"]) }
    };
  }

  // base × (1 + 증가율 × level)
  function scale(base, rate, level) {
    const m = 1 + (Number(rate)||0) * (level|0);
    const c = structuredClone(base);

    c.phys_atk*=m; c.mag_atk*=m; c.str*=m; c.int*=m; c.acc*=m; c.phys_crit*=m; c.mag_crit*=m;
    c.phys_crit_rate*=m; c.mag_crit_rate*=m; c.add_damage*=m; c.damage_inc*=m; c.crit_damage_inc*=m;
    c.phys_atk_pct*=m; c.mag_atk_pct*=m; c.skill_atk_inc*=m;
    c.elem.fire*=m; c.elem.water*=m; c.elem.light*=m; c.elem.dark*=m;
    c.elem_add_damage.fire*=m; c.elem_add_damage.water*=m; c.elem_add_damage.light*=m; c.elem_add_damage.dark*=m;
    c.speed.attack*=m; c.speed.move*=m; c.speed.cast*=m; c.cdr*=m;
    c.dot_add.bleed*=m; c.dot_add.burn*=m; c.dot_add.shock*=m;
    c.dot_inc.bleed*=m; c.dot_inc.burn*=m; c.dot_inc.shock*=m;
    c.other.def_break_inc*=m; c.other.enchant_bleed*=m;
    return c;
  }

  // stats 합치기 (네 sumSelections의 add 규칙과 동일하게 가산)
  function addStats(dst, st){
    if(!st) return dst;
    dst.phys_atk += st.phys_atk||0; dst.mag_atk += st.mag_atk||0;
    dst.str += st.str||0; dst.int += st.int||0;
    dst.phys_crit += st.phys_crit||0; dst.mag_crit += st.mag_crit||0;
    dst.phys_crit_rate += st.phys_crit_rate||0; dst.mag_crit_rate += st.mag_crit_rate||0;
    dst.add_damage += st.add_damage||0; dst.damage_inc += st.damage_inc||0; dst.crit_damage_inc += st.crit_damage_inc||0;
    dst.phys_atk_pct += st.phys_atk_pct||0; dst.mag_atk_pct += st.mag_atk_pct||0;
    dst.skill_atk_inc += st.skill_atk_inc||0;
    if(st.elem){ dst.elem.fire+=st.elem.fire||0; dst.elem.water+=st.elem.water||0; dst.elem.light+=st.elem.light||0; dst.elem.dark+=st.elem.dark||0; }
    dst.cdr += st.cdr||0;
    if(st.speed){ dst.speed.attack+=st.speed.attack||0; dst.speed.move+=st.speed.move||0; dst.speed.cast+=st.speed.cast||0; }
    if(st.other){ dst.def_break_inc += st.other.def_break_inc||0; }
    return dst;
  }

  function emptyStatsLikeSum() {
    return {
      phys_atk:0, mag_atk:0, str:0, int:0, acc:0,
      phys_crit:0, mag_crit:0, phys_crit_rate:0, mag_crit_rate:0,
      add_damage:0, damage_inc:0, crit_damage_inc:0,
      phys_atk_pct:0, mag_atk_pct:0, skill_atk_inc:0,
      elem:{fire:0,water:0,light:0,dark:0,all:0},
      speed:{attack:0,move:0,cast:0},
      cdr:0, def_break_inc:0
    };
  }

  // 선택 아이템에서 "레벨링(N)" 컬럼 추출 → {N: sum}
// 붙일 위치: 버프 모듈 파일(혹은 공용 util)에 선언
function collectItemLevelings(selections) {
  const out = Object.create(null);

  // 슬롯별로 배열/단일객체 섞여도 모두 순회
  const eachItems = (sel) => (
    !sel ? [] :
    Array.isArray(sel) ? sel :
    [sel.selected || sel].filter(Boolean)
  );

  // 숫자 파서(쉼표/문자 제거)
  const toNum = (v) => {
    const n = Number(String(v ?? '').replace(/[^\d.-]/g, ''));
    return Number.isFinite(n) ? n : 0;
  };

  // "레벨링(10)", "레벨링10", "Lv10", "레벨 10", "버프레벨(10)" 등 허용
  const isLevelCol = (k) => {
    const s = String(k || '').replace(/\s+/g, '');
    return /^(?:레벨링|레벨|버프레벨|Lv|LV)\(?\d+\)?$/.test(s);
  };
  const pickLevel = (k) => {
    const m = String(k || '').replace(/\s+/g, '').match(/(\d+)/);
    return m ? Number(m[1]) : NaN;
  };

  for (const [, sel] of Object.entries(selections || {})) {
    for (const it of eachItems(sel)) {
      const raw = it?.raw || it;
      if (!raw || typeof raw !== 'object') continue;

      for (const [k, v] of Object.entries(raw)) {
        if (!isLevelCol(k)) continue;
        const N = pickLevel(k);           // 10 / 15 / 25 / …
        const val = toNum(v);             // 1, 2, …
        if (!Number.isFinite(N) || !val) continue;
        out[N] = (out[N] || 0) + val;
        console.log('[BUFF-DEBUG] 레벨링 감지:', { col:k, N, val, item: it?.name || raw?.이름 || '?' });
      }
    }
  }

  console.log('[BUFF-DEBUG] 레벨링 합산 맵:', out); // 예: {10:8, 15:2}
  return out;
}

// 1) 강력 정규화 유틸 (기존 cleanUrl 포함 확장)
function norm(s) {
  // cleanUrl: 앞뒤 공백/따옴표 제거, 백슬래시 → 슬래시
  const base = cleanUrl(s);
  // 제로폭/비가시 공백류 추가 제거 + 모든 공백 제거
  return String(base)
    .normalize('NFC')
    .replace(/[\uFEFF\u00A0\u200B-\u200D\u2060\u180E]/g, '')
    .replace(/\s+/g, '');
}
// 2) BUFF 로더: __charKey 생성 보강 + 로깅 보강
async function preload() {
  if (cache.ready) return;

  console.log('[BUFF-DEBUG] fetch URL =', window.BUFF_SHEET);
  const text = await fetch(window.BUFF_SHEET, { cache: 'no-store' }).then(r => r.text());
  const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
  const rawRows = parsed.data || [];

  // 1) 헤더 정규화 함수: BOM/비가시 공백/모든 공백 제거 + 소문자
  const normKey = (k) => String(k ?? '')
    .replace(/[\uFEFF\u00A0]/g, '')  // BOM, NBSP 제거
    .replace(/\s+/g, '')             // 모든 공백 제거
    .toLowerCase();

  // 2) 값 정규화: 네 cleanUrl을 활용 + 내부 공백/비가시 공백 제거
  const normVal = (v) => cleanUrl(v).replace(/[\uFEFF\u00A0]/g, '').replace(/\s+/g, '');

  // 3) 각 행의 키를 정규화해서 새 객체로 만든 뒤, __charKey 생성
  cache.rows = rawRows.map(row => {
    const n = {};
    for (const [k, v] of Object.entries(row)) n[normKey(k)] = v;

    // 시트에 따라 다양한 표기를 모두 커버
    const job  = n['직업군'] || n['직업'] || '';
    const name = n['캐릭터'] || n['캐릭터명'] || n['캐릭명'] || n['직업명'] || '';

    // BUFF_SHEET가 '캐릭터' 한 열에 "남귀검사소울브링어"가 들어있는 경우도 커버
    const charKey = normVal(job + name) || normVal(name);
    return { ...row, __charKey: charKey };  // 원본 필드 유지 + 키 추가
  });

  console.log('[BUFF-DEBUG] BUFF rows:', cache.rows.length,
              '샘플 __charKey:', cache.rows.slice(0, 5).map(r => r.__charKey));

  cache.ready = true;
}

// base 객체에서 숫자 필드(0이 아닌 곳)에만 delta를 더함 (중첩 객체도 처리)
function addDeltaWherePresent(base, delta) {
  const walk = (obj) => {
    if (!obj || typeof obj !== 'object') return obj;
    const out = Array.isArray(obj) ? [] : {};
    for (const [k, v] of Object.entries(obj)) {
      if (v && typeof v === 'object') {
        out[k] = walk(v);
      } else if (typeof v === 'number') {
        out[k] = (v !== 0) ? (v + delta) : v;
      } else {
        out[k] = v;
      }
    }
    return out;
  };
  return walk(base);
}

// ★ 가산형 스케일: "원래값 + (증가율 * 레벨링합)"
function scaleAdd(baseStats, incRaw, levelCount) {
  // 네가 이미 가진 toNum() 재사용 (%, 글자 등 있으면 숫자만 남기고 싶으면 아래 한 줄 활성화)
  // incRaw = String(incRaw).replace(/[^0-9.-]/g, '');
  const inc   = toNum(incRaw);      // 예: "4" -> 4
  const steps = toNum(levelCount);  // 예: 8
  const delta = inc * steps;        // 예: 32
  return addDeltaWherePresent(baseStats, delta);
}


// 3) 매칭: 현재 선택 캐릭터 키 만들기 + 필터
async function computeBuffStats() {
if (!(state.currentCharacter?.name)) {
  return null; // 캐릭터 없으면 버프 미적용
}
  if (!cache.ready) await preload();

  const want = (state.currentCharacter?.jobGroupLabel || '') + (state.currentCharacter?.name || '');
  const fullName = cleanUrl(want).replace(/[\uFEFF\u00A0]/g, '').replace(/\s+/g, '');

  // __charKey는 이미 정규화된 상태
  const rows = cache.rows.filter(r => r.__charKey === fullName);
  console.log('[BUFF-DEBUG] BUFF_SHEET 매칭:', { fullName, count: rows.length });

  const levMap = collectItemLevelings?.(state.selections || {}) || {};
  console.log('[BUFF-DEBUG] 레벨링 합산:', levMap);

  let total = emptyStatsLikeSum();
  for (const r of rows) {
    const skillName = String(r['스킬명'] || r['skillname'] || '').trim();
    const req  = Number(r['스킬렙제'] || r['skillreq'] || 0);
// (교체 코드: 가산형 적용)
const incRaw = r['증가율'] || r['rate'] || 0;  // 원문 유지
const base   = rowToBaseStats(r);
const level  = toNum(levMap[req] || 0);
const scaled = scaleAdd(base, incRaw, level);  // ★ 가산형

    console.log(
  `[BUFF-DEBUG] req=${req}, level=${level}, inc=${incRaw} → delta=${toNum(incRaw)*level}`,
  { base, scaled });
    total = addStats(total, scaled);
  }
  console.log('[BUFF-DEBUG] 최종 합산 버프 스탯:', total);
  return total;
}






  return { computeBuffStats };
})();
</script>

  <script>
    /* ======== 마법봉인(슬롯별 3구역 단일 선택) & 마법부여 ======== */
    (function () {
      // 상태 슬롯
      window.state = window.state || {};
      state.seals = state.seals || {}; // { [slotKey]: { unique, general1, general2 } }
      state.enchants = state.enchants || {}; // { [slotKey]: {name, stats...} }

      /* ===== 마법봉인: 모달/스타일 동적 생성 ===== */
      function ensureSealModalBuilt() {
        if (document.getElementById('sealModal')) return;
        const html = `
<div id="sealModal" class="modal" aria-hidden="true">
  <div class="backdrop" data-close></div>
  <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="sealDlgTitle"
       style="width:min(980px,95vw);height:min(1620px,88vh);">
    <header>
      <h2 id="sealDlgTitle">마법봉인 설정</h2>
    </header>
    <div class="items" style="padding:10px;">
      <div class="seal-grid">
        <div class="seal-col">
          <div class="seal-col-title">고유옵션</div>
          <div id="sealListUnique" class="seal-list"></div>
        </div>
        <div class="seal-col">
          <div class="seal-col-title">일반옵션 1</div>
          <div id="sealListGeneral1" class="seal-list"></div>
        </div>
        <div class="seal-col">
          <div class="seal-col-title">일반옵션 2</div>
          <div id="sealListGeneral2" class="seal-list"></div>
        </div>
      </div>
    </div>
  </div>
</div>`;
        document.body.insertAdjacentHTML('beforeend', html);
        const modal = document.getElementById('sealModal');
        modal.addEventListener('click', (e) => {
          if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) closeSealModal();
        });
      }

      function ensureSealStyles() {
        if (document.getElementById('sealStyles')) return;
        const css = `
.seal-grid { display:grid; background: #0e0b09; grid-template-columns:1fr 1fr 1fr; gap:12px; }
.seal-col { border:1px solid var(--border, #333); background: #0e0b09; border-radius:12px; padding:10px; overflow:auto; max-height: calc(88vh - 140px); }
.seal-col-title { font-weight:700; color: #f0e6d2; background: #0e0b09; margin-bottom:8px; }
.seal-option { display:grid; width:100%; text-align:left; padding:8px 10px; color: #f0e6d2; cousor: pointer; margin:4px 0; border-radius:10px;
  border:1px solid var(--border,#333); background:var(--card,#1a130f); cursor:pointer; font-size:13px; }
.seal-option:hover { border-color: #xfa24f; box-shadow: 0 0 0 2px rgba(207, 162, 79, .25) inset; filter:brightness(1.08); }
.seal-option.selected { outline:2px solid #e7c27a; }
`;
        const s = document.createElement('style'); s.id = 'sealStyles'; s.textContent = css;
        document.head.appendChild(s);
      }

      function closeSealModal() {
        const modal = document.getElementById('sealModal');
        if (modal) { modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true'); }
        state.ui = state.ui || {};
        state.ui.sealTemp = null;
      }

      function sealTypeKeysForSlot(slotKey) {
        if (slotKey === 'weapon') return { u: '무기고유', g: '무기일반' };
        if (['headshoulder', 'top', 'bottom', 'belt', 'shoes'].includes(slotKey))
          return { u: '방어고유', g: '방어일반' };
        if (['bracelet', 'necklace', 'ring'].includes(slotKey))
          return { u: '악세고유', g: '악세일반' };
        if (slotKey === 'support') return { u: '보장고유', g: '보장일반' };
        return null;
      }

      /* ===== 마법부여: 로직 ===== */
      function enchantTypeForSlot(slotKey) {
        return ({
          weapon: '무기마부', top: '상의마부', bottom: '하의마부',
          headshoulder: '머리어깨마부', belt: '허리마부', shoes: '신발마부',
          bracelet: '팔찌마부', necklace: '목걸이마부', ring: '반지마부',
          support: '보장마부'
        })[slotKey] || null;
      }

      function closeEnchantPicker() {
        const modal = document.getElementById('enchantModal');
        if (modal) {
          modal.classList.remove('show');
          modal.setAttribute('aria-hidden', 'true');
        }
      }

      async function openEnchantPicker(slotKey, btnEl) {
        const type = enchantTypeForSlot(slotKey);
        if (!type) return;

        if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

        const list = (DBEnh.byType[type] || []).slice();
        const enchantListEl = document.getElementById('enchantList');
        enchantListEl.innerHTML = '';

        list.forEach(opt => {
          const b = document.createElement('button');
          b.className = 'enh-option';
          b.textContent = opt.name || '(이름없음)';
          b.onclick = () => {
            state.enchants[slotKey] = opt;
            if (btnEl) btnEl.textContent = opt.name;
            closeEnchantPicker();
            if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
          };
          enchantListEl.appendChild(b);
        });

        const enchantDlgTitle = document.getElementById('enchantDlgTitle');
        if (enchantDlgTitle) {
          enchantDlgTitle.textContent = `${window.labelForSlot(slotKey) || '아이템'} 마법부여 선택`;
        }

        const enchantModal = document.getElementById('enchantModal');
        if (enchantModal) {
          enchantModal.classList.add('show');
          enchantModal.setAttribute('aria-hidden', 'false');
        }
      }


      /* ===== 공통 UI 갱신 로직 ===== */
      function refreshSealLabelsFromState() {
        document.querySelectorAll('.slot-row').forEach(row => {
          const slotEl = row.querySelector('.slot'); const code = slotEl?.getAttribute('data-slot');
          const slotKey = (window.SLOT_MAP || {})[code]; const rects = row.querySelectorAll('.outer-rects .rect');
          if (!slotKey || rects.length < 2) return;
          const has = !!(state.seals?.[slotKey]?.unique && state.seals?.[slotKey]?.general1 && state.seals?.[slotKey]?.general2);
          rects[1].textContent = has ? '마봉 설정완료' : '마봉 설정';
          refreshSealCaptionsForSlot(slotKey);
        });
      }

      function getSealCaptionText(obj) {
        if (!obj) return "";
        return (obj.badge ?? obj.level ?? obj.label ?? obj.text ?? obj.caption ?? obj.name ?? obj.imgText ?? "").toString().trim();
      }

      function refreshSealCaptionsForSlot(slotKey) {
        if (!slotKey) return;
        const el = window.tileElForSlot(slotKey);
        if (!el) return;
        const code = el.getAttribute('data-slot') || "";
        if (el.classList.contains('mini') || /^C[1-4]$/.test(code)) return;

        let cap = el.querySelector('.seal-captions');
        if (!cap) {
          cap = document.createElement('div');
          cap.className = 'seal-captions';
          el.appendChild(cap);
        }
        cap.innerHTML = '';

        const sel = (state.seals || {})[slotKey] || {};
        const u = sel.unique || null;
        const g1 = sel.general1 || null;
        const g2 = sel.general2 || null;

        const uTxt = getSealCaptionText(u);
        const g1Txt = getSealCaptionText(g1);
        const g2Txt = getSealCaptionText(g2);

        if (!uTxt && !g1Txt && !g2Txt) { cap.style.display = 'none'; return; }
        cap.style.display = 'flex';

        if (uTxt) {
          const rowU = document.createElement('div');
          rowU.className = 'seal-row seal-row-unique';
          const chipU = document.createElement('div');
          chipU.className = 'seal-chip';
          chipU.textContent = uTxt;
          rowU.appendChild(chipU);
          cap.appendChild(rowU);
        }

        if (g1Txt || g2Txt) {
          const rowG = document.createElement('div');
          rowG.className = 'seal-row seal-row-general';
          if (g1Txt) {
            const chip1 = document.createElement('div');
            chip1.className = 'seal-chip';
            chip1.textContent = g1Txt;
            rowG.appendChild(chip1);
          }
          if (g2Txt) {
            const chip2 = document.createElement('div');
            chip2.className = 'seal-chip';
            chip2.textContent = g2Txt;
            rowG.appendChild(chip2);
          }
          cap.appendChild(rowG);
        }
      }

      function refreshSealCaptionsFromState() {
        document.querySelectorAll('.slot-row .slot').forEach(slotEl => {
          const code = slotEl.getAttribute('data-slot');
          if (!code) return;
          const slotKey = (window.SLOT_MAP || {})[code];
          if (!slotKey) return;
          if (slotEl.classList.contains('mini') || /^C[1-4]$/.test(code)) return; // 미니 제외
          refreshSealCaptionsForSlot(slotKey);
        });
      }

      function buildSealList(listEl, choices, current, onPick) {
        listEl.innerHTML = '';
        choices.forEach(opt => {
          const b = document.createElement('button');
          b.className = 'seal-option' + ((current && current.name === opt.name) ? ' selected' : '');
          b.textContent = opt.name || '(이름없음)';
          b.title = opt.tag ? `분류: ${opt.tag}` : '';
          b.addEventListener('click', () => onPick(opt, b));
          listEl.appendChild(b);
        });
      }

      function tryFinalizeSeal(slotKey, btnEl) {
        const tmp = state.ui?.sealTemp;
        if (!tmp) return;
        if (tmp.unique && tmp.general1 && tmp.general2) {
          state.seals[slotKey] = { unique: tmp.unique, general1: tmp.general1, general2: tmp.general2 };
          refreshSealCaptionsForSlot(slotKey);
          if (btnEl) btnEl.textContent = '마봉 설정완료';
          if (typeof recalcAndRenderPanel === 'function') recalcAndRenderPanel();
          closeSealModal();
        }
      }

      async function openSealModal(slotKey, btnEl) {
        ensureSealStyles();
        ensureSealModalBuilt();
        if (typeof ensureEnhLoaded === 'function') await ensureEnhLoaded();

        const keys = sealTypeKeysForSlot(slotKey);
        if (!keys) return;

        const uniq = (DBEnh?.byType?.[keys.u] || (DBEnh?.list || []).filter(o => (o?.type || '') === keys.u)).slice();
        const gen = (DBEnh?.byType?.[keys.g] || (DBEnh?.list || []).filter(o => (o?.type || '') === keys.g)).slice();

        state.ui = state.ui || {};
        const prev = (state.seals?.[slotKey]) || {};
        state.ui.sealTemp = {
          unique: prev.unique || null, general1: prev.general1 || null, general2: prev.general2 || null, slotKey, btnEl
        };

        const $ = (id) => document.getElementById(id);
        const listU = $('sealListUnique'), listG1 = $('sealListGeneral1'), listG2 = $('sealListGeneral2');

        buildSealList(listU, uniq, prev.unique, (opt, btn) => {
          state.ui.sealTemp.unique = opt;
          listU.querySelectorAll('.seal-option').forEach(x => x.classList.remove('selected')); btn.classList.add('selected');
          tryFinalizeSeal(slotKey, btnEl);
        });
        buildSealList(listG1, gen, prev.general1, (opt, btn) => {
          state.ui.sealTemp.general1 = opt;
          listG1.querySelectorAll('.seal-option').forEach(x => x.classList.remove('selected')); btn.classList.add('selected');
          tryFinalizeSeal(slotKey, btnEl);
        });
        buildSealList(listG2, gen, prev.general2, (opt, btn) => {
          state.ui.sealTemp.general2 = opt;
          listG2.querySelectorAll('.seal-option').forEach(x => x.classList.remove('selected')); btn.classList.add('selected');
          tryFinalizeSeal(slotKey, btnEl);
        });

        const modal = document.getElementById('sealModal');
        modal.classList.add('show'); modal.setAttribute('aria-hidden', 'false');
      }

      // DOM 로드 후 바인딩
      document.addEventListener('DOMContentLoaded', () => {
        refreshSealLabelsFromState();

        const enchantModal = document.getElementById('enchantModal');
        if (enchantModal) {
          enchantModal.addEventListener('click', (e) => {
            if (e.target.hasAttribute('data-close') || e.target.classList.contains('backdrop')) {
              closeEnchantPicker();
            }
          });
        }

        document.querySelectorAll('.slot-row').forEach(row => {
          const slotEl = row.querySelector('.slot');
          const code = slotEl?.getAttribute('data-slot');
          const slotKey = (window.SLOT_MAP || {})[code];
          const rects = row.querySelectorAll('.outer-rects .rect');
          if (!slotKey) return;

          // 마봉 (두번째 버튼)
          if (rects.length >= 2) {
            const secondBtn = rects[1];
            secondBtn.textContent = '마봉 설정';
            secondBtn.addEventListener('click', (e) => { e.stopPropagation(); openSealModal(slotKey, secondBtn); });
          }

          // 마법부여 (세번째 버튼)
          if (rects.length >= 3) {
            const thirdBtn = rects[2];
            if (enchantTypeForSlot(slotKey)) {
              thirdBtn.textContent = '마법 부여';
              thirdBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                openEnchantPicker(slotKey, thirdBtn);
              });
            } else {
              thirdBtn.classList.add('disabled');
            }
          }
        });
      });

      // 합산 함수 확장: 마봉, 마부 스탯 합산
// 합산 함수 확장: 마봉, 마부 스탯 합산
try {
  const _base = window.sumSelections;
  if (typeof _base === 'function') {
    window.sumSelections = function () {
      const S = _base();

      // 누적기 안전 보정
      S.__skillMul = S.__skillMul || 1;
      S.__skillAddBuff = S.__skillAddBuff || 0;

      const add = (st, src = 'other') => {
        if (!st) return;

        // 1) 스증 분기
        if (st.skill_atk_inc) {
          if (src === 'buff') S.__skillAddBuff += (st.skill_atk_inc || 0);   // (여기선 안 씀)
          else                S.__skillMul *= (1 + (st.skill_atk_inc || 0));  // 마봉/마부는 곱
        }

        // 2) 나머지 스탯 가산
        S.phys_atk += st.phys_atk || 0; S.mag_atk += st.mag_atk || 0;
        S.str += st.str || 0; S.int += st.int || 0;
        S.phys_crit += st.phys_crit || 0; S.mag_crit += st.mag_crit || 0;
        S.phys_crit_rate += st.phys_crit_rate || 0; S.mag_crit_rate += st.mag_crit_rate || 0;
        S.add_damage += st.add_damage || 0;
        if (st.elem_add_damage) {
          S.elem_add_sum = (S.elem_add_sum || 0)
            + (st.elem_add_damage.fire || 0) + (st.elem_add_damage.water || 0)
            + (st.elem_add_damage.light || 0) + (st.elem_add_damage.dark || 0);
        }
        S.str_pct += st.str_pct || 0; S.int_pct += st.int_pct || 0;
        S.damage_inc += st.damage_inc || 0; S.crit_damage_inc += st.crit_damage_inc || 0;
        S.phys_atk_pct += st.phys_atk_pct || 0; S.mag_atk_pct += st.mag_atk_pct || 0;
        if (st.elem) { S.elem.fire += st.elem.fire || 0; S.elem.water += st.elem.water || 0; S.elem.light += st.elem.light || 0; S.elem.dark += st.elem.dark || 0; }
        S.cdr += st.cdr || 0;
        if (st.speed) { S.speed.attack += st.speed.attack || 0; S.speed.move += st.speed.move || 0; S.speed.cast += st.speed.cast || 0; }
        if (st.other) { S.def_break_inc += st.other.def_break_inc || 0; }
      };

      // 마봉(시일/seal)
      Object.values(state.seals || {}).forEach(p => {
        if (p?.unique?.stats) add(p.unique.stats, 'other');
        if (p?.general1?.stats) add(p.general1.stats, 'other');
        if (p?.general2?.stats) add(p.general2.stats, 'other');
      });

      // 마부(enchants)
      Object.values(state.enchants || {}).forEach(p => {
        if (p?.stats) add(p.stats, 'other');
      });

      // ★ 여기서 최종 스증 확정: (곱-1) + 버프합
      S.skill_atk_inc = (S.__skillMul - 1) + S.__skillAddBuff;

      // 임시 키 정리(선택)
      // delete S.__skillMul; delete S.__skillAddBuff;

      return S;
    };
  }
} catch (e) { console.warn('Seal/Enchant sumSelections extension failed', e); }


      // 전역에서 접근 필요 시 export
      window.refreshSealLabelsFromState = refreshSealLabelsFromState;
      window.refreshSealCaptionsForSlot = refreshSealCaptionsForSlot;
      window.refreshSealCaptionsFromState = refreshSealCaptionsFromState;
      if (document.readyState !== 'loading') {
        refreshSealCaptionsFromState();
      } else {
        document.addEventListener('DOMContentLoaded', refreshSealCaptionsFromState);
      }

      window.openSealModal = openSealModal;
    })();

  </script>
</body>

</html>